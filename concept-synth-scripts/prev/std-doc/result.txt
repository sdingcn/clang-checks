[-[data:_Cont]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:28743:1
Printed constraint (original):
(
 requires (_Cont o) { o.data(); }
)
Printed constraint (optimized):
requires (_Cont o) { o.data(); }
Inferred constraint:


[-[__invoke:_A0]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:733:1
Printed constraint (original):
(
 requires (_A0 o) { o.get(); }
)
Printed constraint (optimized):
requires (_A0 o) { o.get(); }
Inferred constraint:


[-[shuffle:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19316:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 (
  (
   requires (_RandomAccessIterator x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
requires (_RandomAccessIterator x0) { ++x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[transform:_UnaryOperation]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20529:1
Printed constraint (original):
(
 requires (_UnaryOperation f, _InputIterator x0) { f(*x0); }
)
Printed constraint (optimized):
requires (_UnaryOperation f, _InputIterator x0) { f(*x0); }
Inferred constraint:
UnaryFunction Predicate 

[-[__sample:_Distance]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18328:1
Printed constraint (original):
(
 requires (_Distance x0) { --x0; }
)
Printed constraint (optimized):
requires (_Distance x0) { --x0; }
Inferred constraint:
BidirectionalIterator RandomAccessIterator Float Integral 

[-[is_permutation:_ForwardIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12368:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (true)
     ) &&
     requires (_ForwardIterator2 x0) { *x0; } &&
     requires (_ForwardIterator2 x0) { ++x0; }
    )
   ) &&
   requires (_ForwardIterator2 x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator2 x0) { *x0; } &&
 requires (_ForwardIterator2 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[search:_ForwardIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7936:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (true)
     ) &&
     (
      (true)
     ) &&
     (
      (true)
     ) &&
     requires (_ForwardIterator1 x0, _ForwardIterator1 x1) { x0 - x1; }
    ) ||
    (
     (
      (true)
     )
    )
   ) &&
   (
    (
     (
      (
       (
        (true)
       ) &&
       requires (_ForwardIterator1 x0) { ++x0; } &&
       requires (_ForwardIterator1 x0) { *x0; } &&
       (
        (true)
       ) &&
       (
        (true)
       ) &&
       true
      )
     ) &&
     (
      (true)
     ) &&
     requires (_ForwardIterator1 x0, _ForwardIterator1 x1) { x1 - x0; } &&
     (
      (true)
     )
    ) ||
    (
     (
      (
       (
        (true)
       ) &&
       requires (_ForwardIterator1 x0) { ++x0; } &&
       requires (_ForwardIterator1 x0) { *x0; } &&
       (
        (true)
       ) &&
       (
        (true)
       )
      )
     )
    )
   ) &&
   requires (_ForwardIterator1 x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 (
  (
   requires (_ForwardIterator1 x0) { ++x0; } &&
   requires (_ForwardIterator1 x0) { *x0; } &&
   requires (_ForwardIterator1 x0, _ForwardIterator1 x1) { x1 - x0; }
  ) ||
  (
   requires (_ForwardIterator1 x0) { ++x0; } &&
   requires (_ForwardIterator1 x0) { *x0; }
  )
 ) &&
 requires (_ForwardIterator1 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__half_positive:_Tp]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:5820:1
Printed constraint (original):
(
 requires (_Tp x0, int x1) { x0 / x1; }
)
Printed constraint (optimized):
requires (_Tp x0, int x1) { x0 / x1; }
Inferred constraint:
Float Integral 

[-[iter_swap:_ForwardIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:2223:1
Printed constraint (original):
(
 requires (_ForwardIterator1 x0) { *x0; }
)
Printed constraint (optimized):
requires (_ForwardIterator1 x0) { *x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[find_first_of:_BinaryPredicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:8899:1
Printed constraint (original):
(
 (
  (
   requires (_BinaryPredicate f, _ForwardIterator1 x0, _ForwardIterator2 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
  )
 )
)
Printed constraint (optimized):
requires (_BinaryPredicate f, _ForwardIterator1 x0, _ForwardIterator2 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[uninitialized_move:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29940:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_ForwardIterator x0) { *x0; } &&
     requires (_ForwardIterator x0) { ++x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[replace_copy_if:_Predicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20392:1
Printed constraint (original):
(
 requires (_Predicate f, _InputIterator x0) { {f(*x0)} -> std::convertible_to<bool>; }
)
Printed constraint (optimized):
requires (_Predicate f, _InputIterator x0) { {f(*x0)} -> std::convertible_to<bool>; }
Inferred constraint:
UnaryFunction Predicate 

[-[transform:_OutputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20529:1
Printed constraint (original):
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[min:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7304:1
Printed constraint (original):
(
 requires (_Compare f, _Tp x0, _Tp x1) { f(x0, x1); }
)
Printed constraint (optimized):
requires (_Compare f, _Tp x0, _Tp x1) { f(x0, x1); }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__invoke:_Fp]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:726:1
Printed constraint (original):
(
 requires (_Fp x0, _A0 x1) { x1 .* x0; }
)
Printed constraint (optimized):
requires (_Fp x0, _A0 x1) { x1 .* x0; }
Inferred constraint:


[-[adjacent_find:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:5739:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_ForwardIterator x0, _ForwardIterator x1) { ++x1 != x0; } &&
     requires (_ForwardIterator x0, _ForwardIterator x1) { x1 == x0; }
    )
   ) &&
   (
    (
     requires (_ForwardIterator x0) { *x0; } &&
     requires (_ForwardIterator x0) { ++x0; } &&
     requires (_ForwardIterator x0, _ForwardIterator x1) { x0 == x1; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0, _ForwardIterator x1) { ++x1 != x0; } &&
 requires (_ForwardIterator x0, _ForwardIterator x1) { x1 == x0; } &&
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0, _ForwardIterator x1) { x0 == x1; }
)
Inferred constraint:
InputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[partial_sort_copy:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:15035:1
Printed constraint (original):
(
 (
  (
   (
    (true)
   ) &&
   (
    (
     (
      (
       (
        (
         requires (_RandomAccessIterator x0) { ++x0; } &&
         requires (_RandomAccessIterator x0) { --x0; } &&
         (
          (
           requires (_RandomAccessIterator x0) { --x0; } &&
           requires (_RandomAccessIterator x0) { *x0; }
          )
         ) &&
         requires (_RandomAccessIterator x0) { *x0; } &&
         (
          (
           requires (_RandomAccessIterator x0) { ++x0; } &&
           requires (_RandomAccessIterator x0) { *x0; } &&
           true
          )
         )
        )
       ) &&
       requires (_RandomAccessIterator x0) { --x0; }
      )
     ) &&
     (
      (
       requires (_RandomAccessIterator x0) { ++x0; } &&
       requires (_RandomAccessIterator x0) { *x0; }
      )
     ) &&
     (
      (
       (
        (
         requires (_RandomAccessIterator x0) { ++x0; } &&
         requires (_RandomAccessIterator x0) { *x0; }
        )
       )
      )
     ) &&
     requires (_RandomAccessIterator x0) { *x0; } &&
     requires (_RandomAccessIterator x0) { ++x0; }
    )
   ) &&
   requires (_RandomAccessIterator x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Inferred constraint:
RandomAccessIterator 

[-[make_heap:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12560:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
     true
    )
   )
  )
 )
)
Printed constraint (optimized):
requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__replace_copy_if_impl:_InIter]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:17813:1
Printed constraint (original):
(
 requires (_InIter x0) { ++x0; } &&
 requires (_InIter x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_InIter x0) { ++x0; } &&
 requires (_InIter x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[lexicographical_compare:_InputIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12468:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_InputIterator2 x0) { *x0; } &&
     requires (_InputIterator2 x0) { ++x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator2 x0) { *x0; } &&
 requires (_InputIterator2 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[includes:_InputIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:9140:1
Printed constraint (original):
(
 (
  (
   (
    (true)
   ) &&
   (
    (
     requires (_InputIterator1 x0) { *x0; } &&
     requires (_InputIterator1 x0) { ++x0; }
    )
   ) &&
   requires (_InputIterator1 x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[merge:_OutputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12670:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       )
      )
     ) &&
     requires (_OutputIterator x0) { *x0; } &&
     (
      (
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       )
      )
     ) &&
     requires (_OutputIterator x0) { ++x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[replace:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20366:1
Printed constraint (original):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__remove_if_impl:_Iter]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:17575:1
Printed constraint (original):
(
 requires (_Iter x0) { *x0; } &&
 requires (_Iter x0) { ++x0; } &&
 (
  (
   requires (_Iter x0) { *x0; } &&
   requires (_Iter x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_Iter x0) { *x0; } &&
 requires (_Iter x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[remove_copy:_OutputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20327:1
Printed constraint (original):
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[binary_search:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:5883:1
Printed constraint (original):
(
 requires (_Compare f, _Tp x0, _ForwardIterator x1) { f(x0, *x1); } &&
 (
  (
   (
    (true)
   )
  )
 )
)
Printed constraint (optimized):
requires (_Compare f, _Tp x0, _ForwardIterator x1) { f(x0, *x1); }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__find_first_of_ce:_BinaryPredicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:8886:1
Printed constraint (original):
(
 requires (_BinaryPredicate f, _ForwardIterator1 x0, _ForwardIterator2 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
)
Printed constraint (optimized):
requires (_BinaryPredicate f, _ForwardIterator1 x0, _ForwardIterator2 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[destroy_n:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:11096:1
Printed constraint (original):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[remove_copy_if:_Predicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:17641:1
Printed constraint (original):
(
 requires (_Predicate f, _InputIterator x0) { f(*x0); }
)
Printed constraint (optimized):
requires (_Predicate f, _InputIterator x0) { f(*x0); }
Inferred constraint:
UnaryFunction Predicate 

[-[for_each:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:8932:1
Printed constraint (original):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__search_n_impl:_DiffT]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18627:1
Printed constraint (original):
(
 (
  (
   requires (_DiffT x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
requires (_DiffT x0) { ++x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[equal:_BinaryPredicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7639:1
Printed constraint (original):
(
 (
  (
   requires (_BinaryPredicate f, _InputIterator1 x0, _InputIterator2 x1) { f(*x0, *x1); }
  ) ||
  (
   (
    (
     requires (_BinaryPredicate f, _InputIterator1 x0, _InputIterator2 x1) { f(*x0, *x1); }
    )
   )
  )
 )
)
Printed constraint (optimized):
requires (_BinaryPredicate f, _InputIterator1 x0, _InputIterator2 x1) { f(*x0, *x1); }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[for_each_n:_Function]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:8942:1
Printed constraint (original):
(
 requires (_Function f, _InputIterator x0) { f(*x0); }
)
Printed constraint (optimized):
requires (_Function f, _InputIterator x0) { f(*x0); }
Inferred constraint:
UnaryFunction Predicate 

[-[adjacent_find:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:5734:1
Printed constraint (original):
(
 (
  (
   requires (_ForwardIterator x0, _ForwardIterator x1) { ++x1 != x0; } &&
   requires (_ForwardIterator x0, _ForwardIterator x1) { x1 == x0; }
  )
 ) &&
 (
  (
   requires (_ForwardIterator x0) { *x0; } &&
   requires (_ForwardIterator x0) { ++x0; } &&
   requires (_ForwardIterator x0, _ForwardIterator x1) { x0 == x1; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0, _ForwardIterator x1) { ++x1 != x0; } &&
 requires (_ForwardIterator x0, _ForwardIterator x1) { x1 == x0; } &&
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0, _ForwardIterator x1) { x0 == x1; }
)
Inferred constraint:
InputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[is_sorted:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12427:1
Printed constraint (original):
(
 (
  (
   requires (_ForwardIterator x0) { *x0; } &&
   requires (_ForwardIterator x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__inplace_merge:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12137:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (true)
     )
    )
   ) &&
   (
    (true)
   ) &&
   requires (_Compare f, _BidirectionalIterator x0, _BidirectionalIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
   (
    true
   ) &&
   (
    (
     (
      (
       true
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
requires (_Compare f, _BidirectionalIterator x0, _BidirectionalIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[copy_if:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7524:1
Printed constraint (original):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__min_element:_Iter]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7267:1
Printed constraint (original):
(
 requires (_Iter x0) { *x0; } &&
 requires (_Iter x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_Iter x0) { *x0; } &&
 requires (_Iter x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__find_end:_Iter1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:8803:1
Printed constraint (original):
(
 requires (_Iter1 x0) { --x0; }
)
Printed constraint (optimized):
requires (_Iter1 x0) { --x0; }
Inferred constraint:
BidirectionalIterator RandomAccessIterator Float Integral 

[-[find_end:_ForwardIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:8878:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (true)
     ) &&
     (
      (
       requires (_ForwardIterator2 x0) { ++x0; } &&
       requires (_ForwardIterator2 x0) { *x0; }
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator2 x0) { ++x0; } &&
 requires (_ForwardIterator2 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[uninitialized_move_n:_Size]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29963:1
Printed constraint (original):
(
 (
  (
   requires (_Size x0) { --x0; }
  )
 )
)
Printed constraint (optimized):
requires (_Size x0) { --x0; }
Inferred constraint:
BidirectionalIterator RandomAccessIterator Float Integral 

[-[partition:_Predicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:15102:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
     requires (_Predicate f, _ForwardIterator x0) { f(*x0); }
    ) ||
    (
     requires (_Predicate f, _ForwardIterator x0) { f(*x0); }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 (
  requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
  requires (_Predicate f, _ForwardIterator x0) { f(*x0); }
 ) ||
 requires (_Predicate f, _ForwardIterator x0) { f(*x0); }
)
Inferred constraint:
UnaryFunction Predicate 

[-[__includes:_Iter1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:9109:1
Printed constraint (original):
(
 requires (_Iter1 x0) { *x0; } &&
 requires (_Iter1 x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_Iter1 x0) { *x0; } &&
 requires (_Iter1 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[includes:_InputIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:9140:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_InputIterator2 x0) { ++x0; } &&
     requires (_InputIterator2 x0) { *x0; }
    )
   ) &&
   (
    (true)
   ) &&
   requires (_InputIterator2 x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator2 x0) { ++x0; } &&
 requires (_InputIterator2 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[is_heap_until:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12205:1
Printed constraint (original):
(
 (
  (
   requires (_RandomAccessIterator x0) { ++x0; } &&
   requires (_RandomAccessIterator x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__equal:_RandomAccessIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7629:1
Printed constraint (original):
(
 (
  (
   requires (_RandomAccessIterator1 x0) { *x0; } &&
   requires (_RandomAccessIterator1 x0) { ++x0; }
  )
 ) &&
 (
  (
   (
    (
     requires (_RandomAccessIterator1 x0) { ++x0; } &&
     requires (_RandomAccessIterator1 x0, _RandomAccessIterator1 x1) { x0 != x1; }
    ) ||
    (
     requires (_RandomAccessIterator1 x0, _RandomAccessIterator1 x1) { x0 - x1; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator1 x0) { *x0; } &&
 requires (_RandomAccessIterator1 x0) { ++x0; } &&
 (
  (
   requires (_RandomAccessIterator1 x0) { ++x0; } &&
   requires (_RandomAccessIterator1 x0, _RandomAccessIterator1 x1) { x0 != x1; }
  ) ||
  requires (_RandomAccessIterator1 x0, _RandomAccessIterator1 x1) { x0 - x1; }
 )
)
Inferred constraint:
InputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[count_if:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7595:1
Printed constraint (original):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[set_intersection:_InputIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18871:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 (
  (
   requires (_InputIterator1 x0) { ++x0; } &&
   requires (_InputIterator1 x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator1 x0) { ++x0; } &&
 requires (_InputIterator1 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[equal_range:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7733:1
Printed constraint (original):
(
 (
  (
   (
    (true)
   ) &&
   (
    (
     (
      (true)
     ) &&
     (
      (
       requires (_ForwardIterator x0) { ++x0; } &&
       requires (_ForwardIterator x0) { *x0; }
      )
     ) &&
     requires (_ForwardIterator x0) { ++x0; } &&
     (
      (true)
     ) &&
     requires (_ForwardIterator x0) { *x0; }
    )
   ) &&
   requires (_ForwardIterator x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[equal_range:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7719:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 (
  (
   (
    (true)
   ) &&
   (
    (
     requires (_ForwardIterator x0) { ++x0; } &&
     requires (_ForwardIterator x0) { *x0; }
    )
   ) &&
   requires (_ForwardIterator x0) { ++x0; } &&
   (
    (true)
   ) &&
   requires (_ForwardIterator x0) { *x0; }
  )
 ) &&
 requires (_ForwardIterator x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[swap_ranges:_ForwardIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:9348:1
Printed constraint (original):
(
 (
  (
   requires (_ForwardIterator2 x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
requires (_ForwardIterator2 x0) { ++x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[__fill_n:_Size]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7744:1
Printed constraint (original):
(
 requires (_Size x0) { --x0; }
)
Printed constraint (optimized):
requires (_Size x0) { --x0; }
Inferred constraint:
BidirectionalIterator RandomAccessIterator Float Integral 

[-[__find_end:_Iter1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:8756:1
Printed constraint (original):
(
 requires (_Iter1 x0) { --x0; }
)
Printed constraint (optimized):
requires (_Iter1 x0) { --x0; }
Inferred constraint:
BidirectionalIterator RandomAccessIterator Float Integral 

[-[find_first_of:_ForwardIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:8905:1
Printed constraint (original):
(
 (
  (
   requires (_ForwardIterator1 x0) { *x0; } &&
   requires (_ForwardIterator1 x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator1 x0) { *x0; } &&
 requires (_ForwardIterator1 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__uninitialized_move_n:_Size]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29949:1
Printed constraint (original):
(
 requires (_Size x0) { --x0; }
)
Printed constraint (optimized):
requires (_Size x0) { --x0; }
Inferred constraint:
BidirectionalIterator RandomAccessIterator Float Integral 

[-[inplace_merge:_BidirectionalIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12163:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        (true)
       ) &&
       (
        (
         (
          (
           (
            (
             requires (_BidirectionalIterator x0) { ++x0; }
            )
           ) &&
           (
            (
             requires (_BidirectionalIterator x0) { *x0; } &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             )
            )
           )
          ) ||
          (
           (
            (
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             requires (_BidirectionalIterator x0) { *x0; } &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             )
            )
           ) &&
           (
            (
             requires (_BidirectionalIterator x0) { ++x0; }
            )
           ) &&
           (
            (
             requires (_BidirectionalIterator x0) { *x0; } &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             )
            )
           )
          ) ||
          (
           (
            (
             requires (_BidirectionalIterator x0) { *x0; } &&
             true &&
             (
              (
               requires (_BidirectionalIterator x0) { ++x0; }
              )
             ) &&
             (
              (
               requires (_BidirectionalIterator x0) { ++x0; }
              )
             ) &&
             requires (_BidirectionalIterator x0) { --x0; } &&
             (
              (true)
             ) &&
             (
              (true)
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             requires (_BidirectionalIterator x0) { *x0; } &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             )
            )
           ) &&
           (
            (
             requires (_BidirectionalIterator x0) { ++x0; }
            )
           ) &&
           (
            (
             requires (_BidirectionalIterator x0) { *x0; } &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             )
            )
           )
          )
         )
        )
       ) &&
       (
        (true)
       ) &&
       (
        (true)
       ) &&
       (
        (
         (
          (true)
         ) &&
         (
          (
           requires (_BidirectionalIterator x0) { ++x0; } &&
           requires (_BidirectionalIterator x0) { *x0; }
          )
         ) &&
         requires (_BidirectionalIterator x0) { *x0; }
        )
       ) &&
       requires (_BidirectionalIterator x0) { *x0; } &&
       requires (_BidirectionalIterator x0) { ++x0; } &&
       (
        true
       ) &&
       (
        (
         (
          (
           requires (_BidirectionalIterator x0) { *x0; } &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           requires (_BidirectionalIterator x0) { ++x0; }
          )
         ) &&
         (
          (true)
         ) &&
         (
          (
           requires (_BidirectionalIterator x0) { ++x0; } &&
           requires (_BidirectionalIterator x0) { *x0; }
          )
         ) &&
         requires (_BidirectionalIterator x0) { ++x0; }
        )
       )
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 (
  (
   requires (_BidirectionalIterator x0) { ++x0; } &&
   requires (_BidirectionalIterator x0) { *x0; }
  ) ||
  (
   requires (_BidirectionalIterator x0) { *x0; } &&
   requires (_BidirectionalIterator x0) { ++x0; }
  ) ||
  (
   requires (_BidirectionalIterator x0) { *x0; } &&
   requires (_BidirectionalIterator x0) { ++x0; } &&
   requires (_BidirectionalIterator x0) { --x0; }
  )
 ) &&
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[destroy_n:_Size]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:11096:1
Printed constraint (original):
(
 requires (_Size x0) { --x0; }
)
Printed constraint (optimized):
requires (_Size x0) { --x0; }
Inferred constraint:
BidirectionalIterator RandomAccessIterator Float Integral 

[-[__search_impl:_Iter1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7905:1
Printed constraint (original):
(
 (
  (
   (
    (true)
   ) &&
   requires (_Iter1 x0) { ++x0; } &&
   requires (_Iter1 x0) { *x0; } &&
   (
    (true)
   ) &&
   (
    (true)
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_Iter1 x0) { ++x0; } &&
 requires (_Iter1 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__search_forward_impl:_Iter1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7797:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 requires (_Iter1 x0) { ++x0; } &&
 requires (_Iter1 x0) { *x0; } &&
 (
  (true)
 ) &&
 (
  (true)
 )
)
Printed constraint (optimized):
(
 requires (_Iter1 x0) { ++x0; } &&
 requires (_Iter1 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[search:_ForwardIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7926:1
Printed constraint (original):
(
 (
  (
   (
    (true)
   ) &&
   (
    (true)
   ) &&
   (
    (true)
   ) &&
   requires (_ForwardIterator1 x0, _ForwardIterator1 x1) { x0 - x1; }
  ) ||
  (
   (
    (true)
   )
  )
 ) &&
 (
  (
   (
    (
     (
      (true)
     ) &&
     requires (_ForwardIterator1 x0) { ++x0; } &&
     requires (_ForwardIterator1 x0) { *x0; } &&
     (
      (true)
     ) &&
     (
      (true)
     ) &&
     true
    )
   ) &&
   (
    (true)
   ) &&
   requires (_ForwardIterator1 x0, _ForwardIterator1 x1) { x1 - x0; } &&
   (
    (true)
   )
  ) ||
  (
   (
    (
     (
      (true)
     ) &&
     requires (_ForwardIterator1 x0) { ++x0; } &&
     requires (_ForwardIterator1 x0) { *x0; } &&
     (
      (true)
     ) &&
     (
      (true)
     )
    )
   )
  )
 ) &&
 requires (_ForwardIterator1 x0) { *x0; }
)
Printed constraint (optimized):
(
 (
  (
   requires (_ForwardIterator1 x0) { ++x0; } &&
   requires (_ForwardIterator1 x0) { *x0; } &&
   requires (_ForwardIterator1 x0, _ForwardIterator1 x1) { x1 - x0; }
  ) ||
  (
   requires (_ForwardIterator1 x0) { ++x0; } &&
   requires (_ForwardIterator1 x0) { *x0; }
  )
 ) &&
 requires (_ForwardIterator1 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[search:_ForwardIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7936:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (true)
     ) &&
     requires (_ForwardIterator2 x0, _ForwardIterator2 x1) { x0 - x1; }
    ) ||
    (
     (
      (true)
     )
    )
   ) &&
   (
    (
     (
      (
       requires (_ForwardIterator2 x0) { ++x0; } &&
       requires (_ForwardIterator2 x0) { *x0; }
      )
     ) &&
     requires (_ForwardIterator2 x0, _ForwardIterator2 x1) { x1 - x0; }
    ) ||
    (
     (
      (
       requires (_ForwardIterator2 x0) { ++x0; } &&
       requires (_ForwardIterator2 x0) { *x0; }
      )
     )
    )
   ) &&
   requires (_ForwardIterator2 x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 (
  (
   requires (_ForwardIterator2 x0) { ++x0; } &&
   requires (_ForwardIterator2 x0) { *x0; } &&
   requires (_ForwardIterator2 x0, _ForwardIterator2 x1) { x1 - x0; }
  ) ||
  (
   requires (_ForwardIterator2 x0) { ++x0; } &&
   requires (_ForwardIterator2 x0) { *x0; }
  )
 ) &&
 requires (_ForwardIterator2 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[is_heap:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12221:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_RandomAccessIterator x0) { ++x0; } &&
     requires (_RandomAccessIterator x0) { *x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[copy_if:_Predicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7524:1
Printed constraint (original):
(
 requires (_Predicate f, _InputIterator x0) { {f(*x0)} -> std::convertible_to<bool>; }
)
Printed constraint (optimized):
requires (_Predicate f, _InputIterator x0) { {f(*x0)} -> std::convertible_to<bool>; }
Inferred constraint:
UnaryFunction Predicate 

[-[is_sorted_until:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12413:1
Printed constraint (original):
(
 (
  (
   requires (_Compare f, _ForwardIterator x0, _ForwardIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
  )
 )
)
Printed constraint (optimized):
requires (_Compare f, _ForwardIterator x0, _ForwardIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[all_of:_Predicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:5746:1
Printed constraint (original):
(
 requires (_Predicate f, _InputIterator x0) { f(*x0); }
)
Printed constraint (optimized):
requires (_Predicate f, _InputIterator x0) { f(*x0); }
Inferred constraint:
UnaryFunction Predicate 

[-[merge:_InputIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12670:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_InputIterator1 x0) { *x0; } &&
     requires (_InputIterator1 x0) { ++x0; } &&
     (
      (
       (
        (
         (
          (
           (
            (
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       ) &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       )
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[equal:_InputIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7639:1
Printed constraint (original):
(
 (
  (
   requires (_InputIterator1 x0) { *x0; } &&
   requires (_InputIterator1 x0) { ++x0; }
  ) ||
  (
   (
    (
     requires (_InputIterator1 x0) { *x0; } &&
     requires (_InputIterator1 x0) { ++x0; }
    )
   ) &&
   (
    (
     (
      (
       requires (_InputIterator1 x0) { ++x0; } &&
       requires (_InputIterator1 x0, _InputIterator1 x1) { x0 != x1; }
      ) ||
      (
       requires (_InputIterator1 x0, _InputIterator1 x1) { x0 - x1; }
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 (
  requires (_InputIterator1 x0) { *x0; } &&
  requires (_InputIterator1 x0) { ++x0; }
 ) ||
 (
  requires (_InputIterator1 x0) { *x0; } &&
  requires (_InputIterator1 x0) { ++x0; } &&
  (
   (
    requires (_InputIterator1 x0) { ++x0; } &&
    requires (_InputIterator1 x0, _InputIterator1 x1) { x0 != x1; }
   ) ||
   requires (_InputIterator1 x0, _InputIterator1 x1) { x0 - x1; }
  )
 )
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[merge:_InputIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12662:1
Printed constraint (original):
(
 (
  (
   requires (_InputIterator1 x0) { *x0; } &&
   requires (_InputIterator1 x0) { ++x0; } &&
   (
    (
     (
      (
       (
        (
         (
          (
           (
            (true)
           )
          ) ||
          (true)
         )
        )
       )
      )
     ) &&
     (
      (
       (
        (
         (
          (
           (
            (true)
           ) &&
           (
            (true)
           )
          ) ||
          (true)
         )
        )
       )
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[mismatch:_InputIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12812:1
Printed constraint (original):
(
 (
  (
   requires (_InputIterator1 x0) { *x0; } &&
   requires (_InputIterator1 x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[replace_copy:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20377:1
Printed constraint (original):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__min_element_impl:_Ip]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:16691:1
Printed constraint (original):
(
 requires (_Ip x0) { *x0; } &&
 requires (_Ip x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_Ip x0) { *x0; } &&
 requires (_Ip x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[transform:_InputIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20538:1
Printed constraint (original):
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__partial_sort_copy:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14997:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_RandomAccessIterator x0) { ++x0; } &&
     requires (_RandomAccessIterator x0) { --x0; } &&
     (
      (
       requires (_RandomAccessIterator x0) { --x0; } &&
       requires (_RandomAccessIterator x0) { *x0; }
      )
     ) &&
     requires (_RandomAccessIterator x0) { *x0; } &&
     (
      (
       requires (_RandomAccessIterator x0) { ++x0; } &&
       requires (_RandomAccessIterator x0) { *x0; } &&
       true
      )
     )
    )
   ) &&
   requires (_RandomAccessIterator x0) { --x0; }
  )
 ) &&
 (
  (
   requires (_RandomAccessIterator x0) { ++x0; } &&
   requires (_RandomAccessIterator x0) { *x0; }
  )
 ) &&
 (
  (
   (
    (
     requires (_RandomAccessIterator x0) { ++x0; } &&
     requires (_RandomAccessIterator x0) { *x0; }
    )
   )
  )
 ) &&
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Inferred constraint:
RandomAccessIterator 

[-[minmax:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12767:1
Printed constraint (original):
(
 requires (_Compare f, _Tp x0, _Tp x1) { f(x0, x1); }
)
Printed constraint (optimized):
requires (_Compare f, _Tp x0, _Tp x1) { f(x0, x1); }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[partition_point:_Predicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:15137:1
Printed constraint (original):
(
 requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; }
)
Printed constraint (optimized):
requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; }
Inferred constraint:
UnaryFunction Predicate 

[-[find_end:_ForwardIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:8871:1
Printed constraint (original):
(
 (
  (
   (
    (true)
   ) &&
   (
    (
     requires (_ForwardIterator2 x0) { ++x0; } &&
     requires (_ForwardIterator2 x0) { *x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator2 x0) { ++x0; } &&
 requires (_ForwardIterator2 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[min_element:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7294:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (true)
     )
    )
   ) &&
   (
    (
     (
      (
       requires (_ForwardIterator x0) { *x0; } &&
       requires (_ForwardIterator x0) { ++x0; }
      )
     )
    )
   ) &&
   requires (_ForwardIterator x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[min_element:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7284:1
Printed constraint (original):
(
 (
  (
   (
    (true)
   )
  )
 ) &&
 (
  (
   (
    (
     requires (_ForwardIterator x0) { *x0; } &&
     requires (_ForwardIterator x0) { ++x0; }
    )
   )
  )
 ) &&
 requires (_ForwardIterator x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__find_first_of_ce:_ForwardIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:8886:1
Printed constraint (original):
(
 requires (_ForwardIterator1 x0) { *x0; } &&
 requires (_ForwardIterator1 x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_ForwardIterator1 x0) { *x0; } &&
 requires (_ForwardIterator1 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[for_each:_Function]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:8932:1
Printed constraint (original):
(
 requires (_Function f, _InputIterator x0) { f(*x0); }
)
Printed constraint (optimized):
requires (_Function f, _InputIterator x0) { f(*x0); }
Inferred constraint:
UnaryFunction Predicate 

[-[generate:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:8957:1
Printed constraint (original):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[generate:_Generator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:8957:1
Printed constraint (original):
(
 requires (_Generator f) { f(); }
)
Printed constraint (optimized):
requires (_Generator f) { f(); }
Inferred constraint:


[-[__search_random_access_impl:_DiffT1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7837:1
Printed constraint (original):
(
 requires (_DiffT1 x0, _Iter1 x1) { x1 + x0; }
)
Printed constraint (optimized):
requires (_DiffT1 x0, _Iter1 x1) { x1 + x0; }
Inferred constraint:
RandomAccessIterator Float Integral 

[-[__sample:_PopulationIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18328:1
Printed constraint (original):
(
 requires (_PopulationIterator x0) { *x0; } &&
 requires (_PopulationIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_PopulationIterator x0) { *x0; } &&
 requires (_PopulationIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__find_end:_Iter2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:8803:1
Printed constraint (original):
(
 requires (_Iter2 x0) { *x0; } &&
 requires (_Iter2 x0) { --x0; }
)
Printed constraint (optimized):
(
 requires (_Iter2 x0) { *x0; } &&
 requires (_Iter2 x0) { --x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[adjacent_find:_BinaryPredicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:5734:1
Printed constraint (original):
(
 (
  (
   requires (_BinaryPredicate f, _ForwardIterator x0, _ForwardIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
  )
 )
)
Printed constraint (optimized):
requires (_BinaryPredicate f, _ForwardIterator x0, _ForwardIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[copy_n:_OutputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7542:1
Printed constraint (original):
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[partial_sort:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:13078:1
Printed constraint (original):
(
 (
  (
   (
    (true)
   ) &&
   (
    (true)
   )
  )
 ) &&
 (
  (
   (
    (
     requires (_RandomAccessIterator x0) { ++x0; } &&
     (
      (
       (
        (
         requires (_RandomAccessIterator x0) { ++x0; } &&
         requires (_RandomAccessIterator x0) { --x0; } &&
         (
          (
           requires (_RandomAccessIterator x0) { --x0; } &&
           requires (_RandomAccessIterator x0) { *x0; }
          )
         ) &&
         requires (_RandomAccessIterator x0) { *x0; } &&
         (
          (
           requires (_RandomAccessIterator x0) { ++x0; } &&
           requires (_RandomAccessIterator x0) { *x0; } &&
           true
          )
         )
        )
       ) &&
       requires (_RandomAccessIterator x0) { --x0; }
      )
     ) &&
     (
      (
       requires (_RandomAccessIterator x0) { ++x0; } &&
       requires (_RandomAccessIterator x0) { *x0; }
      )
     ) &&
     requires (_RandomAccessIterator x0) { *x0; } &&
     (
      (
       (
        (
         requires (_RandomAccessIterator x0) { ++x0; } &&
         requires (_RandomAccessIterator x0) { *x0; }
        )
       )
      )
     )
    )
   ) &&
   (
    (true)
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Inferred constraint:
RandomAccessIterator 

[-[partition_copy:_OutputIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:15113:1
Printed constraint (original):
(
 requires (_OutputIterator2 x0) { ++x0; } &&
 requires (_OutputIterator2 x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_OutputIterator2 x0) { ++x0; } &&
 requires (_OutputIterator2 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__uninitialized_value_construct_n:_Size]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29905:1
Printed constraint (original):
(
 requires (_Size x0) { --x0; }
)
Printed constraint (optimized):
requires (_Size x0) { --x0; }
Inferred constraint:
BidirectionalIterator RandomAccessIterator Float Integral 

[-[find_end:_ForwardIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:8878:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (true)
     ) &&
     (
      (
       requires (_ForwardIterator1 x0) { ++x0; } &&
       requires (_ForwardIterator1 x0) { *x0; }
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator1 x0) { ++x0; } &&
 requires (_ForwardIterator1 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[equal:_BinaryPredicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7607:1
Printed constraint (original):
(
 requires (_BinaryPredicate f, _InputIterator1 x0, _InputIterator2 x1) { f(*x0, *x1); }
)
Printed constraint (optimized):
requires (_BinaryPredicate f, _InputIterator1 x0, _InputIterator2 x1) { f(*x0, *x1); }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[search:_ForwardIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7926:1
Printed constraint (original):
(
 (
  (
   (
    (true)
   ) &&
   requires (_ForwardIterator2 x0, _ForwardIterator2 x1) { x0 - x1; }
  ) ||
  (
   (
    (true)
   )
  )
 ) &&
 (
  (
   (
    (
     requires (_ForwardIterator2 x0) { ++x0; } &&
     requires (_ForwardIterator2 x0) { *x0; }
    )
   ) &&
   requires (_ForwardIterator2 x0, _ForwardIterator2 x1) { x1 - x0; }
  ) ||
  (
   (
    (
     requires (_ForwardIterator2 x0) { ++x0; } &&
     requires (_ForwardIterator2 x0) { *x0; }
    )
   )
  )
 ) &&
 requires (_ForwardIterator2 x0) { *x0; }
)
Printed constraint (optimized):
(
 (
  (
   requires (_ForwardIterator2 x0) { ++x0; } &&
   requires (_ForwardIterator2 x0) { *x0; } &&
   requires (_ForwardIterator2 x0, _ForwardIterator2 x1) { x1 - x0; }
  ) ||
  (
   requires (_ForwardIterator2 x0) { ++x0; } &&
   requires (_ForwardIterator2 x0) { *x0; }
  )
 ) &&
 requires (_ForwardIterator2 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[find_first_of:_ForwardIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:8899:1
Printed constraint (original):
(
 (
  (
   requires (_ForwardIterator2 x0) { *x0; } &&
   requires (_ForwardIterator2 x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator2 x0) { *x0; } &&
 requires (_ForwardIterator2 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[replace_copy_if:_OutputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20392:1
Printed constraint (original):
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__search_impl:_Iter2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7877:1
Printed constraint (original):
(
 (
  (
   requires (_Iter2 x0) { ++x0; } &&
   requires (_Iter2 x0) { *x0; }
  )
 ) &&
 requires (_Iter2 x0, _Sent2 x1) { x1 - x0; }
)
Printed constraint (optimized):
(
 requires (_Iter2 x0) { ++x0; } &&
 requires (_Iter2 x0) { *x0; } &&
 requires (_Iter2 x0, _Sent2 x1) { x1 - x0; }
)
Inferred constraint:
RandomAccessIterator 

[-[__search_random_access_impl:_Iter2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7837:1
Printed constraint (original):
(
 requires (_Iter2 x0) { ++x0; } &&
 requires (_Iter2 x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_Iter2 x0) { ++x0; } &&
 requires (_Iter2 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__swap_ranges:_ForwardIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:9337:1
Printed constraint (original):
(
 requires (_ForwardIterator1 x0) { ++x0; }
)
Printed constraint (optimized):
requires (_ForwardIterator1 x0) { ++x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[swap_ranges:_ForwardIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:9348:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 (
  (
   requires (_ForwardIterator1 x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
requires (_ForwardIterator1 x0) { ++x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[for_each_n:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:8942:1
Printed constraint (original):
(
 requires (_InputIterator x0) { ++x0; } &&
 requires (_InputIterator x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator x0) { ++x0; } &&
 requires (_InputIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[nth_element:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14912:1
Printed constraint (original):
(
 (
  (
   (
    (
     true &&
     true &&
     requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
     true &&
     true &&
     (
      (
       requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
      )
     ) &&
     requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); } &&
     (
      (
       (
        (
         (
          (true)
         )
        )
       )
      )
     ) &&
     (
      (
       requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
       requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
)
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__rotate_right:_BidirectionalIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:9368:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        (true)
       ) &&
       (
        (true)
       )
      ) ||
      (true)
     )
    )
   )
  )
 ) &&
 (
  (
   (
    (
     (
      (
       (
        (true)
       )
      ) ||
      (true)
     )
    )
   )
  )
 ) &&
 requires (_BidirectionalIterator x0) { *x0; } &&
 (
  (
   (
    (
     (
      (
       (
        (true)
       ) &&
       (
        (true)
       )
      ) ||
      (true)
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
requires (_BidirectionalIterator x0) { *x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__find_end_classic:_ForwardIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:8853:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 (
  (
   requires (_ForwardIterator2 x0) { ++x0; } &&
   requires (_ForwardIterator2 x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator2 x0) { ++x0; } &&
 requires (_ForwardIterator2 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__rotate_forward:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:9380:1
Printed constraint (original):
(
 requires (_ForwardIterator x0) { ++x0; }
)
Printed constraint (optimized):
requires (_ForwardIterator x0) { ++x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[__unique:_Sent]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20061:1
Printed constraint (original):
(
 (
  (
   requires (_Sent x0, _Iter x1) { ++x1 != x0; } &&
   requires (_Sent x0, _Iter x1) { x1 == x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_Sent x0, _Iter x1) { ++x1 != x0; } &&
 requires (_Sent x0, _Iter x1) { x1 == x0; }
)
Inferred constraint:
InputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[equal:_InputIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7647:1
Printed constraint (original):
(
 (
  (
   requires (_InputIterator2 x0) { *x0; } &&
   requires (_InputIterator2 x0) { ++x0; }
  ) ||
  (
   (
    (
     requires (_InputIterator2 x0) { *x0; } &&
     requires (_InputIterator2 x0) { ++x0; }
    )
   ) &&
   (
    (
     (
      (
       requires (_InputIterator2 x0) { ++x0; } &&
       requires (_InputIterator2 x0, _InputIterator2 x1) { x0 != x1; }
      ) ||
      (
       requires (_InputIterator2 x0, _InputIterator2 x1) { x0 - x1; }
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 (
  requires (_InputIterator2 x0) { *x0; } &&
  requires (_InputIterator2 x0) { ++x0; }
 ) ||
 (
  requires (_InputIterator2 x0) { *x0; } &&
  requires (_InputIterator2 x0) { ++x0; } &&
  (
   (
    requires (_InputIterator2 x0) { ++x0; } &&
    requires (_InputIterator2 x0, _InputIterator2 x1) { x0 != x1; }
   ) ||
   requires (_InputIterator2 x0, _InputIterator2 x1) { x0 - x1; }
  )
 )
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__count_if_impl:_Iter]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:15707:1
Printed constraint (original):
(
 requires (_Iter x0) { *x0; } &&
 requires (_Iter x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_Iter x0) { *x0; } &&
 requires (_Iter x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[copy_if:_OutputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7524:1
Printed constraint (original):
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__min_element:_Iter]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7278:1
Printed constraint (original):
(
 (
  (
   requires (_Iter x0) { *x0; } &&
   requires (_Iter x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_Iter x0) { *x0; } &&
 requires (_Iter x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__replace_copy_if_impl:_OutIter]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:17813:1
Printed constraint (original):
(
 requires (_OutIter x0) { ++x0; } &&
 requires (_OutIter x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_OutIter x0) { ++x0; } &&
 requires (_OutIter x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__uninitialized_value_construct:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29885:1
Printed constraint (original):
(
 (
  (
   requires (_ForwardIterator x0) { *x0; } &&
   requires (_ForwardIterator x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[is_permutation:_ForwardIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12385:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (true)
     ) &&
     requires (_ForwardIterator1 x0) { ++x0; } &&
     requires (_ForwardIterator1 x0) { *x0; }
    ) ||
    (
     (
      (
       (
        (true)
       ) &&
       requires (_ForwardIterator1 x0) { ++x0; } &&
       requires (_ForwardIterator1 x0) { *x0; }
      ) ||
      true
     ) &&
     (
      (
       (
        (
         requires (_ForwardIterator1 x0) { ++x0; } &&
         requires (_ForwardIterator1 x0, _ForwardIterator1 x1) { x0 != x1; }
        ) ||
        (
         requires (_ForwardIterator1 x0, _ForwardIterator1 x1) { x0 - x1; }
        )
       )
      )
     )
    )
   )
  )
 ) &&
 (
  (
   (
    (
     (
      (true)
     )
    ) ||
    (
     (
      (
       (
        (true)
       )
      ) ||
      true
     ) &&
     (
      (
       (
        (
         requires (_ForwardIterator1 x0) { ++x0; } &&
         requires (_ForwardIterator1 x0, _ForwardIterator1 x1) { x0 != x1; }
        ) ||
        (
         requires (_ForwardIterator1 x0, _ForwardIterator1 x1) { x0 - x1; }
        )
       )
      )
     )
    )
   )
  )
 ) &&
 requires (_ForwardIterator1 x0) { *x0; }
)
Printed constraint (optimized):
(
 (
  (
   requires (_ForwardIterator1 x0) { ++x0; } &&
   requires (_ForwardIterator1 x0) { *x0; }
  ) ||
  (
   requires (_ForwardIterator1 x0) { ++x0; } &&
   requires (_ForwardIterator1 x0, _ForwardIterator1 x1) { x0 != x1; }
  ) ||
  requires (_ForwardIterator1 x0, _ForwardIterator1 x1) { x0 - x1; }
 ) &&
 requires (_ForwardIterator1 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__fill:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7770:1
Printed constraint (original):
(
 requires (_RandomAccessIterator x0, _RandomAccessIterator x1) { x0 - x1; } &&
 (
  (
   (
    (
     requires (_RandomAccessIterator x0) { *x0; } &&
     requires (_RandomAccessIterator x0) { ++x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0, _RandomAccessIterator x1) { x0 - x1; } &&
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { ++x0; }
)
Inferred constraint:
RandomAccessIterator 

[-[__equal_range:_Iter]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7696:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 (
  (
   requires (_Iter x0) { ++x0; } &&
   requires (_Iter x0) { *x0; }
  )
 ) &&
 requires (_Iter x0) { ++x0; } &&
 (
  (true)
 ) &&
 requires (_Iter x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_Iter x0) { ++x0; } &&
 requires (_Iter x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__sort4:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14236:1
Printed constraint (original):
(
 requires (_Compare f, _ForwardIterator x0, _ForwardIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 (
  (
   requires (_Compare f, _ForwardIterator x0, _ForwardIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
   requires (_Compare f, _ForwardIterator x0, _ForwardIterator x1) { f(*x0, *x1); }
  )
 )
)
Printed constraint (optimized):
(
 requires (_Compare f, _ForwardIterator x0, _ForwardIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 requires (_Compare f, _ForwardIterator x0, _ForwardIterator x1) { f(*x0, *x1); }
)
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[find_if_not:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:8922:1
Printed constraint (original):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[end:_Cp]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:10991:1
Printed constraint (original):
(
 requires (_Cp o) { o.end(); }
)
Printed constraint (optimized):
requires (_Cp o) { o.end(); }
Inferred constraint:


[-[is_permutation:_ForwardIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12359:1
Printed constraint (original):
(
 (
  (
   (
    (true)
   ) &&
   requires (_ForwardIterator2 x0) { *x0; } &&
   requires (_ForwardIterator2 x0) { ++x0; }
  )
 ) &&
 requires (_ForwardIterator2 x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_ForwardIterator2 x0) { *x0; } &&
 requires (_ForwardIterator2 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[equal:_InputIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7615:1
Printed constraint (original):
(
 (
  (
   requires (_InputIterator1 x0) { *x0; } &&
   requires (_InputIterator1 x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[distance:_InputIter]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:5425:1
Printed constraint (original):
(
 (
  (
   requires (_InputIter x0) { ++x0; } &&
   requires (_InputIter x0, _InputIter x1) { x0 != x1; }
  ) ||
  (
   requires (_InputIter x0, _InputIter x1) { x0 - x1; }
  )
 )
)
Printed constraint (optimized):
(
 (
  requires (_InputIter x0) { ++x0; } &&
  requires (_InputIter x0, _InputIter x1) { x0 != x1; }
 ) ||
 requires (_InputIter x0, _InputIter x1) { x0 - x1; }
)
Inferred constraint:
InputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[is_permutation:_ForwardIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12373:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (true)
     )
    ) ||
    (
     (
      (
       (
        (true)
       )
      ) ||
      true
     ) &&
     (
      (
       (
        (
         requires (_ForwardIterator2 x0) { ++x0; } &&
         requires (_ForwardIterator2 x0, _ForwardIterator2 x1) { x0 != x1; }
        ) ||
        (
         requires (_ForwardIterator2 x0, _ForwardIterator2 x1) { x0 - x1; }
        )
       )
      )
     )
    )
   )
  )
 ) &&
 (
  (
   (
    (
     requires (_ForwardIterator2 x0) { ++x0; } &&
     (
      (true)
     ) &&
     requires (_ForwardIterator2 x0) { *x0; }
    ) ||
    (
     (
      (
       requires (_ForwardIterator2 x0) { ++x0; } &&
       (
        (true)
       ) &&
       requires (_ForwardIterator2 x0) { *x0; }
      ) ||
      true
     ) &&
     (
      (
       (
        (
         requires (_ForwardIterator2 x0) { ++x0; } &&
         requires (_ForwardIterator2 x0, _ForwardIterator2 x1) { x0 != x1; }
        ) ||
        (
         requires (_ForwardIterator2 x0, _ForwardIterator2 x1) { x0 - x1; }
        )
       )
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 (
  requires (_ForwardIterator2 x0) { ++x0; } &&
  requires (_ForwardIterator2 x0) { *x0; }
 ) ||
 (
  requires (_ForwardIterator2 x0) { ++x0; } &&
  requires (_ForwardIterator2 x0, _ForwardIterator2 x1) { x0 != x1; }
 ) ||
 requires (_ForwardIterator2 x0, _ForwardIterator2 x1) { x0 - x1; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[__search_impl:_Sent2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7877:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 requires (_Sent2 x0, _Iter2 x1) { x0 - x1; }
)
Printed constraint (optimized):
requires (_Sent2 x0, _Iter2 x1) { x0 - x1; }
Inferred constraint:
RandomAccessIterator Float Integral 

[-[mismatch:_InputIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12812:1
Printed constraint (original):
(
 (
  (
   requires (_InputIterator2 x0) { *x0; } &&
   requires (_InputIterator2 x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator2 x0) { *x0; } &&
 requires (_InputIterator2 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[mismatch:_InputIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12803:1
Printed constraint (original):
(
 requires (_InputIterator2 x0) { *x0; } &&
 requires (_InputIterator2 x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator2 x0) { *x0; } &&
 requires (_InputIterator2 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__search_impl:_Sent1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7877:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 (
  (true)
 ) &&
 (
  (true)
 ) &&
 requires (_Sent1 x0, _Iter1 x1) { x0 - x1; }
)
Printed constraint (optimized):
requires (_Sent1 x0, _Iter1 x1) { x0 - x1; }
Inferred constraint:
RandomAccessIterator Float Integral 

[-[round:_ToDuration]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20991:1
Printed constraint (original):
(
 requires (_ToDuration o) { o.count(); }
)
Printed constraint (optimized):
requires (_ToDuration o) { o.count(); }
Inferred constraint:


[-[__nth_element_impl:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14899:1
Printed constraint (original):
(
 (
  (
   true &&
   true &&
   requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
   true &&
   true &&
   (
    (
     requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
    )
   ) &&
   requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); } &&
   (
    (
     (
      (
       (
        (true)
       )
      )
     )
    )
   ) &&
   (
    (
     requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
     requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
)
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[uninitialized_default_construct:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29859:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 (
  (
   (
    (
     requires (_ForwardIterator x0) { *x0; } &&
     requires (_ForwardIterator x0) { ++x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[equal:_InputIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7647:1
Printed constraint (original):
(
 (
  (
   requires (_InputIterator1 x0) { *x0; } &&
   requires (_InputIterator1 x0) { ++x0; }
  ) ||
  (
   (
    (
     requires (_InputIterator1 x0) { *x0; } &&
     requires (_InputIterator1 x0) { ++x0; }
    )
   ) &&
   (
    (
     (
      (
       requires (_InputIterator1 x0) { ++x0; } &&
       requires (_InputIterator1 x0, _InputIterator1 x1) { x0 != x1; }
      ) ||
      (
       requires (_InputIterator1 x0, _InputIterator1 x1) { x0 - x1; }
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 (
  requires (_InputIterator1 x0) { *x0; } &&
  requires (_InputIterator1 x0) { ++x0; }
 ) ||
 (
  requires (_InputIterator1 x0) { *x0; } &&
  requires (_InputIterator1 x0) { ++x0; } &&
  (
   (
    requires (_InputIterator1 x0) { ++x0; } &&
    requires (_InputIterator1 x0, _InputIterator1 x1) { x0 != x1; }
   ) ||
   requires (_InputIterator1 x0, _InputIterator1 x1) { x0 - x1; }
  )
 )
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__reverse_destroy:_BidirectionalIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:11072:1
Printed constraint (original):
(
 requires (_BidirectionalIterator x0) { *x0; } &&
 requires (_BidirectionalIterator x0) { --x0; }
)
Printed constraint (optimized):
(
 requires (_BidirectionalIterator x0) { *x0; } &&
 requires (_BidirectionalIterator x0) { --x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[__equal:_InputIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7620:1
Printed constraint (original):
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__half_inplace_merge:_InputIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12004:1
Printed constraint (original):
(
 requires (_InputIterator1 x0) { ++x0; } &&
 requires (_InputIterator1 x0) { *x0; } &&
 (
  (
   (
    (
     (
      (
       (
        (true)
       ) &&
       (
        (true)
       )
      ) ||
      (true)
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator1 x0) { ++x0; } &&
 requires (_InputIterator1 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[lower_bound:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:5875:1
Printed constraint (original):
(
 (
  (
   (
    (true)
   ) &&
   (
    (
     requires (_ForwardIterator x0) { ++x0; } &&
     requires (_ForwardIterator x0) { *x0; }
    )
   ) &&
   requires (_ForwardIterator x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[reverse_copy:_OutputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20419:1
Printed constraint (original):
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[set_intersection:_OutputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18888:1
Printed constraint (original):
(
 (
  (
   requires (_OutputIterator x0) { ++x0; } &&
   requires (_OutputIterator x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[max:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12604:1
Printed constraint (original):
(
 requires (_Compare f, _Tp x0, _Tp x1) { f(x0, x1); }
)
Printed constraint (optimized):
requires (_Compare f, _Tp x0, _Tp x1) { f(x0, x1); }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[inplace_merge:_BidirectionalIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12157:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (true)
     ) &&
     (
      (
       (
        (
         (
          (
           requires (_BidirectionalIterator x0) { ++x0; }
          )
         ) &&
         (
          (
           requires (_BidirectionalIterator x0) { *x0; } &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           )
          )
         )
        ) ||
        (
         (
          (
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           requires (_BidirectionalIterator x0) { *x0; } &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           )
          )
         ) &&
         (
          (
           requires (_BidirectionalIterator x0) { ++x0; }
          )
         ) &&
         (
          (
           requires (_BidirectionalIterator x0) { *x0; } &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           )
          )
         )
        ) ||
        (
         (
          (
           requires (_BidirectionalIterator x0) { *x0; } &&
           true &&
           (
            (
             requires (_BidirectionalIterator x0) { ++x0; }
            )
           ) &&
           (
            (
             requires (_BidirectionalIterator x0) { ++x0; }
            )
           ) &&
           requires (_BidirectionalIterator x0) { --x0; } &&
           (
            (true)
           ) &&
           (
            (true)
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           requires (_BidirectionalIterator x0) { *x0; } &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           )
          )
         ) &&
         (
          (
           requires (_BidirectionalIterator x0) { ++x0; }
          )
         ) &&
         (
          (
           requires (_BidirectionalIterator x0) { *x0; } &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           )
          )
         )
        )
       )
      )
     ) &&
     (
      (true)
     ) &&
     (
      (true)
     ) &&
     (
      (
       (
        (true)
       ) &&
       (
        (
         requires (_BidirectionalIterator x0) { ++x0; } &&
         requires (_BidirectionalIterator x0) { *x0; }
        )
       ) &&
       requires (_BidirectionalIterator x0) { *x0; }
      )
     ) &&
     requires (_BidirectionalIterator x0) { *x0; } &&
     requires (_BidirectionalIterator x0) { ++x0; } &&
     (
      true
     ) &&
     (
      (
       (
        (
         requires (_BidirectionalIterator x0) { *x0; } &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         requires (_BidirectionalIterator x0) { ++x0; }
        )
       ) &&
       (
        (true)
       ) &&
       (
        (
         requires (_BidirectionalIterator x0) { ++x0; } &&
         requires (_BidirectionalIterator x0) { *x0; }
        )
       ) &&
       requires (_BidirectionalIterator x0) { ++x0; }
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 (
  (
   requires (_BidirectionalIterator x0) { ++x0; } &&
   requires (_BidirectionalIterator x0) { *x0; }
  ) ||
  (
   requires (_BidirectionalIterator x0) { *x0; } &&
   requires (_BidirectionalIterator x0) { ++x0; }
  ) ||
  (
   requires (_BidirectionalIterator x0) { *x0; } &&
   requires (_BidirectionalIterator x0) { ++x0; } &&
   requires (_BidirectionalIterator x0) { --x0; }
  )
 ) &&
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[is_heap:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12213:1
Printed constraint (original):
(
 (
  (
   requires (_RandomAccessIterator x0) { ++x0; } &&
   requires (_RandomAccessIterator x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[is_partitioned:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12232:1
Printed constraint (original):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[uninitialized_fill_n:_Size]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29839:1
Printed constraint (original):
(
 (
  (
   requires (_Size x0) { --x0; }
  )
 )
)
Printed constraint (optimized):
requires (_Size x0) { --x0; }
Inferred constraint:
BidirectionalIterator RandomAccessIterator Float Integral 

[-[__find_first_of_ce:_ForwardIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:8886:1
Printed constraint (original):
(
 requires (_ForwardIterator2 x0) { *x0; } &&
 requires (_ForwardIterator2 x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_ForwardIterator2 x0) { *x0; } &&
 requires (_ForwardIterator2 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__find_end:_Iter2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:8756:1
Printed constraint (original):
(
 requires (_Iter2 x0) { *x0; } &&
 requires (_Iter2 x0) { --x0; }
)
Printed constraint (optimized):
(
 requires (_Iter2 x0) { *x0; } &&
 requires (_Iter2 x0) { --x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[find_if_not:_Predicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:8922:1
Printed constraint (original):
(
 requires (_Predicate f, _InputIterator x0) { f(*x0); }
)
Printed constraint (optimized):
requires (_Predicate f, _InputIterator x0) { f(*x0); }
Inferred constraint:
UnaryFunction Predicate 

[-[partition_copy:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:15113:1
Printed constraint (original):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__is_permutation:_Sent2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12334:1
Printed constraint (original):
(
 (
  (
   (
    (true)
   )
  ) ||
  true
 ) &&
 (
  (
   (
    (
     requires (_Sent2 x0) { ++x0; } &&
     requires (_Sent2 x0, _Sent2 x1) { x0 != x1; }
    ) ||
    (
     requires (_Sent2 x0, _Sent2 x1) { x0 - x1; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 (
  requires (_Sent2 x0) { ++x0; } &&
  requires (_Sent2 x0, _Sent2 x1) { x0 != x1; }
 ) ||
 requires (_Sent2 x0, _Sent2 x1) { x0 - x1; }
)
Inferred constraint:
InputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[unique_copy:_OutputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20199:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_OutputIterator x0) { ++x0; } &&
     requires (_OutputIterator x0) { *x0; }
    ) ||
    (
     requires (_OutputIterator x0) { ++x0; } &&
     requires (_OutputIterator x0) { *x0; }
    ) ||
    (
     requires (_OutputIterator x0) { ++x0; } &&
     requires (_OutputIterator x0) { *x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[is_permutation:_ForwardIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12385:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (true)
     )
    ) ||
    (
     (
      (
       (
        (true)
       )
      ) ||
      true
     ) &&
     (
      (
       (
        (
         requires (_ForwardIterator2 x0) { ++x0; } &&
         requires (_ForwardIterator2 x0, _ForwardIterator2 x1) { x0 != x1; }
        ) ||
        (
         requires (_ForwardIterator2 x0, _ForwardIterator2 x1) { x0 - x1; }
        )
       )
      )
     )
    )
   )
  )
 ) &&
 (
  (
   (
    (
     requires (_ForwardIterator2 x0) { ++x0; } &&
     (
      (true)
     ) &&
     requires (_ForwardIterator2 x0) { *x0; }
    ) ||
    (
     (
      (
       requires (_ForwardIterator2 x0) { ++x0; } &&
       (
        (true)
       ) &&
       requires (_ForwardIterator2 x0) { *x0; }
      ) ||
      true
     ) &&
     (
      (
       (
        (
         requires (_ForwardIterator2 x0) { ++x0; } &&
         requires (_ForwardIterator2 x0, _ForwardIterator2 x1) { x0 != x1; }
        ) ||
        (
         requires (_ForwardIterator2 x0, _ForwardIterator2 x1) { x0 - x1; }
        )
       )
      )
     )
    )
   )
  )
 ) &&
 requires (_ForwardIterator2 x0) { *x0; }
)
Printed constraint (optimized):
(
 (
  (
   requires (_ForwardIterator2 x0) { ++x0; } &&
   requires (_ForwardIterator2 x0) { *x0; }
  ) ||
  (
   requires (_ForwardIterator2 x0) { ++x0; } &&
   requires (_ForwardIterator2 x0, _ForwardIterator2 x1) { x0 != x1; }
  ) ||
  requires (_ForwardIterator2 x0, _ForwardIterator2 x1) { x0 - x1; }
 ) &&
 requires (_ForwardIterator2 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[count:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7583:1
Printed constraint (original):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[is_sorted_until:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12419:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_ForwardIterator x0) { *x0; } &&
     requires (_ForwardIterator x0) { ++x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[is_sorted_until:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12413:1
Printed constraint (original):
(
 (
  (
   requires (_ForwardIterator x0) { *x0; } &&
   requires (_ForwardIterator x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__find_end_impl:_Iter1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:8706:1
Printed constraint (original):
(
 requires (_Iter1 x0) { ++x0; } &&
 requires (_Iter1 x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_Iter1 x0) { ++x0; } &&
 requires (_Iter1 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__is_sorted_until:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12397:1
Printed constraint (original):
(
 requires (_Compare f, _ForwardIterator x0, _ForwardIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
)
Printed constraint (optimized):
requires (_Compare f, _ForwardIterator x0, _ForwardIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__partition_impl:_BidirectionalIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:15069:1
Printed constraint (original):
(
 requires (_BidirectionalIterator x0) { --x0; } &&
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { *x0; } &&
 (
  (true)
 ) &&
 (
  (true)
 )
)
Printed constraint (optimized):
(
 requires (_BidirectionalIterator x0) { --x0; } &&
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { *x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[is_sorted:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12435:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_ForwardIterator x0) { *x0; } &&
     requires (_ForwardIterator x0) { ++x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[transform:_BinaryOperation]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20538:1
Printed constraint (original):
(
 requires (_BinaryOperation f, _InputIterator1 x0, _InputIterator2 x1) { f(*x0, *x1); }
)
Printed constraint (optimized):
requires (_BinaryOperation f, _InputIterator1 x0, _InputIterator2 x1) { f(*x0, *x1); }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__is_sorted_until:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12397:1
Printed constraint (original):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[lexicographical_compare:_InputIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12459:1
Printed constraint (original):
(
 (
  (
   requires (_InputIterator1 x0) { *x0; } &&
   requires (_InputIterator1 x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[lexicographical_compare:_InputIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12468:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_InputIterator1 x0) { *x0; } &&
     requires (_InputIterator1 x0) { ++x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__equal:_BinaryPredicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7620:1
Printed constraint (original):
(
 requires (_BinaryPredicate f, _InputIterator1 x0, _InputIterator2 x1) { f(*x0, *x1); }
)
Printed constraint (optimized):
requires (_BinaryPredicate f, _InputIterator1 x0, _InputIterator2 x1) { f(*x0, *x1); }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__lexicographical_compare:_InputIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12445:1
Printed constraint (original):
(
 requires (_InputIterator2 x0) { *x0; } &&
 requires (_InputIterator2 x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator2 x0) { *x0; } &&
 requires (_InputIterator2 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__search_n_random_access_impl:_SizeT]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18567:1
Printed constraint (original):
(
 requires (_SizeT x0) { ++x0; }
)
Printed constraint (optimized):
requires (_SizeT x0) { ++x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[__max_element:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12573:1
Printed constraint (original):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[unique:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20080:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       requires (_ForwardIterator x0, _ForwardIterator x1) { ++x1 != x0; } &&
       requires (_ForwardIterator x0, _ForwardIterator x1) { x1 == x0; }
      )
     )
    )
   ) &&
   (
    (
     requires (_ForwardIterator x0) { *x0; } &&
     requires (_ForwardIterator x0) { ++x0; } &&
     (
      (
       requires (_ForwardIterator x0) { *x0; } &&
       requires (_ForwardIterator x0) { ++x0; } &&
       requires (_ForwardIterator x0, _ForwardIterator x1) { x0 == x1; }
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0, _ForwardIterator x1) { ++x1 != x0; } &&
 requires (_ForwardIterator x0, _ForwardIterator x1) { x1 == x0; } &&
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0, _ForwardIterator x1) { x0 == x1; }
)
Inferred constraint:
InputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[equal:_InputIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7607:1
Printed constraint (original):
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[max_element:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12588:1
Printed constraint (original):
(
 (
  (
   requires (_Compare f, _ForwardIterator x0, _ForwardIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
  )
 )
)
Printed constraint (optimized):
requires (_Compare f, _ForwardIterator x0, _ForwardIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__make_heap:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12548:1
Printed constraint (original):
(
 (
  (
   requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
   true
  )
 )
)
Printed constraint (optimized):
requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__partial_sort_impl:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:13045:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       true &&
       true
      )
     ) &&
     (
      (
       true
      )
     )
    )
   )
  )
 ) &&
 (
  (
   requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
   true
  )
 ) &&
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 (
  (
   (
    (
     requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
     true
    )
   )
  )
 )
)
Printed constraint (optimized):
requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[merge:_InputIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12662:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (
           (
            (true)
           )
          ) ||
          (true)
         )
        )
       )
      )
     ) &&
     (
      (
       (
        (
         (
          (
           (
            (true)
           ) &&
           (
            (true)
           )
          ) ||
          (true)
         )
        )
       )
      )
     )
    )
   ) &&
   requires (_InputIterator2 x0) { ++x0; } &&
   requires (_InputIterator2 x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator2 x0) { ++x0; } &&
 requires (_InputIterator2 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[merge:_InputIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12670:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (
           (
            (
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       ) &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       )
      )
     ) &&
     requires (_InputIterator2 x0) { ++x0; } &&
     requires (_InputIterator2 x0) { *x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator2 x0) { ++x0; } &&
 requires (_InputIterator2 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[stable_partition:_Predicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19634:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        true
       ) &&
       requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
       true
      )
     ) &&
     requires (_Predicate f, _ForwardIterator x0) { f(*x0); }
    ) ||
    (
     (
      (
       (
        true
       ) &&
       requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
       true
      ) ||
      (
       (
        (
         (
          true
         ) &&
         requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
         true
        ) ||
        true
       ) &&
       true &&
       requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
       true
      )
     ) &&
     requires (_Predicate f, _ForwardIterator x0) { f(*x0); }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
 requires (_Predicate f, _ForwardIterator x0) { f(*x0); }
)
Inferred constraint:
UnaryFunction Predicate 

[-[minmax_element:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12749:1
Printed constraint (original):
(
 (
  (
   requires (_ForwardIterator x0) { ++x0; }
  )
 ) &&
 (
  (true)
 ) &&
 requires (_ForwardIterator x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__is_heap_until:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12173:1
Printed constraint (original):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[iter_swap:_ForwardIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:2223:1
Printed constraint (original):
(
 requires (_ForwardIterator2 x0) { *x0; }
)
Printed constraint (optimized):
requires (_ForwardIterator2 x0) { *x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__uninitialized_default_construct:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29846:1
Printed constraint (original):
(
 (
  (
   requires (_ForwardIterator x0) { *x0; } &&
   requires (_ForwardIterator x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__minmax_element_impl:_Iter]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12715:1
Printed constraint (original):
(
 requires (_Iter x0) { ++x0; }
)
Printed constraint (optimized):
requires (_Iter x0) { ++x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[minmax_element:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12760:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_ForwardIterator x0) { ++x0; }
    )
   ) &&
   (
    (true)
   ) &&
   requires (_ForwardIterator x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__partition:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:15095:1
Printed constraint (original):
(
 (
  (
   requires (_ForwardIterator x0) { ++x0; } &&
   requires (_ForwardIterator x0) { *x0; } &&
   (
    (true)
   ) &&
   (
    (true)
   )
  ) ||
  (
   requires (_ForwardIterator x0) { --x0; } &&
   requires (_ForwardIterator x0) { ++x0; } &&
   requires (_ForwardIterator x0) { *x0; } &&
   (
    (true)
   ) &&
   (
    (true)
   )
  )
 )
)
Printed constraint (optimized):
(
 (
  requires (_ForwardIterator x0) { ++x0; } &&
  requires (_ForwardIterator x0) { *x0; }
 ) ||
 (
  requires (_ForwardIterator x0) { --x0; } &&
  requires (_ForwardIterator x0) { ++x0; } &&
  requires (_ForwardIterator x0) { *x0; }
 )
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__sample:_Distance]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18308:1
Printed constraint (original):
(
 requires (_Distance x0) { ++x0; }
)
Printed constraint (optimized):
requires (_Distance x0) { ++x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[mismatch:_BinaryPredicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12803:1
Printed constraint (original):
(
 requires (_BinaryPredicate f, _InputIterator1 x0, _InputIterator2 x1) { f(*x0, *x1); }
)
Printed constraint (optimized):
requires (_BinaryPredicate f, _InputIterator1 x0, _InputIterator2 x1) { f(*x0, *x1); }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__nth_element:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14755:1
Printed constraint (original):
(
 true &&
 true &&
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 true &&
 true &&
 (
  (
   requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
  )
 ) &&
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); } &&
 (
  (
   (
    (
     (
      (true)
     )
    )
   )
  )
 ) &&
 (
  (
   requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
   requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
  )
 )
)
Printed constraint (optimized):
(
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
)
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[mismatch:_InputIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12828:1
Printed constraint (original):
(
 (
  (
   requires (_InputIterator1 x0) { *x0; } &&
   requires (_InputIterator1 x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[mismatch:_InputIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12828:1
Printed constraint (original):
(
 (
  (
   requires (_InputIterator2 x0) { *x0; } &&
   requires (_InputIterator2 x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator2 x0) { *x0; } &&
 requires (_InputIterator2 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[mismatch:_InputIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12818:1
Printed constraint (original):
(
 requires (_InputIterator2 x0) { *x0; } &&
 requires (_InputIterator2 x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator2 x0) { *x0; } &&
 requires (_InputIterator2 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[unique_copy:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20199:1
Printed constraint (original):
(
 (
  (
   (
    (true) ||
    (true) ||
    (true)
   ) &&
   (
    (
     requires (_InputIterator x0) { ++x0; } &&
     requires (_InputIterator x0) { *x0; }
    ) ||
    (
     requires (_InputIterator x0) { ++x0; } &&
     requires (_InputIterator x0) { *x0; }
    ) ||
    (
     requires (_InputIterator x0) { ++x0; } &&
     requires (_InputIterator x0) { *x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator x0) { ++x0; } &&
 requires (_InputIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[uninitialized_value_construct:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29898:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 (
  (
   (
    (
     requires (_ForwardIterator x0) { *x0; } &&
     requires (_ForwardIterator x0) { ++x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[prev_permutation:_BidirectionalIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:15198:1
Printed constraint (original):
(
 (
  (
   (
    (true)
   ) &&
   (
    (
     (
      (
       (
        (
         requires (_BidirectionalIterator x0) { ++x0; } &&
         requires (_BidirectionalIterator x0) { --x0; }
        ) ||
        (
         requires (_BidirectionalIterator x0) { ++x0; } &&
         requires (_BidirectionalIterator x0) { --x0; }
        )
       )
      )
     ) &&
     requires (_BidirectionalIterator x0) { *x0; } &&
     (
      (
       (
        (
         requires (_BidirectionalIterator x0) { ++x0; } &&
         requires (_BidirectionalIterator x0) { --x0; }
        ) ||
        (
         requires (_BidirectionalIterator x0) { ++x0; } &&
         requires (_BidirectionalIterator x0) { --x0; }
        )
       )
      )
     ) &&
     requires (_BidirectionalIterator x0) { --x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { --x0; } &&
 requires (_BidirectionalIterator x0) { *x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[prev_permutation:_BidirectionalIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:15190:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 (
  (
   (
    (
     (
      (
       requires (_BidirectionalIterator x0) { ++x0; } &&
       requires (_BidirectionalIterator x0) { --x0; }
      ) ||
      (
       requires (_BidirectionalIterator x0) { ++x0; } &&
       requires (_BidirectionalIterator x0) { --x0; }
      )
     )
    )
   ) &&
   requires (_BidirectionalIterator x0) { *x0; } &&
   (
    (
     (
      (
       requires (_BidirectionalIterator x0) { ++x0; } &&
       requires (_BidirectionalIterator x0) { --x0; }
      ) ||
      (
       requires (_BidirectionalIterator x0) { ++x0; } &&
       requires (_BidirectionalIterator x0) { --x0; }
      )
     )
    )
   ) &&
   requires (_BidirectionalIterator x0) { --x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { --x0; } &&
 requires (_BidirectionalIterator x0) { *x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[is_partitioned:_Predicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12232:1
Printed constraint (original):
(
 requires (_Predicate f, _InputIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
 requires (_Predicate f, _InputIterator x0) { f(*x0); }
)
Printed constraint (optimized):
(
 requires (_Predicate f, _InputIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
 requires (_Predicate f, _InputIterator x0) { f(*x0); }
)
Inferred constraint:
UnaryFunction Predicate 

[-[__rotate_impl:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:9491:1
Printed constraint (original):
(
 (
  (
   requires (_RandomAccessIterator x0) { *x0; } &&
   true &&
   (
    (
     requires (_RandomAccessIterator x0) { ++x0; }
    )
   ) &&
   (
    (
     requires (_RandomAccessIterator x0) { ++x0; }
    )
   ) &&
   requires (_RandomAccessIterator x0) { --x0; } &&
   (
    (true)
   ) &&
   (
    (true)
   )
  )
 ) &&
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (true)
         ) &&
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   ) &&
   (
    (
     (
      (
       (
        (
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   ) &&
   requires (_RandomAccessIterator x0) { *x0; } &&
   (
    (
     (
      (
       (
        (
         (
          (true)
         ) &&
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   )
  )
 ) &&
 (
  (
   requires (_RandomAccessIterator x0) { ++x0; }
  )
 ) &&
 (
  (
   requires (_RandomAccessIterator x0) { *x0; } &&
   (
    (
     (
      (
       (
        (
         (
          (true)
         ) &&
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   ) &&
   (
    (
     (
      (
       (
        (
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; }
)
Inferred constraint:
RandomAccessIterator 

[-[push_heap:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12957:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_RandomAccessIterator x0) { --x0; } &&
     requires (_RandomAccessIterator x0) { *x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[pop_heap:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:13006:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_RandomAccessIterator x0) { ++x0; } &&
     requires (_RandomAccessIterator x0) { --x0; } &&
     (
      (
       requires (_RandomAccessIterator x0) { --x0; } &&
       requires (_RandomAccessIterator x0) { *x0; }
      )
     ) &&
     requires (_RandomAccessIterator x0) { *x0; } &&
     (
      (
       requires (_RandomAccessIterator x0) { ++x0; } &&
       requires (_RandomAccessIterator x0) { *x0; } &&
       true
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Inferred constraint:
RandomAccessIterator 

[-[__partition_impl:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:15046:1
Printed constraint (original):
(
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0) { *x0; } &&
 (
  (true)
 ) &&
 (
  (true)
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__merge:_InputIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12639:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   ) &&
   (
    (
     (
      (
       (
        (
         (
          (true)
         ) &&
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   )
  )
 ) &&
 requires (_InputIterator2 x0) { ++x0; } &&
 requires (_InputIterator2 x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator2 x0) { ++x0; } &&
 requires (_InputIterator2 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[make_heap:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12565:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       requires (_RandomAccessIterator x0) { ++x0; } &&
       requires (_RandomAccessIterator x0) { *x0; }
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[includes:_InputIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:9122:1
Printed constraint (original):
(
 (
  (
   requires (_InputIterator2 x0) { ++x0; } &&
   requires (_InputIterator2 x0) { *x0; }
  )
 ) &&
 (
  (true)
 ) &&
 requires (_InputIterator2 x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator2 x0) { ++x0; } &&
 requires (_InputIterator2 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__is_permutation:_Iter2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12348:1
Printed constraint (original):
(
 (
  (
   requires (_Iter2 x0) { ++x0; } &&
   (
    (true)
   ) &&
   requires (_Iter2 x0) { *x0; }
  ) ||
  (
   (
    (
     requires (_Iter2 x0) { ++x0; } &&
     (
      (true)
     ) &&
     requires (_Iter2 x0) { *x0; }
    ) ||
    true
   ) &&
   (
    (
     (
      (
       requires (_Sent2 x0) { ++x0; } &&
       requires (_Sent2 x0, _Sent2 x1) { x0 != x1; }
      ) ||
      (
       requires (_Sent2 x0, _Sent2 x1) { x0 - x1; }
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 (
  requires (_Iter2 x0) { ++x0; } &&
  requires (_Iter2 x0) { *x0; }
 ) ||
 (
  requires (_Sent2 x0) { ++x0; } &&
  requires (_Sent2 x0, _Sent2 x1) { x0 != x1; }
 ) ||
 requires (_Sent2 x0, _Sent2 x1) { x0 - x1; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[fill:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7777:1
Printed constraint (original):
(
 (
  (
   requires (_ForwardIterator x0) { *x0; } &&
   requires (_ForwardIterator x0) { ++x0; }
  ) ||
  (
   requires (_ForwardIterator x0, _ForwardIterator x1) { x0 - x1; } &&
   (
    (
     (
      (
       requires (_ForwardIterator x0) { *x0; } &&
       requires (_ForwardIterator x0) { ++x0; }
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 (
  requires (_ForwardIterator x0) { *x0; } &&
  requires (_ForwardIterator x0) { ++x0; }
 ) ||
 (
  requires (_ForwardIterator x0, _ForwardIterator x1) { x0 - x1; } &&
  requires (_ForwardIterator x0) { *x0; } &&
  requires (_ForwardIterator x0) { ++x0; }
 )
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[find_first_of:_ForwardIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:8905:1
Printed constraint (original):
(
 (
  (
   requires (_ForwardIterator2 x0) { *x0; } &&
   requires (_ForwardIterator2 x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator2 x0) { *x0; } &&
 requires (_ForwardIterator2 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__fill:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7762:1
Printed constraint (original):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__find_if_impl:_Ip]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:15931:1
Printed constraint (original):
(
 requires (_Ip x0) { *x0; } &&
 requires (_Ip x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_Ip x0) { *x0; } &&
 requires (_Ip x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__shuffle:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19295:1
Printed constraint (original):
(
 requires (_RandomAccessIterator x0) { ++x0; }
)
Printed constraint (optimized):
requires (_RandomAccessIterator x0) { ++x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[__sort3:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14202:1
Printed constraint (original):
(
 requires (_ForwardIterator x0) { *x0; }
)
Printed constraint (optimized):
requires (_ForwardIterator x0) { *x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[is_permutation:_BinaryPredicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12359:1
Printed constraint (original):
(
 (
  (
   (
    (true)
   ) &&
   requires (_BinaryPredicate f, _ForwardIterator1 x0, _ForwardIterator2 x1) { f(*x0, *x1); }
  )
 )
)
Printed constraint (optimized):
requires (_BinaryPredicate f, _ForwardIterator1 x0, _ForwardIterator2 x1) { f(*x0, *x1); }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__is_permutation:_BinaryPredicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12288:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 requires (_BinaryPredicate f, _ForwardIterator1 x0, _ForwardIterator2 x1) { f(*x0, *x1); }
)
Printed constraint (optimized):
requires (_BinaryPredicate f, _ForwardIterator1 x0, _ForwardIterator2 x1) { f(*x0, *x1); }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[equal:_InputIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7615:1
Printed constraint (original):
(
 (
  (
   requires (_InputIterator2 x0) { *x0; } &&
   requires (_InputIterator2 x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator2 x0) { *x0; } &&
 requires (_InputIterator2 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[pop_heap:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12998:1
Printed constraint (original):
(
 (
  (
   requires (_RandomAccessIterator x0) { ++x0; } &&
   requires (_RandomAccessIterator x0) { --x0; } &&
   (
    (
     requires (_RandomAccessIterator x0) { --x0; } &&
     requires (_RandomAccessIterator x0) { *x0; }
    )
   ) &&
   requires (_RandomAccessIterator x0) { *x0; } &&
   (
    (
     requires (_RandomAccessIterator x0) { ++x0; } &&
     requires (_RandomAccessIterator x0) { *x0; } &&
     true
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Inferred constraint:
RandomAccessIterator 

[-[__uninitialized_copy_n:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29776:1
Printed constraint (original):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[sort_heap:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:13022:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_RandomAccessIterator x0) { ++x0; } &&
     requires (_RandomAccessIterator x0) { --x0; } &&
     (
      (
       requires (_RandomAccessIterator x0) { --x0; } &&
       requires (_RandomAccessIterator x0) { *x0; }
      )
     ) &&
     requires (_RandomAccessIterator x0) { *x0; } &&
     (
      (
       requires (_RandomAccessIterator x0) { ++x0; } &&
       requires (_RandomAccessIterator x0) { *x0; } &&
       true
      )
     )
    )
   ) &&
   requires (_RandomAccessIterator x0) { --x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Inferred constraint:
RandomAccessIterator 

[-[any_of:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:5756:1
Printed constraint (original):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; } &&
 requires (_InputIterator x0, _InputIterator x1) { x0 != x1; }
)
Printed constraint (optimized):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; } &&
 requires (_InputIterator x0, _InputIterator x1) { x0 != x1; }
)
Inferred constraint:
InputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[rend:_Cp]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29308:1
Printed constraint (original):
(
 requires (_Cp o) { o.rend(); }
)
Printed constraint (optimized):
requires (_Cp o) { o.rend(); }
Inferred constraint:


[-[__is_permutation:_ForwardIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12288:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 requires (_ForwardIterator1 x0) { *x0; } &&
 requires (_ForwardIterator1 x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_ForwardIterator1 x0) { *x0; } &&
 requires (_ForwardIterator1 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[is_permutation:_ForwardIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12368:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (true)
     )
    )
   ) &&
   (
    (
     (
      (true)
     ) &&
     requires (_ForwardIterator1 x0) { *x0; } &&
     requires (_ForwardIterator1 x0) { ++x0; }
    )
   ) &&
   requires (_ForwardIterator1 x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator1 x0) { *x0; } &&
 requires (_ForwardIterator1 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__merge:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12639:1
Printed constraint (original):
(
 requires (_Compare f, _InputIterator2 x0, _InputIterator1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
)
Printed constraint (optimized):
requires (_Compare f, _InputIterator2 x0, _InputIterator1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__sort5_maybe_branchless:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14356:1
Printed constraint (original):
(
 (
  (
   requires (_RandomAccessIterator x0) { *x0; }
  )
 ) &&
 (
  (
   requires (_RandomAccessIterator x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
requires (_RandomAccessIterator x0) { *x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[is_permutation:_ForwardIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12373:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (true)
     )
    ) ||
    (
     (
      (
       (
        (true)
       )
      ) ||
      true
     ) &&
     (
      (
       (
        (
         requires (_ForwardIterator1 x0) { ++x0; } &&
         requires (_ForwardIterator1 x0, _ForwardIterator1 x1) { x0 != x1; }
        ) ||
        (
         requires (_ForwardIterator1 x0, _ForwardIterator1 x1) { x0 - x1; }
        )
       )
      )
     )
    )
   )
  )
 ) &&
 (
  (
   (
    (
     (
      (true)
     ) &&
     requires (_ForwardIterator1 x0) { ++x0; } &&
     requires (_ForwardIterator1 x0) { *x0; }
    ) ||
    (
     (
      (
       (
        (true)
       ) &&
       requires (_ForwardIterator1 x0) { ++x0; } &&
       requires (_ForwardIterator1 x0) { *x0; }
      ) ||
      true
     ) &&
     (
      (
       (
        (
         requires (_ForwardIterator1 x0) { ++x0; } &&
         requires (_ForwardIterator1 x0, _ForwardIterator1 x1) { x0 != x1; }
        ) ||
        (
         requires (_ForwardIterator1 x0, _ForwardIterator1 x1) { x0 - x1; }
        )
       )
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 (
  requires (_ForwardIterator1 x0) { ++x0; } &&
  requires (_ForwardIterator1 x0) { *x0; }
 ) ||
 (
  requires (_ForwardIterator1 x0) { ++x0; } &&
  requires (_ForwardIterator1 x0, _ForwardIterator1 x1) { x0 != x1; }
 ) ||
 requires (_ForwardIterator1 x0, _ForwardIterator1 x1) { x0 - x1; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[__sort4_maybe_branchless:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14350:1
Printed constraint (original):
(
 (
  (
   requires (_RandomAccessIterator x0) { *x0; } &&
   (
    (
     requires (_RandomAccessIterator x0) { *x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
requires (_RandomAccessIterator x0) { *x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__is_permutation:_Iter1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12348:1
Printed constraint (original):
(
 (
  (
   (
    (true)
   ) &&
   requires (_Iter1 x0) { ++x0; } &&
   requires (_Iter1 x0) { *x0; }
  ) ||
  (
   (
    (
     (
      (true)
     ) &&
     requires (_Iter1 x0) { ++x0; } &&
     requires (_Iter1 x0) { *x0; }
    ) ||
    true
   ) &&
   (
    (
     (
      (
       requires (_Sent1 x0) { ++x0; } &&
       requires (_Sent1 x0, _Sent1 x1) { x0 != x1; }
      ) ||
      (
       requires (_Sent1 x0, _Sent1 x1) { x0 - x1; }
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 (
  requires (_Iter1 x0) { ++x0; } &&
  requires (_Iter1 x0) { *x0; }
 ) ||
 (
  requires (_Sent1 x0) { ++x0; } &&
  requires (_Sent1 x0, _Sent1 x1) { x0 != x1; }
 ) ||
 requires (_Sent1 x0, _Sent1 x1) { x0 - x1; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[__is_permutation:_Sent1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12334:1
Printed constraint (original):
(
 (
  (
   (
    (true)
   )
  ) ||
  true
 ) &&
 (
  (
   (
    (
     requires (_Sent1 x0) { ++x0; } &&
     requires (_Sent1 x0, _Sent1 x1) { x0 != x1; }
    ) ||
    (
     requires (_Sent1 x0, _Sent1 x1) { x0 - x1; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 (
  requires (_Sent1 x0) { ++x0; } &&
  requires (_Sent1 x0, _Sent1 x1) { x0 != x1; }
 ) ||
 requires (_Sent1 x0, _Sent1 x1) { x0 - x1; }
)
Inferred constraint:
InputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[remove_copy_if:_OutputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:17641:1
Printed constraint (original):
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__allocator_destroy_multidimensional:_BidirIter]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29971:1
Printed constraint (original):
(
 requires (_BidirIter x0) { *x0; } &&
 requires (_BidirIter x0) { --x0; }
)
Printed constraint (optimized):
(
 requires (_BidirIter x0) { *x0; } &&
 requires (_BidirIter x0) { --x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[__lexicographical_compare:_InputIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12445:1
Printed constraint (original):
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__uninitialized_fill_n:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29822:1
Printed constraint (original):
(
 (
  (
   requires (_ForwardIterator x0) { *x0; } &&
   requires (_ForwardIterator x0) { ++x0; }
  )
 ) &&
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[destroy:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:11091:1
Printed constraint (original):
(
 (
  (
   requires (_ForwardIterator x0) { *x0; } &&
   requires (_ForwardIterator x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__sort5_maybe_branchless:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14356:1
Printed constraint (original):
(
 (
  (
   true &&
   requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
  )
 ) &&
 (
  (
   requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
  )
 )
)
Printed constraint (optimized):
requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__sort4_maybe_branchless:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14350:1
Printed constraint (original):
(
 (
  (
   requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
   (
    (
     requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
     requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
)
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__swap_ranges:_ForwardIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:9337:1
Printed constraint (original):
(
 requires (_ForwardIterator2 x0) { ++x0; }
)
Printed constraint (optimized):
requires (_ForwardIterator2 x0) { ++x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[__sort4_maybe_branchless:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14340:1
Printed constraint (original):
(
 (
  (
   requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
  )
 )
)
Printed constraint (optimized):
requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__introsort:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14503:1
Printed constraint (original):
(
 true &&
 true &&
 (
  (true)
 ) &&
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 (
  (
   (
    (
     true &&
     requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
    )
   ) &&
   (
    (
     requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
    )
   )
  ) ||
  (
   (
    (
     requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
     requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
    )
   )
  )
 ) &&
 (
  (
   (
    (
     requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
    )
   )
  ) ||
  (
   (
    (
     requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
     (
      (
       requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
       requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
      )
     )
    )
   )
  )
 ) &&
 (
  (
   (
    (
     true &&
     requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
    )
   ) &&
   (
    (
     requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
    )
   )
  ) ||
  (
   (
    (true)
   )
  )
 ) &&
 (
  (
   requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
   requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
  )
 ) &&
 (
  (true)
 ) &&
 true &&
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); } &&
 (
  true
 ) &&
 (
  (
   true &&
   requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
   (
    (
     (
      (
       true &&
       requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
      )
     ) &&
     (
      (
       requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
      )
     )
    ) ||
    (
     (
      (
       requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
       requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
      )
     )
    )
   )
  )
 ) &&
 true
)
Printed constraint (optimized):
(
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 (
  requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); } ||
  (
   requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
   requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
  )
 ) &&
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
)
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__log2i:_Number]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14652:1
Printed constraint (original):
(
 requires (_Number x0) { x0++; }
)
Printed constraint (optimized):
requires (_Number x0) { x0++; }
Inferred constraint:
InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[__sort:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14669:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_RandomAccessIterator x0) { *x0; }
    )
   ) &&
   (
    (
     (
      (
       requires (_RandomAccessIterator x0) { *x0; } &&
       (
        (
         requires (_RandomAccessIterator x0) { *x0; } &&
         (
          (
           requires (_RandomAccessIterator x0) { *x0; }
          )
         )
        )
       )
      )
     )
    )
   ) &&
   requires (_RandomAccessIterator x0) { ++x0; } &&
   true &&
   (
    (
     (
      (true)
     ) &&
     (
      (true)
     )
    )
   ) &&
   (
    true
   ) &&
   (
    (
     requires (_RandomAccessIterator x0) { --x0; } &&
     requires (_RandomAccessIterator x0) { ++x0; } &&
     requires (_RandomAccessIterator x0) { *x0; } &&
     (
      (
       (
        (
         requires (_RandomAccessIterator x0) { *x0; }
        )
       ) &&
       (
        (
         requires (_RandomAccessIterator x0) { *x0; }
        )
       )
      ) ||
      (
       (
        (
         requires (_RandomAccessIterator x0) { *x0; }
        )
       )
      )
     )
    )
   ) &&
   (
    (
     requires (_RandomAccessIterator x0) { ++x0; } &&
     (
      (
       (
        (
         requires (_RandomAccessIterator x0) { *x0; }
        )
       ) &&
       (
        (
         requires (_RandomAccessIterator x0) { *x0; }
        )
       )
      ) ||
      (
       (
        (
         (
          (
           requires (_RandomAccessIterator x0) { *x0; } &&
           (
            (
             requires (_RandomAccessIterator x0) { *x0; } &&
             (
              (
               requires (_RandomAccessIterator x0) { *x0; }
              )
             )
            )
           )
          )
         )
        )
       )
      )
     ) &&
     (
      (
       (
        (
         requires (_RandomAccessIterator x0) { *x0; }
        )
       )
      ) ||
      (
       (
        (
         requires (_RandomAccessIterator x0) { *x0; } &&
         (
          (
           requires (_RandomAccessIterator x0) { *x0; }
          )
         )
        )
       )
      )
     ) &&
     (
      (
       (
        (
         requires (_RandomAccessIterator x0) { *x0; }
        )
       ) &&
       (
        (
         requires (_RandomAccessIterator x0) { *x0; }
        )
       )
      ) ||
      (
       (
        (
         requires (_RandomAccessIterator x0) { *x0; }
        )
       )
      )
     ) &&
     requires (_RandomAccessIterator x0) { *x0; } &&
     requires (_RandomAccessIterator x0) { --x0; }
    )
   ) &&
   (
    (
     (
      (
       requires (_RandomAccessIterator x0) { *x0; }
      )
     ) &&
     (
      (
       requires (_RandomAccessIterator x0) { *x0; }
      )
     )
    ) ||
    (
     (
      (
       (
        (
         requires (_RandomAccessIterator x0) { *x0; } &&
         (
          (
           requires (_RandomAccessIterator x0) { *x0; } &&
           (
            (
             requires (_RandomAccessIterator x0) { *x0; }
            )
           )
          )
         )
        )
       )
      )
     )
    )
   ) &&
   (
    (
     (
      (
       requires (_RandomAccessIterator x0) { *x0; }
      )
     )
    ) ||
    (
     (
      (
       requires (_RandomAccessIterator x0) { *x0; } &&
       (
        (
         requires (_RandomAccessIterator x0) { *x0; }
        )
       )
      )
     )
    )
   ) &&
   (
    (
     (
      (
       requires (_RandomAccessIterator x0) { *x0; }
      )
     ) &&
     (
      (
       requires (_RandomAccessIterator x0) { *x0; }
      )
     )
    ) ||
    (
     (
      (
       requires (_RandomAccessIterator x0) { *x0; }
      )
     )
    )
   ) &&
   requires (_RandomAccessIterator x0) { *x0; } &&
   (
    (
     (
      (
       requires (_RandomAccessIterator x0) { ++x0; } &&
       (
        (
         (
          (
           requires (_RandomAccessIterator x0) { ++x0; } &&
           requires (_RandomAccessIterator x0) { --x0; } &&
           (
            (
             requires (_RandomAccessIterator x0) { --x0; } &&
             requires (_RandomAccessIterator x0) { *x0; }
            )
           ) &&
           requires (_RandomAccessIterator x0) { *x0; } &&
           (
            (
             requires (_RandomAccessIterator x0) { ++x0; } &&
             requires (_RandomAccessIterator x0) { *x0; } &&
             true
            )
           )
          )
         ) &&
         requires (_RandomAccessIterator x0) { --x0; }
        )
       ) &&
       (
        (
         requires (_RandomAccessIterator x0) { ++x0; } &&
         requires (_RandomAccessIterator x0) { *x0; }
        )
       ) &&
       requires (_RandomAccessIterator x0) { *x0; } &&
       (
        (
         (
          (
           requires (_RandomAccessIterator x0) { ++x0; } &&
           requires (_RandomAccessIterator x0) { *x0; }
          )
         )
        )
       )
      )
     ) &&
     (
      (true)
     )
    )
   ) &&
   requires (_RandomAccessIterator x0) { --x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; }
)
Inferred constraint:
RandomAccessIterator 

[-[__introsort:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14503:1
Printed constraint (original):
(
 (
  (
   requires (_RandomAccessIterator x0) { *x0; }
  )
 ) &&
 (
  (
   (
    (
     requires (_RandomAccessIterator x0) { *x0; } &&
     (
      (
       requires (_RandomAccessIterator x0) { *x0; } &&
       (
        (
         requires (_RandomAccessIterator x0) { *x0; }
        )
       )
      )
     )
    )
   )
  )
 ) &&
 requires (_RandomAccessIterator x0) { ++x0; } &&
 true &&
 (
  (
   (
    (true)
   ) &&
   (
    (true)
   )
  )
 ) &&
 (
  true
 ) &&
 (
  (
   requires (_RandomAccessIterator x0) { --x0; } &&
   requires (_RandomAccessIterator x0) { ++x0; } &&
   requires (_RandomAccessIterator x0) { *x0; } &&
   (
    (
     (
      (
       requires (_RandomAccessIterator x0) { *x0; }
      )
     ) &&
     (
      (
       requires (_RandomAccessIterator x0) { *x0; }
      )
     )
    ) ||
    (
     (
      (
       requires (_RandomAccessIterator x0) { *x0; }
      )
     )
    )
   )
  )
 ) &&
 (
  (
   requires (_RandomAccessIterator x0) { ++x0; } &&
   (
    (
     (
      (
       requires (_RandomAccessIterator x0) { *x0; }
      )
     ) &&
     (
      (
       requires (_RandomAccessIterator x0) { *x0; }
      )
     )
    ) ||
    (
     (
      (
       (
        (
         requires (_RandomAccessIterator x0) { *x0; } &&
         (
          (
           requires (_RandomAccessIterator x0) { *x0; } &&
           (
            (
             requires (_RandomAccessIterator x0) { *x0; }
            )
           )
          )
         )
        )
       )
      )
     )
    )
   ) &&
   (
    (
     (
      (
       requires (_RandomAccessIterator x0) { *x0; }
      )
     )
    ) ||
    (
     (
      (
       requires (_RandomAccessIterator x0) { *x0; } &&
       (
        (
         requires (_RandomAccessIterator x0) { *x0; }
        )
       )
      )
     )
    )
   ) &&
   (
    (
     (
      (
       requires (_RandomAccessIterator x0) { *x0; }
      )
     ) &&
     (
      (
       requires (_RandomAccessIterator x0) { *x0; }
      )
     )
    ) ||
    (
     (
      (
       requires (_RandomAccessIterator x0) { *x0; }
      )
     )
    )
   ) &&
   requires (_RandomAccessIterator x0) { *x0; } &&
   requires (_RandomAccessIterator x0) { --x0; }
  )
 ) &&
 (
  (
   (
    (
     requires (_RandomAccessIterator x0) { *x0; }
    )
   ) &&
   (
    (
     requires (_RandomAccessIterator x0) { *x0; }
    )
   )
  ) ||
  (
   (
    (
     (
      (
       requires (_RandomAccessIterator x0) { *x0; } &&
       (
        (
         requires (_RandomAccessIterator x0) { *x0; } &&
         (
          (
           requires (_RandomAccessIterator x0) { *x0; }
          )
         )
        )
       )
      )
     )
    )
   )
  )
 ) &&
 (
  (
   (
    (
     requires (_RandomAccessIterator x0) { *x0; }
    )
   )
  ) ||
  (
   (
    (
     requires (_RandomAccessIterator x0) { *x0; } &&
     (
      (
       requires (_RandomAccessIterator x0) { *x0; }
      )
     )
    )
   )
  )
 ) &&
 (
  (
   (
    (
     requires (_RandomAccessIterator x0) { *x0; }
    )
   ) &&
   (
    (
     requires (_RandomAccessIterator x0) { *x0; }
    )
   )
  ) ||
  (
   (
    (
     requires (_RandomAccessIterator x0) { *x0; }
    )
   )
  )
 ) &&
 requires (_RandomAccessIterator x0) { *x0; } &&
 (
  (
   (
    (
     requires (_RandomAccessIterator x0) { ++x0; } &&
     (
      (
       (
        (
         requires (_RandomAccessIterator x0) { ++x0; } &&
         requires (_RandomAccessIterator x0) { --x0; } &&
         (
          (
           requires (_RandomAccessIterator x0) { --x0; } &&
           requires (_RandomAccessIterator x0) { *x0; }
          )
         ) &&
         requires (_RandomAccessIterator x0) { *x0; } &&
         (
          (
           requires (_RandomAccessIterator x0) { ++x0; } &&
           requires (_RandomAccessIterator x0) { *x0; } &&
           true
          )
         )
        )
       ) &&
       requires (_RandomAccessIterator x0) { --x0; }
      )
     ) &&
     (
      (
       requires (_RandomAccessIterator x0) { ++x0; } &&
       requires (_RandomAccessIterator x0) { *x0; }
      )
     ) &&
     requires (_RandomAccessIterator x0) { *x0; } &&
     (
      (
       (
        (
         requires (_RandomAccessIterator x0) { ++x0; } &&
         requires (_RandomAccessIterator x0) { *x0; }
        )
       )
      )
     )
    )
   ) &&
   (
    (true)
   )
  )
 ) &&
 requires (_RandomAccessIterator x0) { --x0; }
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; }
)
Inferred constraint:
RandomAccessIterator 

[-[__insertion_sort_incomplete:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14422:1
Printed constraint (original):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 (
  (
   (
    (
     requires (_RandomAccessIterator x0) { *x0; }
    )
   ) &&
   (
    (
     requires (_RandomAccessIterator x0) { *x0; }
    )
   )
  ) ||
  (
   (
    (
     (
      (
       requires (_RandomAccessIterator x0) { *x0; } &&
       (
        (
         requires (_RandomAccessIterator x0) { *x0; } &&
         (
          (
           requires (_RandomAccessIterator x0) { *x0; }
          )
         )
        )
       )
      )
     )
    )
   )
  )
 ) &&
 (
  (
   (
    (
     requires (_RandomAccessIterator x0) { *x0; }
    )
   )
  ) ||
  (
   (
    (
     requires (_RandomAccessIterator x0) { *x0; } &&
     (
      (
       requires (_RandomAccessIterator x0) { *x0; }
      )
     )
    )
   )
  )
 ) &&
 (
  (
   (
    (
     requires (_RandomAccessIterator x0) { *x0; }
    )
   ) &&
   (
    (
     requires (_RandomAccessIterator x0) { *x0; }
    )
   )
  ) ||
  (
   (
    (
     requires (_RandomAccessIterator x0) { *x0; }
    )
   )
  )
 ) &&
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { --x0; }
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { --x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[__sort5_maybe_branchless:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14367:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_RandomAccessIterator x0) { *x0; } &&
     (
      (
       requires (_RandomAccessIterator x0) { *x0; } &&
       (
        (
         requires (_RandomAccessIterator x0) { *x0; }
        )
       )
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
requires (_RandomAccessIterator x0) { *x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[merge:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12662:1
Printed constraint (original):
(
 (
  (
   requires (_Compare f, _InputIterator2 x0, _InputIterator1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
  )
 )
)
Printed constraint (optimized):
requires (_Compare f, _InputIterator2 x0, _InputIterator1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__insertion_sort_3:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14400:1
Printed constraint (original):
(
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; } &&
 (
  (
   (
    (
     requires (_RandomAccessIterator x0) { *x0; }
    )
   ) &&
   (
    (
     requires (_RandomAccessIterator x0) { *x0; }
    )
   )
  ) ||
  (
   (
    (
     requires (_RandomAccessIterator x0) { *x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[__sort5_wrap_policy:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14283:1
Printed constraint (original):
(
 (
  (
   requires (_ForwardIterator x0) { *x0; } &&
   (
    (
     requires (_ForwardIterator x0) { *x0; } &&
     (
      (
       requires (_ForwardIterator x0) { *x0; }
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
requires (_ForwardIterator x0) { *x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__nth_element_find_guard:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14741:1
Printed constraint (original):
(
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
)
Printed constraint (optimized):
requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__is_permutation:_Iter2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12307:1
Printed constraint (original):
(
 requires (_Iter2 x0) { ++x0; } &&
 (
  (true)
 ) &&
 requires (_Iter2 x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_Iter2 x0) { ++x0; } &&
 requires (_Iter2 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__is_permutation:_Iter2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12334:1
Printed constraint (original):
(
 (
  (
   requires (_Iter2 x0) { ++x0; } &&
   (
    (true)
   ) &&
   requires (_Iter2 x0) { *x0; }
  ) ||
  true
 ) &&
 (
  (
   (
    (
     requires (_Sent2 x0) { ++x0; } &&
     requires (_Sent2 x0, _Sent2 x1) { x0 != x1; }
    ) ||
    (
     requires (_Sent2 x0, _Sent2 x1) { x0 - x1; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 (
  requires (_Sent2 x0) { ++x0; } &&
  requires (_Sent2 x0, _Sent2 x1) { x0 != x1; }
 ) ||
 requires (_Sent2 x0, _Sent2 x1) { x0 - x1; }
)
Inferred constraint:
InputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[__algo_gcd:_Integral]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:9414:1
Printed constraint (original):
(
 requires (_Integral x0, _Integral x1) { x0 % x1; }
)
Printed constraint (optimized):
requires (_Integral x0, _Integral x1) { x0 % x1; }
Inferred constraint:
Integral 

[-[__merge:_InputIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12639:1
Printed constraint (original):
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; } &&
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   ) &&
   (
    (
     (
      (
       (
        (
         (
          (true)
         ) &&
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__stable_partition_impl:_Distance]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19507:1
Printed constraint (original):
(
 (
  (
   requires (_Distance x0) { --x0; } &&
   (
    true
   ) &&
   requires (_Distance x0, int x1) { x0 / x1; }
  ) ||
  true
 ) &&
 requires (_Distance x0) { --x0; } &&
 requires (_Distance x0, int x1) { x0 / x1; }
)
Printed constraint (optimized):
(
 requires (_Distance x0) { --x0; } &&
 requires (_Distance x0, int x1) { x0 / x1; }
)
Inferred constraint:
Float Integral 

[-[set_symmetric_difference:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19018:1
Printed constraint (original):
(
 (
  (
   requires (_Compare f, _InputIterator2 x0, _InputIterator1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
   requires (_Compare f, _InputIterator1 x0, _InputIterator2 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_Compare f, _InputIterator2 x0, _InputIterator1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 requires (_Compare f, _InputIterator1 x0, _InputIterator2 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
)
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__stable_partition_impl:_Distance]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19410:1
Printed constraint (original):
(
 requires (_Distance x0) { --x0; } &&
 (
  true
 ) &&
 requires (_Distance x0, int x1) { x0 / x1; }
)
Printed constraint (optimized):
(
 requires (_Distance x0) { --x0; } &&
 requires (_Distance x0, int x1) { x0 / x1; }
)
Inferred constraint:
Float Integral 

[-[partial_sort_copy:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:15023:1
Printed constraint (original):
(
 (
  (
   requires (_InputIterator x0) { *x0; } &&
   requires (_InputIterator x0) { ++x0; }
  )
 ) &&
 (
  (true)
 ) &&
 requires (_InputIterator x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[binary_search:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:5892:1
Printed constraint (original):
(
 (
  (
   requires (_ForwardIterator x0) { *x0; } &&
   requires (_ForwardIterator x0, _ForwardIterator x1) { x0 != x1; } &&
   (
    (
     (
      (true)
     ) &&
     (
      (
       requires (_ForwardIterator x0) { ++x0; } &&
       requires (_ForwardIterator x0) { *x0; }
      )
     ) &&
     requires (_ForwardIterator x0) { *x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0, _ForwardIterator x1) { x0 != x1; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
InputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__partial_sort_copy:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14997:1
Printed constraint (original):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__is_permutation:_ForwardIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12288:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 requires (_ForwardIterator2 x0) { *x0; } &&
 requires (_ForwardIterator2 x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_ForwardIterator2 x0) { *x0; } &&
 requires (_ForwardIterator2 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[remove_copy:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20327:1
Printed constraint (original):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__prev_permutation:_BidirectionalIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:15161:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_BidirectionalIterator x0) { ++x0; } &&
     requires (_BidirectionalIterator x0) { --x0; }
    ) ||
    (
     requires (_BidirectionalIterator x0) { ++x0; } &&
     requires (_BidirectionalIterator x0) { --x0; }
    )
   )
  )
 ) &&
 requires (_BidirectionalIterator x0) { *x0; } &&
 (
  (
   (
    (
     requires (_BidirectionalIterator x0) { ++x0; } &&
     requires (_BidirectionalIterator x0) { --x0; }
    ) ||
    (
     requires (_BidirectionalIterator x0) { ++x0; } &&
     requires (_BidirectionalIterator x0) { --x0; }
    )
   )
  )
 ) &&
 requires (_BidirectionalIterator x0) { --x0; }
)
Printed constraint (optimized):
(
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { --x0; } &&
 requires (_BidirectionalIterator x0) { *x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[find_end:_ForwardIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:8871:1
Printed constraint (original):
(
 (
  (
   (
    (true)
   ) &&
   (
    (
     requires (_ForwardIterator1 x0) { ++x0; } &&
     requires (_ForwardIterator1 x0) { *x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator1 x0) { ++x0; } &&
 requires (_ForwardIterator1 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[none_of:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12919:1
Printed constraint (original):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__includes:_Iter2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:9109:1
Printed constraint (original):
(
 requires (_Iter2 x0) { ++x0; } &&
 requires (_Iter2 x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_Iter2 x0) { ++x0; } &&
 requires (_Iter2 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__inplace_merge:_BidirectionalIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12063:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 (
  (
   (
    (
     (
      (
       requires (_BidirectionalIterator x0) { ++x0; }
      )
     ) &&
     (
      (
       requires (_BidirectionalIterator x0) { *x0; } &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       ) &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       )
      )
     )
    ) ||
    (
     (
      (
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       ) &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       ) &&
       requires (_BidirectionalIterator x0) { *x0; } &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       )
      )
     ) &&
     (
      (
       requires (_BidirectionalIterator x0) { ++x0; }
      )
     ) &&
     (
      (
       requires (_BidirectionalIterator x0) { *x0; } &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       ) &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       )
      )
     )
    ) ||
    (
     (
      (
       requires (_BidirectionalIterator x0) { *x0; } &&
       true &&
       (
        (
         requires (_BidirectionalIterator x0) { ++x0; }
        )
       ) &&
       (
        (
         requires (_BidirectionalIterator x0) { ++x0; }
        )
       ) &&
       requires (_BidirectionalIterator x0) { --x0; } &&
       (
        (true)
       ) &&
       (
        (true)
       )
      )
     ) &&
     (
      (
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       ) &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       ) &&
       requires (_BidirectionalIterator x0) { *x0; } &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       )
      )
     ) &&
     (
      (
       requires (_BidirectionalIterator x0) { ++x0; }
      )
     ) &&
     (
      (
       requires (_BidirectionalIterator x0) { *x0; } &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       ) &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       )
      )
     )
    )
   )
  )
 ) &&
 (
  (true)
 ) &&
 (
  (true)
 ) &&
 (
  (
   (
    (true)
   ) &&
   (
    (
     requires (_BidirectionalIterator x0) { ++x0; } &&
     requires (_BidirectionalIterator x0) { *x0; }
    )
   ) &&
   requires (_BidirectionalIterator x0) { *x0; }
  )
 ) &&
 requires (_BidirectionalIterator x0) { *x0; } &&
 requires (_BidirectionalIterator x0) { ++x0; } &&
 (
  true
 ) &&
 (
  (
   (
    (
     requires (_BidirectionalIterator x0) { *x0; } &&
     (
      (
       (
        (
         (
          (
           (
            (true)
           ) &&
           (
            (true)
           )
          ) ||
          (true)
         )
        )
       )
      )
     ) &&
     requires (_BidirectionalIterator x0) { ++x0; }
    )
   ) &&
   (
    (true)
   ) &&
   (
    (
     requires (_BidirectionalIterator x0) { ++x0; } &&
     requires (_BidirectionalIterator x0) { *x0; }
    )
   ) &&
   requires (_BidirectionalIterator x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 (
  (
   requires (_BidirectionalIterator x0) { ++x0; } &&
   requires (_BidirectionalIterator x0) { *x0; }
  ) ||
  (
   requires (_BidirectionalIterator x0) { *x0; } &&
   requires (_BidirectionalIterator x0) { ++x0; }
  ) ||
  (
   requires (_BidirectionalIterator x0) { *x0; } &&
   requires (_BidirectionalIterator x0) { ++x0; } &&
   requires (_BidirectionalIterator x0) { --x0; }
  )
 ) &&
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[end:_Cp]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:10998:1
Printed constraint (original):
(
 requires (_Cp o) { o.end(); }
)
Printed constraint (optimized):
requires (_Cp o) { o.end(); }
Inferred constraint:


[-[__remove_copy_if_impl:_InIter]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:17661:1
Printed constraint (original):
(
 requires (_InIter x0) { *x0; } &&
 requires (_InIter x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InIter x0) { *x0; } &&
 requires (_InIter x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[transform:_InputIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20538:1
Printed constraint (original):
(
 requires (_InputIterator2 x0) { *x0; } &&
 requires (_InputIterator2 x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator2 x0) { *x0; } &&
 requires (_InputIterator2 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[uninitialized_copy:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29767:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_ForwardIterator x0) { *x0; } &&
     requires (_ForwardIterator x0) { ++x0; }
    )
   ) &&
   requires (_ForwardIterator x0) { *x0; } &&
   requires (_ForwardIterator x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__stable_sort_impl:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19846:1
Printed constraint (original):
(
 (
  (
   (
    (
     true
    )
   ) &&
   (
    (
     (
      (
       (
        (true)
       )
      )
     ) &&
     (
      (true)
     ) &&
     requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
     (
      true
     ) &&
     (
      (
       (
        (
         true
        )
       )
      )
     )
    )
   ) &&
   (
    (
     true
    )
   ) &&
   (
    true
   ) &&
   (
    (
     (
      (
       requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
      )
     ) &&
     (
      (
       true &&
       true
      )
     ) &&
     true
    )
   ) &&
   true
  )
 )
)
Printed constraint (optimized):
requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__merge_impl:_InIter1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:16820:1
Printed constraint (original):
(
 requires (_InIter1 x0) { ++x0; } &&
 requires (_InIter1 x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_InIter1 x0) { ++x0; } &&
 requires (_InIter1 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__merge_impl:_OutIter]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:16820:1
Printed constraint (original):
(
 requires (_OutIter x0) { *x0; } &&
 requires (_OutIter x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_OutIter x0) { *x0; } &&
 requires (_OutIter x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__partially_sorted_swap:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14316:1
Printed constraint (original):
(
 requires (_RandomAccessIterator x0) { *x0; }
)
Printed constraint (optimized):
requires (_RandomAccessIterator x0) { *x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[none_of:_Predicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12919:1
Printed constraint (original):
(
 requires (_Predicate f, _InputIterator x0) { {f(*x0)} -> std::convertible_to<bool>; }
)
Printed constraint (optimized):
requires (_Predicate f, _InputIterator x0) { {f(*x0)} -> std::convertible_to<bool>; }
Inferred constraint:
UnaryFunction Predicate 

[-[remove_copy_if:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:17641:1
Printed constraint (original):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__find_end_classic:_ForwardIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:8853:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 (
  (
   requires (_ForwardIterator1 x0) { ++x0; } &&
   requires (_ForwardIterator1 x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator1 x0) { ++x0; } &&
 requires (_ForwardIterator1 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[shift_left:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20440:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (true)
         ) &&
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   )
  )
 ) &&
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   ) &&
   (
    (
     (
      (
       (
        (
         (
          (true)
         ) &&
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   )
  )
 ) &&
 requires (_ForwardIterator x0) { ++x0; } &&
 true
)
Printed constraint (optimized):
requires (_ForwardIterator x0) { ++x0; }
Inferred constraint:
RandomAccessIterator Float Integral 

[-[reverse:_BidirectionalIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12864:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_BidirectionalIterator x0) { ++x0; } &&
     requires (_BidirectionalIterator x0) { --x0; }
    ) ||
    (
     requires (_BidirectionalIterator x0) { ++x0; } &&
     requires (_BidirectionalIterator x0) { --x0; }
    )
   )
  )
 ) &&
 (
  (
   (
    (
     requires (_BidirectionalIterator x0) { ++x0; } &&
     requires (_BidirectionalIterator x0) { --x0; }
    ) ||
    (
     requires (_BidirectionalIterator x0) { ++x0; } &&
     requires (_BidirectionalIterator x0) { --x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { --x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator Float Integral 

[-[lower_bound:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:5867:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 (
  (
   requires (_ForwardIterator x0) { ++x0; } &&
   requires (_ForwardIterator x0) { *x0; }
  )
 ) &&
 requires (_ForwardIterator x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[set_intersection:_InputIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18888:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 (
  (
   requires (_InputIterator2 x0) { ++x0; } &&
   requires (_InputIterator2 x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator2 x0) { ++x0; } &&
 requires (_InputIterator2 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[next_permutation:_BidirectionalIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12901:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 (
  (
   (
    (
     (
      (
       requires (_BidirectionalIterator x0) { ++x0; } &&
       requires (_BidirectionalIterator x0) { --x0; }
      ) ||
      (
       requires (_BidirectionalIterator x0) { ++x0; } &&
       requires (_BidirectionalIterator x0) { --x0; }
      )
     )
    )
   ) &&
   requires (_BidirectionalIterator x0) { *x0; } &&
   (
    (
     (
      (
       requires (_BidirectionalIterator x0) { ++x0; } &&
       requires (_BidirectionalIterator x0) { --x0; }
      ) ||
      (
       requires (_BidirectionalIterator x0) { ++x0; } &&
       requires (_BidirectionalIterator x0) { --x0; }
      )
     )
    )
   ) &&
   requires (_BidirectionalIterator x0) { --x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { --x0; } &&
 requires (_BidirectionalIterator x0) { *x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[__partial_sort:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:13066:1
Printed constraint (original):
(
 (
  (
   requires (_RandomAccessIterator x0) { ++x0; } &&
   (
    (
     (
      (
       requires (_RandomAccessIterator x0) { ++x0; } &&
       requires (_RandomAccessIterator x0) { --x0; } &&
       (
        (
         requires (_RandomAccessIterator x0) { --x0; } &&
         requires (_RandomAccessIterator x0) { *x0; }
        )
       ) &&
       requires (_RandomAccessIterator x0) { *x0; } &&
       (
        (
         requires (_RandomAccessIterator x0) { ++x0; } &&
         requires (_RandomAccessIterator x0) { *x0; } &&
         true
        )
       )
      )
     ) &&
     requires (_RandomAccessIterator x0) { --x0; }
    )
   ) &&
   (
    (
     requires (_RandomAccessIterator x0) { ++x0; } &&
     requires (_RandomAccessIterator x0) { *x0; }
    )
   ) &&
   requires (_RandomAccessIterator x0) { *x0; } &&
   (
    (
     (
      (
       requires (_RandomAccessIterator x0) { ++x0; } &&
       requires (_RandomAccessIterator x0) { *x0; }
      )
     )
    )
   )
  )
 ) &&
 (
  (true)
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Inferred constraint:
RandomAccessIterator 

[-[__lower_bound_impl:_Iter]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:5850:1
Printed constraint (original):
(
 requires (_Iter x0) { ++x0; } &&
 requires (_Iter x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_Iter x0) { ++x0; } &&
 requires (_Iter x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__sample:_PopulationIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18347:1
Printed constraint (original):
(
 (
  (
   requires (_PopulationIterator x0) { *x0; } &&
   requires (_PopulationIterator x0) { ++x0; }
  ) ||
  (
   requires (_PopulationIterator x0) { *x0; } &&
   requires (_PopulationIterator x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_PopulationIterator x0) { *x0; } &&
 requires (_PopulationIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__search_n_forward_impl:_SizeT]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18530:1
Printed constraint (original):
(
 requires (_SizeT x0) { ++x0; }
)
Printed constraint (optimized):
requires (_SizeT x0) { ++x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[__is_heap_until:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12173:1
Printed constraint (original):
(
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
)
Printed constraint (optimized):
requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__search_n_random_access_impl:_Iter]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18567:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 requires (_Iter x0) { *x0; } &&
 (
  (true)
 ) &&
 requires (_Iter x0) { ++x0; } &&
 (
  (true)
 )
)
Printed constraint (optimized):
(
 requires (_Iter x0) { *x0; } &&
 requires (_Iter x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__sort5:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14256:1
Printed constraint (original):
(
 requires (_ForwardIterator x0) { *x0; } &&
 (
  (
   requires (_ForwardIterator x0) { *x0; } &&
   (
    (
     requires (_ForwardIterator x0) { *x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
requires (_ForwardIterator x0) { *x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__fill_n:_OutputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7744:1
Printed constraint (original):
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__search_n_impl:_DiffT]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18608:1
Printed constraint (original):
(
 (
  (
   requires (_DiffT x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
requires (_DiffT x0) { ++x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[__set_difference:_InIter2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18732:1
Printed constraint (original):
(
 requires (_InIter2 x0) { ++x0; } &&
 requires (_InIter2 x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_InIter2 x0) { ++x0; } &&
 requires (_InIter2 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[merge:_OutputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12662:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (
           (
            (true)
           ) &&
           (
            (true)
           )
          ) ||
          (true)
         )
        )
       )
      )
     )
    )
   ) &&
   requires (_OutputIterator x0) { *x0; } &&
   (
    (
     (
      (
       (
        (
         (
          (
           (
            (true)
           ) &&
           (
            (true)
           )
          ) ||
          (true)
         )
        )
       )
      )
     )
    )
   ) &&
   requires (_OutputIterator x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[mismatch:_InputIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12803:1
Printed constraint (original):
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__merge:_OutputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12639:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (true)
         ) &&
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   )
  )
 ) &&
 requires (_OutputIterator x0) { *x0; } &&
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (true)
         ) &&
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   )
  )
 ) &&
 requires (_OutputIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__remove_copy_if_impl:_OutIter]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:17661:1
Printed constraint (original):
(
 requires (_OutIter x0) { ++x0; } &&
 requires (_OutIter x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_OutIter x0) { ++x0; } &&
 requires (_OutIter x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__sort3_maybe_branchless:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14334:1
Printed constraint (original):
(
 (
  (
   requires (_RandomAccessIterator x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
requires (_RandomAccessIterator x0) { *x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__search_random_access_impl:_Iter1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7837:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 requires (_Iter1 x0) { ++x0; } &&
 requires (_Iter1 x0) { *x0; } &&
 (
  (true)
 ) &&
 (
  (true)
 ) &&
 requires (_Iter1 x0, _DiffT1 x1) { x0 + x1; }
)
Printed constraint (optimized):
(
 requires (_Iter1 x0) { ++x0; } &&
 requires (_Iter1 x0) { *x0; } &&
 requires (_Iter1 x0, _DiffT1 x1) { x0 + x1; }
)
Inferred constraint:
RandomAccessIterator 

[-[search_n:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18657:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (true)
     )
    ) ||
    (
     (
      (true)
     )
    )
   ) &&
   (
    (
     (
      (
       (
        (true)
       ) &&
       requires (_ForwardIterator x0) { *x0; } &&
       (
        (true)
       ) &&
       requires (_ForwardIterator x0) { ++x0; } &&
       (
        (true)
       )
      )
     )
    ) ||
    (
     (
      (
       (
        (true)
       ) &&
       requires (_ForwardIterator x0) { *x0; } &&
       (
        (true)
       ) &&
       requires (_ForwardIterator x0) { ++x0; } &&
       (
        (true)
       )
      )
     )
    )
   ) &&
   requires (_ForwardIterator x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__search_n_impl:_Iter1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18627:1
Printed constraint (original):
(
 (
  (
   (
    (true)
   ) &&
   requires (_Iter1 x0) { *x0; } &&
   (
    (true)
   ) &&
   requires (_Iter1 x0) { ++x0; } &&
   (
    (true)
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_Iter1 x0) { *x0; } &&
 requires (_Iter1 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__cond_swap:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14308:1
Printed constraint (original):
(
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
)
Printed constraint (optimized):
requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__set_difference:_OutIter]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18732:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        (true)
       ) &&
       (
        (true)
       )
      ) ||
      (true)
     )
    )
   )
  )
 ) &&
 requires (_OutIter x0) { ++x0; } &&
 requires (_OutIter x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_OutIter x0) { ++x0; } &&
 requires (_OutIter x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[binary_search:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:5883:1
Printed constraint (original):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0, _ForwardIterator x1) { x0 != x1; } &&
 (
  (
   (
    (true)
   ) &&
   (
    (
     requires (_ForwardIterator x0) { ++x0; } &&
     requires (_ForwardIterator x0) { *x0; }
    )
   ) &&
   requires (_ForwardIterator x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0, _ForwardIterator x1) { x0 != x1; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
InputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__floyd_sift_down:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12518:1
Printed constraint (original):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; } &&
 true
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Inferred constraint:
RandomAccessIterator 

[-[set_difference:_InputIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18750:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   )
  )
 ) &&
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (true)
         ) &&
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   ) &&
   requires (_InputIterator1 x0) { ++x0; } &&
   requires (_InputIterator1 x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator1 x0) { ++x0; } &&
 requires (_InputIterator1 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__set_difference:_Comp]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18732:1
Printed constraint (original):
(
 requires (_Comp f, _InIter2 x0, _InIter1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 requires (_Comp f, _InIter1 x0, _InIter2 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
)
Printed constraint (optimized):
(
 requires (_Comp f, _InIter2 x0, _InIter1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 requires (_Comp f, _InIter1 x0, _InIter2 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
)
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__equal:_BinaryPredicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7629:1
Printed constraint (original):
(
 (
  (
   requires (_BinaryPredicate f, _RandomAccessIterator1 x0, _RandomAccessIterator2 x1) { f(*x0, *x1); }
  )
 )
)
Printed constraint (optimized):
requires (_BinaryPredicate f, _RandomAccessIterator1 x0, _RandomAccessIterator2 x1) { f(*x0, *x1); }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[set_difference:_InputIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18762:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   )
  )
 ) &&
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (true)
         ) &&
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   ) &&
   requires (_InputIterator1 x0) { ++x0; } &&
   requires (_InputIterator1 x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator1 x0) { ++x0; } &&
 requires (_InputIterator1 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[set_difference:_InputIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18762:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 (
  (
   requires (_InputIterator2 x0) { ++x0; } &&
   requires (_InputIterator2 x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator2 x0) { ++x0; } &&
 requires (_InputIterator2 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[set_intersection:_InputIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18871:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 (
  (
   requires (_InputIterator2 x0) { ++x0; } &&
   requires (_InputIterator2 x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator2 x0) { ++x0; } &&
 requires (_InputIterator2 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[set_intersection:_InputIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18888:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 (
  (
   requires (_InputIterator1 x0) { ++x0; } &&
   requires (_InputIterator1 x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator1 x0) { ++x0; } &&
 requires (_InputIterator1 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[set_union:_InputIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19177:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (
           (
            (true)
           )
          ) ||
          (true)
         )
        )
       )
      )
     )
    )
   ) &&
   (
    (
     (
      (
       (
        (
         (
          (
           (
            (true)
           ) &&
           (
            (true)
           )
          ) ||
          (true)
         )
        )
       )
      )
     ) &&
     requires (_InputIterator2 x0) { ++x0; } &&
     requires (_InputIterator2 x0) { *x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator2 x0) { ++x0; } &&
 requires (_InputIterator2 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[set_symmetric_difference:_InputIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19035:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (
           (
            (true)
           )
          ) ||
          (true)
         )
        )
       )
      )
     )
    )
   ) &&
   (
    (
     requires (_InputIterator1 x0) { ++x0; } &&
     requires (_InputIterator1 x0) { *x0; } &&
     (
      (
       (
        (
         (
          (
           (
            (true)
           ) &&
           (
            (true)
           )
          ) ||
          (true)
         )
        )
       )
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator1 x0) { ++x0; } &&
 requires (_InputIterator1 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[copy_n:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7542:1
Printed constraint (original):
(
 requires (_InputIterator x0) { ++x0; } &&
 requires (_InputIterator x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator x0) { ++x0; } &&
 requires (_InputIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[set_difference:_OutputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18762:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (true)
         ) &&
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   ) &&
   requires (_OutputIterator x0) { ++x0; } &&
   requires (_OutputIterator x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[set_union:_InputIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19160:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   )
  )
 ) &&
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (true)
         ) &&
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   ) &&
   requires (_InputIterator2 x0) { ++x0; } &&
   requires (_InputIterator2 x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator2 x0) { ++x0; } &&
 requires (_InputIterator2 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__set_symmetric_difference:_InIter2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18990:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        (true)
       ) &&
       (
        (true)
       )
      ) ||
      (true)
     )
    )
   )
  )
 ) &&
 requires (_InIter2 x0) { ++x0; } &&
 requires (_InIter2 x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_InIter2 x0) { ++x0; } &&
 requires (_InIter2 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[set_symmetric_difference:_OutputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19035:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_OutputIterator x0) { ++x0; } &&
     (
      (
       (
        (
         (
          (
           (
            (true)
           ) &&
           (
            (true)
           )
          ) ||
          (true)
         )
        )
       )
      )
     ) &&
     requires (_OutputIterator x0) { *x0; } &&
     (
      (
       (
        (
         (
          (
           (
            (true)
           ) &&
           (
            (true)
           )
          ) ||
          (true)
         )
        )
       )
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[set_symmetric_difference:_OutputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19018:1
Printed constraint (original):
(
 (
  (
   requires (_OutputIterator x0) { ++x0; } &&
   (
    (
     (
      (
       (
        (
         (
          (true)
         ) &&
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   ) &&
   requires (_OutputIterator x0) { *x0; } &&
   (
    (
     (
      (
       (
        (
         (
          (true)
         ) &&
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__set_symmetric_difference:_OutIter]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18990:1
Printed constraint (original):
(
 requires (_OutIter x0) { ++x0; } &&
 (
  (
   (
    (
     (
      (
       (
        (true)
       ) &&
       (
        (true)
       )
      ) ||
      (true)
     )
    )
   )
  )
 ) &&
 requires (_OutIter x0) { *x0; } &&
 (
  (
   (
    (
     (
      (
       (
        (true)
       ) &&
       (
        (true)
       )
      ) ||
      (true)
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_OutIter x0) { ++x0; } &&
 requires (_OutIter x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__set_union:_OutIter]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19136:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        (true)
       ) &&
       (
        (true)
       )
      ) ||
      (true)
     )
    )
   )
  )
 ) &&
 requires (_OutIter x0) { *x0; } &&
 (
  (
   (
    (
     (
      (
       (
        (true)
       ) &&
       (
        (true)
       )
      ) ||
      (true)
     )
    )
   )
  )
 ) &&
 requires (_OutIter x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_OutIter x0) { *x0; } &&
 requires (_OutIter x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[next_permutation:_BidirectionalIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12909:1
Printed constraint (original):
(
 (
  (
   (
    (true)
   ) &&
   (
    (
     (
      (
       (
        (
         requires (_BidirectionalIterator x0) { ++x0; } &&
         requires (_BidirectionalIterator x0) { --x0; }
        ) ||
        (
         requires (_BidirectionalIterator x0) { ++x0; } &&
         requires (_BidirectionalIterator x0) { --x0; }
        )
       )
      )
     ) &&
     requires (_BidirectionalIterator x0) { *x0; } &&
     (
      (
       (
        (
         requires (_BidirectionalIterator x0) { ++x0; } &&
         requires (_BidirectionalIterator x0) { --x0; }
        ) ||
        (
         requires (_BidirectionalIterator x0) { ++x0; } &&
         requires (_BidirectionalIterator x0) { --x0; }
        )
       )
      )
     ) &&
     requires (_BidirectionalIterator x0) { --x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { --x0; } &&
 requires (_BidirectionalIterator x0) { *x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[__sample:_PopulationIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18308:1
Printed constraint (original):
(
 requires (_PopulationIterator x0) { *x0; } &&
 requires (_PopulationIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_PopulationIterator x0) { *x0; } &&
 requires (_PopulationIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__set_union:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19136:1
Printed constraint (original):
(
 requires (_Compare f, _InIter1 x0, _InIter2 x1) { f(*x0, *x1); } &&
 requires (_Compare f, _InIter2 x0, _InIter1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
)
Printed constraint (optimized):
(
 requires (_Compare f, _InIter1 x0, _InIter2 x1) { f(*x0, *x1); } &&
 requires (_Compare f, _InIter2 x0, _InIter1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
)
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__is_sorted_until_impl:_Iter]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:16509:1
Printed constraint (original):
(
 requires (_Iter x0) { *x0; }
)
Printed constraint (optimized):
requires (_Iter x0) { *x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[set_union:_InputIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19177:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (
           (
            (true)
           )
          ) ||
          (true)
         )
        )
       )
      )
     )
    )
   ) &&
   (
    (
     requires (_InputIterator1 x0) { ++x0; } &&
     requires (_InputIterator1 x0) { *x0; } &&
     (
      (
       (
        (
         (
          (
           (
            (true)
           ) &&
           (
            (true)
           )
          ) ||
          (true)
         )
        )
       )
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator1 x0) { ++x0; } &&
 requires (_InputIterator1 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__reverse:_BidirectionalIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12858:1
Printed constraint (original):
(
 (
  (
   requires (_Sentinel x0) { ++x0; } &&
   requires (_Sentinel x0) { --x0; }
  ) ||
  (
   requires (_Sentinel x0) { ++x0; } &&
   requires (_Sentinel x0) { --x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_Sentinel x0) { ++x0; } &&
 requires (_Sentinel x0) { --x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator Float Integral 

[-[__set_union:_InIter1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19136:1
Printed constraint (original):
(
 requires (_InIter1 x0) { ++x0; } &&
 requires (_InIter1 x0) { *x0; } &&
 (
  (
   (
    (
     (
      (
       (
        (true)
       ) &&
       (
        (true)
       )
      ) ||
      (true)
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_InIter1 x0) { ++x0; } &&
 requires (_InIter1 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[set_union:_OutputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19160:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (true)
         ) &&
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   ) &&
   requires (_OutputIterator x0) { *x0; } &&
   (
    (
     (
      (
       (
        (
         (
          (true)
         ) &&
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   ) &&
   requires (_OutputIterator x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[remove:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20306:1
Printed constraint (original):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; } &&
 (
  (
   requires (_ForwardIterator x0) { *x0; } &&
   requires (_ForwardIterator x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[sample:_PopulationIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18367:1
Printed constraint (original):
(
 (
  (
   (
    (true) ||
    (true)
   )
  )
 ) &&
 (
  (
   (
    (
     requires (_PopulationIterator x0) { *x0; } &&
     requires (_PopulationIterator x0) { ++x0; }
    ) ||
    (
     requires (_PopulationIterator x0) { *x0; } &&
     requires (_PopulationIterator x0) { ++x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_PopulationIterator x0) { *x0; } &&
 requires (_PopulationIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__stable_partition:_Predicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19627:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      true
     ) &&
     requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
     true
    )
   ) &&
   requires (_Predicate f, _ForwardIterator x0) { f(*x0); }
  ) ||
  (
   (
    (
     (
      true
     ) &&
     requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
     true
    ) ||
    (
     (
      (
       (
        true
       ) &&
       requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
       true
      ) ||
      true
     ) &&
     true &&
     requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
     true
    )
   ) &&
   requires (_Predicate f, _ForwardIterator x0) { f(*x0); }
  )
 )
)
Printed constraint (optimized):
(
 requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
 requires (_Predicate f, _ForwardIterator x0) { f(*x0); }
)
Inferred constraint:
UnaryFunction Predicate 

[-[__adjacent_find:_Iter]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:5721:1
Printed constraint (original):
(
 requires (_Iter x0) { *x0; } &&
 requires (_Iter x0) { ++x0; } &&
 requires (_Iter x0, _Sent x1) { x0 == x1; }
)
Printed constraint (optimized):
(
 requires (_Iter x0) { *x0; } &&
 requires (_Iter x0) { ++x0; } &&
 requires (_Iter x0, _Sent x1) { x0 == x1; }
)
Inferred constraint:
InputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__stable_partition_impl:_Predicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19591:1
Printed constraint (original):
(
 (
  (
   (
    true
   ) &&
   requires (_Predicate f, _BidirectionalIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
   true
  ) ||
  (
   (
    (
     (
      true
     ) &&
     requires (_Predicate f, _BidirectionalIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
     true
    ) ||
    true
   ) &&
   true &&
   requires (_Predicate f, _BidirectionalIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
   true
  )
 ) &&
 requires (_Predicate f, _BidirectionalIterator x0) { f(*x0); }
)
Printed constraint (optimized):
(
 requires (_Predicate f, _BidirectionalIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
 requires (_Predicate f, _BidirectionalIterator x0) { f(*x0); }
)
Inferred constraint:
UnaryFunction Predicate 

[-[__find_end_impl:_Iter2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:8706:1
Printed constraint (original):
(
 requires (_Iter2 x0) { ++x0; } &&
 requires (_Iter2 x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_Iter2 x0) { ++x0; } &&
 requires (_Iter2 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__stable_partition_impl:_Predicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19507:1
Printed constraint (original):
(
 (
  (
   (
    true
   ) &&
   requires (_Predicate f, _BidirectionalIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
   true
  ) ||
  true
 ) &&
 true &&
 requires (_Predicate f, _BidirectionalIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
 true
)
Printed constraint (optimized):
requires (_Predicate f, _BidirectionalIterator x0) { {f(*x0)} -> std::convertible_to<bool>; }
Inferred constraint:
UnaryFunction Predicate 

[-[__stable_partition:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19627:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (true)
     ) &&
     (
      (
       (
        (
         (
          (
           requires (_ForwardIterator x0) { ++x0; }
          )
         ) &&
         (
          (
           requires (_ForwardIterator x0) { *x0; } &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           )
          )
         )
        ) ||
        (
         (
          (
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           requires (_ForwardIterator x0) { *x0; } &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           )
          )
         ) &&
         (
          (
           requires (_ForwardIterator x0) { ++x0; }
          )
         ) &&
         (
          (
           requires (_ForwardIterator x0) { *x0; } &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           )
          )
         )
        ) ||
        (
         (
          (
           requires (_ForwardIterator x0) { *x0; } &&
           true &&
           (
            (
             requires (_ForwardIterator x0) { ++x0; }
            )
           ) &&
           (
            (
             requires (_ForwardIterator x0) { ++x0; }
            )
           ) &&
           requires (_ForwardIterator x0) { --x0; } &&
           (
            (true)
           ) &&
           (
            (true)
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           requires (_ForwardIterator x0) { *x0; } &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           )
          )
         ) &&
         (
          (
           requires (_ForwardIterator x0) { ++x0; }
          )
         ) &&
         (
          (
           requires (_ForwardIterator x0) { *x0; } &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           )
          )
         )
        )
       )
      )
     ) &&
     (
      true
     ) &&
     requires (_ForwardIterator x0) { *x0; } &&
     requires (_ForwardIterator x0) { ++x0; }
    )
   ) &&
   requires (_ForwardIterator x0) { ++x0; } &&
   requires (_ForwardIterator x0) { *x0; }
  ) ||
  (
   (
    (
     (
      (true)
     ) &&
     (
      (
       (
        (
         (
          (
           requires (_ForwardIterator x0) { ++x0; }
          )
         ) &&
         (
          (
           requires (_ForwardIterator x0) { *x0; } &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           )
          )
         )
        ) ||
        (
         (
          (
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           requires (_ForwardIterator x0) { *x0; } &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           )
          )
         ) &&
         (
          (
           requires (_ForwardIterator x0) { ++x0; }
          )
         ) &&
         (
          (
           requires (_ForwardIterator x0) { *x0; } &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           )
          )
         )
        ) ||
        (
         (
          (
           requires (_ForwardIterator x0) { *x0; } &&
           true &&
           (
            (
             requires (_ForwardIterator x0) { ++x0; }
            )
           ) &&
           (
            (
             requires (_ForwardIterator x0) { ++x0; }
            )
           ) &&
           requires (_ForwardIterator x0) { --x0; } &&
           (
            (true)
           ) &&
           (
            (true)
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           requires (_ForwardIterator x0) { *x0; } &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           )
          )
         ) &&
         (
          (
           requires (_ForwardIterator x0) { ++x0; }
          )
         ) &&
         (
          (
           requires (_ForwardIterator x0) { *x0; } &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           )
          )
         )
        )
       )
      )
     ) &&
     (
      true
     ) &&
     requires (_ForwardIterator x0) { *x0; } &&
     requires (_ForwardIterator x0) { ++x0; }
    ) ||
    (
     (
      (true)
     ) &&
     (
      (
       (
        (true)
       ) &&
       (
        (
         (
          (
           (
            (
             requires (_ForwardIterator x0) { ++x0; }
            )
           ) &&
           (
            (
             requires (_ForwardIterator x0) { *x0; } &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             )
            )
           )
          ) ||
          (
           (
            (
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             requires (_ForwardIterator x0) { *x0; } &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             )
            )
           ) &&
           (
            (
             requires (_ForwardIterator x0) { ++x0; }
            )
           ) &&
           (
            (
             requires (_ForwardIterator x0) { *x0; } &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             )
            )
           )
          ) ||
          (
           (
            (
             requires (_ForwardIterator x0) { *x0; } &&
             true &&
             (
              (
               requires (_ForwardIterator x0) { ++x0; }
              )
             ) &&
             (
              (
               requires (_ForwardIterator x0) { ++x0; }
              )
             ) &&
             requires (_ForwardIterator x0) { --x0; } &&
             (
              (true)
             ) &&
             (
              (true)
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             requires (_ForwardIterator x0) { *x0; } &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             )
            )
           ) &&
           (
            (
             requires (_ForwardIterator x0) { ++x0; }
            )
           ) &&
           (
            (
             requires (_ForwardIterator x0) { *x0; } &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             )
            )
           )
          )
         )
        )
       ) &&
       (
        true
       ) &&
       requires (_ForwardIterator x0) { *x0; } &&
       requires (_ForwardIterator x0) { ++x0; }
      ) ||
      true
     ) &&
     requires (_ForwardIterator x0) { ++x0; } &&
     requires (_ForwardIterator x0) { --x0; } &&
     (
      (
       (
        (
         (
          (
           requires (_ForwardIterator x0) { ++x0; }
          )
         ) &&
         (
          (
           requires (_ForwardIterator x0) { *x0; } &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           )
          )
         )
        ) ||
        (
         (
          (
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           requires (_ForwardIterator x0) { *x0; } &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           )
          )
         ) &&
         (
          (
           requires (_ForwardIterator x0) { ++x0; }
          )
         ) &&
         (
          (
           requires (_ForwardIterator x0) { *x0; } &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           )
          )
         )
        ) ||
        (
         (
          (
           requires (_ForwardIterator x0) { *x0; } &&
           true &&
           (
            (
             requires (_ForwardIterator x0) { ++x0; }
            )
           ) &&
           (
            (
             requires (_ForwardIterator x0) { ++x0; }
            )
           ) &&
           requires (_ForwardIterator x0) { --x0; } &&
           (
            (true)
           ) &&
           (
            (true)
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           requires (_ForwardIterator x0) { *x0; } &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           )
          )
         ) &&
         (
          (
           requires (_ForwardIterator x0) { ++x0; }
          )
         ) &&
         (
          (
           requires (_ForwardIterator x0) { *x0; } &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           )
          )
         )
        )
       )
      )
     ) &&
     requires (_ForwardIterator x0) { *x0; }
    )
   ) &&
   requires (_ForwardIterator x0) { --x0; } &&
   requires (_ForwardIterator x0) { ++x0; } &&
   requires (_ForwardIterator x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 (
  (
   (
    requires (_ForwardIterator x0) { ++x0; } &&
    requires (_ForwardIterator x0) { *x0; }
   ) ||
   (
    requires (_ForwardIterator x0) { *x0; } &&
    requires (_ForwardIterator x0) { ++x0; }
   ) ||
   (
    requires (_ForwardIterator x0) { *x0; } &&
    requires (_ForwardIterator x0) { ++x0; } &&
    requires (_ForwardIterator x0) { --x0; }
   )
  ) &&
  requires (_ForwardIterator x0) { *x0; } &&
  requires (_ForwardIterator x0) { ++x0; }
 ) ||
 (
  (
   (
    (
     (
      requires (_ForwardIterator x0) { ++x0; } &&
      requires (_ForwardIterator x0) { *x0; }
     ) ||
     (
      requires (_ForwardIterator x0) { *x0; } &&
      requires (_ForwardIterator x0) { ++x0; }
     ) ||
     (
      requires (_ForwardIterator x0) { *x0; } &&
      requires (_ForwardIterator x0) { ++x0; } &&
      requires (_ForwardIterator x0) { --x0; }
     )
    ) &&
    requires (_ForwardIterator x0) { *x0; } &&
    requires (_ForwardIterator x0) { ++x0; }
   ) ||
   (
    requires (_ForwardIterator x0) { ++x0; } &&
    requires (_ForwardIterator x0) { --x0; } &&
    (
     (
      requires (_ForwardIterator x0) { ++x0; } &&
      requires (_ForwardIterator x0) { *x0; }
     ) ||
     (
      requires (_ForwardIterator x0) { *x0; } &&
      requires (_ForwardIterator x0) { ++x0; }
     ) ||
     (
      requires (_ForwardIterator x0) { *x0; } &&
      requires (_ForwardIterator x0) { ++x0; } &&
      requires (_ForwardIterator x0) { --x0; }
     )
    ) &&
    requires (_ForwardIterator x0) { *x0; }
   )
  ) &&
  requires (_ForwardIterator x0) { --x0; } &&
  requires (_ForwardIterator x0) { ++x0; } &&
  requires (_ForwardIterator x0) { *x0; }
 )
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__unique_copy:_OutputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20125:1
Printed constraint (original):
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[stable_partition:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19634:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        (true)
       ) &&
       (
        (
         (
          (
           (
            (
             requires (_ForwardIterator x0) { ++x0; }
            )
           ) &&
           (
            (
             requires (_ForwardIterator x0) { *x0; } &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             )
            )
           )
          ) ||
          (
           (
            (
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             requires (_ForwardIterator x0) { *x0; } &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             )
            )
           ) &&
           (
            (
             requires (_ForwardIterator x0) { ++x0; }
            )
           ) &&
           (
            (
             requires (_ForwardIterator x0) { *x0; } &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             )
            )
           )
          ) ||
          (
           (
            (
             requires (_ForwardIterator x0) { *x0; } &&
             true &&
             (
              (
               requires (_ForwardIterator x0) { ++x0; }
              )
             ) &&
             (
              (
               requires (_ForwardIterator x0) { ++x0; }
              )
             ) &&
             requires (_ForwardIterator x0) { --x0; } &&
             (
              (true)
             ) &&
             (
              (true)
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             requires (_ForwardIterator x0) { *x0; } &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             )
            )
           ) &&
           (
            (
             requires (_ForwardIterator x0) { ++x0; }
            )
           ) &&
           (
            (
             requires (_ForwardIterator x0) { *x0; } &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             )
            )
           )
          )
         )
        )
       ) &&
       (
        true
       ) &&
       requires (_ForwardIterator x0) { *x0; } &&
       requires (_ForwardIterator x0) { ++x0; }
      )
     ) &&
     requires (_ForwardIterator x0) { ++x0; } &&
     requires (_ForwardIterator x0) { *x0; }
    ) ||
    (
     (
      (
       (
        (true)
       ) &&
       (
        (
         (
          (
           (
            (
             requires (_ForwardIterator x0) { ++x0; }
            )
           ) &&
           (
            (
             requires (_ForwardIterator x0) { *x0; } &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             )
            )
           )
          ) ||
          (
           (
            (
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             requires (_ForwardIterator x0) { *x0; } &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             )
            )
           ) &&
           (
            (
             requires (_ForwardIterator x0) { ++x0; }
            )
           ) &&
           (
            (
             requires (_ForwardIterator x0) { *x0; } &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             )
            )
           )
          ) ||
          (
           (
            (
             requires (_ForwardIterator x0) { *x0; } &&
             true &&
             (
              (
               requires (_ForwardIterator x0) { ++x0; }
              )
             ) &&
             (
              (
               requires (_ForwardIterator x0) { ++x0; }
              )
             ) &&
             requires (_ForwardIterator x0) { --x0; } &&
             (
              (true)
             ) &&
             (
              (true)
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             requires (_ForwardIterator x0) { *x0; } &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             )
            )
           ) &&
           (
            (
             requires (_ForwardIterator x0) { ++x0; }
            )
           ) &&
           (
            (
             requires (_ForwardIterator x0) { *x0; } &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             )
            )
           )
          )
         )
        )
       ) &&
       (
        true
       ) &&
       requires (_ForwardIterator x0) { *x0; } &&
       requires (_ForwardIterator x0) { ++x0; }
      ) ||
      (
       (
        (true)
       ) &&
       (
        (
         (
          (true)
         ) &&
         (
          (
           (
            (
             (
              (
               requires (_ForwardIterator x0) { ++x0; }
              )
             ) &&
             (
              (
               requires (_ForwardIterator x0) { *x0; } &&
               (
                (
                 (
                  (
                   (
                    (
                     (
                      (true)
                     ) &&
                     (
                      (true)
                     )
                    ) ||
                    (true)
                   )
                  )
                 )
                )
               ) &&
               (
                (
                 (
                  (
                   (
                    (
                     (
                      (true)
                     )
                    ) ||
                    (true)
                   )
                  )
                 )
                )
               )
              )
             )
            ) ||
            (
             (
              (
               (
                (
                 (
                  (
                   (
                    (
                     (
                      (true)
                     ) &&
                     (
                      (true)
                     )
                    ) ||
                    (true)
                   )
                  )
                 )
                )
               ) &&
               (
                (
                 (
                  (
                   (
                    (
                     (
                      (true)
                     )
                    ) ||
                    (true)
                   )
                  )
                 )
                )
               ) &&
               requires (_ForwardIterator x0) { *x0; } &&
               (
                (
                 (
                  (
                   (
                    (
                     (
                      (true)
                     ) &&
                     (
                      (true)
                     )
                    ) ||
                    (true)
                   )
                  )
                 )
                )
               )
              )
             ) &&
             (
              (
               requires (_ForwardIterator x0) { ++x0; }
              )
             ) &&
             (
              (
               requires (_ForwardIterator x0) { *x0; } &&
               (
                (
                 (
                  (
                   (
                    (
                     (
                      (true)
                     ) &&
                     (
                      (true)
                     )
                    ) ||
                    (true)
                   )
                  )
                 )
                )
               ) &&
               (
                (
                 (
                  (
                   (
                    (
                     (
                      (true)
                     )
                    ) ||
                    (true)
                   )
                  )
                 )
                )
               )
              )
             )
            ) ||
            (
             (
              (
               requires (_ForwardIterator x0) { *x0; } &&
               true &&
               (
                (
                 requires (_ForwardIterator x0) { ++x0; }
                )
               ) &&
               (
                (
                 requires (_ForwardIterator x0) { ++x0; }
                )
               ) &&
               requires (_ForwardIterator x0) { --x0; } &&
               (
                (true)
               ) &&
               (
                (true)
               )
              )
             ) &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (
                     (
                      (true)
                     ) &&
                     (
                      (true)
                     )
                    ) ||
                    (true)
                   )
                  )
                 )
                )
               ) &&
               (
                (
                 (
                  (
                   (
                    (
                     (
                      (true)
                     )
                    ) ||
                    (true)
                   )
                  )
                 )
                )
               ) &&
               requires (_ForwardIterator x0) { *x0; } &&
               (
                (
                 (
                  (
                   (
                    (
                     (
                      (true)
                     ) &&
                     (
                      (true)
                     )
                    ) ||
                    (true)
                   )
                  )
                 )
                )
               )
              )
             ) &&
             (
              (
               requires (_ForwardIterator x0) { ++x0; }
              )
             ) &&
             (
              (
               requires (_ForwardIterator x0) { *x0; } &&
               (
                (
                 (
                  (
                   (
                    (
                     (
                      (true)
                     ) &&
                     (
                      (true)
                     )
                    ) ||
                    (true)
                   )
                  )
                 )
                )
               ) &&
               (
                (
                 (
                  (
                   (
                    (
                     (
                      (true)
                     )
                    ) ||
                    (true)
                   )
                  )
                 )
                )
               )
              )
             )
            )
           )
          )
         ) &&
         (
          true
         ) &&
         requires (_ForwardIterator x0) { *x0; } &&
         requires (_ForwardIterator x0) { ++x0; }
        ) ||
        true
       ) &&
       requires (_ForwardIterator x0) { ++x0; } &&
       requires (_ForwardIterator x0) { --x0; } &&
       (
        (
         (
          (
           (
            (
             requires (_ForwardIterator x0) { ++x0; }
            )
           ) &&
           (
            (
             requires (_ForwardIterator x0) { *x0; } &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             )
            )
           )
          ) ||
          (
           (
            (
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             requires (_ForwardIterator x0) { *x0; } &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             )
            )
           ) &&
           (
            (
             requires (_ForwardIterator x0) { ++x0; }
            )
           ) &&
           (
            (
             requires (_ForwardIterator x0) { *x0; } &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             )
            )
           )
          ) ||
          (
           (
            (
             requires (_ForwardIterator x0) { *x0; } &&
             true &&
             (
              (
               requires (_ForwardIterator x0) { ++x0; }
              )
             ) &&
             (
              (
               requires (_ForwardIterator x0) { ++x0; }
              )
             ) &&
             requires (_ForwardIterator x0) { --x0; } &&
             (
              (true)
             ) &&
             (
              (true)
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             requires (_ForwardIterator x0) { *x0; } &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             )
            )
           ) &&
           (
            (
             requires (_ForwardIterator x0) { ++x0; }
            )
           ) &&
           (
            (
             requires (_ForwardIterator x0) { *x0; } &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             )
            )
           )
          )
         )
        )
       ) &&
       requires (_ForwardIterator x0) { *x0; }
      )
     ) &&
     requires (_ForwardIterator x0) { --x0; } &&
     requires (_ForwardIterator x0) { ++x0; } &&
     requires (_ForwardIterator x0) { *x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 (
  (
   (
    requires (_ForwardIterator x0) { ++x0; } &&
    requires (_ForwardIterator x0) { *x0; }
   ) ||
   (
    requires (_ForwardIterator x0) { *x0; } &&
    requires (_ForwardIterator x0) { ++x0; }
   ) ||
   (
    requires (_ForwardIterator x0) { *x0; } &&
    requires (_ForwardIterator x0) { ++x0; } &&
    requires (_ForwardIterator x0) { --x0; }
   )
  ) &&
  requires (_ForwardIterator x0) { *x0; } &&
  requires (_ForwardIterator x0) { ++x0; }
 ) ||
 (
  (
   (
    (
     (
      requires (_ForwardIterator x0) { ++x0; } &&
      requires (_ForwardIterator x0) { *x0; }
     ) ||
     (
      requires (_ForwardIterator x0) { *x0; } &&
      requires (_ForwardIterator x0) { ++x0; }
     ) ||
     (
      requires (_ForwardIterator x0) { *x0; } &&
      requires (_ForwardIterator x0) { ++x0; } &&
      requires (_ForwardIterator x0) { --x0; }
     )
    ) &&
    requires (_ForwardIterator x0) { *x0; } &&
    requires (_ForwardIterator x0) { ++x0; }
   ) ||
   (
    requires (_ForwardIterator x0) { ++x0; } &&
    requires (_ForwardIterator x0) { --x0; } &&
    (
     (
      requires (_ForwardIterator x0) { ++x0; } &&
      requires (_ForwardIterator x0) { *x0; }
     ) ||
     (
      requires (_ForwardIterator x0) { *x0; } &&
      requires (_ForwardIterator x0) { ++x0; }
     ) ||
     (
      requires (_ForwardIterator x0) { *x0; } &&
      requires (_ForwardIterator x0) { ++x0; } &&
      requires (_ForwardIterator x0) { --x0; }
     )
    ) &&
    requires (_ForwardIterator x0) { *x0; }
   )
  ) &&
  requires (_ForwardIterator x0) { --x0; } &&
  requires (_ForwardIterator x0) { ++x0; } &&
  requires (_ForwardIterator x0) { *x0; }
 )
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__sort_impl:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14715:1
Printed constraint (original):
(
 (
  (
   (
    (true)
   ) &&
   (
    (true)
   )
  )
 ) &&
 (
  (
   (
    (
     requires (_RandomAccessIterator x0) { ++x0; } &&
     (
      (
       (
        (
         requires (_RandomAccessIterator x0) { ++x0; } &&
         requires (_RandomAccessIterator x0) { --x0; } &&
         (
          (
           requires (_RandomAccessIterator x0) { --x0; } &&
           requires (_RandomAccessIterator x0) { *x0; }
          )
         ) &&
         requires (_RandomAccessIterator x0) { *x0; } &&
         (
          (
           requires (_RandomAccessIterator x0) { ++x0; } &&
           requires (_RandomAccessIterator x0) { *x0; } &&
           true
          )
         )
        )
       ) &&
       requires (_RandomAccessIterator x0) { --x0; }
      )
     ) &&
     (
      (
       requires (_RandomAccessIterator x0) { ++x0; } &&
       requires (_RandomAccessIterator x0) { *x0; }
      )
     ) &&
     requires (_RandomAccessIterator x0) { *x0; } &&
     (
      (
       (
        (
         requires (_RandomAccessIterator x0) { ++x0; } &&
         requires (_RandomAccessIterator x0) { *x0; }
        )
       )
      )
     )
    )
   ) &&
   (
    (true)
   )
  )
 ) &&
 (
  (true)
 ) &&
 (
  (true)
 ) &&
 (
  (true)
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Inferred constraint:
RandomAccessIterator 

[-[partial_sort_copy:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:15035:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_InputIterator x0) { *x0; } &&
     requires (_InputIterator x0) { ++x0; }
    )
   ) &&
   (
    (true)
   ) &&
   requires (_InputIterator x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__stable_partition_impl:_BidirectionalIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19507:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 (
  (
   (
    (true)
   ) &&
   (
    (
     (
      (
       (
        (
         requires (_BidirectionalIterator x0) { ++x0; }
        )
       ) &&
       (
        (
         requires (_BidirectionalIterator x0) { *x0; } &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         )
        )
       )
      ) ||
      (
       (
        (
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         requires (_BidirectionalIterator x0) { *x0; } &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         )
        )
       ) &&
       (
        (
         requires (_BidirectionalIterator x0) { ++x0; }
        )
       ) &&
       (
        (
         requires (_BidirectionalIterator x0) { *x0; } &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         )
        )
       )
      ) ||
      (
       (
        (
         requires (_BidirectionalIterator x0) { *x0; } &&
         true &&
         (
          (
           requires (_BidirectionalIterator x0) { ++x0; }
          )
         ) &&
         (
          (
           requires (_BidirectionalIterator x0) { ++x0; }
          )
         ) &&
         requires (_BidirectionalIterator x0) { --x0; } &&
         (
          (true)
         ) &&
         (
          (true)
         )
        )
       ) &&
       (
        (
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         requires (_BidirectionalIterator x0) { *x0; } &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         )
        )
       ) &&
       (
        (
         requires (_BidirectionalIterator x0) { ++x0; }
        )
       ) &&
       (
        (
         requires (_BidirectionalIterator x0) { *x0; } &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         )
        )
       )
      )
     )
    )
   ) &&
   (
    true
   ) &&
   requires (_BidirectionalIterator x0) { *x0; } &&
   requires (_BidirectionalIterator x0) { ++x0; }
  ) ||
  true
 ) &&
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { --x0; } &&
 (
  (
   (
    (
     (
      (
       requires (_BidirectionalIterator x0) { ++x0; }
      )
     ) &&
     (
      (
       requires (_BidirectionalIterator x0) { *x0; } &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       ) &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       )
      )
     )
    ) ||
    (
     (
      (
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       ) &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       ) &&
       requires (_BidirectionalIterator x0) { *x0; } &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       )
      )
     ) &&
     (
      (
       requires (_BidirectionalIterator x0) { ++x0; }
      )
     ) &&
     (
      (
       requires (_BidirectionalIterator x0) { *x0; } &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       ) &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       )
      )
     )
    ) ||
    (
     (
      (
       requires (_BidirectionalIterator x0) { *x0; } &&
       true &&
       (
        (
         requires (_BidirectionalIterator x0) { ++x0; }
        )
       ) &&
       (
        (
         requires (_BidirectionalIterator x0) { ++x0; }
        )
       ) &&
       requires (_BidirectionalIterator x0) { --x0; } &&
       (
        (true)
       ) &&
       (
        (true)
       )
      )
     ) &&
     (
      (
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       ) &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       ) &&
       requires (_BidirectionalIterator x0) { *x0; } &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       )
      )
     ) &&
     (
      (
       requires (_BidirectionalIterator x0) { ++x0; }
      )
     ) &&
     (
      (
       requires (_BidirectionalIterator x0) { *x0; } &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       ) &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       )
      )
     )
    )
   )
  )
 ) &&
 requires (_BidirectionalIterator x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { --x0; } &&
 (
  (
   requires (_BidirectionalIterator x0) { ++x0; } &&
   requires (_BidirectionalIterator x0) { *x0; }
  ) ||
  (
   requires (_BidirectionalIterator x0) { *x0; } &&
   requires (_BidirectionalIterator x0) { ++x0; }
  ) ||
  (
   requires (_BidirectionalIterator x0) { *x0; } &&
   requires (_BidirectionalIterator x0) { ++x0; } &&
   requires (_BidirectionalIterator x0) { --x0; }
  )
 ) &&
 requires (_BidirectionalIterator x0) { *x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[__stable_partition_impl:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19410:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 (
  (
   (
    (
     (
      (
       requires (_ForwardIterator x0) { ++x0; }
      )
     ) &&
     (
      (
       requires (_ForwardIterator x0) { *x0; } &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       ) &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       )
      )
     )
    ) ||
    (
     (
      (
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       ) &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       ) &&
       requires (_ForwardIterator x0) { *x0; } &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       )
      )
     ) &&
     (
      (
       requires (_ForwardIterator x0) { ++x0; }
      )
     ) &&
     (
      (
       requires (_ForwardIterator x0) { *x0; } &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       ) &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       )
      )
     )
    ) ||
    (
     (
      (
       requires (_ForwardIterator x0) { *x0; } &&
       true &&
       (
        (
         requires (_ForwardIterator x0) { ++x0; }
        )
       ) &&
       (
        (
         requires (_ForwardIterator x0) { ++x0; }
        )
       ) &&
       requires (_ForwardIterator x0) { --x0; } &&
       (
        (true)
       ) &&
       (
        (true)
       )
      )
     ) &&
     (
      (
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       ) &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       ) &&
       requires (_ForwardIterator x0) { *x0; } &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       )
      )
     ) &&
     (
      (
       requires (_ForwardIterator x0) { ++x0; }
      )
     ) &&
     (
      (
       requires (_ForwardIterator x0) { *x0; } &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       ) &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       )
      )
     )
    )
   )
  )
 ) &&
 (
  true
 ) &&
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 (
  (
   requires (_ForwardIterator x0) { ++x0; } &&
   requires (_ForwardIterator x0) { *x0; }
  ) ||
  (
   requires (_ForwardIterator x0) { *x0; } &&
   requires (_ForwardIterator x0) { ++x0; }
  ) ||
  (
   requires (_ForwardIterator x0) { *x0; } &&
   requires (_ForwardIterator x0) { ++x0; } &&
   requires (_ForwardIterator x0) { --x0; }
  )
 ) &&
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__search_n_impl:_Iter]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18608:1
Printed constraint (original):
(
 (
  (
   (
    (true)
   ) &&
   requires (_Iter x0) { *x0; } &&
   (
    (true)
   ) &&
   requires (_Iter x0) { ++x0; } &&
   (
    (true)
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_Iter x0) { *x0; } &&
 requires (_Iter x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[set_union:_InputIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19160:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   )
  )
 ) &&
 (
  (
   requires (_InputIterator1 x0) { ++x0; } &&
   requires (_InputIterator1 x0) { *x0; } &&
   (
    (
     (
      (
       (
        (
         (
          (true)
         ) &&
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator1 x0) { ++x0; } &&
 requires (_InputIterator1 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__nth_element:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14755:1
Printed constraint (original):
(
 (
  (
   requires (_RandomAccessIterator x0) { *x0; } &&
   requires (_RandomAccessIterator x0) { --x0; }
  )
 ) &&
 (
  (
   (
    (
     (
      (true)
     )
    )
   ) &&
   requires (_RandomAccessIterator x0) { ++x0; } &&
   (
    (
     (
      (
       requires (_RandomAccessIterator x0) { *x0; } &&
       requires (_RandomAccessIterator x0) { ++x0; }
      )
     )
    )
   ) &&
   requires (_RandomAccessIterator x0) { --x0; }
  )
 ) &&
 (
  (
   requires (_RandomAccessIterator x0) { *x0; }
  )
 ) &&
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { --x0; }
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { ++x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[__merge_move_construct:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19680:1
Printed constraint (original):
(
 requires (_Compare f, _InputIterator2 x0, _InputIterator1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
)
Printed constraint (optimized):
requires (_Compare f, _InputIterator2 x0, _InputIterator1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__merge_move_assign:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19720:1
Printed constraint (original):
(
 requires (_Compare f, _InputIterator2 x0, _InputIterator1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
)
Printed constraint (optimized):
requires (_Compare f, _InputIterator2 x0, _InputIterator1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__uninitialized_allocator_copy:_Iter2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:30087:1
Printed constraint (original):
(
 requires (_Iter2 x0) { ++x0; }
)
Printed constraint (optimized):
requires (_Iter2 x0) { ++x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[__merge_move_assign:_InputIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19720:1
Printed constraint (original):
(
 requires (_InputIterator2 x0) { ++x0; } &&
 requires (_InputIterator2 x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator2 x0) { ++x0; } &&
 requires (_InputIterator2 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[partial_sort_copy:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:15023:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 (
  (
   (
    (
     (
      (
       requires (_RandomAccessIterator x0) { ++x0; } &&
       requires (_RandomAccessIterator x0) { --x0; } &&
       (
        (
         requires (_RandomAccessIterator x0) { --x0; } &&
         requires (_RandomAccessIterator x0) { *x0; }
        )
       ) &&
       requires (_RandomAccessIterator x0) { *x0; } &&
       (
        (
         requires (_RandomAccessIterator x0) { ++x0; } &&
         requires (_RandomAccessIterator x0) { *x0; } &&
         true
        )
       )
      )
     ) &&
     requires (_RandomAccessIterator x0) { --x0; }
    )
   ) &&
   (
    (
     requires (_RandomAccessIterator x0) { ++x0; } &&
     requires (_RandomAccessIterator x0) { *x0; }
    )
   ) &&
   (
    (
     (
      (
       requires (_RandomAccessIterator x0) { ++x0; } &&
       requires (_RandomAccessIterator x0) { *x0; }
      )
     )
    )
   ) &&
   requires (_RandomAccessIterator x0) { *x0; } &&
   requires (_RandomAccessIterator x0) { ++x0; }
  )
 ) &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Inferred constraint:
RandomAccessIterator 

[-[is_permutation:_ForwardIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12359:1
Printed constraint (original):
(
 (
  (
   (
    (true)
   )
  )
 ) &&
 (
  (
   (
    (true)
   ) &&
   requires (_ForwardIterator1 x0) { *x0; } &&
   requires (_ForwardIterator1 x0) { ++x0; }
  )
 ) &&
 requires (_ForwardIterator1 x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_ForwardIterator1 x0) { *x0; } &&
 requires (_ForwardIterator1 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__stable_sort_move:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19754:1
Printed constraint (original):
(
 (
  (
   requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
  )
 ) &&
 (
  (
   true &&
   true
  )
 ) &&
 true
)
Printed constraint (optimized):
requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[stable_sort:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19864:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      true
     ) &&
     (
      (
       (
        (
         requires (_RandomAccessIterator x0) { *x0; } &&
         requires (_RandomAccessIterator x0) { ++x0; }
        )
       ) &&
       (
        (
         requires (_RandomAccessIterator x0) { *x0; } &&
         requires (_RandomAccessIterator x0) { ++x0; }
        )
       ) &&
       requires (_RandomAccessIterator x0) { *x0; } &&
       (
        (
         requires (_RandomAccessIterator x0) { *x0; } &&
         requires (_RandomAccessIterator x0) { ++x0; }
        )
       ) &&
       requires (_RandomAccessIterator x0) { --x0; }
      )
     ) &&
     (
      (
       requires (_RandomAccessIterator x0) { *x0; } &&
       requires (_RandomAccessIterator x0) { ++x0; }
      )
     ) &&
     (
      (
       (
        (true)
       ) &&
       (
        (
         (
          (
           (
            (
             requires (_RandomAccessIterator x0) { ++x0; }
            )
           ) &&
           (
            (
             requires (_RandomAccessIterator x0) { *x0; } &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             )
            )
           )
          ) ||
          (
           (
            (
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             requires (_RandomAccessIterator x0) { *x0; } &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             )
            )
           ) &&
           (
            (
             requires (_RandomAccessIterator x0) { ++x0; }
            )
           ) &&
           (
            (
             requires (_RandomAccessIterator x0) { *x0; } &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             )
            )
           )
          ) ||
          (
           (
            (
             requires (_RandomAccessIterator x0) { *x0; } &&
             true &&
             (
              (
               requires (_RandomAccessIterator x0) { ++x0; }
              )
             ) &&
             (
              (
               requires (_RandomAccessIterator x0) { ++x0; }
              )
             ) &&
             requires (_RandomAccessIterator x0) { --x0; } &&
             (
              (true)
             ) &&
             (
              (true)
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             requires (_RandomAccessIterator x0) { *x0; } &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             )
            )
           ) &&
           (
            (
             requires (_RandomAccessIterator x0) { ++x0; }
            )
           ) &&
           (
            (
             requires (_RandomAccessIterator x0) { *x0; } &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             )
            )
           )
          )
         )
        )
       ) &&
       (
        (true)
       ) &&
       (
        (true)
       ) &&
       (
        (
         (
          (true)
         ) &&
         (
          (
           requires (_RandomAccessIterator x0) { ++x0; } &&
           requires (_RandomAccessIterator x0) { *x0; }
          )
         ) &&
         requires (_RandomAccessIterator x0) { *x0; }
        )
       ) &&
       requires (_RandomAccessIterator x0) { *x0; } &&
       requires (_RandomAccessIterator x0) { ++x0; } &&
       (
        true
       ) &&
       (
        (
         (
          (
           requires (_RandomAccessIterator x0) { *x0; } &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           requires (_RandomAccessIterator x0) { ++x0; }
          )
         ) &&
         (
          (true)
         ) &&
         (
          (
           requires (_RandomAccessIterator x0) { ++x0; } &&
           requires (_RandomAccessIterator x0) { *x0; }
          )
         ) &&
         requires (_RandomAccessIterator x0) { ++x0; }
        )
       )
      )
     ) &&
     (
      (
       requires (_RandomAccessIterator x0) { --x0; } &&
       requires (_RandomAccessIterator x0) { *x0; } &&
       requires (_RandomAccessIterator x0) { ++x0; }
      )
     ) &&
     requires (_RandomAccessIterator x0) { *x0; } &&
     requires (_RandomAccessIterator x0) { --x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 (
  (
   requires (_RandomAccessIterator x0) { ++x0; } &&
   requires (_RandomAccessIterator x0) { *x0; }
  ) ||
  (
   requires (_RandomAccessIterator x0) { *x0; } &&
   requires (_RandomAccessIterator x0) { ++x0; }
  ) ||
  (
   requires (_RandomAccessIterator x0) { *x0; } &&
   requires (_RandomAccessIterator x0) { ++x0; } &&
   requires (_RandomAccessIterator x0) { --x0; }
  )
 )
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[stable_sort:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19864:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       true
      )
     ) &&
     (
      (
       (
        (
         (
          (true)
         )
        )
       ) &&
       (
        (true)
       ) &&
       requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
       (
        true
       ) &&
       (
        (
         (
          (
           true
          )
         )
        )
       )
      )
     ) &&
     (
      (
       true
      )
     ) &&
     (
      true
     ) &&
     (
      (
       (
        (
         requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
        )
       ) &&
       (
        (
         true &&
         true
        )
       ) &&
       true
      )
     ) &&
     true
    )
   )
  )
 )
)
Printed constraint (optimized):
requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__set_intersection:_InIter2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18850:1
Printed constraint (original):
(
 requires (_InIter2 x0) { ++x0; } &&
 requires (_InIter2 x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_InIter2 x0) { ++x0; } &&
 requires (_InIter2 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__selection_sort:_BidirectionalIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14373:1
Printed constraint (original):
(
 (
  (
   (
    (true)
   )
  )
 ) &&
 requires (_BidirectionalIterator x0) { ++x0; } &&
 (
  (
   (
    (
     requires (_BidirectionalIterator x0) { *x0; } &&
     requires (_BidirectionalIterator x0) { ++x0; }
    )
   )
  )
 ) &&
 requires (_BidirectionalIterator x0) { --x0; }
)
Printed constraint (optimized):
(
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { *x0; } &&
 requires (_BidirectionalIterator x0) { --x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[search_n:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18646:1
Printed constraint (original):
(
 (
  (
   (
    (true)
   )
  ) ||
  (
   (
    (true)
   )
  )
 ) &&
 (
  (
   (
    (
     (
      (true)
     ) &&
     requires (_ForwardIterator x0) { *x0; } &&
     (
      (true)
     ) &&
     requires (_ForwardIterator x0) { ++x0; } &&
     (
      (true)
     )
    )
   )
  ) ||
  (
   (
    (
     (
      (true)
     ) &&
     requires (_ForwardIterator x0) { *x0; } &&
     (
      (true)
     ) &&
     requires (_ForwardIterator x0) { ++x0; } &&
     (
      (true)
     )
    )
   )
  )
 ) &&
 requires (_ForwardIterator x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__inplace_merge:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12063:1
Printed constraint (original):
(
 (
  (
   (
    (true)
   )
  )
 ) &&
 (
  (true)
 ) &&
 requires (_Compare f, _BidirectionalIterator x0, _BidirectionalIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 (
  true
 ) &&
 (
  (
   (
    (
     true
    )
   )
  )
 )
)
Printed constraint (optimized):
requires (_Compare f, _BidirectionalIterator x0, _BidirectionalIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__equal:_InputIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7620:1
Printed constraint (original):
(
 requires (_InputIterator2 x0) { *x0; } &&
 requires (_InputIterator2 x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator2 x0) { *x0; } &&
 requires (_InputIterator2 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__stable_sort_impl:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19846:1
Printed constraint (original):
(
 (
  (
   (
    true
   ) &&
   (
    (
     (
      (
       requires (_RandomAccessIterator x0) { *x0; } &&
       requires (_RandomAccessIterator x0) { ++x0; }
      )
     ) &&
     (
      (
       requires (_RandomAccessIterator x0) { *x0; } &&
       requires (_RandomAccessIterator x0) { ++x0; }
      )
     ) &&
     requires (_RandomAccessIterator x0) { *x0; } &&
     (
      (
       requires (_RandomAccessIterator x0) { *x0; } &&
       requires (_RandomAccessIterator x0) { ++x0; }
      )
     ) &&
     requires (_RandomAccessIterator x0) { --x0; }
    )
   ) &&
   (
    (
     requires (_RandomAccessIterator x0) { *x0; } &&
     requires (_RandomAccessIterator x0) { ++x0; }
    )
   ) &&
   (
    (
     (
      (true)
     ) &&
     (
      (
       (
        (
         (
          (
           requires (_RandomAccessIterator x0) { ++x0; }
          )
         ) &&
         (
          (
           requires (_RandomAccessIterator x0) { *x0; } &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           )
          )
         )
        ) ||
        (
         (
          (
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           requires (_RandomAccessIterator x0) { *x0; } &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           )
          )
         ) &&
         (
          (
           requires (_RandomAccessIterator x0) { ++x0; }
          )
         ) &&
         (
          (
           requires (_RandomAccessIterator x0) { *x0; } &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           )
          )
         )
        ) ||
        (
         (
          (
           requires (_RandomAccessIterator x0) { *x0; } &&
           true &&
           (
            (
             requires (_RandomAccessIterator x0) { ++x0; }
            )
           ) &&
           (
            (
             requires (_RandomAccessIterator x0) { ++x0; }
            )
           ) &&
           requires (_RandomAccessIterator x0) { --x0; } &&
           (
            (true)
           ) &&
           (
            (true)
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           requires (_RandomAccessIterator x0) { *x0; } &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           )
          )
         ) &&
         (
          (
           requires (_RandomAccessIterator x0) { ++x0; }
          )
         ) &&
         (
          (
           requires (_RandomAccessIterator x0) { *x0; } &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           )
          )
         )
        )
       )
      )
     ) &&
     (
      (true)
     ) &&
     (
      (true)
     ) &&
     (
      (
       (
        (true)
       ) &&
       (
        (
         requires (_RandomAccessIterator x0) { ++x0; } &&
         requires (_RandomAccessIterator x0) { *x0; }
        )
       ) &&
       requires (_RandomAccessIterator x0) { *x0; }
      )
     ) &&
     requires (_RandomAccessIterator x0) { *x0; } &&
     requires (_RandomAccessIterator x0) { ++x0; } &&
     (
      true
     ) &&
     (
      (
       (
        (
         requires (_RandomAccessIterator x0) { *x0; } &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         requires (_RandomAccessIterator x0) { ++x0; }
        )
       ) &&
       (
        (true)
       ) &&
       (
        (
         requires (_RandomAccessIterator x0) { ++x0; } &&
         requires (_RandomAccessIterator x0) { *x0; }
        )
       ) &&
       requires (_RandomAccessIterator x0) { ++x0; }
      )
     )
    )
   ) &&
   (
    (
     requires (_RandomAccessIterator x0) { --x0; } &&
     requires (_RandomAccessIterator x0) { *x0; } &&
     requires (_RandomAccessIterator x0) { ++x0; }
    )
   ) &&
   requires (_RandomAccessIterator x0) { *x0; } &&
   requires (_RandomAccessIterator x0) { --x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 (
  (
   requires (_RandomAccessIterator x0) { ++x0; } &&
   requires (_RandomAccessIterator x0) { *x0; }
  ) ||
  (
   requires (_RandomAccessIterator x0) { *x0; } &&
   requires (_RandomAccessIterator x0) { ++x0; }
  ) ||
  (
   requires (_RandomAccessIterator x0) { *x0; } &&
   requires (_RandomAccessIterator x0) { ++x0; } &&
   requires (_RandomAccessIterator x0) { --x0; }
  )
 )
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[__set_union:_InIter2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19136:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        (true)
       ) &&
       (
        (true)
       )
      ) ||
      (true)
     )
    )
   )
  )
 ) &&
 requires (_InIter2 x0) { ++x0; } &&
 requires (_InIter2 x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_InIter2 x0) { ++x0; } &&
 requires (_InIter2 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__distance:_RandIter]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:5418:1
Printed constraint (original):
(
 requires (_RandIter x0, _RandIter x1) { x0 - x1; }
)
Printed constraint (optimized):
requires (_RandIter x0, _RandIter x1) { x0 - x1; }
Inferred constraint:
RandomAccessIterator Float Integral 

[-[__insertion_sort_move:_BidirectionalIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14474:1
Printed constraint (original):
(
 requires (_BidirectionalIterator x0) { *x0; } &&
 requires (_BidirectionalIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_BidirectionalIterator x0) { *x0; } &&
 requires (_BidirectionalIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__search_n_forward_impl:_Iter]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18530:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 requires (_Iter x0) { *x0; } &&
 (
  (true)
 ) &&
 requires (_Iter x0) { ++x0; } &&
 (
  (true)
 )
)
Printed constraint (optimized):
(
 requires (_Iter x0) { *x0; } &&
 requires (_Iter x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[unique:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20075:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_ForwardIterator x0, _ForwardIterator x1) { ++x1 != x0; } &&
     requires (_ForwardIterator x0, _ForwardIterator x1) { x1 == x0; }
    )
   )
  )
 ) &&
 (
  (
   requires (_ForwardIterator x0) { *x0; } &&
   requires (_ForwardIterator x0) { ++x0; } &&
   (
    (
     requires (_ForwardIterator x0) { *x0; } &&
     requires (_ForwardIterator x0) { ++x0; } &&
     requires (_ForwardIterator x0, _ForwardIterator x1) { x0 == x1; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0, _ForwardIterator x1) { ++x1 != x0; } &&
 requires (_ForwardIterator x0, _ForwardIterator x1) { x1 == x0; } &&
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0, _ForwardIterator x1) { x0 == x1; }
)
Inferred constraint:
InputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__partition_impl:_Predicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:15069:1
Printed constraint (original):
(
 requires (_Predicate f, _BidirectionalIterator x0) { f(*x0); }
)
Printed constraint (optimized):
requires (_Predicate f, _BidirectionalIterator x0) { f(*x0); }
Inferred constraint:
UnaryFunction Predicate 

[-[__partition:_Predicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:15095:1
Printed constraint (original):
(
 (
  (
   requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
   requires (_Predicate f, _ForwardIterator x0) { f(*x0); }
  ) ||
  (
   requires (_Predicate f, _ForwardIterator x0) { f(*x0); }
  )
 )
)
Printed constraint (optimized):
(
 (
  requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
  requires (_Predicate f, _ForwardIterator x0) { f(*x0); }
 ) ||
 requires (_Predicate f, _ForwardIterator x0) { f(*x0); }
)
Inferred constraint:
UnaryFunction Predicate 

[-[__unique_copy:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20146:1
Printed constraint (original):
(
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__unique_copy:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20125:1
Printed constraint (original):
(
 requires (_InputIterator x0) { ++x0; } &&
 requires (_InputIterator x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator x0) { ++x0; } &&
 requires (_InputIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__uninitialized_move_n:_IterMove]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29949:1
Printed constraint (original):
(
 requires (_IterMove f, _InputIterator x0) { f(x0); }
)
Printed constraint (optimized):
requires (_IterMove f, _InputIterator x0) { f(x0); }
Inferred constraint:
UnaryFunction Predicate 

[-[__adjacent_find:_BinaryPredicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:5721:1
Printed constraint (original):
(
 requires (_BinaryPredicate f, _Iter x0, _Iter x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
)
Printed constraint (optimized):
requires (_BinaryPredicate f, _Iter x0, _Iter x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[unique_copy:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20183:1
Printed constraint (original):
(
 (
  (true) ||
  (true) ||
  (true)
 ) &&
 (
  (
   requires (_InputIterator x0) { ++x0; } &&
   requires (_InputIterator x0) { *x0; }
  ) ||
  (
   requires (_InputIterator x0) { ++x0; } &&
   requires (_InputIterator x0) { *x0; }
  ) ||
  (
   requires (_InputIterator x0) { ++x0; } &&
   requires (_InputIterator x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator x0) { ++x0; } &&
 requires (_InputIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[find_if:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:8912:1
Printed constraint (original):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[replace_copy:_OutputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20377:1
Printed constraint (original):
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__unique_copy:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20167:1
Printed constraint (original):
(
 requires (_InputIterator x0) { ++x0; } &&
 requires (_InputIterator x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator x0) { ++x0; } &&
 requires (_InputIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[replace_copy_if:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20392:1
Printed constraint (original):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__sift_down:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12482:1
Printed constraint (original):
(
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 true
)
Printed constraint (optimized):
requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[data:_Cont]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:28737:1
Printed constraint (original):
(
 requires (_Cont o) { o.data(); }
)
Printed constraint (optimized):
requires (_Cont o) { o.data(); }
Inferred constraint:


[-[replace_if:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20407:1
Printed constraint (original):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__sort3_maybe_branchless:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14327:1
Printed constraint (original):
(
 (
  (
   requires (_RandomAccessIterator x0) { *x0; }
  )
 ) &&
 (
  (
   requires (_RandomAccessIterator x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
requires (_RandomAccessIterator x0) { *x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[replace_if:_Predicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20407:1
Printed constraint (original):
(
 requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; }
)
Printed constraint (optimized):
requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; }
Inferred constraint:
UnaryFunction Predicate 

[-[reverse_copy:_BidirectionalIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20419:1
Printed constraint (original):
(
 requires (_BidirectionalIterator x0) { --x0; }
)
Printed constraint (optimized):
requires (_BidirectionalIterator x0) { --x0; }
Inferred constraint:
BidirectionalIterator RandomAccessIterator Float Integral 

[-[__stable_partition_impl:_Predicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19410:1
Printed constraint (original):
(
 (
  true
 ) &&
 requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
 true
)
Printed constraint (optimized):
requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; }
Inferred constraint:
UnaryFunction Predicate 

[-[__max_element:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12573:1
Printed constraint (original):
(
 requires (_Compare f, _ForwardIterator x0, _ForwardIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
)
Printed constraint (optimized):
requires (_Compare f, _ForwardIterator x0, _ForwardIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__swap_ranges:_ForwardIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:9326:1
Printed constraint (original):
(
 requires (_ForwardIterator1 x0) { ++x0; }
)
Printed constraint (optimized):
requires (_ForwardIterator1 x0) { ++x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[shift_right:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20467:1
Printed constraint (original):
(
 requires (_ForwardIterator x0) { *x0; } &&
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   ) &&
   (
    (
     (
      (
       (
        (
         (
          (true)
         ) &&
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   )
  )
 ) &&
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   ) &&
   (
    (
     (
      (
       (
        (
         (
          (true)
         ) &&
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   )
  )
 ) &&
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   ) &&
   (
    (
     (
      (
       (
        (
         (
          (true)
         ) &&
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   )
  )
 ) &&
 requires (_ForwardIterator x0) { ++x0; } &&
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (true)
         ) &&
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   )
  )
 ) &&
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (true)
         ) &&
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   )
  )
 ) &&
 requires (_ForwardIterator x0) { --x0; }
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0) { --x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[set_symmetric_difference:_InputIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19035:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (
           (
            (true)
           )
          ) ||
          (true)
         )
        )
       )
      )
     )
    )
   ) &&
   (
    (
     (
      (
       (
        (
         (
          (
           (
            (true)
           ) &&
           (
            (true)
           )
          ) ||
          (true)
         )
        )
       )
      )
     ) &&
     requires (_InputIterator2 x0) { ++x0; } &&
     requires (_InputIterator2 x0) { *x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator2 x0) { ++x0; } &&
 requires (_InputIterator2 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[set_difference:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18750:1
Printed constraint (original):
(
 (
  (
   requires (_Compare f, _InputIterator2 x0, _InputIterator1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
   requires (_Compare f, _InputIterator1 x0, _InputIterator2 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_Compare f, _InputIterator2 x0, _InputIterator1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 requires (_Compare f, _InputIterator1 x0, _InputIterator2 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
)
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[transform:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20529:1
Printed constraint (original):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[lexicographical_compare:_InputIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12459:1
Printed constraint (original):
(
 (
  (
   requires (_InputIterator2 x0) { *x0; } &&
   requires (_InputIterator2 x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator2 x0) { *x0; } &&
 requires (_InputIterator2 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[equal:_InputIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7639:1
Printed constraint (original):
(
 (
  (
   requires (_InputIterator2 x0) { *x0; } &&
   requires (_InputIterator2 x0) { ++x0; }
  ) ||
  (
   (
    (
     requires (_InputIterator2 x0) { *x0; } &&
     requires (_InputIterator2 x0) { ++x0; }
    )
   ) &&
   (
    (
     (
      (
       requires (_InputIterator2 x0) { ++x0; } &&
       requires (_InputIterator2 x0, _InputIterator2 x1) { x0 != x1; }
      ) ||
      (
       requires (_InputIterator2 x0, _InputIterator2 x1) { x0 - x1; }
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 (
  requires (_InputIterator2 x0) { *x0; } &&
  requires (_InputIterator2 x0) { ++x0; }
 ) ||
 (
  requires (_InputIterator2 x0) { *x0; } &&
  requires (_InputIterator2 x0) { ++x0; } &&
  (
   (
    requires (_InputIterator2 x0) { ++x0; } &&
    requires (_InputIterator2 x0, _InputIterator2 x1) { x0 != x1; }
   ) ||
   requires (_InputIterator2 x0, _InputIterator2 x1) { x0 - x1; }
  )
 )
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__stable_partition_impl:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19476:1
Printed constraint (original):
(
 (
  (
   (
    (true)
   ) &&
   (
    (
     (
      (
       (
        (
         requires (_ForwardIterator x0) { ++x0; }
        )
       ) &&
       (
        (
         requires (_ForwardIterator x0) { *x0; } &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         )
        )
       )
      ) ||
      (
       (
        (
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         requires (_ForwardIterator x0) { *x0; } &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         )
        )
       ) &&
       (
        (
         requires (_ForwardIterator x0) { ++x0; }
        )
       ) &&
       (
        (
         requires (_ForwardIterator x0) { *x0; } &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         )
        )
       )
      ) ||
      (
       (
        (
         requires (_ForwardIterator x0) { *x0; } &&
         true &&
         (
          (
           requires (_ForwardIterator x0) { ++x0; }
          )
         ) &&
         (
          (
           requires (_ForwardIterator x0) { ++x0; }
          )
         ) &&
         requires (_ForwardIterator x0) { --x0; } &&
         (
          (true)
         ) &&
         (
          (true)
         )
        )
       ) &&
       (
        (
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         requires (_ForwardIterator x0) { *x0; } &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         )
        )
       ) &&
       (
        (
         requires (_ForwardIterator x0) { ++x0; }
        )
       ) &&
       (
        (
         requires (_ForwardIterator x0) { *x0; } &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         )
        )
       )
      )
     )
    )
   ) &&
   (
    true
   ) &&
   requires (_ForwardIterator x0) { *x0; } &&
   requires (_ForwardIterator x0) { ++x0; }
  )
 ) &&
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0) { *x0; }
)
Printed constraint (optimized):
(
 (
  (
   requires (_ForwardIterator x0) { ++x0; } &&
   requires (_ForwardIterator x0) { *x0; }
  ) ||
  (
   requires (_ForwardIterator x0) { *x0; } &&
   requires (_ForwardIterator x0) { ++x0; }
  ) ||
  (
   requires (_ForwardIterator x0) { *x0; } &&
   requires (_ForwardIterator x0) { ++x0; } &&
   requires (_ForwardIterator x0) { --x0; }
  )
 ) &&
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__search_random_access_impl:_DiffT2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7837:1
Printed constraint (original):
(
 requires (_DiffT2 x0, int x1) { x0 - x1; }
)
Printed constraint (optimized):
requires (_DiffT2 x0, int x1) { x0 - x1; }
Inferred constraint:
RandomAccessIterator Float Integral 

[-[equal:_InputIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7607:1
Printed constraint (original):
(
 requires (_InputIterator2 x0) { *x0; } &&
 requires (_InputIterator2 x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator2 x0) { *x0; } &&
 requires (_InputIterator2 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[uninitialized_fill:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29815:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 (
  (
   (
    (
     requires (_ForwardIterator x0) { *x0; } &&
     requires (_ForwardIterator x0) { ++x0; }
    )
   ) &&
   requires (_ForwardIterator x0) { *x0; } &&
   requires (_ForwardIterator x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__merge_move_construct:_InputIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19680:1
Printed constraint (original):
(
 requires (_InputIterator2 x0) { *x0; } &&
 requires (_InputIterator2 x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator2 x0) { *x0; } &&
 requires (_InputIterator2 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__unique:_BinaryPredicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20061:1
Printed constraint (original):
(
 requires (_BinaryPredicate f, _Iter x0, _Iter x1) { f(*x0, *x1); } &&
 (
  (
   requires (_BinaryPredicate f, _Iter x0, _Iter x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_BinaryPredicate f, _Iter x0, _Iter x1) { f(*x0, *x1); } &&
 requires (_BinaryPredicate f, _Iter x0, _Iter x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
)
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[push_heap:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12964:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       requires (_RandomAccessIterator x0) { --x0; } &&
       requires (_RandomAccessIterator x0) { *x0; }
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[__uninitialized_allocator_move_if_noexcept:_Iter1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:30144:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   ) &&
   (
    (
     (
      (
       (
        (
         (
          (true)
         ) &&
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   )
  )
 ) &&
 requires (_Iter1 x0) { ++x0; } &&
 requires (_Iter1 x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_Iter1 x0) { ++x0; } &&
 requires (_Iter1 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__uninitialized_value_construct_n:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29905:1
Printed constraint (original):
(
 (
  (
   requires (_ForwardIterator x0) { *x0; } &&
   requires (_ForwardIterator x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[rbegin:_Cp]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29296:1
Printed constraint (original):
(
 requires (_Cp o) { o.rbegin(); }
)
Printed constraint (optimized):
requires (_Cp o) { o.rbegin(); }
Inferred constraint:


[-[__stable_partition_impl:_Pair]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19507:1
Printed constraint (original):
(
 (
  (
   requires (_Pair o) { o.first; } &&
   (
    true
   ) &&
   requires (_Pair o) { o.second; }
  ) ||
  true
 ) &&
 requires (_Pair o) { o.first; } &&
 requires (_Pair o) { o.second; }
)
Printed constraint (optimized):
(
 requires (_Pair o) { o.first; } &&
 requires (_Pair o) { o.second; }
)
Inferred constraint:


[-[partial_sort:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:13088:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (true)
     ) &&
     (
      (true)
     )
    )
   ) &&
   (
    (
     (
      (
       requires (_RandomAccessIterator x0) { ++x0; } &&
       (
        (
         (
          (
           requires (_RandomAccessIterator x0) { ++x0; } &&
           requires (_RandomAccessIterator x0) { --x0; } &&
           (
            (
             requires (_RandomAccessIterator x0) { --x0; } &&
             requires (_RandomAccessIterator x0) { *x0; }
            )
           ) &&
           requires (_RandomAccessIterator x0) { *x0; } &&
           (
            (
             requires (_RandomAccessIterator x0) { ++x0; } &&
             requires (_RandomAccessIterator x0) { *x0; } &&
             true
            )
           )
          )
         ) &&
         requires (_RandomAccessIterator x0) { --x0; }
        )
       ) &&
       (
        (
         requires (_RandomAccessIterator x0) { ++x0; } &&
         requires (_RandomAccessIterator x0) { *x0; }
        )
       ) &&
       requires (_RandomAccessIterator x0) { *x0; } &&
       (
        (
         (
          (
           requires (_RandomAccessIterator x0) { ++x0; } &&
           requires (_RandomAccessIterator x0) { *x0; }
          )
         )
        )
       )
      )
     ) &&
     (
      (true)
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Inferred constraint:
RandomAccessIterator 

[-[__stable_sort:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19805:1
Printed constraint (original):
(
 (
  true
 ) &&
 (
  (
   (
    (
     requires (_RandomAccessIterator x0) { *x0; } &&
     requires (_RandomAccessIterator x0) { ++x0; }
    )
   ) &&
   (
    (
     requires (_RandomAccessIterator x0) { *x0; } &&
     requires (_RandomAccessIterator x0) { ++x0; }
    )
   ) &&
   requires (_RandomAccessIterator x0) { *x0; } &&
   (
    (
     requires (_RandomAccessIterator x0) { *x0; } &&
     requires (_RandomAccessIterator x0) { ++x0; }
    )
   ) &&
   requires (_RandomAccessIterator x0) { --x0; }
  )
 ) &&
 (
  (
   requires (_RandomAccessIterator x0) { *x0; } &&
   requires (_RandomAccessIterator x0) { ++x0; }
  )
 ) &&
 (
  (
   (
    (true)
   ) &&
   (
    (
     (
      (
       (
        (
         requires (_RandomAccessIterator x0) { ++x0; }
        )
       ) &&
       (
        (
         requires (_RandomAccessIterator x0) { *x0; } &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         )
        )
       )
      ) ||
      (
       (
        (
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         requires (_RandomAccessIterator x0) { *x0; } &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         )
        )
       ) &&
       (
        (
         requires (_RandomAccessIterator x0) { ++x0; }
        )
       ) &&
       (
        (
         requires (_RandomAccessIterator x0) { *x0; } &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         )
        )
       )
      ) ||
      (
       (
        (
         requires (_RandomAccessIterator x0) { *x0; } &&
         true &&
         (
          (
           requires (_RandomAccessIterator x0) { ++x0; }
          )
         ) &&
         (
          (
           requires (_RandomAccessIterator x0) { ++x0; }
          )
         ) &&
         requires (_RandomAccessIterator x0) { --x0; } &&
         (
          (true)
         ) &&
         (
          (true)
         )
        )
       ) &&
       (
        (
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         requires (_RandomAccessIterator x0) { *x0; } &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         )
        )
       ) &&
       (
        (
         requires (_RandomAccessIterator x0) { ++x0; }
        )
       ) &&
       (
        (
         requires (_RandomAccessIterator x0) { *x0; } &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         )
        )
       )
      )
     )
    )
   ) &&
   (
    (true)
   ) &&
   (
    (true)
   ) &&
   (
    (
     (
      (true)
     ) &&
     (
      (
       requires (_RandomAccessIterator x0) { ++x0; } &&
       requires (_RandomAccessIterator x0) { *x0; }
      )
     ) &&
     requires (_RandomAccessIterator x0) { *x0; }
    )
   ) &&
   requires (_RandomAccessIterator x0) { *x0; } &&
   requires (_RandomAccessIterator x0) { ++x0; } &&
   (
    true
   ) &&
   (
    (
     (
      (
       requires (_RandomAccessIterator x0) { *x0; } &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       ) &&
       requires (_RandomAccessIterator x0) { ++x0; }
      )
     ) &&
     (
      (true)
     ) &&
     (
      (
       requires (_RandomAccessIterator x0) { ++x0; } &&
       requires (_RandomAccessIterator x0) { *x0; }
      )
     ) &&
     requires (_RandomAccessIterator x0) { ++x0; }
    )
   )
  )
 ) &&
 (
  (
   requires (_RandomAccessIterator x0) { --x0; } &&
   requires (_RandomAccessIterator x0) { *x0; } &&
   requires (_RandomAccessIterator x0) { ++x0; }
  )
 ) &&
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { --x0; }
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 (
  (
   requires (_RandomAccessIterator x0) { ++x0; } &&
   requires (_RandomAccessIterator x0) { *x0; }
  ) ||
  (
   requires (_RandomAccessIterator x0) { *x0; } &&
   requires (_RandomAccessIterator x0) { ++x0; }
  ) ||
  (
   requires (_RandomAccessIterator x0) { *x0; } &&
   requires (_RandomAccessIterator x0) { ++x0; } &&
   requires (_RandomAccessIterator x0) { --x0; }
  )
 )
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[__stable_partition_impl:_Pair]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19410:1
Printed constraint (original):
(
 requires (_Pair o) { o.first; } &&
 (
  true
 ) &&
 requires (_Pair o) { o.second; }
)
Printed constraint (optimized):
(
 requires (_Pair o) { o.first; } &&
 requires (_Pair o) { o.second; }
)
Inferred constraint:


[-[__sort_heap:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:13014:1
Printed constraint (original):
(
 (
  (
   requires (_RandomAccessIterator x0) { ++x0; } &&
   requires (_RandomAccessIterator x0) { --x0; } &&
   (
    (
     requires (_RandomAccessIterator x0) { --x0; } &&
     requires (_RandomAccessIterator x0) { *x0; }
    )
   ) &&
   requires (_RandomAccessIterator x0) { *x0; } &&
   (
    (
     requires (_RandomAccessIterator x0) { ++x0; } &&
     requires (_RandomAccessIterator x0) { *x0; } &&
     true
    )
   )
  )
 ) &&
 requires (_RandomAccessIterator x0) { --x0; }
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Inferred constraint:
RandomAccessIterator 

[-[__allocator_construct_at_multidimensional:_Tp]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29998:1
Printed constraint (original):
(
 (
  (
   requires (_Tp x0) { *x0; } &&
   requires (_Tp x0) { --x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_Tp x0) { *x0; } &&
 requires (_Tp x0) { --x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[rotate:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:9523:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 (
  (
   (
    (
     (
      (
       requires (_ForwardIterator x0) { ++x0; }
      )
     ) &&
     (
      (
       requires (_ForwardIterator x0) { *x0; } &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       ) &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       )
      )
     )
    ) ||
    (
     (
      (
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       ) &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       ) &&
       requires (_ForwardIterator x0) { *x0; } &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       )
      )
     ) &&
     (
      (
       requires (_ForwardIterator x0) { ++x0; }
      )
     ) &&
     (
      (
       requires (_ForwardIterator x0) { *x0; } &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       ) &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       )
      )
     )
    ) ||
    (
     (
      (
       requires (_ForwardIterator x0) { *x0; } &&
       true &&
       (
        (
         requires (_ForwardIterator x0) { ++x0; }
        )
       ) &&
       (
        (
         requires (_ForwardIterator x0) { ++x0; }
        )
       ) &&
       requires (_ForwardIterator x0) { --x0; } &&
       (
        (true)
       ) &&
       (
        (true)
       )
      )
     ) &&
     (
      (
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       ) &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       ) &&
       requires (_ForwardIterator x0) { *x0; } &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       )
      )
     ) &&
     (
      (
       requires (_ForwardIterator x0) { ++x0; }
      )
     ) &&
     (
      (
       requires (_ForwardIterator x0) { *x0; } &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       ) &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       )
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 (
  requires (_ForwardIterator x0) { ++x0; } &&
  requires (_ForwardIterator x0) { *x0; }
 ) ||
 (
  requires (_ForwardIterator x0) { *x0; } &&
  requires (_ForwardIterator x0) { ++x0; }
 ) ||
 (
  requires (_ForwardIterator x0) { *x0; } &&
  requires (_ForwardIterator x0) { ++x0; } &&
  requires (_ForwardIterator x0) { --x0; }
 )
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[uninitialized_fill_n:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29839:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_ForwardIterator x0) { *x0; } &&
     requires (_ForwardIterator x0) { ++x0; }
    )
   ) &&
   requires (_ForwardIterator x0) { *x0; } &&
   requires (_ForwardIterator x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[transform:_OutputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20538:1
Printed constraint (original):
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[partition_point:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:15137:1
Printed constraint (original):
(
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0) { *x0; } &&
 (
  (
   (
    (
     requires (_ForwardIterator x0) { ++x0; }
    ) ||
    (
     requires (_ForwardIterator x0) { --x0; } &&
     requires (_ForwardIterator x0) { ++x0; }
    ) ||
    (
     true
    )
   )
  )
 ) &&
 (
  (
   (
    (
     requires (_ForwardIterator x0) { ++x0; } &&
     requires (_ForwardIterator x0, _ForwardIterator x1) { x0 != x1; }
    ) ||
    (
     requires (_ForwardIterator x0, _ForwardIterator x1) { x0 - x1; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0) { *x0; } &&
 (
  (
   requires (_ForwardIterator x0) { ++x0; } &&
   requires (_ForwardIterator x0, _ForwardIterator x1) { x0 != x1; }
  ) ||
  requires (_ForwardIterator x0, _ForwardIterator x1) { x0 - x1; }
 )
)
Inferred constraint:
InputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[nth_element:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14918:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_RandomAccessIterator x0) { ++x0; } &&
     (
      (true)
     ) &&
     (
      (
       (
        (
         requires (_RandomAccessIterator x0) { *x0; } &&
         requires (_RandomAccessIterator x0) { --x0; }
        )
       ) &&
       (
        (
         (
          (
           (
            (true)
           )
          )
         ) &&
         requires (_RandomAccessIterator x0) { ++x0; } &&
         (
          (
           (
            (
             requires (_RandomAccessIterator x0) { *x0; } &&
             requires (_RandomAccessIterator x0) { ++x0; }
            )
           )
          )
         ) &&
         requires (_RandomAccessIterator x0) { --x0; }
        )
       ) &&
       (
        (
         requires (_RandomAccessIterator x0) { *x0; }
        )
       ) &&
       requires (_RandomAccessIterator x0) { ++x0; } &&
       requires (_RandomAccessIterator x0) { *x0; } &&
       requires (_RandomAccessIterator x0) { --x0; }
      )
     ) &&
     (
      (true)
     ) &&
     (
      (true)
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { --x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[sort:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14734:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        (true)
       ) &&
       (
        (true)
       )
      )
     ) &&
     (
      (
       (
        (
         requires (_RandomAccessIterator x0) { ++x0; } &&
         (
          (
           (
            (
             requires (_RandomAccessIterator x0) { ++x0; } &&
             requires (_RandomAccessIterator x0) { --x0; } &&
             (
              (
               requires (_RandomAccessIterator x0) { --x0; } &&
               requires (_RandomAccessIterator x0) { *x0; }
              )
             ) &&
             requires (_RandomAccessIterator x0) { *x0; } &&
             (
              (
               requires (_RandomAccessIterator x0) { ++x0; } &&
               requires (_RandomAccessIterator x0) { *x0; } &&
               true
              )
             )
            )
           ) &&
           requires (_RandomAccessIterator x0) { --x0; }
          )
         ) &&
         (
          (
           requires (_RandomAccessIterator x0) { ++x0; } &&
           requires (_RandomAccessIterator x0) { *x0; }
          )
         ) &&
         requires (_RandomAccessIterator x0) { *x0; } &&
         (
          (
           (
            (
             requires (_RandomAccessIterator x0) { ++x0; } &&
             requires (_RandomAccessIterator x0) { *x0; }
            )
           )
          )
         )
        )
       ) &&
       (
        (true)
       )
      )
     ) &&
     (
      (true)
     ) &&
     (
      (true)
     ) &&
     (
      (true)
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Inferred constraint:
RandomAccessIterator 

[-[ssize:_Cont]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29344:1
Printed constraint (original):
(
 requires (_Cont o) { o.size(); }
)
Printed constraint (optimized):
requires (_Cont o) { o.size(); }
Inferred constraint:


[-[nth_element:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14912:1
Printed constraint (original):
(
 (
  (
   requires (_RandomAccessIterator x0) { ++x0; } &&
   (
    (true)
   ) &&
   (
    (
     (
      (
       requires (_RandomAccessIterator x0) { *x0; } &&
       requires (_RandomAccessIterator x0) { --x0; }
      )
     ) &&
     (
      (
       (
        (
         (
          (true)
         )
        )
       ) &&
       requires (_RandomAccessIterator x0) { ++x0; } &&
       (
        (
         (
          (
           requires (_RandomAccessIterator x0) { *x0; } &&
           requires (_RandomAccessIterator x0) { ++x0; }
          )
         )
        )
       ) &&
       requires (_RandomAccessIterator x0) { --x0; }
      )
     ) &&
     (
      (
       requires (_RandomAccessIterator x0) { *x0; }
      )
     ) &&
     requires (_RandomAccessIterator x0) { ++x0; } &&
     requires (_RandomAccessIterator x0) { *x0; } &&
     requires (_RandomAccessIterator x0) { --x0; }
    )
   ) &&
   (
    (true)
   ) &&
   (
    (true)
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { --x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[__nth_element_impl:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14899:1
Printed constraint (original):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 (
  (true)
 ) &&
 (
  (
   (
    (
     requires (_RandomAccessIterator x0) { *x0; } &&
     requires (_RandomAccessIterator x0) { --x0; }
    )
   ) &&
   (
    (
     (
      (
       (
        (true)
       )
      )
     ) &&
     requires (_RandomAccessIterator x0) { ++x0; } &&
     (
      (
       (
        (
         requires (_RandomAccessIterator x0) { *x0; } &&
         requires (_RandomAccessIterator x0) { ++x0; }
        )
       )
      )
     ) &&
     requires (_RandomAccessIterator x0) { --x0; }
    )
   ) &&
   (
    (
     requires (_RandomAccessIterator x0) { *x0; }
    )
   ) &&
   requires (_RandomAccessIterator x0) { ++x0; } &&
   requires (_RandomAccessIterator x0) { *x0; } &&
   requires (_RandomAccessIterator x0) { --x0; }
  )
 ) &&
 (
  (true)
 ) &&
 (
  (true)
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { --x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[__set_symmetric_difference:_InIter1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18990:1
Printed constraint (original):
(
 requires (_InIter1 x0) { ++x0; } &&
 requires (_InIter1 x0) { *x0; } &&
 (
  (
   (
    (
     (
      (
       (
        (true)
       ) &&
       (
        (true)
       )
      ) ||
      (true)
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_InIter1 x0) { ++x0; } &&
 requires (_InIter1 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[max_element:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12588:1
Printed constraint (original):
(
 (
  (
   requires (_ForwardIterator x0) { *x0; } &&
   requires (_ForwardIterator x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__nth_element_find_guard:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14741:1
Printed constraint (original):
(
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { --x0; }
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { --x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[uninitialized_move:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29940:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 (
  (
   requires (_InputIterator x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
requires (_InputIterator x0) { ++x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[set_union:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19160:1
Printed constraint (original):
(
 (
  (
   requires (_Compare f, _InputIterator1 x0, _InputIterator2 x1) { f(*x0, *x1); } &&
   requires (_Compare f, _InputIterator2 x0, _InputIterator1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_Compare f, _InputIterator1 x0, _InputIterator2 x1) { f(*x0, *x1); } &&
 requires (_Compare f, _InputIterator2 x0, _InputIterator1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
)
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[generate_n:_OutputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:8967:1
Printed constraint (original):
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[uninitialized_default_construct_n:_Size]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29879:1
Printed constraint (original):
(
 (
  (
   requires (_Size x0) { --x0; }
  )
 )
)
Printed constraint (optimized):
requires (_Size x0) { --x0; }
Inferred constraint:
BidirectionalIterator RandomAccessIterator Float Integral 

[-[__half_inplace_merge:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12004:1
Printed constraint (original):
(
 requires (_Compare f, _InputIterator2 x0, _InputIterator1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
)
Printed constraint (optimized):
requires (_Compare f, _InputIterator2 x0, _InputIterator1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__libcpp_thread_poll_with_backoff:_Fn]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:21560:1
Printed constraint (original):
(
 requires (_Fn f) { {f()} -> std::convertible_to<bool>; }
)
Printed constraint (optimized):
requires (_Fn f) { {f()} -> std::convertible_to<bool>; }
Inferred constraint:


[-[uninitialized_copy_n:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29790:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_ForwardIterator x0) { *x0; } &&
     requires (_ForwardIterator x0) { ++x0; }
    )
   ) &&
   requires (_ForwardIterator x0) { *x0; } &&
   requires (_ForwardIterator x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__search_impl:_Iter2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7905:1
Printed constraint (original):
(
 (
  (
   requires (_Iter2 x0) { ++x0; } &&
   requires (_Iter2 x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_Iter2 x0) { ++x0; } &&
 requires (_Iter2 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__replace_if_impl:_Iter]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:17737:1
Printed constraint (original):
(
 requires (_Iter x0) { *x0; } &&
 requires (_Iter x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_Iter x0) { *x0; } &&
 requires (_Iter x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__search_forward_impl:_Iter2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7797:1
Printed constraint (original):
(
 requires (_Iter2 x0) { ++x0; } &&
 requires (_Iter2 x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_Iter2 x0) { ++x0; } &&
 requires (_Iter2 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__set_intersection:_OutIter]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18850:1
Printed constraint (original):
(
 requires (_OutIter x0) { ++x0; } &&
 requires (_OutIter x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_OutIter x0) { ++x0; } &&
 requires (_OutIter x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__partial_sort_impl:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:13045:1
Printed constraint (original):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 (
  (
   (
    (
     requires (_RandomAccessIterator x0) { ++x0; } &&
     requires (_RandomAccessIterator x0) { --x0; } &&
     (
      (
       requires (_RandomAccessIterator x0) { --x0; } &&
       requires (_RandomAccessIterator x0) { *x0; }
      )
     ) &&
     requires (_RandomAccessIterator x0) { *x0; } &&
     (
      (
       requires (_RandomAccessIterator x0) { ++x0; } &&
       requires (_RandomAccessIterator x0) { *x0; } &&
       true
      )
     )
    )
   ) &&
   requires (_RandomAccessIterator x0) { --x0; }
  )
 ) &&
 (
  (
   requires (_RandomAccessIterator x0) { ++x0; } &&
   requires (_RandomAccessIterator x0) { *x0; }
  )
 ) &&
 requires (_RandomAccessIterator x0) { *x0; } &&
 (
  (
   (
    (
     requires (_RandomAccessIterator x0) { ++x0; } &&
     requires (_RandomAccessIterator x0) { *x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Inferred constraint:
RandomAccessIterator 

[-[count_if:_Predicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7595:1
Printed constraint (original):
(
 requires (_Predicate f, _InputIterator x0) { {f(*x0)} -> std::convertible_to<bool>; }
)
Printed constraint (optimized):
requires (_Predicate f, _InputIterator x0) { {f(*x0)} -> std::convertible_to<bool>; }
Inferred constraint:
UnaryFunction Predicate 

[-[__lerp:_Fp]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:24984:1
Printed constraint (original):
(
 true &&
 true &&
 requires (_Fp x0, _Fp x1) { x0 * x1; }
)
Printed constraint (optimized):
requires (_Fp x0, _Fp x1) { x0 * x1; }
Inferred constraint:
Float Integral 

[-[max_element:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12594:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_ForwardIterator x0) { *x0; } &&
     requires (_ForwardIterator x0) { ++x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__pop_heap:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12972:1
Printed constraint (original):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 (
  (
   requires (_RandomAccessIterator x0) { --x0; } &&
   requires (_RandomAccessIterator x0) { *x0; }
  )
 ) &&
 requires (_RandomAccessIterator x0) { *x0; } &&
 (
  (
   requires (_RandomAccessIterator x0) { ++x0; } &&
   requires (_RandomAccessIterator x0) { *x0; } &&
   true
  )
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Inferred constraint:
RandomAccessIterator 

[-[fpclassify:_A1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:23754:1
Printed constraint (original):
(
 requires (_A1 x0, int x1) { x0 == x1; }
)
Printed constraint (optimized):
requires (_A1 x0, int x1) { x0 == x1; }
Inferred constraint:
InputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[__adjacent_find:_Sent]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:5721:1
Printed constraint (original):
(
 requires (_Sent x0, _Iter x1) { ++x1 != x0; } &&
 requires (_Sent x0, _Iter x1) { x1 == x0; }
)
Printed constraint (optimized):
(
 requires (_Sent x0, _Iter x1) { ++x1 != x0; } &&
 requires (_Sent x0, _Iter x1) { x1 == x0; }
)
Inferred constraint:
InputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[unique_copy:_OutputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20183:1
Printed constraint (original):
(
 (
  (
   requires (_OutputIterator x0) { ++x0; } &&
   requires (_OutputIterator x0) { *x0; }
  ) ||
  (
   requires (_OutputIterator x0) { ++x0; } &&
   requires (_OutputIterator x0) { *x0; }
  ) ||
  (
   requires (_OutputIterator x0) { ++x0; } &&
   requires (_OutputIterator x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__uninitialized_allocator_fill_n_multidimensional:_Size]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:30043:1
Printed constraint (original):
(
 requires (_Size x0) { --x0; }
)
Printed constraint (optimized):
requires (_Size x0) { --x0; }
Inferred constraint:
BidirectionalIterator RandomAccessIterator Float Integral 

[-[__unique_copy:_OutputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20146:1
Printed constraint (original):
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__sift_down:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12482:1
Printed constraint (original):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__merge_move_assign:_OutputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19720:1
Printed constraint (original):
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__lexicographical_compare:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12445:1
Printed constraint (original):
(
 requires (_Compare f, _InputIterator2 x0, _InputIterator1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 requires (_Compare f, _InputIterator1 x0, _InputIterator2 x1) { f(*x0, *x1); }
)
Printed constraint (optimized):
(
 requires (_Compare f, _InputIterator2 x0, _InputIterator1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 requires (_Compare f, _InputIterator1 x0, _InputIterator2 x1) { f(*x0, *x1); }
)
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__advance:_InputIter]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:4826:1
Printed constraint (original):
(
 requires (_InputIter x0) { ++x0; }
)
Printed constraint (optimized):
requires (_InputIter x0) { ++x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[set_difference:_OutputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18750:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (true)
         ) &&
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   ) &&
   requires (_OutputIterator x0) { ++x0; } &&
   requires (_OutputIterator x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[size:_Cont]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29335:1
Printed constraint (original):
(
 requires (_Cont o) { o.size(); }
)
Printed constraint (optimized):
requires (_Cont o) { o.size(); }
Inferred constraint:


[-[mismatch:_BinaryPredicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12818:1
Printed constraint (original):
(
 requires (_BinaryPredicate f, _InputIterator1 x0, _InputIterator2 x1) { f(*x0, *x1); }
)
Printed constraint (optimized):
requires (_BinaryPredicate f, _InputIterator1 x0, _InputIterator2 x1) { f(*x0, *x1); }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[signbit:_A1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:23742:1
Printed constraint (original):
(
 requires (_A1 x0, int x1) { x0 < x1; }
)
Printed constraint (optimized):
requires (_A1 x0, int x1) { x0 < x1; }
Inferred constraint:
RandomAccessIterator Float Integral 

[-[__unique:_Iter]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20061:1
Printed constraint (original):
(
 requires (_Iter x0) { *x0; } &&
 requires (_Iter x0) { ++x0; } &&
 (
  (
   requires (_Iter x0) { *x0; } &&
   requires (_Iter x0) { ++x0; } &&
   requires (_Iter x0, _Sent x1) { x0 == x1; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_Iter x0) { *x0; } &&
 requires (_Iter x0) { ++x0; } &&
 requires (_Iter x0, _Sent x1) { x0 == x1; }
)
Inferred constraint:
InputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__cxx_atomic_wait:_Fn]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:22454:1
Printed constraint (original):
(
 (
  (
   requires (_Fn f) { {f()} -> std::convertible_to<bool>; }
  )
 )
)
Printed constraint (optimized):
requires (_Fn f) { {f()} -> std::convertible_to<bool>; }
Inferred constraint:


[-[__insertion_sort:_BidirectionalIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14384:1
Printed constraint (original):
(
 requires (_BidirectionalIterator x0) { --x0; } &&
 requires (_BidirectionalIterator x0) { *x0; } &&
 requires (_BidirectionalIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_BidirectionalIterator x0) { --x0; } &&
 requires (_BidirectionalIterator x0) { *x0; } &&
 requires (_BidirectionalIterator x0) { ++x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[mismatch:_InputIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12818:1
Printed constraint (original):
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[generate_n:_Generator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:8967:1
Printed constraint (original):
(
 requires (_Generator f) { f(); }
)
Printed constraint (optimized):
requires (_Generator f) { f(); }
Inferred constraint:


[-[__uninitialized_move:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29924:1
Printed constraint (original):
(
 (
  (
   requires (_ForwardIterator x0) { *x0; } &&
   requires (_ForwardIterator x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__allocator_destroy:_Iter]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:30067:1
Printed constraint (original):
(
 requires (_Iter x0) { ++x0; }
)
Printed constraint (optimized):
requires (_Iter x0) { ++x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[__uninitialized_move:_IterMove]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29924:1
Printed constraint (original):
(
 requires (_IterMove f, _InputIterator x0) { f(x0); }
)
Printed constraint (optimized):
requires (_IterMove f, _InputIterator x0) { f(x0); }
Inferred constraint:
UnaryFunction Predicate 

[-[uninitialized_move_n:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29963:1
Printed constraint (original):
(
 (
  (
   requires (_InputIterator x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
requires (_InputIterator x0) { ++x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[__unique_copy:_BinaryPredicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20146:1
Printed constraint (original):
(
 requires (_BinaryPredicate f, _ForwardIterator x0, _ForwardIterator x1) { f(*x0, *x1); }
)
Printed constraint (optimized):
requires (_BinaryPredicate f, _ForwardIterator x0, _ForwardIterator x1) { f(*x0, *x1); }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[begin:_Cp]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:10984:1
Printed constraint (original):
(
 requires (_Cp o) { o.begin(); }
)
Printed constraint (optimized):
requires (_Cp o) { o.begin(); }
Inferred constraint:


[-[__uninitialized_default_construct_n:_Size]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29866:1
Printed constraint (original):
(
 requires (_Size x0) { --x0; }
)
Printed constraint (optimized):
requires (_Size x0) { --x0; }
Inferred constraint:
BidirectionalIterator RandomAccessIterator Float Integral 

[-[__merge_move_assign:_InputIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19720:1
Printed constraint (original):
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[fill_n:_OutputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7753:1
Printed constraint (original):
(
 (
  (
   requires (_OutputIterator x0) { *x0; } &&
   requires (_OutputIterator x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[empty:_Cont]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:28757:1
Printed constraint (original):
(
 requires (_Cont o) { o.empty(); }
)
Printed constraint (optimized):
requires (_Cont o) { o.empty(); }
Inferred constraint:


[-[__stable_sort:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19805:1
Printed constraint (original):
(
 (
  (
   true
  )
 ) &&
 (
  (
   (
    (
     (
      (true)
     )
    )
   ) &&
   (
    (true)
   ) &&
   requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
   (
    true
   ) &&
   (
    (
     (
      (
       true
      )
     )
    )
   )
  )
 ) &&
 (
  (
   true
  )
 ) &&
 (
  true
 ) &&
 (
  (
   (
    (
     requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
    )
   ) &&
   (
    (
     true &&
     true
    )
   ) &&
   true
  )
 ) &&
 true
)
Printed constraint (optimized):
requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__sort4:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14236:1
Printed constraint (original):
(
 requires (_ForwardIterator x0) { *x0; } &&
 (
  (
   requires (_ForwardIterator x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
requires (_ForwardIterator x0) { *x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__reverse_impl:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12849:1
Printed constraint (original):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; }
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator Float Integral 

[-[__reverse_impl:_BidirectionalIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12836:1
Printed constraint (original):
(
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { --x0; }
)
Printed constraint (optimized):
(
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { --x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator Float Integral 

[-[__distance:_InputIter]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:5408:1
Printed constraint (original):
(
 requires (_InputIter x0) { ++x0; } &&
 requires (_InputIter x0, _InputIter x1) { x0 != x1; }
)
Printed constraint (optimized):
(
 requires (_InputIter x0) { ++x0; } &&
 requires (_InputIter x0, _InputIter x1) { x0 != x1; }
)
Inferred constraint:
InputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[__uninitialized_copy:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29753:1
Printed constraint (original):
(
 (
  (
   requires (_ForwardIterator x0) { *x0; } &&
   requires (_ForwardIterator x0) { ++x0; }
  )
 ) &&
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__stable_partition_impl:_Predicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19476:1
Printed constraint (original):
(
 (
  (
   (
    true
   ) &&
   requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
   true
  )
 ) &&
 requires (_Predicate f, _ForwardIterator x0) { f(*x0); }
)
Printed constraint (optimized):
(
 requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
 requires (_Predicate f, _ForwardIterator x0) { f(*x0); }
)
Inferred constraint:
UnaryFunction Predicate 

[-[__unique_copy:_InputAndOutputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20167:1
Printed constraint (original):
(
 requires (_InputAndOutputIterator x0) { ++x0; } &&
 requires (_InputAndOutputIterator x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_InputAndOutputIterator x0) { ++x0; } &&
 requires (_InputAndOutputIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[find_first_of:_ForwardIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:8899:1
Printed constraint (original):
(
 (
  (
   requires (_ForwardIterator1 x0) { *x0; } &&
   requires (_ForwardIterator1 x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator1 x0) { *x0; } &&
 requires (_ForwardIterator1 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[all_of:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:5746:1
Printed constraint (original):
(
 requires (_InputIterator x0) { ++x0; } &&
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0, _InputIterator x1) { x0 != x1; }
)
Printed constraint (optimized):
(
 requires (_InputIterator x0) { ++x0; } &&
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0, _InputIterator x1) { x0 != x1; }
)
Inferred constraint:
InputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__libcpp_erase_if_container:_Container]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:28771:1
Printed constraint (original):
(
 true &&
 requires (_Container o) { o.begin(); } &&
 requires (_Container o) { o.end(); } &&
 requires (_Container o) { o.size(); }
)
Printed constraint (optimized):
(
 requires (_Container o) { o.begin(); } &&
 requires (_Container o) { o.end(); } &&
 requires (_Container o) { o.size(); }
)
Inferred constraint:


[-[uninitialized_value_construct_n:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29918:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_ForwardIterator x0) { *x0; } &&
     requires (_ForwardIterator x0) { ++x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[find:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7787:1
Printed constraint (original):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__uninitialized_move_n:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29949:1
Printed constraint (original):
(
 requires (_InputIterator x0) { ++x0; }
)
Printed constraint (optimized):
requires (_InputIterator x0) { ++x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[__is_permutation:_Iter1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12334:1
Printed constraint (original):
(
 (
  (
   (
    (true)
   ) &&
   requires (_Iter1 x0) { ++x0; } &&
   requires (_Iter1 x0) { *x0; }
  ) ||
  true
 ) &&
 (
  (
   (
    (
     requires (_Sent1 x0) { ++x0; } &&
     requires (_Sent1 x0, _Sent1 x1) { x0 != x1; }
    ) ||
    (
     requires (_Sent1 x0, _Sent1 x1) { x0 - x1; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 (
  requires (_Sent1 x0) { ++x0; } &&
  requires (_Sent1 x0, _Sent1 x1) { x0 != x1; }
 ) ||
 requires (_Sent1 x0, _Sent1 x1) { x0 - x1; }
)
Inferred constraint:
InputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[__uninitialized_move:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29924:1
Printed constraint (original):
(
 requires (_InputIterator x0) { ++x0; }
)
Printed constraint (optimized):
requires (_InputIterator x0) { ++x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[__next_permutation:_BidirectionalIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12873:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_BidirectionalIterator x0) { ++x0; } &&
     requires (_BidirectionalIterator x0) { --x0; }
    ) ||
    (
     requires (_BidirectionalIterator x0) { ++x0; } &&
     requires (_BidirectionalIterator x0) { --x0; }
    )
   )
  )
 ) &&
 requires (_BidirectionalIterator x0) { *x0; } &&
 (
  (
   (
    (
     requires (_BidirectionalIterator x0) { ++x0; } &&
     requires (_BidirectionalIterator x0) { --x0; }
    ) ||
    (
     requires (_BidirectionalIterator x0) { ++x0; } &&
     requires (_BidirectionalIterator x0) { --x0; }
    )
   )
  )
 ) &&
 requires (_BidirectionalIterator x0) { --x0; }
)
Printed constraint (optimized):
(
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { --x0; } &&
 requires (_BidirectionalIterator x0) { *x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[is_heap_until:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12199:1
Printed constraint (original):
(
 (
  (
   requires (_RandomAccessIterator x0) { ++x0; } &&
   requires (_RandomAccessIterator x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[find_if:_Predicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:8912:1
Printed constraint (original):
(
 requires (_Predicate f, _InputIterator x0) { {f(*x0)} -> std::convertible_to<bool>; }
)
Printed constraint (optimized):
requires (_Predicate f, _InputIterator x0) { {f(*x0)} -> std::convertible_to<bool>; }
Inferred constraint:
UnaryFunction Predicate 

[-[__sort4_maybe_branchless:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14340:1
Printed constraint (original):
(
 (
  (
   requires (_RandomAccessIterator x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
requires (_RandomAccessIterator x0) { *x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__inplace_merge:_BidirectionalIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12137:1
Printed constraint (original):
(
 (
  (
   (
    (true)
   ) &&
   (
    (
     (
      (
       (
        (
         requires (_BidirectionalIterator x0) { ++x0; }
        )
       ) &&
       (
        (
         requires (_BidirectionalIterator x0) { *x0; } &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         )
        )
       )
      ) ||
      (
       (
        (
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         requires (_BidirectionalIterator x0) { *x0; } &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         )
        )
       ) &&
       (
        (
         requires (_BidirectionalIterator x0) { ++x0; }
        )
       ) &&
       (
        (
         requires (_BidirectionalIterator x0) { *x0; } &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         )
        )
       )
      ) ||
      (
       (
        (
         requires (_BidirectionalIterator x0) { *x0; } &&
         true &&
         (
          (
           requires (_BidirectionalIterator x0) { ++x0; }
          )
         ) &&
         (
          (
           requires (_BidirectionalIterator x0) { ++x0; }
          )
         ) &&
         requires (_BidirectionalIterator x0) { --x0; } &&
         (
          (true)
         ) &&
         (
          (true)
         )
        )
       ) &&
       (
        (
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         requires (_BidirectionalIterator x0) { *x0; } &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         )
        )
       ) &&
       (
        (
         requires (_BidirectionalIterator x0) { ++x0; }
        )
       ) &&
       (
        (
         requires (_BidirectionalIterator x0) { *x0; } &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         )
        )
       )
      )
     )
    )
   ) &&
   (
    (true)
   ) &&
   (
    (true)
   ) &&
   (
    (
     (
      (true)
     ) &&
     (
      (
       requires (_BidirectionalIterator x0) { ++x0; } &&
       requires (_BidirectionalIterator x0) { *x0; }
      )
     ) &&
     requires (_BidirectionalIterator x0) { *x0; }
    )
   ) &&
   requires (_BidirectionalIterator x0) { *x0; } &&
   requires (_BidirectionalIterator x0) { ++x0; } &&
   (
    true
   ) &&
   (
    (
     (
      (
       requires (_BidirectionalIterator x0) { *x0; } &&
       (
        (
         (
          (
           (
            (
             (
              (true)
             ) &&
             (
              (true)
             )
            ) ||
            (true)
           )
          )
         )
        )
       ) &&
       requires (_BidirectionalIterator x0) { ++x0; }
      )
     ) &&
     (
      (true)
     ) &&
     (
      (
       requires (_BidirectionalIterator x0) { ++x0; } &&
       requires (_BidirectionalIterator x0) { *x0; }
      )
     ) &&
     requires (_BidirectionalIterator x0) { ++x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 (
  (
   requires (_BidirectionalIterator x0) { ++x0; } &&
   requires (_BidirectionalIterator x0) { *x0; }
  ) ||
  (
   requires (_BidirectionalIterator x0) { *x0; } &&
   requires (_BidirectionalIterator x0) { ++x0; }
  ) ||
  (
   requires (_BidirectionalIterator x0) { *x0; } &&
   requires (_BidirectionalIterator x0) { ++x0; } &&
   requires (_BidirectionalIterator x0) { --x0; }
  )
 ) &&
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__cond_swap:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14308:1
Printed constraint (original):
(
 requires (_RandomAccessIterator x0) { *x0; }
)
Printed constraint (optimized):
requires (_RandomAccessIterator x0) { *x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[remove_if:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20345:1
Printed constraint (original):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; } &&
 (
  (
   requires (_ForwardIterator x0) { *x0; } &&
   requires (_ForwardIterator x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[partition_copy:_Predicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:15113:1
Printed constraint (original):
(
 requires (_Predicate f, _InputIterator x0) { {f(*x0)} -> std::convertible_to<bool>; }
)
Printed constraint (optimized):
requires (_Predicate f, _InputIterator x0) { {f(*x0)} -> std::convertible_to<bool>; }
Inferred constraint:
UnaryFunction Predicate 

[-[sort:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14729:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (true)
     ) &&
     (
      (true)
     )
    )
   ) &&
   (
    (
     (
      (
       requires (_RandomAccessIterator x0) { ++x0; } &&
       (
        (
         (
          (
           requires (_RandomAccessIterator x0) { ++x0; } &&
           requires (_RandomAccessIterator x0) { --x0; } &&
           (
            (
             requires (_RandomAccessIterator x0) { --x0; } &&
             requires (_RandomAccessIterator x0) { *x0; }
            )
           ) &&
           requires (_RandomAccessIterator x0) { *x0; } &&
           (
            (
             requires (_RandomAccessIterator x0) { ++x0; } &&
             requires (_RandomAccessIterator x0) { *x0; } &&
             true
            )
           )
          )
         ) &&
         requires (_RandomAccessIterator x0) { --x0; }
        )
       ) &&
       (
        (
         requires (_RandomAccessIterator x0) { ++x0; } &&
         requires (_RandomAccessIterator x0) { *x0; }
        )
       ) &&
       requires (_RandomAccessIterator x0) { *x0; } &&
       (
        (
         (
          (
           requires (_RandomAccessIterator x0) { ++x0; } &&
           requires (_RandomAccessIterator x0) { *x0; }
          )
         )
        )
       )
      )
     ) &&
     (
      (true)
     )
    )
   ) &&
   (
    (true)
   ) &&
   (
    (true)
   ) &&
   (
    (true)
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Inferred constraint:
RandomAccessIterator 

[-[stable_sort:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19869:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        true
       ) &&
       (
        (
         (
          (
           requires (_RandomAccessIterator x0) { *x0; } &&
           requires (_RandomAccessIterator x0) { ++x0; }
          )
         ) &&
         (
          (
           requires (_RandomAccessIterator x0) { *x0; } &&
           requires (_RandomAccessIterator x0) { ++x0; }
          )
         ) &&
         requires (_RandomAccessIterator x0) { *x0; } &&
         (
          (
           requires (_RandomAccessIterator x0) { *x0; } &&
           requires (_RandomAccessIterator x0) { ++x0; }
          )
         ) &&
         requires (_RandomAccessIterator x0) { --x0; }
        )
       ) &&
       (
        (
         requires (_RandomAccessIterator x0) { *x0; } &&
         requires (_RandomAccessIterator x0) { ++x0; }
        )
       ) &&
       (
        (
         (
          (true)
         ) &&
         (
          (
           (
            (
             (
              (
               requires (_RandomAccessIterator x0) { ++x0; }
              )
             ) &&
             (
              (
               requires (_RandomAccessIterator x0) { *x0; } &&
               (
                (
                 (
                  (
                   (
                    (
                     (
                      (true)
                     ) &&
                     (
                      (true)
                     )
                    ) ||
                    (true)
                   )
                  )
                 )
                )
               ) &&
               (
                (
                 (
                  (
                   (
                    (
                     (
                      (true)
                     )
                    ) ||
                    (true)
                   )
                  )
                 )
                )
               )
              )
             )
            ) ||
            (
             (
              (
               (
                (
                 (
                  (
                   (
                    (
                     (
                      (true)
                     ) &&
                     (
                      (true)
                     )
                    ) ||
                    (true)
                   )
                  )
                 )
                )
               ) &&
               (
                (
                 (
                  (
                   (
                    (
                     (
                      (true)
                     )
                    ) ||
                    (true)
                   )
                  )
                 )
                )
               ) &&
               requires (_RandomAccessIterator x0) { *x0; } &&
               (
                (
                 (
                  (
                   (
                    (
                     (
                      (true)
                     ) &&
                     (
                      (true)
                     )
                    ) ||
                    (true)
                   )
                  )
                 )
                )
               )
              )
             ) &&
             (
              (
               requires (_RandomAccessIterator x0) { ++x0; }
              )
             ) &&
             (
              (
               requires (_RandomAccessIterator x0) { *x0; } &&
               (
                (
                 (
                  (
                   (
                    (
                     (
                      (true)
                     ) &&
                     (
                      (true)
                     )
                    ) ||
                    (true)
                   )
                  )
                 )
                )
               ) &&
               (
                (
                 (
                  (
                   (
                    (
                     (
                      (true)
                     )
                    ) ||
                    (true)
                   )
                  )
                 )
                )
               )
              )
             )
            ) ||
            (
             (
              (
               requires (_RandomAccessIterator x0) { *x0; } &&
               true &&
               (
                (
                 requires (_RandomAccessIterator x0) { ++x0; }
                )
               ) &&
               (
                (
                 requires (_RandomAccessIterator x0) { ++x0; }
                )
               ) &&
               requires (_RandomAccessIterator x0) { --x0; } &&
               (
                (true)
               ) &&
               (
                (true)
               )
              )
             ) &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (
                     (
                      (true)
                     ) &&
                     (
                      (true)
                     )
                    ) ||
                    (true)
                   )
                  )
                 )
                )
               ) &&
               (
                (
                 (
                  (
                   (
                    (
                     (
                      (true)
                     )
                    ) ||
                    (true)
                   )
                  )
                 )
                )
               ) &&
               requires (_RandomAccessIterator x0) { *x0; } &&
               (
                (
                 (
                  (
                   (
                    (
                     (
                      (true)
                     ) &&
                     (
                      (true)
                     )
                    ) ||
                    (true)
                   )
                  )
                 )
                )
               )
              )
             ) &&
             (
              (
               requires (_RandomAccessIterator x0) { ++x0; }
              )
             ) &&
             (
              (
               requires (_RandomAccessIterator x0) { *x0; } &&
               (
                (
                 (
                  (
                   (
                    (
                     (
                      (true)
                     ) &&
                     (
                      (true)
                     )
                    ) ||
                    (true)
                   )
                  )
                 )
                )
               ) &&
               (
                (
                 (
                  (
                   (
                    (
                     (
                      (true)
                     )
                    ) ||
                    (true)
                   )
                  )
                 )
                )
               )
              )
             )
            )
           )
          )
         ) &&
         (
          (true)
         ) &&
         (
          (true)
         ) &&
         (
          (
           (
            (true)
           ) &&
           (
            (
             requires (_RandomAccessIterator x0) { ++x0; } &&
             requires (_RandomAccessIterator x0) { *x0; }
            )
           ) &&
           requires (_RandomAccessIterator x0) { *x0; }
          )
         ) &&
         requires (_RandomAccessIterator x0) { *x0; } &&
         requires (_RandomAccessIterator x0) { ++x0; } &&
         (
          true
         ) &&
         (
          (
           (
            (
             requires (_RandomAccessIterator x0) { *x0; } &&
             (
              (
               (
                (
                 (
                  (
                   (
                    (true)
                   ) &&
                   (
                    (true)
                   )
                  ) ||
                  (true)
                 )
                )
               )
              )
             ) &&
             requires (_RandomAccessIterator x0) { ++x0; }
            )
           ) &&
           (
            (true)
           ) &&
           (
            (
             requires (_RandomAccessIterator x0) { ++x0; } &&
             requires (_RandomAccessIterator x0) { *x0; }
            )
           ) &&
           requires (_RandomAccessIterator x0) { ++x0; }
          )
         )
        )
       ) &&
       (
        (
         requires (_RandomAccessIterator x0) { --x0; } &&
         requires (_RandomAccessIterator x0) { *x0; } &&
         requires (_RandomAccessIterator x0) { ++x0; }
        )
       ) &&
       requires (_RandomAccessIterator x0) { *x0; } &&
       requires (_RandomAccessIterator x0) { --x0; }
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 (
  (
   requires (_RandomAccessIterator x0) { ++x0; } &&
   requires (_RandomAccessIterator x0) { *x0; }
  ) ||
  (
   requires (_RandomAccessIterator x0) { *x0; } &&
   requires (_RandomAccessIterator x0) { ++x0; }
  ) ||
  (
   requires (_RandomAccessIterator x0) { *x0; } &&
   requires (_RandomAccessIterator x0) { ++x0; } &&
   requires (_RandomAccessIterator x0) { --x0; }
  )
 )
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[__buffered_inplace_merge:_BidirectionalIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12030:1
Printed constraint (original):
(
 (
  (
   requires (_BidirectionalIterator x0) { *x0; } &&
   (
    (
     (
      (
       (
        (
         (
          (true)
         ) &&
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   ) &&
   requires (_BidirectionalIterator x0) { ++x0; }
  )
 ) &&
 (
  (true)
 ) &&
 (
  (
   requires (_BidirectionalIterator x0) { ++x0; } &&
   requires (_BidirectionalIterator x0) { *x0; }
  )
 ) &&
 requires (_BidirectionalIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_BidirectionalIterator x0) { *x0; } &&
 requires (_BidirectionalIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__set_symmetric_difference:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18990:1
Printed constraint (original):
(
 requires (_Compare f, _InIter2 x0, _InIter1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 requires (_Compare f, _InIter1 x0, _InIter2 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
)
Printed constraint (optimized):
(
 requires (_Compare f, _InIter2 x0, _InIter1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 requires (_Compare f, _InIter1 x0, _InIter2 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
)
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__destroy:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:11065:1
Printed constraint (original):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__half_inplace_merge:_InputIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12004:1
Printed constraint (original):
(
 requires (_InputIterator2 x0) { ++x0; } &&
 requires (_InputIterator2 x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator2 x0) { ++x0; } &&
 requires (_InputIterator2 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__merge_impl:_InIter2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:16820:1
Printed constraint (original):
(
 requires (_InIter2 x0) { ++x0; } &&
 requires (_InIter2 x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_InIter2 x0) { ++x0; } &&
 requires (_InIter2 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[set_intersection:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18871:1
Printed constraint (original):
(
 (
  (
   requires (_Compare f, _InputIterator2 x0, _InputIterator1 x1) { f(*x0, *x1); } &&
   requires (_Compare f, _InputIterator1 x0, _InputIterator2 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_Compare f, _InputIterator2 x0, _InputIterator1 x1) { f(*x0, *x1); } &&
 requires (_Compare f, _InputIterator1 x0, _InputIterator2 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
)
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[rbegin:_Cp]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29302:1
Printed constraint (original):
(
 requires (_Cp o) { o.rbegin(); }
)
Printed constraint (optimized):
requires (_Cp o) { o.rbegin(); }
Inferred constraint:


[-[__insertion_sort_3:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14400:1
Printed constraint (original):
(
 true &&
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 (
  (
   (
    (
     true &&
     requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
    )
   ) &&
   (
    (
     requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
    )
   )
  ) ||
  (
   (
    (
     requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
     requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 (
  requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); } ||
  (
   requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
   requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
  )
 )
)
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__sort3:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14202:1
Printed constraint (original):
(
 requires (_Compare f, _ForwardIterator x0, _ForwardIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 requires (_Compare f, _ForwardIterator x0, _ForwardIterator x1) { f(*x0, *x1); }
)
Printed constraint (optimized):
(
 requires (_Compare f, _ForwardIterator x0, _ForwardIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 requires (_Compare f, _ForwardIterator x0, _ForwardIterator x1) { f(*x0, *x1); }
)
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__sort3_maybe_branchless:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14334:1
Printed constraint (original):
(
 (
  (
   requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
   requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
  )
 )
)
Printed constraint (optimized):
(
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
)
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__search_impl:_Iter1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7877:1
Printed constraint (original):
(
 (
  (
   (
    (true)
   ) &&
   requires (_Iter1 x0) { ++x0; } &&
   requires (_Iter1 x0) { *x0; } &&
   (
    (true)
   ) &&
   (
    (true)
   ) &&
   true
  )
 ) &&
 (
  (true)
 ) &&
 requires (_Iter1 x0, _Sent1 x1) { x1 - x0; } &&
 (
  (true)
 )
)
Printed constraint (optimized):
(
 requires (_Iter1 x0) { ++x0; } &&
 requires (_Iter1 x0) { *x0; } &&
 requires (_Iter1 x0, _Sent1 x1) { x1 - x0; }
)
Inferred constraint:
RandomAccessIterator 

[-[__sort3_maybe_branchless:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14327:1
Printed constraint (original):
(
 (
  (
   true &&
   requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
  )
 ) &&
 (
  (
   requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
  )
 )
)
Printed constraint (optimized):
requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[begin:_Cp]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:10977:1
Printed constraint (original):
(
 requires (_Cp o) { o.begin(); }
)
Printed constraint (optimized):
requires (_Cp o) { o.begin(); }
Inferred constraint:


[-[isnormal:_A1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:23809:1
Printed constraint (original):
(
 requires (_A1 x0, int x1) { x0 != x1; }
)
Printed constraint (optimized):
requires (_A1 x0, int x1) { x0 != x1; }
Inferred constraint:
InputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[__uninitialized_allocator_move_if_noexcept:_Iter1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:30124:1
Printed constraint (original):
(
 requires (_Iter1 x0) { ++x0; } &&
 requires (_Iter1 x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_Iter1 x0) { ++x0; } &&
 requires (_Iter1 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__rotate_impl:_BidirectionalIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:9475:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (true)
         ) &&
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   ) &&
   (
    (
     (
      (
       (
        (
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   ) &&
   requires (_BidirectionalIterator x0) { *x0; } &&
   (
    (
     (
      (
       (
        (
         (
          (true)
         ) &&
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   )
  )
 ) &&
 (
  (
   requires (_BidirectionalIterator x0) { ++x0; }
  )
 ) &&
 (
  (
   requires (_BidirectionalIterator x0) { *x0; } &&
   (
    (
     (
      (
       (
        (
         (
          (true)
         ) &&
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   ) &&
   (
    (
     (
      (
       (
        (
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_BidirectionalIterator x0) { *x0; } &&
 requires (_BidirectionalIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__uninitialized_copy_n:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29776:1
Printed constraint (original):
(
 (
  (
   requires (_ForwardIterator x0) { *x0; } &&
   requires (_ForwardIterator x0) { ++x0; }
  )
 ) &&
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[sort_heap:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:13029:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       requires (_RandomAccessIterator x0) { ++x0; } &&
       requires (_RandomAccessIterator x0) { --x0; } &&
       (
        (
         requires (_RandomAccessIterator x0) { --x0; } &&
         requires (_RandomAccessIterator x0) { *x0; }
        )
       ) &&
       requires (_RandomAccessIterator x0) { *x0; } &&
       (
        (
         requires (_RandomAccessIterator x0) { ++x0; } &&
         requires (_RandomAccessIterator x0) { *x0; } &&
         true
        )
       )
      )
     ) &&
     requires (_RandomAccessIterator x0) { --x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Inferred constraint:
RandomAccessIterator 

[-[lexicographical_compare:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12459:1
Printed constraint (original):
(
 (
  (
   requires (_Compare f, _InputIterator2 x0, _InputIterator1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
   requires (_Compare f, _InputIterator1 x0, _InputIterator2 x1) { f(*x0, *x1); }
  )
 )
)
Printed constraint (optimized):
(
 requires (_Compare f, _InputIterator2 x0, _InputIterator1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 requires (_Compare f, _InputIterator1 x0, _InputIterator2 x1) { f(*x0, *x1); }
)
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__uninitialized_copy:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29753:1
Printed constraint (original):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__uninitialized_allocator_move_if_noexcept:_Iter2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:30144:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (true)
         ) &&
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   )
  )
 ) &&
 requires (_Iter2 x0) { ++x0; }
)
Printed constraint (optimized):
requires (_Iter2 x0) { ++x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[__uninitialized_fill_n:_Size]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29822:1
Printed constraint (original):
(
 requires (_Size x0) { --x0; }
)
Printed constraint (optimized):
requires (_Size x0) { --x0; }
Inferred constraint:
BidirectionalIterator RandomAccessIterator Float Integral 

[-[set_symmetric_difference:_InputIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19018:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   )
  )
 ) &&
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (true)
         ) &&
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   ) &&
   requires (_InputIterator2 x0) { ++x0; } &&
   requires (_InputIterator2 x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator2 x0) { ++x0; } &&
 requires (_InputIterator2 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[partition:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:15102:1
Printed constraint (original):
(
 (
  (
   (
    (true) ||
    (true)
   )
  )
 ) &&
 (
  (
   (
    (
     requires (_ForwardIterator x0) { ++x0; } &&
     requires (_ForwardIterator x0) { *x0; } &&
     (
      (true)
     ) &&
     (
      (true)
     )
    ) ||
    (
     requires (_ForwardIterator x0) { --x0; } &&
     requires (_ForwardIterator x0) { ++x0; } &&
     requires (_ForwardIterator x0) { *x0; } &&
     (
      (true)
     ) &&
     (
      (true)
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 (
  requires (_ForwardIterator x0) { ++x0; } &&
  requires (_ForwardIterator x0) { *x0; }
 ) ||
 (
  requires (_ForwardIterator x0) { --x0; } &&
  requires (_ForwardIterator x0) { ++x0; } &&
  requires (_ForwardIterator x0) { *x0; }
 )
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__is_permutation:_Iter1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12307:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 requires (_Iter1 x0) { ++x0; } &&
 requires (_Iter1 x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_Iter1 x0) { ++x0; } &&
 requires (_Iter1 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__make_heap:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12548:1
Printed constraint (original):
(
 (
  (
   requires (_RandomAccessIterator x0) { ++x0; } &&
   requires (_RandomAccessIterator x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__equal:_RandomAccessIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7629:1
Printed constraint (original):
(
 (
  (
   requires (_RandomAccessIterator2 x0) { *x0; } &&
   requires (_RandomAccessIterator2 x0) { ++x0; }
  )
 ) &&
 (
  (
   (
    (
     requires (_RandomAccessIterator2 x0) { ++x0; } &&
     requires (_RandomAccessIterator2 x0, _RandomAccessIterator2 x1) { x0 != x1; }
    ) ||
    (
     requires (_RandomAccessIterator2 x0, _RandomAccessIterator2 x1) { x0 - x1; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator2 x0) { *x0; } &&
 requires (_RandomAccessIterator2 x0) { ++x0; } &&
 (
  (
   requires (_RandomAccessIterator2 x0) { ++x0; } &&
   requires (_RandomAccessIterator2 x0, _RandomAccessIterator2 x1) { x0 != x1; }
  ) ||
  requires (_RandomAccessIterator2 x0, _RandomAccessIterator2 x1) { x0 - x1; }
 )
)
Inferred constraint:
InputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__uninitialized_default_construct_n:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29866:1
Printed constraint (original):
(
 (
  (
   requires (_ForwardIterator x0) { *x0; } &&
   requires (_ForwardIterator x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__push_heap:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12951:1
Printed constraint (original):
(
 (
  (
   requires (_RandomAccessIterator x0) { --x0; } &&
   requires (_RandomAccessIterator x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[__sift_up:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12929:1
Printed constraint (original):
(
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[__partially_sorted_swap:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:14316:1
Printed constraint (original):
(
 true &&
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
)
Printed constraint (optimized):
requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__merge_move_construct:_InputIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19680:1
Printed constraint (original):
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[set_symmetric_difference:_InputIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19018:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   )
  )
 ) &&
 (
  (
   requires (_InputIterator1 x0) { ++x0; } &&
   requires (_InputIterator1 x0) { *x0; } &&
   (
    (
     (
      (
       (
        (
         (
          (true)
         ) &&
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator1 x0) { ++x0; } &&
 requires (_InputIterator1 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__uninitialized_move_n:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29949:1
Printed constraint (original):
(
 (
  (
   requires (_ForwardIterator x0) { *x0; } &&
   requires (_ForwardIterator x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__half_inplace_merge:_OutputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12004:1
Printed constraint (original):
(
 requires (_OutputIterator x0) { *x0; } &&
 (
  (
   (
    (
     (
      (
       (
        (true)
       ) &&
       (
        (true)
       )
      ) ||
      (true)
     )
    )
   )
  )
 ) &&
 requires (_OutputIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[set_difference:_InputIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18750:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 (
  (
   requires (_InputIterator2 x0) { ++x0; } &&
   requires (_InputIterator2 x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator2 x0) { ++x0; } &&
 requires (_InputIterator2 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[rend:_Cp]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29314:1
Printed constraint (original):
(
 requires (_Cp o) { o.rend(); }
)
Printed constraint (optimized):
requires (_Cp o) { o.rend(); }
Inferred constraint:


[-[__uninitialized_allocator_fill_n_multidimensional:_BidirIter]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:30043:1
Printed constraint (original):
(
 requires (_BidirIter x0) { *x0; } &&
 requires (_BidirIter x0) { ++x0; } &&
 (
  (
   requires (_BidirIter x0) { *x0; } &&
   requires (_BidirIter x0) { --x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_BidirIter x0) { *x0; } &&
 requires (_BidirIter x0) { ++x0; } &&
 requires (_BidirIter x0) { --x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[__rotate:_Iterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:9508:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_Iterator x0) { ++x0; }
    )
   ) &&
   (
    (
     requires (_Iterator x0) { *x0; } &&
     (
      (
       (
        (
         (
          (
           (
            (true)
           ) &&
           (
            (true)
           )
          ) ||
          (true)
         )
        )
       )
      )
     ) &&
     (
      (
       (
        (
         (
          (
           (
            (true)
           )
          ) ||
          (true)
         )
        )
       )
      )
     )
    )
   )
  ) ||
  (
   (
    (
     (
      (
       (
        (
         (
          (
           (
            (true)
           ) &&
           (
            (true)
           )
          ) ||
          (true)
         )
        )
       )
      )
     ) &&
     (
      (
       (
        (
         (
          (
           (
            (true)
           )
          ) ||
          (true)
         )
        )
       )
      )
     ) &&
     requires (_Iterator x0) { *x0; } &&
     (
      (
       (
        (
         (
          (
           (
            (true)
           ) &&
           (
            (true)
           )
          ) ||
          (true)
         )
        )
       )
      )
     )
    )
   ) &&
   (
    (
     requires (_Iterator x0) { ++x0; }
    )
   ) &&
   (
    (
     requires (_Iterator x0) { *x0; } &&
     (
      (
       (
        (
         (
          (
           (
            (true)
           ) &&
           (
            (true)
           )
          ) ||
          (true)
         )
        )
       )
      )
     ) &&
     (
      (
       (
        (
         (
          (
           (
            (true)
           )
          ) ||
          (true)
         )
        )
       )
      )
     )
    )
   )
  ) ||
  (
   (
    (
     requires (_Iterator x0) { *x0; } &&
     true &&
     (
      (
       requires (_Iterator x0) { ++x0; }
      )
     ) &&
     (
      (
       requires (_Iterator x0) { ++x0; }
      )
     ) &&
     requires (_Iterator x0) { --x0; } &&
     (
      (true)
     ) &&
     (
      (true)
     )
    )
   ) &&
   (
    (
     (
      (
       (
        (
         (
          (
           (
            (true)
           ) &&
           (
            (true)
           )
          ) ||
          (true)
         )
        )
       )
      )
     ) &&
     (
      (
       (
        (
         (
          (
           (
            (true)
           )
          ) ||
          (true)
         )
        )
       )
      )
     ) &&
     requires (_Iterator x0) { *x0; } &&
     (
      (
       (
        (
         (
          (
           (
            (true)
           ) &&
           (
            (true)
           )
          ) ||
          (true)
         )
        )
       )
      )
     )
    )
   ) &&
   (
    (
     requires (_Iterator x0) { ++x0; }
    )
   ) &&
   (
    (
     requires (_Iterator x0) { *x0; } &&
     (
      (
       (
        (
         (
          (
           (
            (true)
           ) &&
           (
            (true)
           )
          ) ||
          (true)
         )
        )
       )
      )
     ) &&
     (
      (
       (
        (
         (
          (
           (
            (true)
           )
          ) ||
          (true)
         )
        )
       )
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 (
  requires (_Iterator x0) { ++x0; } &&
  requires (_Iterator x0) { *x0; }
 ) ||
 (
  requires (_Iterator x0) { *x0; } &&
  requires (_Iterator x0) { ++x0; }
 ) ||
 (
  requires (_Iterator x0) { *x0; } &&
  requires (_Iterator x0) { ++x0; } &&
  requires (_Iterator x0) { --x0; }
 )
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__rotate_gcd:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:9427:1
Printed constraint (original):
(
 requires (_RandomAccessIterator x0) { *x0; } &&
 true &&
 (
  (
   requires (_RandomAccessIterator x0) { ++x0; }
  )
 ) &&
 (
  (
   requires (_RandomAccessIterator x0) { ++x0; }
  )
 ) &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 (
  (true)
 ) &&
 (
  (true)
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; }
)
Inferred constraint:
RandomAccessIterator 

[-[uninitialized_move_n:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29963:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_ForwardIterator x0) { *x0; } &&
     requires (_ForwardIterator x0) { ++x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[clamp:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:5903:1
Printed constraint (original):
(
 requires (_Compare f, _Tp x0, _Tp x1) { f(x0, x1); }
)
Printed constraint (optimized):
requires (_Compare f, _Tp x0, _Tp x1) { f(x0, x1); }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__constexpr_scalbn:_Tp]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:24951:1
Printed constraint (original):
(
 requires (_Tp x0, _Tp x1) { x0 *= x1; } &&
 true &&
 (
  (true) ||
  (true)
 ) &&
 (
  (true) ||
  (true)
 )
)
Printed constraint (optimized):
requires (_Tp x0, _Tp x1) { x0 *= x1; }
Inferred constraint:
Float Integral 

[-[__partition_impl:_Predicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:15046:1
Printed constraint (original):
(
 requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
 requires (_Predicate f, _ForwardIterator x0) { f(*x0); }
)
Printed constraint (optimized):
(
 requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
 requires (_Predicate f, _ForwardIterator x0) { f(*x0); }
)
Inferred constraint:
UnaryFunction Predicate 

[-[unique:_BinaryPredicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20075:1
Printed constraint (original):
(
 (
  (
   requires (_BinaryPredicate f, _ForwardIterator x0, _ForwardIterator x1) { f(*x0, *x1); } &&
   (
    (
     requires (_BinaryPredicate f, _ForwardIterator x0, _ForwardIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_BinaryPredicate f, _ForwardIterator x0, _ForwardIterator x1) { f(*x0, *x1); } &&
 requires (_BinaryPredicate f, _ForwardIterator x0, _ForwardIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
)
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__rotate_impl:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:9461:1
Printed constraint (original):
(
 (
  (
   requires (_ForwardIterator x0) { ++x0; }
  )
 ) &&
 (
  (
   requires (_ForwardIterator x0) { *x0; } &&
   (
    (
     (
      (
       (
        (
         (
          (true)
         ) &&
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   ) &&
   (
    (
     (
      (
       (
        (
         (
          (true)
         )
        ) ||
        (true)
       )
      )
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__uninitialized_allocator_value_construct_n_multidimensional:_Size]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:30055:1
Printed constraint (original):
(
 requires (_Size x0) { --x0; }
)
Printed constraint (optimized):
requires (_Size x0) { --x0; }
Inferred constraint:
BidirectionalIterator RandomAccessIterator Float Integral 

[-[__convert_to_timespec:_TimeSpec]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:21587:1
Printed constraint (original):
(
 requires (_TimeSpec o) { o.tv_nsec; } &&
 requires (_TimeSpec o) { o.tv_sec; }
)
Printed constraint (optimized):
(
 requires (_TimeSpec o) { o.tv_nsec; } &&
 requires (_TimeSpec o) { o.tv_sec; }
)
Inferred constraint:


[-[__reverse:_Sentinel]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12858:1
Printed constraint (original):
(
 (
  (
   requires (_Sentinel x0) { ++x0; } &&
   requires (_Sentinel x0) { --x0; }
  ) ||
  (
   requires (_Sentinel x0) { ++x0; } &&
   requires (_Sentinel x0) { --x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_Sentinel x0) { ++x0; } &&
 requires (_Sentinel x0) { --x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator Float Integral 

[-[make_heap:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12560:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_RandomAccessIterator x0) { ++x0; } &&
     requires (_RandomAccessIterator x0) { *x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__rotate_left:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:9356:1
Printed constraint (original):
(
 requires (_ForwardIterator x0) { *x0; } &&
 (
  (
   (
    (
     (
      (
       (
        (true)
       ) &&
       (
        (true)
       )
      ) ||
      (true)
     )
    )
   )
  )
 ) &&
 (
  (
   (
    (
     (
      (
       (
        (true)
       )
      ) ||
      (true)
     )
    )
   )
  )
 )
)
Printed constraint (optimized):
requires (_ForwardIterator x0) { *x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__uninitialized_fill:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29798:1
Printed constraint (original):
(
 (
  (
   requires (_ForwardIterator x0) { *x0; } &&
   requires (_ForwardIterator x0) { ++x0; }
  )
 ) &&
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__set_intersection:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18850:1
Printed constraint (original):
(
 requires (_Compare f, _InIter2 x0, _InIter1 x1) { f(*x0, *x1); } &&
 requires (_Compare f, _InIter1 x0, _InIter2 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
)
Printed constraint (optimized):
(
 requires (_Compare f, _InIter2 x0, _InIter1 x1) { f(*x0, *x1); } &&
 requires (_Compare f, _InIter1 x0, _InIter2 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
)
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[uninitialized_copy_n:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29790:1
Printed constraint (original):
(
 (
  (
   requires (_InputIterator x0) { *x0; } &&
   requires (_InputIterator x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__allocator_construct_at_multidimensional:_Tp]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:30019:1
Printed constraint (original):
(
 (
  (
   requires (_Tp x0) { *x0; } &&
   requires (_Tp x0) { --x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_Tp x0) { *x0; } &&
 requires (_Tp x0) { --x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[uninitialized_copy_n:_Size]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29790:1
Printed constraint (original):
(
 (
  (
   requires (_Size x0) { --x0; }
  )
 )
)
Printed constraint (optimized):
requires (_Size x0) { --x0; }
Inferred constraint:
BidirectionalIterator RandomAccessIterator Float Integral 

[-[__uninitialized_copy_n:_Size]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29776:1
Printed constraint (original):
(
 requires (_Size x0) { --x0; }
)
Printed constraint (optimized):
requires (_Size x0) { --x0; }
Inferred constraint:
BidirectionalIterator RandomAccessIterator Float Integral 

[-[__stable_partition_impl:_BidirectionalIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19591:1
Printed constraint (original):
(
 (
  (
   (
    (true)
   ) &&
   (
    (
     (
      (
       (
        (
         requires (_BidirectionalIterator x0) { ++x0; }
        )
       ) &&
       (
        (
         requires (_BidirectionalIterator x0) { *x0; } &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         )
        )
       )
      ) ||
      (
       (
        (
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         requires (_BidirectionalIterator x0) { *x0; } &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         )
        )
       ) &&
       (
        (
         requires (_BidirectionalIterator x0) { ++x0; }
        )
       ) &&
       (
        (
         requires (_BidirectionalIterator x0) { *x0; } &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         )
        )
       )
      ) ||
      (
       (
        (
         requires (_BidirectionalIterator x0) { *x0; } &&
         true &&
         (
          (
           requires (_BidirectionalIterator x0) { ++x0; }
          )
         ) &&
         (
          (
           requires (_BidirectionalIterator x0) { ++x0; }
          )
         ) &&
         requires (_BidirectionalIterator x0) { --x0; } &&
         (
          (true)
         ) &&
         (
          (true)
         )
        )
       ) &&
       (
        (
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         requires (_BidirectionalIterator x0) { *x0; } &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         )
        )
       ) &&
       (
        (
         requires (_BidirectionalIterator x0) { ++x0; }
        )
       ) &&
       (
        (
         requires (_BidirectionalIterator x0) { *x0; } &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         )
        )
       )
      )
     )
    )
   ) &&
   (
    true
   ) &&
   requires (_BidirectionalIterator x0) { *x0; } &&
   requires (_BidirectionalIterator x0) { ++x0; }
  ) ||
  (
   (
    (true)
   ) &&
   (
    (
     (
      (true)
     ) &&
     (
      (
       (
        (
         (
          (
           requires (_BidirectionalIterator x0) { ++x0; }
          )
         ) &&
         (
          (
           requires (_BidirectionalIterator x0) { *x0; } &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           )
          )
         )
        ) ||
        (
         (
          (
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           requires (_BidirectionalIterator x0) { *x0; } &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           )
          )
         ) &&
         (
          (
           requires (_BidirectionalIterator x0) { ++x0; }
          )
         ) &&
         (
          (
           requires (_BidirectionalIterator x0) { *x0; } &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           )
          )
         )
        ) ||
        (
         (
          (
           requires (_BidirectionalIterator x0) { *x0; } &&
           true &&
           (
            (
             requires (_BidirectionalIterator x0) { ++x0; }
            )
           ) &&
           (
            (
             requires (_BidirectionalIterator x0) { ++x0; }
            )
           ) &&
           requires (_BidirectionalIterator x0) { --x0; } &&
           (
            (true)
           ) &&
           (
            (true)
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           requires (_BidirectionalIterator x0) { *x0; } &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           )
          )
         ) &&
         (
          (
           requires (_BidirectionalIterator x0) { ++x0; }
          )
         ) &&
         (
          (
           requires (_BidirectionalIterator x0) { *x0; } &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 ) &&
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           ) &&
           (
            (
             (
              (
               (
                (
                 (
                  (true)
                 )
                ) ||
                (true)
               )
              )
             )
            )
           )
          )
         )
        )
       )
      )
     ) &&
     (
      true
     ) &&
     requires (_BidirectionalIterator x0) { *x0; } &&
     requires (_BidirectionalIterator x0) { ++x0; }
    ) ||
    true
   ) &&
   requires (_BidirectionalIterator x0) { ++x0; } &&
   requires (_BidirectionalIterator x0) { --x0; } &&
   (
    (
     (
      (
       (
        (
         requires (_BidirectionalIterator x0) { ++x0; }
        )
       ) &&
       (
        (
         requires (_BidirectionalIterator x0) { *x0; } &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         )
        )
       )
      ) ||
      (
       (
        (
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         requires (_BidirectionalIterator x0) { *x0; } &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         )
        )
       ) &&
       (
        (
         requires (_BidirectionalIterator x0) { ++x0; }
        )
       ) &&
       (
        (
         requires (_BidirectionalIterator x0) { *x0; } &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         )
        )
       )
      ) ||
      (
       (
        (
         requires (_BidirectionalIterator x0) { *x0; } &&
         true &&
         (
          (
           requires (_BidirectionalIterator x0) { ++x0; }
          )
         ) &&
         (
          (
           requires (_BidirectionalIterator x0) { ++x0; }
          )
         ) &&
         requires (_BidirectionalIterator x0) { --x0; } &&
         (
          (true)
         ) &&
         (
          (true)
         )
        )
       ) &&
       (
        (
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         requires (_BidirectionalIterator x0) { *x0; } &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         )
        )
       ) &&
       (
        (
         requires (_BidirectionalIterator x0) { ++x0; }
        )
       ) &&
       (
        (
         requires (_BidirectionalIterator x0) { *x0; } &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               ) &&
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         ) &&
         (
          (
           (
            (
             (
              (
               (
                (true)
               )
              ) ||
              (true)
             )
            )
           )
          )
         )
        )
       )
      )
     )
    )
   ) &&
   requires (_BidirectionalIterator x0) { *x0; }
  )
 ) &&
 requires (_BidirectionalIterator x0) { --x0; } &&
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { *x0; }
)
Printed constraint (optimized):
(
 (
  (
   (
    (
     requires (_BidirectionalIterator x0) { ++x0; } &&
     requires (_BidirectionalIterator x0) { *x0; }
    ) ||
    (
     requires (_BidirectionalIterator x0) { *x0; } &&
     requires (_BidirectionalIterator x0) { ++x0; }
    ) ||
    (
     requires (_BidirectionalIterator x0) { *x0; } &&
     requires (_BidirectionalIterator x0) { ++x0; } &&
     requires (_BidirectionalIterator x0) { --x0; }
    )
   ) &&
   requires (_BidirectionalIterator x0) { *x0; } &&
   requires (_BidirectionalIterator x0) { ++x0; }
  ) ||
  (
   requires (_BidirectionalIterator x0) { ++x0; } &&
   requires (_BidirectionalIterator x0) { --x0; } &&
   (
    (
     requires (_BidirectionalIterator x0) { ++x0; } &&
     requires (_BidirectionalIterator x0) { *x0; }
    ) ||
    (
     requires (_BidirectionalIterator x0) { *x0; } &&
     requires (_BidirectionalIterator x0) { ++x0; }
    ) ||
    (
     requires (_BidirectionalIterator x0) { *x0; } &&
     requires (_BidirectionalIterator x0) { ++x0; } &&
     requires (_BidirectionalIterator x0) { --x0; }
    )
   ) &&
   requires (_BidirectionalIterator x0) { *x0; }
  )
 ) &&
 requires (_BidirectionalIterator x0) { --x0; } &&
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { *x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[is_sorted:_Compare]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:12427:1
Printed constraint (original):
(
 (
  (
   requires (_Compare f, _ForwardIterator x0, _ForwardIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
  )
 )
)
Printed constraint (optimized):
requires (_Compare f, _ForwardIterator x0, _ForwardIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[__uninitialized_allocator_move_if_noexcept:_Iter2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:30124:1
Printed constraint (original):
(
 requires (_Iter2 x0) { ++x0; }
)
Printed constraint (optimized):
requires (_Iter2 x0) { ++x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[__uninitialized_allocator_copy:_Iter1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:30087:1
Printed constraint (original):
(
 requires (_Iter1 x0) { ++x0; } &&
 requires (_Iter1 x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_Iter1 x0) { ++x0; } &&
 requires (_Iter1 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[uninitialized_default_construct_n:_ForwardIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29879:1
Printed constraint (original):
(
 (
  (
   (
    (
     requires (_ForwardIterator x0) { *x0; } &&
     requires (_ForwardIterator x0) { ++x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__swap_ranges:_ForwardIterator2]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:9326:1
Printed constraint (original):
(
 requires (_ForwardIterator2 x0) { ++x0; }
)
Printed constraint (optimized):
requires (_ForwardIterator2 x0) { ++x0; }
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[__sample:_SampleIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18328:1
Printed constraint (original):
(
 requires (_SampleIterator x0) { x0++; }
)
Printed constraint (optimized):
requires (_SampleIterator x0) { x0++; }
Inferred constraint:
InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator Float Integral 

[-[set_intersection:_OutputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18871:1
Printed constraint (original):
(
 (
  (
   requires (_OutputIterator x0) { ++x0; } &&
   requires (_OutputIterator x0) { *x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[includes:_InputIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:9122:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 (
  (
   requires (_InputIterator1 x0) { *x0; } &&
   requires (_InputIterator1 x0) { ++x0; }
  )
 ) &&
 requires (_InputIterator1 x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__advance:_BiDirIter]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:4832:1
Printed constraint (original):
(
 requires (_BiDirIter x0) { --x0; } &&
 requires (_BiDirIter x0) { ++x0; }
)
Printed constraint (optimized):
(
 requires (_BiDirIter x0) { --x0; } &&
 requires (_BiDirIter x0) { ++x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator Float Integral 

[-[uninitialized_value_construct_n:_Size]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29918:1
Printed constraint (original):
(
 (
  (
   requires (_Size x0) { --x0; }
  )
 )
)
Printed constraint (optimized):
requires (_Size x0) { --x0; }
Inferred constraint:
BidirectionalIterator RandomAccessIterator Float Integral 

[-[any_of:_Predicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:5756:1
Printed constraint (original):
(
 requires (_Predicate f, _InputIterator x0) { {f(*x0)} -> std::convertible_to<bool>; }
)
Printed constraint (optimized):
requires (_Predicate f, _InputIterator x0) { {f(*x0)} -> std::convertible_to<bool>; }
Inferred constraint:
UnaryFunction Predicate 

[-[__set_intersection:_InIter1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18850:1
Printed constraint (original):
(
 requires (_InIter1 x0) { ++x0; } &&
 requires (_InIter1 x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_InIter1 x0) { ++x0; } &&
 requires (_InIter1 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__stable_sort_move:_RandomAccessIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19754:1
Printed constraint (original):
(
 (
  (
   requires (_RandomAccessIterator x0) { *x0; } &&
   requires (_RandomAccessIterator x0) { ++x0; }
  )
 ) &&
 (
  (
   requires (_RandomAccessIterator x0) { *x0; } &&
   requires (_RandomAccessIterator x0) { ++x0; }
  )
 ) &&
 requires (_RandomAccessIterator x0) { *x0; } &&
 (
  (
   requires (_RandomAccessIterator x0) { *x0; } &&
   requires (_RandomAccessIterator x0) { ++x0; }
  )
 ) &&
 requires (_RandomAccessIterator x0) { --x0; }
)
Printed constraint (optimized):
(
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[__unique_copy:_BinaryPredicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20167:1
Printed constraint (original):
(
 requires (_BinaryPredicate f, _InputAndOutputIterator x0, _InputIterator x1) { f(*x0, *x1); }
)
Printed constraint (optimized):
requires (_BinaryPredicate f, _InputAndOutputIterator x0, _InputIterator x1) { f(*x0, *x1); }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[search:_Searcher]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:7942:1
Printed constraint (original):
(
 requires (_Searcher f, _ForwardIterator x0, _ForwardIterator x1) { f(x0, x1); }
)
Printed constraint (optimized):
requires (_Searcher f, _ForwardIterator x0, _ForwardIterator x1) { f(x0, x1); }
Inferred constraint:
BinaryFunction BinaryPredicate 

[-[uninitialized_copy:_InputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:29767:1
Printed constraint (original):
(
 (
  (true)
 ) &&
 (
  (
   requires (_InputIterator x0) { *x0; } &&
   requires (_InputIterator x0) { ++x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[remove_if:_Predicate]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:20345:1
Printed constraint (original):
(
 requires (_Predicate f, _ForwardIterator x0) { f(*x0); } &&
 (
  (
   requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_Predicate f, _ForwardIterator x0) { f(*x0); } &&
 requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; }
)
Inferred constraint:
UnaryFunction Predicate 

[-[set_union:_OutputIterator]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:19177:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        (
         (
          (
           (
            (true)
           ) &&
           (
            (true)
           )
          ) ||
          (true)
         )
        )
       )
      )
     ) &&
     requires (_OutputIterator x0) { *x0; } &&
     (
      (
       (
        (
         (
          (
           (
            (true)
           ) &&
           (
            (true)
           )
          ) ||
          (true)
         )
        )
       )
      )
     ) &&
     requires (_OutputIterator x0) { ++x0; }
    )
   )
  )
 )
)
Printed constraint (optimized):
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__set_difference:_InIter1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:18732:1
Printed constraint (original):
(
 (
  (
   (
    (
     (
      (
       (
        (true)
       ) &&
       (
        (true)
       )
      ) ||
      (true)
     )
    )
   )
  )
 ) &&
 requires (_InIter1 x0) { ++x0; } &&
 requires (_InIter1 x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_InIter1 x0) { ++x0; } &&
 requires (_InIter1 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[partition_copy:_OutputIterator1]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:15113:1
Printed constraint (original):
(
 requires (_OutputIterator1 x0) { ++x0; } &&
 requires (_OutputIterator1 x0) { *x0; }
)
Printed constraint (optimized):
(
 requires (_OutputIterator1 x0) { ++x0; } &&
 requires (_OutputIterator1 x0) { *x0; }
)
Inferred constraint:
Iterator InputIterator OutputIterator ForwardIterator BidirectionalIterator RandomAccessIterator 

[-[__uninitialized_allocator_value_construct_n_multidimensional:_BidirIter]-]
SourceLocation:
/Users/sdingcn/clang-tools/clang-checks/extra-files/std-doc/prep.cc:30055:1
Printed constraint (original):
(
 requires (_BidirIter x0) { *x0; } &&
 requires (_BidirIter x0) { ++x0; } &&
 (
  (
   requires (_BidirIter x0) { *x0; } &&
   requires (_BidirIter x0) { --x0; }
  )
 )
)
Printed constraint (optimized):
(
 requires (_BidirIter x0) { *x0; } &&
 requires (_BidirIter x0) { ++x0; } &&
 requires (_BidirIter x0) { --x0; }
)
Inferred constraint:
BidirectionalIterator RandomAccessIterator 

[-[Erroneous calls]-]
signbit(s);
fpclassify(s);
isnormal(s);
std::data(s);
std::data(s);
std::empty(s);
std::rbegin(s);
std::rbegin(s);
std::rend(s);
std::rend(s);
std::size(s);
std::ssize(s);
std::uninitialized_copy(s, s, s);
std::uninitialized_copy_n(s, s, s);
std::uninitialized_fill(s, s, s);
std::uninitialized_fill_n(s, s, s);
std::uninitialized_default_construct(s, s);
std::uninitialized_default_construct_n(s, s);
std::uninitialized_value_construct(s, s);
std::uninitialized_value_construct_n(s, s);
std::uninitialized_move(s, s, s);
std::uninitialized_move_n(s, s, s);
std::remove_copy_if(s, s, s, s);
std::sample(s, s, s, s, s);
std::search_n(s, s, s, s, s);
std::search_n(s, s, s, s);
std::set_difference(s, s, s, s, s, s);
std::set_difference(s, s, s, s, s);
std::set_intersection(s, s, s, s, s, s);
std::set_intersection(s, s, s, s, s);
std::set_symmetric_difference(s, s, s, s, s, s);
std::set_symmetric_difference(s, s, s, s, s);
std::set_union(s, s, s, s, s, s);
std::set_union(s, s, s, s, s);
std::shuffle(s, s, s);
std::iter_swap(s, s);
std::adjacent_find(s, s, s);
std::adjacent_find(s, s);
std::all_of(s, s, s);
std::any_of(s, s, s);
std::lower_bound(s, s, s, s);
std::lower_bound(s, s, s);
std::binary_search(s, s, s, s);
std::binary_search(s, s, s);
std::clamp(s, s, s, s);
std::min_element(s, s, s);
std::min_element(s, s);
std::min(s, s, s);
std::copy_if(s, s, s, s);
std::copy_n(s, s, s);
std::count(s, s, s);
std::count_if(s, s, s);
std::equal(s, s, s, s);
std::equal(s, s, s);
std::equal(s, s, s, s, s);
std::equal(s, s, s, s);
std::equal_range(s, s, s, s);
std::equal_range(s, s, s);
std::fill_n(s, s, s);
std::fill(s, s, s);
std::find(s, s, s);
std::search(s, s, s, s, s);
std::search(s, s, s, s);
std::search(s, s, s);
std::find_end(s, s, s, s, s);
std::find_end(s, s, s, s);
std::find_first_of(s, s, s, s, s);
std::find_first_of(s, s, s, s);
std::find_if(s, s, s);
std::find_if_not(s, s, s);
std::for_each(s, s, s);
std::for_each_n(s, s, s);
std::generate(s, s, s);
std::generate_n(s, s, s);
std::includes(s, s, s, s, s);
std::includes(s, s, s, s);
std::swap_ranges(s, s, s);
std::rotate(s, s, s);
std::__1::begin(s);
std::__1::begin(s);
std::__1::end(s);
std::__1::end(s);
std::destroy(s, s);
std::destroy_n(s, s);
std::inplace_merge(s, s, s, s);
std::inplace_merge(s, s, s);
std::is_heap_until(s, s, s);
std::is_heap_until(s, s);
std::is_heap(s, s, s);
std::is_heap(s, s);
std::is_partitioned(s, s, s);
std::is_permutation(s, s, s, s);
std::is_permutation(s, s, s);
std::is_permutation(s, s, s, s);
std::is_permutation(s, s, s, s, s);
std::is_sorted_until(s, s, s);
std::is_sorted_until(s, s);
std::is_sorted(s, s, s);
std::is_sorted(s, s);
std::lexicographical_compare(s, s, s, s, s);
std::lexicographical_compare(s, s, s, s);
std::make_heap(s, s, s);
std::make_heap(s, s);
std::max_element(s, s, s);
std::max_element(s, s);
std::max(s, s, s);
std::merge(s, s, s, s, s, s);
std::merge(s, s, s, s, s);
std::minmax_element(s, s, s);
std::minmax_element(s, s);
std::minmax(s, s, s);
std::mismatch(s, s, s, s);
std::mismatch(s, s, s);
std::mismatch(s, s, s, s, s);
std::mismatch(s, s, s, s);
std::reverse(s, s);
std::next_permutation(s, s, s);
std::next_permutation(s, s);
std::none_of(s, s, s);
std::push_heap(s, s, s);
std::push_heap(s, s);
std::pop_heap(s, s, s);
std::pop_heap(s, s);
std::sort_heap(s, s, s);
std::sort_heap(s, s);
std::partial_sort(s, s, s, s);
std::partial_sort(s, s, s);
std::distance(s, s);
std::sort(s, s, s);
std::sort(s, s);
std::nth_element(s, s, s, s);
std::nth_element(s, s, s);
std::partial_sort_copy(s, s, s, s, s);
std::partial_sort_copy(s, s, s, s);
std::partition(s, s, s);
std::partition_copy(s, s, s, s, s);
std::partition_point(s, s, s);
std::prev_permutation(s, s, s);
std::prev_permutation(s, s);
std::stable_partition(s, s, s);
std::stable_sort(s, s, s);
std::stable_sort(s, s);
std::unique(s, s, s);
std::unique(s, s);
std::unique_copy(s, s, s, s);
std::unique_copy(s, s, s);
std::remove(s, s, s);
std::remove_copy(s, s, s, s);
std::remove_if(s, s, s);
std::replace(s, s, s, s);
std::replace_copy(s, s, s, s, s);
std::replace_copy_if(s, s, s, s, s);
std::replace_if(s, s, s, s);
std::reverse_copy(s, s, s);
std::shift_left(s, s, s);
std::shift_right(s, s, s);
std::transform(s, s, s, s);
std::transform(s, s, s, s, s);
std::chrono::round(s);

[-[Summary]-]
Template Type Parameters:
Total = 1712
Nontrivial = 557
Percentage = 32.535
Function Templates:
Total = 821
Nontrivial = 315
Percentage = 38.368
Public Function Templates:
Total = 566
Nontrivial = 159
Percentage = 28.092

[-[Rewritten code]-]
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wmacro-redefined"
#pragma clang diagnostic pop
namespace std { inline namespace __1 { }}
namespace std { inline namespace __1 {
[[noreturn]] __attribute__((__visibility__("default"))) __attribute__((__format__(__printf__, 1, 2)))
void __libcpp_verbose_abort(const char *__format, ...);
}}

namespace std { inline namespace __1 {
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
inline constexpr bool is_constant_evaluated() noexcept {
  return __builtin_is_constant_evaluated();
}
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) inline constexpr
bool __libcpp_is_constant_evaluated() noexcept { return __builtin_is_constant_evaluated(); }
}}
namespace std { inline namespace __1 {
template <bool, class _Tp = void> struct __attribute__((__type_visibility__("default"))) enable_if {};
template <class _Tp> struct __attribute__((__type_visibility__("default"))) enable_if<true, _Tp> {typedef _Tp type;};
template <bool _Bp, class _Tp = void> using __enable_if_t __attribute__((__nodebug__)) = typename enable_if<_Bp, _Tp>::type;
template <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;
}}
namespace std { inline namespace __1 {
template <class _Tp, _Tp __v>
struct __attribute__((__type_visibility__("default"))) integral_constant
{
  static constexpr const _Tp value = __v;
  typedef _Tp value_type;
  typedef integral_constant type;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr operator value_type() const noexcept {return value;}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr value_type operator ()() const noexcept {return value;}
};
template <class _Tp, _Tp __v>
constexpr const _Tp integral_constant<_Tp, __v>::value;
typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;
template <bool _Val>
using _BoolConstant __attribute__((__nodebug__)) = integral_constant<bool, _Val>;
template <bool __b>
using bool_constant = integral_constant<bool, __b>;
}}
namespace std { inline namespace __1 {
template <class _Tp>
struct remove_const {
  using type __attribute__((__nodebug__)) = __remove_const(_Tp);
};
template <class _Tp>
using __remove_const_t = __remove_const(_Tp);
template <class _Tp> using remove_const_t = __remove_const_t<_Tp>;
}}
namespace std { inline namespace __1 {
template <class _Tp>
struct remove_volatile {
  using type __attribute__((__nodebug__)) = __remove_volatile(_Tp);
};
template <class _Tp>
using __remove_volatile_t = __remove_volatile(_Tp);
template <class _Tp> using remove_volatile_t = __remove_volatile_t<_Tp>;
}}
namespace std { inline namespace __1 {
template <class _Tp>
struct remove_cv {
  using type __attribute__((__nodebug__)) = __remove_cv(_Tp);
};
template <class _Tp>
using __remove_cv_t = __remove_cv(_Tp);
template <class _Tp> using remove_cv_t = __remove_cv_t<_Tp>;
}}
namespace std { inline namespace __1 {
template <class _Tp> struct __libcpp_is_integral { enum { value = 0 }; };
template <> struct __libcpp_is_integral<bool> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<char> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<signed char> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned char> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<wchar_t> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<char8_t> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<char16_t> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<char32_t> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<short> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned short> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<int> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned int> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<long> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned long> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<long long> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<unsigned long long> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<__int128_t> { enum { value = 1 }; };
template <> struct __libcpp_is_integral<__uint128_t> { enum { value = 1 }; };
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_integral : _BoolConstant<__is_integral(_Tp)> { };
template <class _Tp>
inline constexpr bool is_integral_v = __is_integral(_Tp);
}}

typedef long int ptrdiff_t;
typedef long unsigned int size_t;
typedef long double max_align_t;
 typedef decltype(nullptr) nullptr_t;
namespace std { inline namespace __1 {
using ::nullptr_t;
using ::ptrdiff_t __attribute__((__using_if_exists__));
using ::size_t __attribute__((__using_if_exists__));
using ::max_align_t __attribute__((__using_if_exists__));
}}
namespace std
{
enum class byte : unsigned char {};
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr byte operator| (byte __lhs, byte __rhs) noexcept
{
    return static_cast<byte>(
      static_cast<unsigned char>(
         static_cast<unsigned int>(__lhs) | static_cast<unsigned int>(__rhs)
    ));
}
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr byte& operator|=(byte& __lhs, byte __rhs) noexcept
{ return __lhs = __lhs | __rhs; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr byte operator& (byte __lhs, byte __rhs) noexcept
{
    return static_cast<byte>(
      static_cast<unsigned char>(
         static_cast<unsigned int>(__lhs) & static_cast<unsigned int>(__rhs)
    ));
}
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr byte& operator&=(byte& __lhs, byte __rhs) noexcept
{ return __lhs = __lhs & __rhs; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr byte operator^ (byte __lhs, byte __rhs) noexcept
{
    return static_cast<byte>(
      static_cast<unsigned char>(
         static_cast<unsigned int>(__lhs) ^ static_cast<unsigned int>(__rhs)
    ));
}
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr byte& operator^=(byte& __lhs, byte __rhs) noexcept
{ return __lhs = __lhs ^ __rhs; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr byte operator~ (byte __b) noexcept
{
    return static_cast<byte>(
      static_cast<unsigned char>(
        ~static_cast<unsigned int>(__b)
    ));
}
template <class _Tp>
using _EnableByteOverload = __enable_if_t<is_integral<_Tp>::value, byte>;
template <class _Integer>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _EnableByteOverload<_Integer> &
  operator<<=(byte& __lhs, _Integer __shift) noexcept
  { return __lhs = __lhs << __shift; }
template <class _Integer>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _EnableByteOverload<_Integer>
  operator<< (byte __lhs, _Integer __shift) noexcept
  { return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(__lhs) << __shift)); }
template <class _Integer>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _EnableByteOverload<_Integer> &
  operator>>=(byte& __lhs, _Integer __shift) noexcept
  { return __lhs = __lhs >> __shift; }
template <class _Integer>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _EnableByteOverload<_Integer>
  operator>> (byte __lhs, _Integer __shift) noexcept
  { return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(__lhs) >> __shift)); }
template <class _Integer, class = _EnableByteOverload<_Integer> >
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Integer
  to_integer(byte __b) noexcept { return static_cast<_Integer>(__b); }
}
namespace std { inline namespace __1 {
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr inline void __debug_db_insert_c(_Tp* __c) {
    (void)(__c);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr inline void __debug_db_insert_i(_Tp* __i) {
    (void)(__i);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr inline void __debug_db_erase_c(_Tp* __c) {
    (void)(__c);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr inline void __debug_db_swap(_Tp* __lhs, _Tp* __rhs) {
    (void)(__lhs);
    (void)(__rhs);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr inline void __debug_db_invalidate_all(_Tp* __c) {
    (void)(__c);
}
}}

namespace std { inline namespace __1 {
template <class _Tp, class _Up>
struct __attribute__((__type_visibility__("default"))) is_same : _BoolConstant<__is_same(_Tp, _Up)> { };
template <class _Tp, class _Up>
inline constexpr bool is_same_v = __is_same(_Tp, _Up);
template <class _Tp, class _Up>
using _IsSame = _BoolConstant<__is_same(_Tp, _Up)>;
template <class _Tp, class _Up>
using _IsNotSame = _BoolConstant<!__is_same(_Tp, _Up)>;
}}
namespace std { inline namespace __1 {
template <class _Tp>
struct __libcpp_is_referenceable : integral_constant<bool, __is_referenceable(_Tp)> {};
}}
namespace std { inline namespace __1 {
template <class _Tp>
using __add_lvalue_reference_t = __add_lvalue_reference(_Tp);
template <class _Tp>
struct add_lvalue_reference {
  using type __attribute__((__nodebug__)) = __add_lvalue_reference_t<_Tp>;
};
template <class _Tp> using add_lvalue_reference_t = __add_lvalue_reference_t<_Tp>;
}}
namespace std { inline namespace __1 {
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_const : _BoolConstant<__is_const(_Tp)> { };
template <class _Tp>
inline constexpr bool is_const_v = __is_const(_Tp);
}}
namespace std { inline namespace __1 {
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_volatile : _BoolConstant<__is_volatile(_Tp)> { };
template <class _Tp>
inline constexpr bool is_volatile_v = __is_volatile(_Tp);
}}
namespace std { inline namespace __1 {
template <class _Tp>
struct remove_reference {
  using type __attribute__((__nodebug__)) = __remove_reference_t(_Tp);
};
template <class _Tp>
using __libcpp_remove_reference_t = __remove_reference_t(_Tp);
template <class _Tp> using remove_reference_t = __libcpp_remove_reference_t<_Tp>;
}}
namespace std { inline namespace __1 {
template <class _Tp, class _Up, bool = is_const<__libcpp_remove_reference_t<_Tp> >::value,
                             bool = is_volatile<__libcpp_remove_reference_t<_Tp> >::value>
struct __apply_cv
{
    typedef __attribute__((__nodebug__)) _Up type;
};
template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, true, false>
{
    typedef __attribute__((__nodebug__)) const _Up type;
};
template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, false, true>
{
    typedef volatile _Up type;
};
template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, true, true>
{
    typedef const volatile _Up type;
};
template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, false, false>
{
    typedef _Up& type;
};
template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, true, false>
{
    typedef const _Up& type;
};
template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, false, true>
{
    typedef volatile _Up& type;
};
template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, true, true>
{
    typedef const volatile _Up& type;
};
}}
namespace std { inline namespace __1 {
template <bool>
struct _IfImpl;
template <>
struct _IfImpl<true> {
  template <class _IfRes, class _ElseRes>
  using _Select __attribute__((__nodebug__)) = _IfRes;
};
template <>
struct _IfImpl<false> {
  template <class _IfRes, class _ElseRes>
  using _Select __attribute__((__nodebug__)) = _ElseRes;
};
template <bool _Cond, class _IfRes, class _ElseRes>
using _If __attribute__((__nodebug__)) = typename _IfImpl<_Cond>::template _Select<_IfRes, _ElseRes>;
template <bool _Bp, class _If, class _Then>
struct __attribute__((__type_visibility__("default"))) conditional {
  using type __attribute__((__nodebug__)) = _If;
};
template <class _If, class _Then>
struct __attribute__((__type_visibility__("default"))) conditional<false, _If, _Then> {
  using type __attribute__((__nodebug__)) = _Then;
};
template <bool _Bp, class _IfRes, class _ElseRes>
using conditional_t __attribute__((__nodebug__)) = typename conditional<_Bp, _IfRes, _ElseRes>::type;
template <bool _Bp, class _If, class _Then>
using __conditional_t __attribute__((__nodebug__)) = typename conditional<_Bp, _If, _Then>::type;
}}
namespace std { inline namespace __1 {
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_void : _BoolConstant<__is_void(_Tp)> { };
template <class _Tp>
inline constexpr bool is_void_v = __is_void(_Tp);
}}
namespace std { inline namespace __1 {
template <class _Tp>
using __add_pointer_t = __add_pointer(_Tp);
template <class _Tp>
struct add_pointer {
  using type __attribute__((__nodebug__)) = __add_pointer_t<_Tp>;
};
template <class _Tp> using add_pointer_t = __add_pointer_t<_Tp>;
}}

namespace std { inline namespace __1 {
template <class _Tp> struct __attribute__((__type_visibility__("default"))) is_array
    : public false_type {};
template <class _Tp> struct __attribute__((__type_visibility__("default"))) is_array<_Tp[]>
    : public true_type {};
template <class _Tp, size_t _Np> struct __attribute__((__type_visibility__("default"))) is_array<_Tp[_Np]>
    : public true_type {};
template <class _Tp>
inline constexpr bool is_array_v = is_array<_Tp>::value;
}}
namespace std { inline namespace __1 {
template<class _Tp>
struct __attribute__((__type_visibility__("default"))) is_lvalue_reference : _BoolConstant<__is_lvalue_reference(_Tp)> { };
template<class _Tp>
struct __attribute__((__type_visibility__("default"))) is_rvalue_reference : _BoolConstant<__is_rvalue_reference(_Tp)> { };
template<class _Tp>
struct __attribute__((__type_visibility__("default"))) is_reference : _BoolConstant<__is_reference(_Tp)> { };
template <class _Tp>
inline constexpr bool is_reference_v = __is_reference(_Tp);
template <class _Tp>
inline constexpr bool is_lvalue_reference_v = __is_lvalue_reference(_Tp);
template <class _Tp>
inline constexpr bool is_rvalue_reference_v = __is_rvalue_reference(_Tp);
}}
namespace std { inline namespace __1 {
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_function : integral_constant<bool, __is_function(_Tp)> {};
template <class _Tp>
inline constexpr bool is_function_v = is_function<_Tp>::value;
}}
namespace std { inline namespace __1 {
template <class _Tp>
struct remove_extent {
  using type __attribute__((__nodebug__)) = __remove_extent(_Tp);
};
template <class _Tp>
using __remove_extent_t = __remove_extent(_Tp);
template <class _Tp> using remove_extent_t = __remove_extent_t<_Tp>;
}}
namespace std { inline namespace __1 {
template <class _Tp>
struct decay {
  using type __attribute__((__nodebug__)) = __decay(_Tp);
};
template <class _Tp> using decay_t = typename decay<_Tp>::type;
}}
namespace std { inline namespace __1 {
template <class _Bp, class _Dp>
struct __attribute__((__type_visibility__("default"))) is_base_of
    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};
template <class _Bp, class _Dp>
inline constexpr bool is_base_of_v = __is_base_of(_Bp, _Dp);
}}
namespace std { inline namespace __1 {
template <class _Tp, class _Up, class = void>
struct __is_core_convertible : public false_type {};
template <class _Tp, class _Up>
struct __is_core_convertible<_Tp, _Up, decltype(
    static_cast<void(*)(_Up)>(0) ( static_cast<_Tp(*)()>(0)() )
)> : public true_type {};
}}
namespace std { inline namespace __1 {
template <class _Tp> struct __libcpp_is_member_pointer {
  enum {
    __is_member = false,
    __is_func = false,
    __is_obj = false
  };
};
template <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> {
  enum {
    __is_member = true,
    __is_func = is_function<_Tp>::value,
    __is_obj = !__is_func,
  };
};
template<class _Tp>
struct __attribute__((__type_visibility__("default"))) is_member_function_pointer
    : _BoolConstant<__is_member_function_pointer(_Tp)> { };
template <class _Tp>
inline constexpr bool is_member_function_pointer_v = __is_member_function_pointer(_Tp);
}}
namespace std { inline namespace __1 {
template<class _Tp>
struct __attribute__((__type_visibility__("default"))) is_member_object_pointer
    : _BoolConstant<__is_member_object_pointer(_Tp)> { };
template <class _Tp>
inline constexpr bool is_member_object_pointer_v = __is_member_object_pointer(_Tp);
}}
namespace std { inline namespace __1 {
template <class _Tp> class __attribute__((__type_visibility__("default"))) reference_wrapper;
template <class _Tp> struct __is_reference_wrapper_impl : public false_type {};
template <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};
template <class _Tp> struct __is_reference_wrapper
    : public __is_reference_wrapper_impl<__remove_cv_t<_Tp> > {};
}}
namespace std { inline namespace __1 {
struct __nat
{
    __nat() = delete;
    __nat(const __nat&) = delete;
    __nat& operator=(const __nat&) = delete;
    ~__nat() = delete;
};
}}

namespace std { inline namespace __1 {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Tp>
_Tp&& __declval(int);
template <class _Tp>
_Tp __declval(long);
#pragma GCC diagnostic pop
template <class _Tp>
decltype(std::__declval<_Tp>(0)) declval() noexcept;
}}
namespace std { inline namespace __1 {
template <class _Tp>
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Tp&&
forward([[_Clang::__lifetimebound__]] __libcpp_remove_reference_t<_Tp>& __t) noexcept {
  return static_cast<_Tp&&>(__t);
}
template <class _Tp>
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Tp&&
forward([[_Clang::__lifetimebound__]] __libcpp_remove_reference_t<_Tp>&& __t) noexcept {
  static_assert(!is_lvalue_reference<_Tp>::value, "cannot forward an rvalue as an lvalue");
  return static_cast<_Tp&&>(__t);
}
}}
namespace std { inline namespace __1 {
struct __any
{
    __any(...);
};
template <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr>
struct __member_pointer_traits_imp
{
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>
{
    typedef _Class& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false>
{
    typedef _Class& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>
{
    typedef _Class const& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false>
{
    typedef _Class const& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>
{
    typedef _Class volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false>
{
    typedef _Class volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>
{
    typedef _Class const volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false>
{
    typedef _Class const volatile& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>
{
    typedef _Class&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false>
{
    typedef _Class&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>
{
    typedef _Class const&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false>
{
    typedef _Class const&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>
{
    typedef _Class volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false>
{
    typedef _Class volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>
{
    typedef _Class const volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param...);
};
template <class _Rp, class _Class, class ..._Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false>
{
    typedef _Class const volatile&& _ClassType;
    typedef _Rp _ReturnType;
    typedef _Rp (_FnType) (_Param..., ...);
};
template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp _Class::*, false, true>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
};
template <class _MP>
struct __member_pointer_traits
    : public __member_pointer_traits_imp<__remove_cv_t<_MP>,
                    is_member_function_pointer<_MP>::value,
                    is_member_object_pointer<_MP>::value>
{
};
template <class _DecayedFp>
struct __member_pointer_class_type {};
template <class _Ret, class _ClassType>
struct __member_pointer_class_type<_Ret _ClassType::*> {
  typedef _ClassType type;
};
template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet1 = typename enable_if
    <
        is_member_function_pointer<_DecayFp>::value
        && is_base_of<_ClassT, _DecayA0>::value
    >::type;
template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type>
using __enable_if_bullet2 = typename enable_if
    <
        is_member_function_pointer<_DecayFp>::value
        && __is_reference_wrapper<_DecayA0>::value
    >::type;
template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet3 = typename enable_if
    <
        is_member_function_pointer<_DecayFp>::value
        && !is_base_of<_ClassT, _DecayA0>::value
        && !__is_reference_wrapper<_DecayA0>::value
    >::type;
template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet4 = typename enable_if
    <
        is_member_object_pointer<_DecayFp>::value
        && is_base_of<_ClassT, _DecayA0>::value
    >::type;
template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type>
using __enable_if_bullet5 = typename enable_if
    <
        is_member_object_pointer<_DecayFp>::value
        && __is_reference_wrapper<_DecayA0>::value
    >::type;
template <class _Fp, class _A0,
         class _DecayFp = typename decay<_Fp>::type,
         class _DecayA0 = typename decay<_A0>::type,
         class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet6 = typename enable_if
    <
        is_member_object_pointer<_DecayFp>::value
        && !is_base_of<_ClassT, _DecayA0>::value
        && !__is_reference_wrapper<_DecayA0>::value
    >::type;
template <class ..._Args>
__nat __invoke(__any, _Args&& ...__args);
template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet1<_Fp, _A0> >
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr decltype((std::declval<_A0>().*std::declval<_Fp>())(std::declval<_Args>()...))
__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
    noexcept(noexcept((static_cast<_A0&&>(__a0).*__f)(static_cast<_Args&&>(__args)...)))
    { return (static_cast<_A0&&>(__a0).*__f)(static_cast<_Args&&>(__args)...); }
template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet2<_Fp, _A0> >
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr decltype((std::declval<_A0>().get().*std::declval<_Fp>())(std::declval<_Args>()...))
__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
    noexcept(noexcept((__a0.get().*__f)(static_cast<_Args&&>(__args)...)))
    { return (__a0.get().*__f)(static_cast<_Args&&>(__args)...); }
template <class _Fp, class _A0, class ..._Args,
          class = __enable_if_bullet3<_Fp, _A0> >
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr decltype(((*std::declval<_A0>()).*std::declval<_Fp>())(std::declval<_Args>()...))
__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
    noexcept(noexcept(((*static_cast<_A0&&>(__a0)).*__f)(static_cast<_Args&&>(__args)...)))
    { return ((*static_cast<_A0&&>(__a0)).*__f)(static_cast<_Args&&>(__args)...); }
template <class _Fp, class _A0,
          class = __enable_if_bullet4<_Fp, _A0> >
// added by concept-synth, original LN: 726
requires
requires (_Fp x0, _A0 x1) { x1 .* x0; }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr decltype(std::declval<_A0>().*std::declval<_Fp>())
__invoke(_Fp&& __f, _A0&& __a0)
    noexcept(noexcept(static_cast<_A0&&>(__a0).*__f))
    { return static_cast<_A0&&>(__a0).*__f; }
template <class _Fp, class _A0,
          class = __enable_if_bullet5<_Fp, _A0> >
// added by concept-synth, original LN: 733
requires
requires (_A0 o) { o.get(); }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr decltype(std::declval<_A0>().get().*std::declval<_Fp>())
__invoke(_Fp&& __f, _A0&& __a0)
    noexcept(noexcept(__a0.get().*__f))
    { return __a0.get().*__f; }
template <class _Fp, class _A0,
          class = __enable_if_bullet6<_Fp, _A0> >
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr decltype((*std::declval<_A0>()).*std::declval<_Fp>())
__invoke(_Fp&& __f, _A0&& __a0)
    noexcept(noexcept((*static_cast<_A0&&>(__a0)).*__f))
    { return (*static_cast<_A0&&>(__a0)).*__f; }
template <class _Fp, class ..._Args>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr decltype(std::declval<_Fp>()(std::declval<_Args>()...))
__invoke(_Fp&& __f, _Args&& ...__args)
    noexcept(noexcept(static_cast<_Fp&&>(__f)(static_cast<_Args&&>(__args)...)))
    { return static_cast<_Fp&&>(__f)(static_cast<_Args&&>(__args)...); }
template <class _Ret, class _Fp, class ..._Args>
struct __invokable_r
{
  template <class _XFp, class ..._XArgs>
  static decltype(std::__invoke(std::declval<_XFp>(), std::declval<_XArgs>()...)) __try_call(int);
  template <class _XFp, class ..._XArgs>
  static __nat __try_call(...);
  using _Result = decltype(__try_call<_Fp, _Args...>(0));
  using type = __conditional_t<
      _IsNotSame<_Result, __nat>::value,
      __conditional_t<is_void<_Ret>::value, true_type, __is_core_convertible<_Result, _Ret> >,
      false_type>;
  static const bool value = type::value;
};
template <class _Fp, class ..._Args>
using __invokable = __invokable_r<void, _Fp, _Args...>;
template <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp, class ..._Args>
struct __nothrow_invokable_r_imp {
  static const bool value = false;
};
template <class _Ret, class _Fp, class ..._Args>
struct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...>
{
    typedef __nothrow_invokable_r_imp _ThisT;
    template <class _Tp>
    static void __test_noexcept(_Tp) noexcept;
    static const bool value = noexcept(_ThisT::__test_noexcept<_Ret>(
        std::__invoke(std::declval<_Fp>(), std::declval<_Args>()...)));
};
template <class _Ret, class _Fp, class ..._Args>
struct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...>
{
    static const bool value = noexcept(
        std::__invoke(std::declval<_Fp>(), std::declval<_Args>()...));
};
template <class _Ret, class _Fp, class ..._Args>
using __nothrow_invokable_r =
    __nothrow_invokable_r_imp<
            __invokable_r<_Ret, _Fp, _Args...>::value,
            is_void<_Ret>::value,
            _Ret, _Fp, _Args...
    >;
template <class _Fp, class ..._Args>
using __nothrow_invokable =
    __nothrow_invokable_r_imp<
            __invokable<_Fp, _Args...>::value,
            true, void, _Fp, _Args...
    >;
template <class _Fp, class ..._Args>
struct __invoke_of
    : public enable_if<
        __invokable<_Fp, _Args...>::value,
        typename __invokable_r<void, _Fp, _Args...>::_Result>
{
};
template <class _Ret, bool = is_void<_Ret>::value>
struct __invoke_void_return_wrapper
{
    template <class ..._Args>
    static _Ret __call(_Args&&... __args) {
        return std::__invoke(std::forward<_Args>(__args)...);
    }
};
template <class _Ret>
struct __invoke_void_return_wrapper<_Ret, true>
{
    template <class ..._Args>
    static void __call(_Args&&... __args) {
        std::__invoke(std::forward<_Args>(__args)...);
    }
};
template <class _Fn, class ..._Args>
struct __attribute__((__type_visibility__("default"))) is_invocable
    : integral_constant<bool, __invokable<_Fn, _Args...>::value> {};
template <class _Ret, class _Fn, class ..._Args>
struct __attribute__((__type_visibility__("default"))) is_invocable_r
    : integral_constant<bool, __invokable_r<_Ret, _Fn, _Args...>::value> {};
template <class _Fn, class ..._Args>
inline constexpr bool is_invocable_v = is_invocable<_Fn, _Args...>::value;
template <class _Ret, class _Fn, class ..._Args>
inline constexpr bool is_invocable_r_v = is_invocable_r<_Ret, _Fn, _Args...>::value;
template <class _Fn, class ..._Args>
struct __attribute__((__type_visibility__("default"))) is_nothrow_invocable
    : integral_constant<bool, __nothrow_invokable<_Fn, _Args...>::value> {};
template <class _Ret, class _Fn, class ..._Args>
struct __attribute__((__type_visibility__("default"))) is_nothrow_invocable_r
    : integral_constant<bool, __nothrow_invokable_r<_Ret, _Fn, _Args...>::value> {};
template <class _Fn, class ..._Args>
inline constexpr bool is_nothrow_invocable_v = is_nothrow_invocable<_Fn, _Args...>::value;
template <class _Ret, class _Fn, class ..._Args>
inline constexpr bool is_nothrow_invocable_r_v = is_nothrow_invocable_r<_Ret, _Fn, _Args...>::value;
template <class _Fn, class... _Args>
struct __attribute__((__type_visibility__("default"))) invoke_result
    : __invoke_of<_Fn, _Args...>
{
};
template <class _Fn, class... _Args>
using invoke_result_t = typename invoke_result<_Fn, _Args...>::type;
template <class _Fn, class ..._Args>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr invoke_result_t<_Fn, _Args...>
invoke(_Fn&& __f, _Args&&... __args)
    noexcept(is_nothrow_invocable_v<_Fn, _Args...>)
{
    return std::__invoke(std::forward<_Fn>(__f), std::forward<_Args>(__args)...);
}
}}
namespace std { inline namespace __1 {
template <class>
struct __attribute__((__type_visibility__("default"))) hash;
}}
namespace std { inline namespace __1 {
template <class _Tp> struct __attribute__((__type_visibility__("default"))) add_const {
  typedef __attribute__((__nodebug__)) const _Tp type;
};
template <class _Tp> using add_const_t = typename add_const<_Tp>::type;
}}
namespace std { inline namespace __1 {
template <class _Tp> struct __attribute__((__type_visibility__("default"))) add_cv {
  typedef __attribute__((__nodebug__)) const volatile _Tp type;
};
template <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;
}}
namespace std { inline namespace __1 {
template <class _Tp>
using __add_rvalue_reference_t = __add_rvalue_reference(_Tp);
template <class _Tp>
struct add_rvalue_reference {
  using type = __add_rvalue_reference_t<_Tp>;
};
template <class _Tp>
using add_rvalue_reference_t = __add_rvalue_reference_t<_Tp>;
}}
namespace std { inline namespace __1 {
template <class _Tp> struct __attribute__((__type_visibility__("default"))) add_volatile {
  typedef __attribute__((__nodebug__)) volatile _Tp type;
};
template <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;
}}
namespace std { inline namespace __1 {
template <class _Hp, class _Tp>
struct __type_list
{
    typedef _Hp _Head;
    typedef _Tp _Tail;
};
template <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;
template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, true>
{
    typedef __attribute__((__nodebug__)) _Hp type;
};
template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, false>
{
    typedef __attribute__((__nodebug__)) typename __find_first<_Tp, _Size>::type type;
};
}}
namespace std { inline namespace __1 {
template <class _Tp>
struct __align_type
{
    static const size_t value = __alignof(_Tp);
    typedef _Tp type;
};
struct __struct_double {long double __lx;};
struct __struct_double4 {double __lx[4];};
typedef
    __type_list<__align_type<unsigned char>,
    __type_list<__align_type<unsigned short>,
    __type_list<__align_type<unsigned int>,
    __type_list<__align_type<unsigned long>,
    __type_list<__align_type<unsigned long long>,
    __type_list<__align_type<double>,
    __type_list<__align_type<long double>,
    __type_list<__align_type<__struct_double>,
    __type_list<__align_type<__struct_double4>,
    __type_list<__align_type<int*>,
    __nat
    > > > > > > > > > > __all_types;
template <size_t _Align>
struct alignas(_Align) __fallback_overaligned {};
template <class _TL, size_t _Align> struct __find_pod;
template <class _Hp, size_t _Align>
struct __find_pod<__type_list<_Hp, __nat>, _Align>
{
    typedef __conditional_t<_Align == _Hp::value, typename _Hp::type, __fallback_overaligned<_Align> > type;
};
template <class _Hp, class _Tp, size_t _Align>
struct __find_pod<__type_list<_Hp, _Tp>, _Align>
{
    typedef __conditional_t<_Align == _Hp::value, typename _Hp::type, typename __find_pod<_Tp, _Align>::type> type;
};
template <class _TL, size_t _Len> struct __find_max_align;
template <class _Hp, size_t _Len>
struct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};
template <size_t _Len, size_t _A1, size_t _A2>
struct __select_align
{
private:
    static const size_t __min = _A2 < _A1 ? _A2 : _A1;
    static const size_t __max = _A1 < _A2 ? _A2 : _A1;
public:
    static const size_t value = _Len < __max ? __min : __max;
};
template <class _Hp, class _Tp, size_t _Len>
struct __find_max_align<__type_list<_Hp, _Tp>, _Len>
    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};
template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
struct __attribute__((__type_visibility__("default"))) aligned_storage
{
    typedef typename __find_pod<__all_types, _Align>::type _Aligner;
    union type
    {
        _Aligner __align;
        unsigned char __data[(_Len + _Align - 1)/_Align * _Align];
    };
};
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;
#pragma GCC diagnostic pop
template <size_t _Len>struct __attribute__((__type_visibility__("default"))) aligned_storage<_Len, 0x1>{ struct alignas(0x1) type { unsigned char __lx[(_Len + 0x1 - 1)/0x1 * 0x1]; };};
template <size_t _Len>struct __attribute__((__type_visibility__("default"))) aligned_storage<_Len, 0x2>{ struct alignas(0x2) type { unsigned char __lx[(_Len + 0x2 - 1)/0x2 * 0x2]; };};
template <size_t _Len>struct __attribute__((__type_visibility__("default"))) aligned_storage<_Len, 0x4>{ struct alignas(0x4) type { unsigned char __lx[(_Len + 0x4 - 1)/0x4 * 0x4]; };};
template <size_t _Len>struct __attribute__((__type_visibility__("default"))) aligned_storage<_Len, 0x8>{ struct alignas(0x8) type { unsigned char __lx[(_Len + 0x8 - 1)/0x8 * 0x8]; };};
template <size_t _Len>struct __attribute__((__type_visibility__("default"))) aligned_storage<_Len, 0x10>{ struct alignas(0x10) type { unsigned char __lx[(_Len + 0x10 - 1)/0x10 * 0x10]; };};
template <size_t _Len>struct __attribute__((__type_visibility__("default"))) aligned_storage<_Len, 0x20>{ struct alignas(0x20) type { unsigned char __lx[(_Len + 0x20 - 1)/0x20 * 0x20]; };};
template <size_t _Len>struct __attribute__((__type_visibility__("default"))) aligned_storage<_Len, 0x40>{ struct alignas(0x40) type { unsigned char __lx[(_Len + 0x40 - 1)/0x40 * 0x40]; };};
template <size_t _Len>struct __attribute__((__type_visibility__("default"))) aligned_storage<_Len, 0x80>{ struct alignas(0x80) type { unsigned char __lx[(_Len + 0x80 - 1)/0x80 * 0x80]; };};
template <size_t _Len>struct __attribute__((__type_visibility__("default"))) aligned_storage<_Len, 0x100>{ struct alignas(0x100) type { unsigned char __lx[(_Len + 0x100 - 1)/0x100 * 0x100]; };};
template <size_t _Len>struct __attribute__((__type_visibility__("default"))) aligned_storage<_Len, 0x200>{ struct alignas(0x200) type { unsigned char __lx[(_Len + 0x200 - 1)/0x200 * 0x200]; };};
template <size_t _Len>struct __attribute__((__type_visibility__("default"))) aligned_storage<_Len, 0x400>{ struct alignas(0x400) type { unsigned char __lx[(_Len + 0x400 - 1)/0x400 * 0x400]; };};
template <size_t _Len>struct __attribute__((__type_visibility__("default"))) aligned_storage<_Len, 0x800>{ struct alignas(0x800) type { unsigned char __lx[(_Len + 0x800 - 1)/0x800 * 0x800]; };};
template <size_t _Len>struct __attribute__((__type_visibility__("default"))) aligned_storage<_Len, 0x1000>{ struct alignas(0x1000) type { unsigned char __lx[(_Len + 0x1000 - 1)/0x1000 * 0x1000]; };};
template <size_t _Len>struct __attribute__((__type_visibility__("default"))) aligned_storage<_Len, 0x2000>{ struct alignas(0x2000) type { unsigned char __lx[(_Len + 0x2000 - 1)/0x2000 * 0x2000]; };};
template <size_t _Len>struct __attribute__((__type_visibility__("default"))) aligned_storage<_Len, 0x4000>{ struct alignas(0x4000) type { unsigned char __lx[(_Len + 0x4000 - 1)/0x4000 * 0x4000]; };};
}}
namespace std { inline namespace __1 {
template <size_t _I0, size_t ..._In>
struct __static_max;
template <size_t _I0>
struct __static_max<_I0>
{
    static const size_t value = _I0;
};
template <size_t _I0, size_t _I1, size_t ..._In>
struct __static_max<_I0, _I1, _In...>
{
    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :
                                             __static_max<_I1, _In...>::value;
};
template <size_t _Len, class _Type0, class ..._Types>
struct aligned_union
{
    static const size_t alignment_value = __static_max<__alignof(_Type0),
                                                       __alignof(_Types)...>::value;
    static const size_t __len = __static_max<_Len, sizeof(_Type0),
                                             sizeof(_Types)...>::value;
    typedef typename aligned_storage<__len, alignment_value>::type type;
};
template <size_t _Len, class... _Types>
using aligned_union_t = typename aligned_union<_Len, _Types...>::type;
}}
namespace std { inline namespace __1 {
template <class _Tp> struct __attribute__((__type_visibility__("default"))) alignment_of
    : public integral_constant<size_t, alignof(_Tp)> {};
template <class _Tp>
inline constexpr size_t alignment_of_v = alignof(_Tp);
}}

namespace std { inline namespace __1 {
template <class, class>
struct __attribute__((__type_visibility__("default"))) pair;
}}
namespace std { inline namespace __1 {
template <class _Tp>
using __remove_const_ref_t = __remove_const_t<__libcpp_remove_reference_t<_Tp> >;
}}
namespace std { inline namespace __1 {
struct __extract_key_fail_tag {};
struct __extract_key_self_tag {};
struct __extract_key_first_tag {};
template <class _ValTy, class _Key, class _RawValTy = __remove_const_ref_t<_ValTy> >
struct __can_extract_key
    : __conditional_t<_IsSame<_RawValTy, _Key>::value, __extract_key_self_tag, __extract_key_fail_tag> {};
template <class _Pair, class _Key, class _First, class _Second>
struct __can_extract_key<_Pair, _Key, pair<_First, _Second> >
    : __conditional_t<_IsSame<__remove_const_t<_First>, _Key>::value, __extract_key_first_tag, __extract_key_fail_tag> {
};
template <class _ValTy, class _Key, class _ContainerValueTy,
          class _RawValTy = __remove_const_ref_t<_ValTy> >
struct __can_extract_map_key
    : integral_constant<bool, _IsSame<_RawValTy, _Key>::value> {};
template <class _ValTy, class _Key, class _RawValTy>
struct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy>
    : false_type {};
}}
namespace std { inline namespace __1 {
template <class _Tp>
using __remove_cvref_t __attribute__((__nodebug__)) = __remove_cvref(_Tp);
template <class _Tp, class _Up>
struct __is_same_uncvref : _IsSame<__remove_cvref_t<_Tp>, __remove_cvref_t<_Up> > {};
template <class _Tp>
struct remove_cvref {
    using type __attribute__((__nodebug__)) = __remove_cvref_t<_Tp>;
};
template <class _Tp> using remove_cvref_t = __remove_cvref_t<_Tp>;
}}
namespace std { inline namespace __1 {
template <class...> using void_t = void;
template <class...>
using __void_t = void;
}}
namespace std { inline namespace __1 {
template <class _Tp, class _Up>
using __cond_type = decltype(false ? std::declval<_Tp>() : std::declval<_Up>());
template <class _Tp, class _Up, class = void>
struct __common_type3 {};
template <class _Tp, class _Up>
struct __common_type3<_Tp, _Up, void_t<__cond_type<const _Tp&, const _Up&>>>
{
    using type = remove_cvref_t<__cond_type<const _Tp&, const _Up&>>;
};
template <class _Tp, class _Up, class = void>
struct __common_type2_imp : __common_type3<_Tp, _Up> {};
template <class _Tp, class _Up>
struct __common_type2_imp<_Tp, _Up, __void_t<decltype(true ? std::declval<_Tp>() : std::declval<_Up>())> >
{
  typedef __attribute__((__nodebug__)) typename decay<decltype(
                         true ? std::declval<_Tp>() : std::declval<_Up>()
                         )>::type type;
};
template <class, class = void>
struct __common_type_impl {};
template <class... _Tp>
struct __common_types;
template <class... _Tp>
struct __attribute__((__type_visibility__("default"))) common_type;
template <class _Tp, class _Up>
struct __common_type_impl<
    __common_types<_Tp, _Up>, __void_t<typename common_type<_Tp, _Up>::type> >
{
  typedef typename common_type<_Tp, _Up>::type type;
};
template <class _Tp, class _Up, class _Vp , class... _Rest>
struct __common_type_impl<
    __common_types<_Tp, _Up, _Vp , _Rest...>,
    __void_t<typename common_type<_Tp, _Up>::type> >
    : __common_type_impl<__common_types<typename common_type<_Tp, _Up>::type,
                                        _Vp , _Rest...> > {
};
template <>
struct __attribute__((__type_visibility__("default"))) common_type<> {};
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) common_type<_Tp>
    : public common_type<_Tp, _Tp> {};
template <class _Tp, class _Up>
struct __attribute__((__type_visibility__("default"))) common_type<_Tp, _Up>
    : conditional<
        _IsSame<_Tp, typename decay<_Tp>::type>::value && _IsSame<_Up, typename decay<_Up>::type>::value,
        __common_type2_imp<_Tp, _Up>,
        common_type<typename decay<_Tp>::type, typename decay<_Up>::type>
    >::type
{};
template <class _Tp, class _Up, class _Vp , class... _Rest>
struct __attribute__((__type_visibility__("default")))
    common_type<_Tp, _Up, _Vp , _Rest...>
    : __common_type_impl<
          __common_types<_Tp, _Up, _Vp , _Rest...> > {};
template <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;
}}
namespace std { inline namespace __1 {
template <class _From, class _To>
struct __copy_cv
{
    using type = _To;
};
template <class _From, class _To>
struct __copy_cv<const _From, _To>
{
    using type = typename add_const<_To>::type;
};
template <class _From, class _To>
struct __copy_cv<volatile _From, _To>
{
    using type = typename add_volatile<_To>::type;
};
template <class _From, class _To>
struct __copy_cv<const volatile _From, _To>
{
    using type = typename add_cv<_To>::type;
};
template <class _From, class _To>
using __copy_cv_t = typename __copy_cv<_From, _To>::type;
}}
namespace std { inline namespace __1 {
template <class _From, class _To>
struct __copy_cvref
{
    using type = __copy_cv_t<_From, _To>;
};
template <class _From, class _To>
struct __copy_cvref<_From&, _To>
{
    using type = __add_lvalue_reference_t<__copy_cv_t<_From, _To> >;
};
template <class _From, class _To>
struct __copy_cvref<_From&&, _To>
{
    using type = __add_rvalue_reference_t<__copy_cv_t<_From, _To> >;
};
template <class _From, class _To>
using __copy_cvref_t = typename __copy_cvref<_From, _To>::type;
}}
namespace std { inline namespace __1 {
template <class _T1, class _T2> struct __attribute__((__type_visibility__("default"))) is_convertible
    : public integral_constant<bool, __is_convertible_to(_T1, _T2)> {};
template <class _From, class _To>
inline constexpr bool is_convertible_v = is_convertible<_From, _To>::value;
}}
namespace std { inline namespace __1 {
template <class _Xp, class _Yp>
using __cond_res =
    decltype(false ? std::declval<_Xp(&)()>()() : std::declval<_Yp(&)()>()());
template <class _Tp>
struct __xref {
  template<class _Up>
  using __apply = __copy_cvref_t<_Tp, _Up>;
};
template<class _Ap, class _Bp, class _Xp = remove_reference_t<_Ap>, class _Yp = remove_reference_t<_Bp>>
struct __common_ref;
template<class _Xp, class _Yp>
using __common_ref_t = typename __common_ref<_Xp, _Yp>::__type;
template<class _Xp, class _Yp>
using __cv_cond_res = __cond_res<__copy_cv_t<_Xp, _Yp>&, __copy_cv_t<_Yp, _Xp>&>;
template<class _Ap, class _Bp, class _Xp, class _Yp>
requires requires { typename __cv_cond_res<_Xp, _Yp>; } && is_reference_v<__cv_cond_res<_Xp, _Yp>>
struct __common_ref<_Ap&, _Bp&, _Xp, _Yp>
{
    using __type = __cv_cond_res<_Xp, _Yp>;
};
template <class _Xp, class _Yp>
using __common_ref_C = remove_reference_t<__common_ref_t<_Xp&, _Yp&>>&&;
template<class _Ap, class _Bp, class _Xp, class _Yp>
requires
  requires { typename __common_ref_C<_Xp, _Yp>; } &&
  is_convertible_v<_Ap&&, __common_ref_C<_Xp, _Yp>> &&
  is_convertible_v<_Bp&&, __common_ref_C<_Xp, _Yp>>
struct __common_ref<_Ap&&, _Bp&&, _Xp, _Yp>
{
    using __type = __common_ref_C<_Xp, _Yp>;
};
template <class _Tp, class _Up>
using __common_ref_D = __common_ref_t<const _Tp&, _Up&>;
template<class _Ap, class _Bp, class _Xp, class _Yp>
requires requires { typename __common_ref_D<_Xp, _Yp>; } &&
         is_convertible_v<_Ap&&, __common_ref_D<_Xp, _Yp>>
struct __common_ref<_Ap&&, _Bp&, _Xp, _Yp>
{
    using __type = __common_ref_D<_Xp, _Yp>;
};
template<class _Ap, class _Bp, class _Xp, class _Yp>
struct __common_ref<_Ap&, _Bp&&, _Xp, _Yp> : __common_ref<_Bp&&, _Ap&> {};
template<class _Ap, class _Bp, class _Xp, class _Yp>
struct __common_ref {};
template <class...>
struct common_reference;
template <class... _Types>
using common_reference_t = typename common_reference<_Types...>::type;
template<>
struct common_reference<> {};
template <class _Tp>
struct common_reference<_Tp>
{
    using type = _Tp;
};
template <class _Tp, class _Up> struct __common_reference_sub_bullet3;
template <class _Tp, class _Up> struct __common_reference_sub_bullet2 : __common_reference_sub_bullet3<_Tp, _Up> {};
template <class _Tp, class _Up> struct __common_reference_sub_bullet1 : __common_reference_sub_bullet2<_Tp, _Up> {};
template <class _Tp, class _Up> struct common_reference<_Tp, _Up> : __common_reference_sub_bullet1<_Tp, _Up> {};
template <class _Tp, class _Up>
requires is_reference_v<_Tp> && is_reference_v<_Up> && requires { typename __common_ref_t<_Tp, _Up>; }
struct __common_reference_sub_bullet1<_Tp, _Up>
{
    using type = __common_ref_t<_Tp, _Up>;
};
template <class, class, template <class> class, template <class> class> struct basic_common_reference {};
template <class _Tp, class _Up>
using __basic_common_reference_t = typename basic_common_reference<
    remove_cvref_t<_Tp>, remove_cvref_t<_Up>,
    __xref<_Tp>::template __apply, __xref<_Up>::template __apply>::type;
template <class _Tp, class _Up>
requires requires { typename __basic_common_reference_t<_Tp, _Up>; }
struct __common_reference_sub_bullet2<_Tp, _Up>
{
    using type = __basic_common_reference_t<_Tp, _Up>;
};
template <class _Tp, class _Up>
requires requires { typename __cond_res<_Tp, _Up>; }
struct __common_reference_sub_bullet3<_Tp, _Up>
{
    using type = __cond_res<_Tp, _Up>;
};
template <class _Tp, class _Up> struct __common_reference_sub_bullet3 : common_type<_Tp, _Up> {};
template <class _Tp, class _Up, class _Vp, class... _Rest>
requires requires { typename common_reference_t<_Tp, _Up>; }
struct common_reference<_Tp, _Up, _Vp, _Rest...>
    : common_reference<common_reference_t<_Tp, _Up>, _Vp, _Rest...>
{};
template <class...> struct common_reference {};
}}
namespace std { inline namespace __1 {
template <class...>
using __expand_to_true = true_type;
template <class... _Pred>
__expand_to_true<__enable_if_t<_Pred::value>...> __and_helper(int);
template <class...>
false_type __and_helper(...);
template <class... _Pred>
using _And __attribute__((__nodebug__)) = decltype(std::__and_helper<_Pred...>(0));
template <class...>
struct conjunction : true_type {};
template <class _Arg>
struct conjunction<_Arg> : _Arg {};
template <class _Arg, class... _Args>
struct conjunction<_Arg, _Args...> : conditional_t<!bool(_Arg::value), _Arg, conjunction<_Args...>> {};
template <class... _Args>
inline constexpr bool conjunction_v = conjunction<_Args...>::value;
}}

namespace std { inline namespace __1 {
template <class _Tp, bool>
struct __attribute__((__type_visibility__("default"))) __dependent_type : public _Tp {};
}}
namespace std { inline namespace __1 {
template <bool>
struct _OrImpl;
template <>
struct _OrImpl<true> {
  template <class _Res, class _First, class... _Rest>
  using _Result __attribute__((__nodebug__)) =
      typename _OrImpl<!bool(_First::value) && sizeof...(_Rest) != 0>::template _Result<_First, _Rest...>;
};
template <>
struct _OrImpl<false> {
  template <class _Res, class...>
  using _Result = _Res;
};
template <class... _Args>
using _Or __attribute__((__nodebug__)) = typename _OrImpl<sizeof...(_Args) != 0>::template _Result<false_type, _Args...>;
template <class... _Args>
struct disjunction : _Or<_Args...> {};
template <class... _Args>
inline constexpr bool disjunction_v = _Or<_Args...>::value;
}}

namespace std { inline namespace __1 {
template<class _Tp, size_t _Dim = 0>
struct __attribute__((__type_visibility__("default"))) extent
    : integral_constant<size_t, __array_extent(_Tp, _Dim)> { };
template <class _Tp, unsigned _Ip = 0>
inline constexpr size_t extent_v = __array_extent(_Tp, _Ip);
}}
namespace std { inline namespace __1 {
template <class _Tp>
struct remove_all_extents {
  using type __attribute__((__nodebug__)) = __remove_all_extents(_Tp);
};
template <class _Tp>
using __remove_all_extents_t = __remove_all_extents(_Tp);
template <class _Tp> using remove_all_extents_t = __remove_all_extents_t<_Tp>;
}}
namespace std { inline namespace __1 {
template <class _Tp> struct __attribute__((__type_visibility__("default"))) has_unique_object_representations
    : public integral_constant<bool,
       __has_unique_object_representations(remove_cv_t<remove_all_extents_t<_Tp>>)> {};
template <class _Tp>
inline constexpr bool has_unique_object_representations_v = has_unique_object_representations<_Tp>::value;
}}
namespace std { inline namespace __1 {
template <class _Tp> struct __attribute__((__type_visibility__("default"))) has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};
template <class _Tp>
inline constexpr bool has_virtual_destructor_v = __has_virtual_destructor(_Tp);
}}

namespace std { inline namespace __1 {
template <class _Tp> struct __attribute__((__type_visibility__("default"))) is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)> {};
template <class _Tp>
inline constexpr bool is_abstract_v = __is_abstract(_Tp);
}}
namespace std { inline namespace __1 {
template <class _Tp> struct __attribute__((__type_visibility__("default")))
is_aggregate : public integral_constant<bool, __is_aggregate(_Tp)> {};
template <class _Tp>
inline constexpr bool is_aggregate_v = __is_aggregate(_Tp);
}}
namespace std { inline namespace __1 {
template <class _Tp> struct __libcpp_is_floating_point : public false_type {};
template <> struct __libcpp_is_floating_point<float> : public true_type {};
template <> struct __libcpp_is_floating_point<double> : public true_type {};
template <> struct __libcpp_is_floating_point<long double> : public true_type {};
template <class _Tp> struct __attribute__((__type_visibility__("default"))) is_floating_point
    : public __libcpp_is_floating_point<__remove_cv_t<_Tp> > {};
template <class _Tp>
inline constexpr bool is_floating_point_v = is_floating_point<_Tp>::value;
}}
namespace std { inline namespace __1 {
template <class _Tp> struct __attribute__((__type_visibility__("default"))) is_arithmetic
    : public integral_constant<bool, is_integral<_Tp>::value ||
                                     is_floating_point<_Tp>::value> {};
template <class _Tp>
inline constexpr bool is_arithmetic_v = is_arithmetic<_Tp>::value;
}}

namespace std { inline namespace __1 {
template<class _Tp, class _Up>
struct __attribute__((__type_visibility__("default"))) is_assignable : _BoolConstant<__is_assignable(_Tp, _Up)> { };
template <class _Tp, class _Arg>
inline constexpr bool is_assignable_v = __is_assignable(_Tp, _Arg);
}}

namespace std { inline namespace __1 {
template <class> struct __attribute__((__type_visibility__("default"))) __libcpp_is_bounded_array : false_type {};
template <class _Tp, size_t _Np> struct __attribute__((__type_visibility__("default"))) __libcpp_is_bounded_array<_Tp[_Np]> : true_type {};
template <class> struct __attribute__((__type_visibility__("default"))) is_bounded_array : false_type {};
template <class _Tp, size_t _Np> struct __attribute__((__type_visibility__("default"))) is_bounded_array<_Tp[_Np]> : true_type {};
template <class _Tp>
inline constexpr
bool is_bounded_array_v = is_bounded_array<_Tp>::value;
}}
namespace std { inline namespace __1 {
template<class _Func, class... _Args, class = decltype(std::declval<_Func>()(std::declval<_Args>()...))>
true_type __is_callable_helper(int);
template<class...>
false_type __is_callable_helper(...);
template<class _Func, class... _Args>
struct __is_callable : decltype(std::__is_callable_helper<_Func, _Args...>(0)) {};
}}
namespace std { inline namespace __1 {
template <class _Tp> struct __attribute__((__type_visibility__("default"))) is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    {};
template <class _Tp>
inline constexpr bool is_standard_layout_v = __is_standard_layout(_Tp);
}}
namespace std { inline namespace __1 {
template <class _Tp> struct __attribute__((__type_visibility__("default"))) is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    {};
template <class _Tp>
inline constexpr bool is_trivial_v = __is_trivial(_Tp);
}}
namespace std { inline namespace __1 {
template <class _CharT>
using _IsCharLikeType = _And<is_standard_layout<_CharT>, is_trivial<_CharT> >;
}}
namespace std { inline namespace __1 {
template <class _Tp> struct __attribute__((__type_visibility__("default"))) is_class
    : public integral_constant<bool, __is_class(_Tp)> {};
template <class _Tp>
inline constexpr bool is_class_v = __is_class(_Tp);
}}
namespace std { inline namespace __1 {
template <class _Tp> struct __is_nullptr_t_impl : public false_type {};
template <> struct __is_nullptr_t_impl<nullptr_t> : public true_type {};
template <class _Tp> struct __attribute__((__type_visibility__("default"))) __is_nullptr_t
    : public __is_nullptr_t_impl<__remove_cv_t<_Tp> > {};
template <class _Tp> struct __attribute__((__type_visibility__("default"))) is_null_pointer
    : public __is_nullptr_t_impl<__remove_cv_t<_Tp> > {};
template <class _Tp>
inline constexpr bool is_null_pointer_v = is_null_pointer<_Tp>::value;
}}
namespace std { inline namespace __1 {
template<class _Tp>
struct __attribute__((__type_visibility__("default"))) is_fundamental : _BoolConstant<__is_fundamental(_Tp)> { };
template <class _Tp>
inline constexpr bool is_fundamental_v = __is_fundamental(_Tp);
}}
namespace std { inline namespace __1 {
template<class _Tp>
struct __attribute__((__type_visibility__("default"))) is_compound : _BoolConstant<__is_compound(_Tp)> { };
template <class _Tp>
inline constexpr bool is_compound_v = __is_compound(_Tp);
}}
namespace std { inline namespace __1 {
template <class _Tp, class ..._Args>
struct __attribute__((__type_visibility__("default"))) is_constructible
    : public integral_constant<bool, __is_constructible(_Tp, _Args...)>
{ };
template <class _Tp, class ..._Args>
inline constexpr bool is_constructible_v = __is_constructible(_Tp, _Args...);
}}

namespace std { inline namespace __1 {
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_copy_assignable
    : public integral_constant<
          bool,
          __is_assignable(__add_lvalue_reference_t<_Tp>,
                          __add_lvalue_reference_t<typename add_const<_Tp>::type>)> {};
template <class _Tp>
inline constexpr bool is_copy_assignable_v = is_copy_assignable<_Tp>::value;
}}
namespace std { inline namespace __1 {
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_copy_constructible
    : public integral_constant<
          bool,
          __is_constructible(_Tp, __add_lvalue_reference_t<typename add_const<_Tp>::type>)> {};
template <class _Tp>
inline constexpr bool is_copy_constructible_v = is_copy_constructible<_Tp>::value;
}}
namespace std { inline namespace __1 {
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_default_constructible
    : public integral_constant<bool, __is_constructible(_Tp)>
    {};
template <class _Tp>
inline constexpr bool is_default_constructible_v = __is_constructible(_Tp);
}}
namespace std { inline namespace __1 {
template<class _Tp>
struct __attribute__((__type_visibility__("default"))) is_destructible : _BoolConstant<__is_destructible(_Tp)> { };
template <class _Tp>
inline constexpr bool is_destructible_v = __is_destructible(_Tp);
}}
namespace std { inline namespace __1 {
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_empty
    : public integral_constant<bool, __is_empty(_Tp)> {};
template <class _Tp>
inline constexpr bool is_empty_v = __is_empty(_Tp);
}}
namespace std { inline namespace __1 {
template <class _Tp> struct __attribute__((__type_visibility__("default"))) is_enum
    : public integral_constant<bool, __is_enum(_Tp)> {};
template <class _Tp>
inline constexpr bool is_enum_v = __is_enum(_Tp);
}}
namespace std { inline namespace __1 {
template <class _Tp> struct __attribute__((__type_visibility__("default")))
__libcpp_is_final : public integral_constant<bool, __is_final(_Tp)> {};
template <class _Tp> struct __attribute__((__type_visibility__("default")))
is_final : public integral_constant<bool, __is_final(_Tp)> {};
template <class _Tp>
inline constexpr bool is_final_v = __is_final(_Tp);
}}
namespace std { inline namespace __1 {
template <class _Tp>
void __test_implicit_default_constructible(_Tp);
template <class _Tp, class = void, class = typename is_default_constructible<_Tp>::type>
struct __is_implicitly_default_constructible
    : false_type
{ };
template <class _Tp>
struct __is_implicitly_default_constructible<_Tp, decltype(std::__test_implicit_default_constructible<_Tp const&>({})), true_type>
    : true_type
{ };
template <class _Tp>
struct __is_implicitly_default_constructible<_Tp, decltype(std::__test_implicit_default_constructible<_Tp const&>({})), false_type>
    : false_type
{ };
}}

namespace std { inline namespace __1 {
}}
namespace std { inline namespace __1 {
template<class _Tp>
struct __attribute__((__type_visibility__("default"))) is_member_pointer : _BoolConstant<__is_member_pointer(_Tp)> { };
template <class _Tp>
inline constexpr bool is_member_pointer_v = __is_member_pointer(_Tp);
}}
namespace std { inline namespace __1 {
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_move_assignable
    : public integral_constant<
          bool,
          __is_assignable(__add_lvalue_reference_t<_Tp>, __add_rvalue_reference_t<_Tp>)> {};
template <class _Tp>
inline constexpr bool is_move_assignable_v = is_move_assignable<_Tp>::value;
}}
namespace std { inline namespace __1 {
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_move_constructible
    : public integral_constant<bool, __is_constructible(_Tp, __add_rvalue_reference_t<_Tp>)>
    {};
template <class _Tp>
inline constexpr bool is_move_constructible_v = is_move_constructible<_Tp>::value;
}}
namespace std { inline namespace __1 {
template <class _Tp, class _Arg>
struct __attribute__((__type_visibility__("default"))) is_nothrow_assignable
    : public integral_constant<bool, __is_nothrow_assignable(_Tp, _Arg)> {};
template <class _Tp, class _Arg>
inline constexpr bool is_nothrow_assignable_v = __is_nothrow_assignable(_Tp, _Arg);
}}
namespace std { inline namespace __1 {
template <
    class _Tp, class... _Args>
struct __attribute__((__type_visibility__("default"))) is_nothrow_constructible
    : public integral_constant<bool, __is_nothrow_constructible(_Tp, _Args...)> {};
template <class _Tp, class ..._Args>
inline constexpr bool is_nothrow_constructible_v = is_nothrow_constructible<_Tp, _Args...>::value;
}}
namespace std { inline namespace __1 {
template <template <class...> class _Func, class ..._Args>
struct _Lazy : _Func<_Args...> {};
}}
namespace std { inline namespace __1 {
template <typename _Tp>
static void __test_noexcept(_Tp) noexcept;
template<typename _Fm, typename _To>
static bool_constant<noexcept(std::__test_noexcept<_To>(std::declval<_Fm>()))>
__is_nothrow_convertible_test();
template <typename _Fm, typename _To>
struct __is_nothrow_convertible_helper: decltype(__is_nothrow_convertible_test<_Fm, _To>())
{ };
template <typename _Fm, typename _To>
struct is_nothrow_convertible : _Or<
    _And<is_void<_To>, is_void<_Fm>>,
    _Lazy<_And, is_convertible<_Fm, _To>, __is_nothrow_convertible_helper<_Fm, _To>>
>::type { };
template <typename _Fm, typename _To>
inline constexpr bool is_nothrow_convertible_v = is_nothrow_convertible<_Fm, _To>::value;
}}
namespace std { inline namespace __1 {
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_nothrow_copy_assignable
    : public integral_constant<
          bool,
          __is_nothrow_assignable(
              __add_lvalue_reference_t<_Tp>,
              __add_lvalue_reference_t<typename add_const<_Tp>::type>)> {};
template <class _Tp>
inline constexpr bool is_nothrow_copy_assignable_v = is_nothrow_copy_assignable<_Tp>::value;
}}
namespace std { inline namespace __1 {
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_nothrow_copy_constructible
    : public integral_constant<
          bool,
          __is_nothrow_constructible(_Tp, typename add_lvalue_reference<typename add_const<_Tp>::type>::type)> {};
template <class _Tp>
inline constexpr bool is_nothrow_copy_constructible_v = is_nothrow_copy_constructible<_Tp>::value;
}}
namespace std { inline namespace __1 {
template <class _Tp> struct __attribute__((__type_visibility__("default"))) is_nothrow_default_constructible
    : public integral_constant<bool, __is_nothrow_constructible(_Tp)>
    {};
template <class _Tp>
inline constexpr bool is_nothrow_default_constructible_v = __is_nothrow_constructible(_Tp);
}}
namespace std { inline namespace __1 {
template<class _Tp>
struct __attribute__((__type_visibility__("default"))) is_pointer : _BoolConstant<__is_pointer(_Tp)> { };
template <class _Tp>
inline constexpr bool is_pointer_v = __is_pointer(_Tp);
}}
namespace std { inline namespace __1 {
template<class _Tp>
struct __attribute__((__type_visibility__("default"))) is_scalar : _BoolConstant<__is_scalar(_Tp)> { };
template <class _Tp>
inline constexpr bool is_scalar_v = __is_scalar(_Tp);
}}
namespace std { inline namespace __1 {
template <bool, class _Tp> struct __libcpp_is_nothrow_destructible;
template <class _Tp>
struct __libcpp_is_nothrow_destructible<false, _Tp>
    : public false_type
{
};
template <class _Tp>
struct __libcpp_is_nothrow_destructible<true, _Tp>
    : public integral_constant<bool, noexcept(std::declval<_Tp>().~_Tp()) >
{
};
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_nothrow_destructible
    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>
{
};
template <class _Tp, size_t _Ns>
struct __attribute__((__type_visibility__("default"))) is_nothrow_destructible<_Tp[_Ns]>
    : public is_nothrow_destructible<_Tp>
{
};
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_nothrow_destructible<_Tp&>
    : public true_type
{
};
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_nothrow_destructible<_Tp&&>
    : public true_type
{
};
template <class _Tp>
inline constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<_Tp>::value;
}}
namespace std { inline namespace __1 {
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_nothrow_move_assignable
    : public integral_constant<
          bool,
          __is_nothrow_assignable(__add_lvalue_reference_t<_Tp>, __add_rvalue_reference_t<_Tp>)> {
};
template <class _Tp>
inline constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<_Tp>::value;
}}
namespace std { inline namespace __1 {
template <class _Tp> struct __attribute__((__type_visibility__("default"))) is_nothrow_move_constructible
    : public integral_constant<bool, __is_nothrow_constructible(_Tp, __add_rvalue_reference_t<_Tp>)>
    {};
template <class _Tp>
inline constexpr bool is_nothrow_move_constructible_v = is_nothrow_move_constructible<_Tp>::value;
}}

namespace std { inline namespace __1 {
template <class _Tp> struct __attribute__((__type_visibility__("default"))) is_union
    : public integral_constant<bool, __is_union(_Tp)> {};
template <class _Tp>
inline constexpr bool is_union_v = __is_union(_Tp);
}}
namespace std { inline namespace __1 {
template<class _Tp>
struct __attribute__((__type_visibility__("default"))) is_object : _BoolConstant<__is_object(_Tp)> { };
template <class _Tp>
inline constexpr bool is_object_v = __is_object(_Tp);
}}
namespace std { inline namespace __1 {
template <class _Tp> struct __attribute__((__type_visibility__("default"))) is_pod
    : public integral_constant<bool, __is_pod(_Tp)> {};
template <class _Tp>
inline constexpr bool is_pod_v = __is_pod(_Tp);
}}

namespace std { inline namespace __1 {
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)> {};
template <class _Tp>
inline constexpr bool is_polymorphic_v = __is_polymorphic(_Tp);
}}
namespace std { inline namespace __1 {
template <class _Tp, bool = is_enum<_Tp>::value> struct __underlying_type_impl;
template <class _Tp>
struct __underlying_type_impl<_Tp, false> {};
template <class _Tp>
struct __underlying_type_impl<_Tp, true>
{
    typedef __underlying_type(_Tp) type;
};
template <class _Tp>
struct underlying_type : __underlying_type_impl<_Tp, is_enum<_Tp>::value> {};
template <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;
}}
namespace std { inline namespace __1 {
}}
namespace std { inline namespace __1 {
template<class _Tp>
struct __attribute__((__type_visibility__("default"))) is_signed : _BoolConstant<__is_signed(_Tp)> { };
template <class _Tp>
inline constexpr bool is_signed_v = __is_signed(_Tp);
}}
namespace std { inline namespace __1 {
template <class _Tp, template <class...> class _Template>
inline constexpr bool __is_specialization_v = false;
template <template <class...> class _Template, class... _Args>
inline constexpr bool __is_specialization_v<_Template<_Args...>, _Template> = true;
}}

namespace std { inline namespace __1 {
template <class _Tp> struct __is_swappable;
template <class _Tp> struct __is_nothrow_swappable;
template <class _Tp>
using __swap_result_t = typename enable_if<is_move_constructible<_Tp>::value && is_move_assignable<_Tp>::value>::type;
template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr __swap_result_t<_Tp>
swap(_Tp& __x, _Tp& __y) noexcept(is_nothrow_move_constructible<_Tp>::value && is_nothrow_move_assignable<_Tp>::value);
template<class _Tp, size_t _Np>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
typename enable_if<
    __is_swappable<_Tp>::value
>::type
swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) noexcept(__is_nothrow_swappable<_Tp>::value);
namespace __detail
{
template <class _Tp, class _Up = _Tp,
          bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value>
struct __swappable_with
{
    template <class _LHS, class _RHS>
    static decltype(swap(std::declval<_LHS>(), std::declval<_RHS>()))
    __test_swap(int);
    template <class, class>
    static __nat __test_swap(long);
    typedef decltype((__test_swap<_Tp, _Up>(0))) __swap1;
    typedef decltype((__test_swap<_Up, _Tp>(0))) __swap2;
    static const bool value = _IsNotSame<__swap1, __nat>::value
                           && _IsNotSame<__swap2, __nat>::value;
};
template <class _Tp, class _Up>
struct __swappable_with<_Tp, _Up, false> : false_type {};
template <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value>
struct __nothrow_swappable_with {
  static const bool value =
      noexcept(swap(std::declval<_Tp>(), std::declval<_Up>()))
  && noexcept(swap(std::declval<_Up>(), std::declval<_Tp>()));
};
template <class _Tp, class _Up>
struct __nothrow_swappable_with<_Tp, _Up, false> : false_type {};
}
template <class _Tp>
struct __is_swappable
    : public integral_constant<bool, __detail::__swappable_with<_Tp&>::value>
{
};
template <class _Tp>
struct __is_nothrow_swappable
    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp&>::value>
{
};
template <class _Tp, class _Up>
struct __attribute__((__type_visibility__("default"))) is_swappable_with
    : public integral_constant<bool, __detail::__swappable_with<_Tp, _Up>::value>
{
};
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_swappable
    : public __conditional_t<
        __libcpp_is_referenceable<_Tp>::value,
        is_swappable_with<
            __add_lvalue_reference_t<_Tp>,
            __add_lvalue_reference_t<_Tp> >,
        false_type
    >
{
};
template <class _Tp, class _Up>
struct __attribute__((__type_visibility__("default"))) is_nothrow_swappable_with
    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp, _Up>::value>
{
};
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_nothrow_swappable
    : public __conditional_t<
        __libcpp_is_referenceable<_Tp>::value,
        is_nothrow_swappable_with<
            __add_lvalue_reference_t<_Tp>,
            __add_lvalue_reference_t<_Tp> >,
        false_type
    >
{
};
template <class _Tp, class _Up>
inline constexpr bool is_swappable_with_v = is_swappable_with<_Tp, _Up>::value;
template <class _Tp>
inline constexpr bool is_swappable_v = is_swappable<_Tp>::value;
template <class _Tp, class _Up>
inline constexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<_Tp, _Up>::value;
template <class _Tp>
inline constexpr bool is_nothrow_swappable_v = is_nothrow_swappable<_Tp>::value;
}}

namespace std { inline namespace __1 {
template <class _Tp, class _Arg>
struct is_trivially_assignable
    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>
{ };
template <class _Tp, class _Arg>
inline constexpr bool is_trivially_assignable_v = __is_trivially_assignable(_Tp, _Arg);
}}
namespace std { inline namespace __1 {
template <class _Tp, class... _Args>
struct __attribute__((__type_visibility__("default"))) is_trivially_constructible
    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>
{
};
template <class _Tp, class... _Args>
inline constexpr bool is_trivially_constructible_v = __is_trivially_constructible(_Tp, _Args...);
}}
namespace std { inline namespace __1 {
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_trivially_copy_assignable
    : public integral_constant<
          bool,
          __is_trivially_assignable(
              __add_lvalue_reference_t<_Tp>,
              __add_lvalue_reference_t<typename add_const<_Tp>::type>)> {};
template <class _Tp>
inline constexpr bool is_trivially_copy_assignable_v = is_trivially_copy_assignable<_Tp>::value;
}}
namespace std { inline namespace __1 {
template <class _Tp> struct __attribute__((__type_visibility__("default"))) is_trivially_copy_constructible
    : public integral_constant<bool, __is_trivially_constructible(_Tp, __add_lvalue_reference_t<const _Tp>)>
    {};
template <class _Tp>
inline constexpr bool is_trivially_copy_constructible_v = is_trivially_copy_constructible<_Tp>::value;
}}
namespace std { inline namespace __1 {
template <class _Tp> struct __attribute__((__type_visibility__("default"))) is_trivially_copyable
    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
    {};
template <class _Tp>
inline constexpr bool is_trivially_copyable_v = __is_trivially_copyable(_Tp);
}}
namespace std { inline namespace __1 {
template <class _Tp> struct __attribute__((__type_visibility__("default"))) is_trivially_default_constructible
    : public integral_constant<bool, __is_trivially_constructible(_Tp)>
    {};
template <class _Tp>
inline constexpr bool is_trivially_default_constructible_v = __is_trivially_constructible(_Tp);
}}
namespace std { inline namespace __1 {
template <class _Tp> struct __attribute__((__type_visibility__("default"))) is_trivially_destructible
    : public integral_constant<bool, __is_trivially_destructible(_Tp)> {};
template <class _Tp>
inline constexpr bool is_trivially_destructible_v = is_trivially_destructible<_Tp>::value;
}}
namespace std { inline namespace __1 {
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_trivially_move_assignable
    : public integral_constant<
          bool,
          __is_trivially_assignable(__add_lvalue_reference_t<_Tp>, __add_rvalue_reference_t<_Tp>)> {};
template <class _Tp>
inline constexpr bool is_trivially_move_assignable_v = is_trivially_move_assignable<_Tp>::value;
}}
namespace std { inline namespace __1 {
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_trivially_move_constructible
    : public integral_constant<bool, __is_trivially_constructible(_Tp, __add_rvalue_reference_t<_Tp>)> {};
template <class _Tp>
inline constexpr bool is_trivially_move_constructible_v = is_trivially_move_constructible<_Tp>::value;
}}
namespace std { inline namespace __1 {
template <class> struct __attribute__((__type_visibility__("default"))) __libcpp_is_unbounded_array : false_type {};
template <class _Tp> struct __attribute__((__type_visibility__("default"))) __libcpp_is_unbounded_array<_Tp[]> : true_type {};
template <class> struct __attribute__((__type_visibility__("default"))) is_unbounded_array : false_type {};
template <class _Tp> struct __attribute__((__type_visibility__("default"))) is_unbounded_array<_Tp[]> : true_type {};
template <class _Tp>
inline constexpr
bool is_unbounded_array_v = is_unbounded_array<_Tp>::value;
}}

namespace std { inline namespace __1 {
template<class _Tp>
struct __attribute__((__type_visibility__("default"))) is_unsigned : _BoolConstant<__is_unsigned(_Tp)> { };
template <class _Tp>
inline constexpr bool is_unsigned_v = __is_unsigned(_Tp);
}}
namespace std { inline namespace __1 {
template<class _Tp>
using __make_const_lvalue_ref = const __libcpp_remove_reference_t<_Tp>&;
}}
namespace std { inline namespace __1 {
template <class _Tp>
using __make_signed_t = __make_signed(_Tp);
template <class _Tp>
struct make_signed {
  using type __attribute__((__nodebug__)) = __make_signed_t<_Tp>;
};
template <class _Tp> using make_signed_t = __make_signed_t<_Tp>;
}}
namespace std { inline namespace __1 {
template <class _Tp>
using __make_unsigned_t = __make_unsigned(_Tp);
template <class _Tp>
struct make_unsigned {
  using type __attribute__((__nodebug__)) = __make_unsigned_t<_Tp>;
};
template <class _Tp> using make_unsigned_t = __make_unsigned_t<_Tp>;
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
__make_unsigned_t<_Tp> __to_unsigned_like(_Tp __x) noexcept {
    return static_cast<__make_unsigned_t<_Tp> >(__x);
}
template <class _Tp, class _Up>
using __copy_unsigned_t = __conditional_t<is_unsigned<_Tp>::value, __make_unsigned_t<_Up>, _Up>;
}}
namespace std { inline namespace __1 {
template<bool _Const, class _Tp>
using __maybe_const = __conditional_t<_Const, const _Tp, _Tp>;
}}
namespace std { inline namespace __1 {
template <class _Pred>
struct _Not : _BoolConstant<!_Pred::value> {};
template <class _Tp>
struct negation : _Not<_Tp> {};
template<class _Tp>
inline constexpr bool negation_v = !_Tp::value;
}}
namespace std { inline namespace __1 {
template <class _Tp> struct __attribute__((__type_visibility__("default"))) rank
    : public integral_constant<size_t, 0> {};
template <class _Tp> struct __attribute__((__type_visibility__("default"))) rank<_Tp[]>
    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
template <class _Tp, size_t _Np> struct __attribute__((__type_visibility__("default"))) rank<_Tp[_Np]>
    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
template <class _Tp>
inline constexpr size_t rank_v = rank<_Tp>::value;
}}
namespace std { inline namespace __1 {
template <class _Tp>
struct remove_pointer {
  using type __attribute__((__nodebug__)) = __remove_pointer(_Tp);
};
template <class _Tp>
using __remove_pointer_t = __remove_pointer(_Tp);
template <class _Tp> using remove_pointer_t = __remove_pointer_t<_Tp>;
}}
namespace std { inline namespace __1 {
}}
namespace std { inline namespace __1 {
template <class _Tp>
struct __type_identity { typedef _Tp type; };
template <class _Tp>
using __type_identity_t __attribute__((__nodebug__)) = typename __type_identity<_Tp>::type;
template<class _Tp> struct type_identity { typedef _Tp type; };
template<class _Tp> using type_identity_t = typename type_identity<_Tp>::type;
}}
typedef signed char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef long long int64_t;

typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long long uint64_t;
typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;
typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;
typedef int8_t int_fast8_t;
typedef int16_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef int64_t int_fast64_t;
typedef uint8_t uint_fast8_t;
typedef uint16_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
typedef uint64_t uint_fast64_t;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long long __int64_t;
typedef unsigned long long __uint64_t;
typedef long __darwin_intptr_t;
typedef unsigned int __darwin_natural_t;
typedef int __darwin_ct_rune_t;
typedef union {
 char __mbstate8[128];
 long long _mbstateL;
} __mbstate_t;
typedef __mbstate_t __darwin_mbstate_t;
typedef long int __darwin_ptrdiff_t;
typedef long unsigned int __darwin_size_t;
typedef __builtin_va_list __darwin_va_list;
typedef int __darwin_wchar_t;
typedef __darwin_wchar_t __darwin_rune_t;
typedef int __darwin_wint_t;
typedef unsigned long __darwin_clock_t;
typedef __uint32_t __darwin_socklen_t;
typedef long __darwin_ssize_t;
typedef long __darwin_time_t;
typedef __int64_t __darwin_blkcnt_t;
typedef __int32_t __darwin_blksize_t;
typedef __int32_t __darwin_dev_t;
typedef unsigned int __darwin_fsblkcnt_t;
typedef unsigned int __darwin_fsfilcnt_t;
typedef __uint32_t __darwin_gid_t;
typedef __uint32_t __darwin_id_t;
typedef __uint64_t __darwin_ino64_t;
typedef __darwin_ino64_t __darwin_ino_t;
typedef __darwin_natural_t __darwin_mach_port_name_t;
typedef __darwin_mach_port_name_t __darwin_mach_port_t;
typedef __uint16_t __darwin_mode_t;
typedef __int64_t __darwin_off_t;
typedef __int32_t __darwin_pid_t;
typedef __uint32_t __darwin_sigset_t;
typedef __int32_t __darwin_suseconds_t;
typedef __uint32_t __darwin_uid_t;
typedef __uint32_t __darwin_useconds_t;
typedef unsigned char __darwin_uuid_t[16];
typedef char __darwin_uuid_string_t[37];
struct __darwin_pthread_handler_rec {
 void (*__routine)(void *);
 void *__arg;
 struct __darwin_pthread_handler_rec *__next;
};
struct _opaque_pthread_attr_t {
 long __sig;
 char __opaque[56];
};
struct _opaque_pthread_cond_t {
 long __sig;
 char __opaque[40];
};
struct _opaque_pthread_condattr_t {
 long __sig;
 char __opaque[8];
};
struct _opaque_pthread_mutex_t {
 long __sig;
 char __opaque[56];
};
struct _opaque_pthread_mutexattr_t {
 long __sig;
 char __opaque[8];
};
struct _opaque_pthread_once_t {
 long __sig;
 char __opaque[8];
};
struct _opaque_pthread_rwlock_t {
 long __sig;
 char __opaque[192];
};
struct _opaque_pthread_rwlockattr_t {
 long __sig;
 char __opaque[16];
};
struct _opaque_pthread_t {
 long __sig;
 struct __darwin_pthread_handler_rec *__cleanup_stack;
 char __opaque[8176];
};
typedef struct _opaque_pthread_attr_t __darwin_pthread_attr_t;
typedef struct _opaque_pthread_cond_t __darwin_pthread_cond_t;
typedef struct _opaque_pthread_condattr_t __darwin_pthread_condattr_t;
typedef unsigned long __darwin_pthread_key_t;
typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t;
typedef struct _opaque_pthread_mutexattr_t __darwin_pthread_mutexattr_t;
typedef struct _opaque_pthread_once_t __darwin_pthread_once_t;
typedef struct _opaque_pthread_rwlock_t __darwin_pthread_rwlock_t;
typedef struct _opaque_pthread_rwlockattr_t __darwin_pthread_rwlockattr_t;
typedef struct _opaque_pthread_t *__darwin_pthread_t;
typedef unsigned char u_int8_t;
typedef unsigned short u_int16_t;
typedef unsigned int u_int32_t;
typedef unsigned long long u_int64_t;
typedef int64_t register_t;
typedef unsigned long uintptr_t;
typedef u_int64_t user_addr_t;
typedef u_int64_t user_size_t;
typedef int64_t user_ssize_t;
typedef int64_t user_long_t;
typedef u_int64_t user_ulong_t;
typedef int64_t user_time_t;
typedef int64_t user_off_t;
typedef u_int64_t syscall_arg_t;

typedef __darwin_intptr_t intptr_t;
typedef long int intmax_t;
typedef long unsigned int uintmax_t;
namespace std { inline namespace __1 {
using ::int8_t __attribute__((__using_if_exists__));
using ::int16_t __attribute__((__using_if_exists__));
using ::int32_t __attribute__((__using_if_exists__));
using ::int64_t __attribute__((__using_if_exists__));
using ::uint8_t __attribute__((__using_if_exists__));
using ::uint16_t __attribute__((__using_if_exists__));
using ::uint32_t __attribute__((__using_if_exists__));
using ::uint64_t __attribute__((__using_if_exists__));
using ::int_least8_t __attribute__((__using_if_exists__));
using ::int_least16_t __attribute__((__using_if_exists__));
using ::int_least32_t __attribute__((__using_if_exists__));
using ::int_least64_t __attribute__((__using_if_exists__));
using ::uint_least8_t __attribute__((__using_if_exists__));
using ::uint_least16_t __attribute__((__using_if_exists__));
using ::uint_least32_t __attribute__((__using_if_exists__));
using ::uint_least64_t __attribute__((__using_if_exists__));
using ::int_fast8_t __attribute__((__using_if_exists__));
using ::int_fast16_t __attribute__((__using_if_exists__));
using ::int_fast32_t __attribute__((__using_if_exists__));
using ::int_fast64_t __attribute__((__using_if_exists__));
using ::uint_fast8_t __attribute__((__using_if_exists__));
using ::uint_fast16_t __attribute__((__using_if_exists__));
using ::uint_fast32_t __attribute__((__using_if_exists__));
using ::uint_fast64_t __attribute__((__using_if_exists__));
using ::intptr_t __attribute__((__using_if_exists__));
using ::uintptr_t __attribute__((__using_if_exists__));
using ::intmax_t __attribute__((__using_if_exists__));
using ::uintmax_t __attribute__((__using_if_exists__));
}}
namespace std { inline namespace __1 {
struct __equal_to {
  template <class _T1, class _T2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool operator()(const _T1& __x, const _T2& __y) const {
    return __x == __y;
  }
};
template <class _T1, class _T2 = _T1>
struct __less
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    bool operator()(const _T1& __x, const _T2& __y) const {return __x < __y;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    bool operator()(const _T2& __x, const _T1& __y) const {return __x < __y;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    bool operator()(const _T2& __x, const _T2& __y) const {return __x < __y;}
};
template <class _T1>
struct __less<_T1, _T1>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
};
template <class _T1>
struct __less<const _T1, _T1>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
};
template <class _T1>
struct __less<_T1, const _T1>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
};
}}
namespace std { inline namespace __1 {
template <class _Tp>
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __libcpp_remove_reference_t<_Tp>&&
move([[_Clang::__lifetimebound__]] _Tp&& __t) noexcept {
  typedef __attribute__((__nodebug__)) __libcpp_remove_reference_t<_Tp> _Up;
  return static_cast<_Up&&>(__t);
}
template <class _Tp>
using __move_if_noexcept_result_t =
    __conditional_t<!is_nothrow_move_constructible<_Tp>::value && is_copy_constructible<_Tp>::value, const _Tp&, _Tp&&>;
template <class _Tp>
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __move_if_noexcept_result_t<_Tp>
move_if_noexcept([[_Clang::__lifetimebound__]] _Tp& __x) noexcept {
  return std::move(__x);
}
}}
namespace std { inline namespace __1 {
template <class _Tp>
using __swap_result_t = typename enable_if<is_move_constructible<_Tp>::value && is_move_assignable<_Tp>::value>::type;
template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __swap_result_t<_Tp> constexpr swap(_Tp& __x, _Tp& __y)
    noexcept(is_nothrow_move_constructible<_Tp>::value&& is_nothrow_move_assignable<_Tp>::value) {
  _Tp __t(std::move(__x));
  __x = std::move(__y);
  __y = std::move(__t);
}
template <class _Tp, size_t _Np>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr typename enable_if<__is_swappable<_Tp>::value>::type
swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) noexcept(__is_nothrow_swappable<_Tp>::value) {
  for (size_t __i = 0; __i != _Np; ++__i) {
    swap(__a[__i], __b[__i]);
  }
}
}}
namespace std { inline namespace __1 {
template <class _ForwardIterator1, class _ForwardIterator2>
// added by concept-synth, original LN: 2223
requires
requires (_ForwardIterator1 x0) { *x0; } &&
requires (_ForwardIterator2 x0) { *x0; }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr void iter_swap(_ForwardIterator1 __a,
                                                                              _ForwardIterator2 __b)
    noexcept(noexcept(swap(*std::declval<_ForwardIterator1>(), *std::declval<_ForwardIterator2>()))) {
  swap(*__a, *__b);
}
}}
namespace std { inline namespace __1 {
template <class _Tp> struct __libcpp_is_signed_integer : public false_type {};
template <> struct __libcpp_is_signed_integer<signed char> : public true_type {};
template <> struct __libcpp_is_signed_integer<signed short> : public true_type {};
template <> struct __libcpp_is_signed_integer<signed int> : public true_type {};
template <> struct __libcpp_is_signed_integer<signed long> : public true_type {};
template <> struct __libcpp_is_signed_integer<signed long long> : public true_type {};
template <> struct __libcpp_is_signed_integer<__int128_t> : public true_type {};
}}
namespace std { inline namespace __1 {
template <class _Tp> struct __libcpp_is_unsigned_integer : public false_type {};
template <> struct __libcpp_is_unsigned_integer<unsigned char> : public true_type {};
template <> struct __libcpp_is_unsigned_integer<unsigned short> : public true_type {};
template <> struct __libcpp_is_unsigned_integer<unsigned int> : public true_type {};
template <> struct __libcpp_is_unsigned_integer<unsigned long> : public true_type {};
template <> struct __libcpp_is_unsigned_integer<unsigned long long> : public true_type {};
template <> struct __libcpp_is_unsigned_integer<__uint128_t> : public true_type {};
}}
namespace std { inline namespace __1 {
template<class _Tp>
concept integral = is_integral_v<_Tp>;
template<class _Tp>
concept signed_integral = integral<_Tp> && is_signed_v<_Tp>;
template<class _Tp>
concept unsigned_integral = integral<_Tp> && !signed_integral<_Tp>;
template<class _Tp>
concept floating_point = is_floating_point_v<_Tp>;
template <class _Tp>
concept __libcpp_unsigned_integer = __libcpp_is_unsigned_integer<_Tp>::value;
template <class _Tp>
concept __libcpp_signed_integer = __libcpp_is_signed_integer<_Tp>::value;
}}
namespace std { inline namespace __1 {
template<class _From, class _To>
concept convertible_to =
  is_convertible_v<_From, _To> &&
  requires {
    static_cast<_To>(std::declval<_From>());
  };
}}
namespace std { inline namespace __1 {
template<class _Tp, class _Up>
concept __same_as_impl = _IsSame<_Tp, _Up>::value;
template<class _Tp, class _Up>
concept same_as = __same_as_impl<_Tp, _Up> && __same_as_impl<_Up, _Tp>;
}}
namespace std { inline namespace __1 {
template<class _Tp, class _Up>
concept common_reference_with =
  same_as<common_reference_t<_Tp, _Up>, common_reference_t<_Up, _Tp>> &&
  convertible_to<_Tp, common_reference_t<_Tp, _Up>> &&
  convertible_to<_Up, common_reference_t<_Tp, _Up>>;
}}
namespace std { inline namespace __1 {
template<class _Lhs, class _Rhs>
concept assignable_from =
  is_lvalue_reference_v<_Lhs> &&
  common_reference_with<__make_const_lvalue_ref<_Lhs>, __make_const_lvalue_ref<_Rhs>> &&
  requires (_Lhs __lhs, _Rhs&& __rhs) {
    { __lhs = std::forward<_Rhs>(__rhs) } -> same_as<_Lhs>;
  };
}}

namespace std { inline namespace __1 {
template<class _Tp>
concept destructible = is_nothrow_destructible_v<_Tp>;
}}
namespace std { inline namespace __1 {
template<class _Tp, class... _Args>
concept constructible_from =
    destructible<_Tp> && is_constructible_v<_Tp, _Args...>;
template<class _Tp>
concept __default_initializable = requires { ::new _Tp; };
template<class _Tp>
concept default_initializable = constructible_from<_Tp> &&
    requires { _Tp{}; } && __default_initializable<_Tp>;
template<class _Tp>
concept move_constructible =
  constructible_from<_Tp, _Tp> && convertible_to<_Tp, _Tp>;
template<class _Tp>
concept copy_constructible =
  move_constructible<_Tp> &&
  constructible_from<_Tp, _Tp&> && convertible_to<_Tp&, _Tp> &&
  constructible_from<_Tp, const _Tp&> && convertible_to<const _Tp&, _Tp> &&
  constructible_from<_Tp, const _Tp> && convertible_to<const _Tp, _Tp>;
}}
namespace std { inline namespace __1 {
template<class _Tp>
concept __class_or_enum = is_class_v<_Tp> || is_union_v<_Tp> || is_enum_v<_Tp>;
template<class _Tp>
concept __workaround_52970 = is_class_v<__remove_cvref_t<_Tp>> || is_union_v<__remove_cvref_t<_Tp>>;
}}
namespace std { inline namespace __1 {
template<class _T1, class _T2 = _T1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_T1 exchange(_T1& __obj, _T2&& __new_value)
    noexcept(is_nothrow_move_constructible<_T1>::value && is_nothrow_assignable<_T1&, _T2>::value)
{
    _T1 __old_value = std::move(__obj);
    __obj = std::forward<_T2>(__new_value);
    return __old_value;
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __swap {
  template<class _Tp>
  void swap(_Tp&, _Tp&) = delete;
  template<class _Tp, class _Up>
  concept __unqualified_swappable_with =
    (__class_or_enum<remove_cvref_t<_Tp>> || __class_or_enum<remove_cvref_t<_Up>>) &&
    requires(_Tp&& __t, _Up&& __u) {
      swap(std::forward<_Tp>(__t), std::forward<_Up>(__u));
    };
  struct __fn;
  template<class _Tp, class _Up, size_t _Size>
  concept __swappable_arrays =
    !__unqualified_swappable_with<_Tp(&)[_Size], _Up(&)[_Size]> &&
    extent_v<_Tp> == extent_v<_Up> &&
    requires(_Tp(& __t)[_Size], _Up(& __u)[_Size], const __fn& __swap) {
      __swap(__t[0], __u[0]);
    };
  template<class _Tp>
  concept __exchangeable =
    !__unqualified_swappable_with<_Tp&, _Tp&> &&
    move_constructible<_Tp> &&
    assignable_from<_Tp&, _Tp>;
  struct __fn {
    template<class _Tp, class _Up>
      requires __unqualified_swappable_with<_Tp, _Up>
    constexpr void operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(swap(std::forward<_Tp>(__t), std::forward<_Up>(__u))))
    {
      swap(std::forward<_Tp>(__t), std::forward<_Up>(__u));
    }
    template<class _Tp, class _Up, size_t _Size>
      requires __swappable_arrays<_Tp, _Up, _Size>
    constexpr void operator()(_Tp(& __t)[_Size], _Up(& __u)[_Size]) const
      noexcept(noexcept((*this)(*__t, *__u)))
    {
      for (size_t __i = 0; __i < _Size; ++__i) {
        (*this)(__t[__i], __u[__i]);
      }
    }
    template<__exchangeable _Tp>
    constexpr void operator()(_Tp& __x, _Tp& __y) const
      noexcept(is_nothrow_move_constructible_v<_Tp> && is_nothrow_move_assignable_v<_Tp>)
    {
      __y = std::exchange(__x, std::move(__y));
    }
  };
}
inline namespace __cpo {
  inline constexpr auto swap = __swap::__fn{};
}
}
template<class _Tp>
concept swappable = requires(_Tp& __a, _Tp& __b) { ranges::swap(__a, __b); };
template<class _Tp, class _Up>
concept swappable_with =
  common_reference_with<_Tp, _Up> &&
  requires(_Tp&& __t, _Up&& __u) {
    ranges::swap(std::forward<_Tp>(__t), std::forward<_Tp>(__t));
    ranges::swap(std::forward<_Up>(__u), std::forward<_Up>(__u));
    ranges::swap(std::forward<_Tp>(__t), std::forward<_Up>(__u));
    ranges::swap(std::forward<_Up>(__u), std::forward<_Tp>(__t));
  };
}}
namespace std { inline namespace __1 {
template<class _Tp>
concept movable =
  is_object_v<_Tp> &&
  move_constructible<_Tp> &&
  assignable_from<_Tp&, _Tp> &&
  swappable<_Tp>;
}}
namespace std { inline namespace __1 {
template<class _Tp>
concept copyable =
  copy_constructible<_Tp> &&
  movable<_Tp> &&
  assignable_from<_Tp&, _Tp&> &&
  assignable_from<_Tp&, const _Tp&> &&
  assignable_from<_Tp&, const _Tp>;
}}
namespace std { inline namespace __1 {
template<class _Dp, class _Bp>
concept derived_from =
  is_base_of_v<_Bp, _Dp> &&
  is_convertible_v<const volatile _Dp*, const volatile _Bp*>;
}}
namespace std { inline namespace __1 {
template<class _Tp>
concept __boolean_testable_impl = convertible_to<_Tp, bool>;
template<class _Tp>
concept __boolean_testable = __boolean_testable_impl<_Tp> && requires(_Tp&& __t) {
  { !std::forward<_Tp>(__t) } -> __boolean_testable_impl;
};
}}
namespace std { inline namespace __1 {
template<class _Tp, class _Up>
concept __weakly_equality_comparable_with =
  requires(__make_const_lvalue_ref<_Tp> __t, __make_const_lvalue_ref<_Up> __u) {
    { __t == __u } -> __boolean_testable;
    { __t != __u } -> __boolean_testable;
    { __u == __t } -> __boolean_testable;
    { __u != __t } -> __boolean_testable;
  };
template<class _Tp>
concept equality_comparable = __weakly_equality_comparable_with<_Tp, _Tp>;
template<class _Tp, class _Up>
concept equality_comparable_with =
  equality_comparable<_Tp> && equality_comparable<_Up> &&
  common_reference_with<__make_const_lvalue_ref<_Tp>, __make_const_lvalue_ref<_Up>> &&
  equality_comparable<
    common_reference_t<
      __make_const_lvalue_ref<_Tp>,
      __make_const_lvalue_ref<_Up>>> &&
  __weakly_equality_comparable_with<_Tp, _Up>;
}}
namespace std { inline namespace __1 {
template<class _Fn, class... _Args>
concept invocable = requires(_Fn&& __fn, _Args&&... __args) {
  std::invoke(std::forward<_Fn>(__fn), std::forward<_Args>(__args)...);
};
template<class _Fn, class... _Args>
concept regular_invocable = invocable<_Fn, _Args...>;
}}

namespace std { inline namespace __1 {
template<class _Fn, class... _Args>
concept predicate =
  regular_invocable<_Fn, _Args...> && __boolean_testable<invoke_result_t<_Fn, _Args...>>;
}}
namespace std { inline namespace __1 {
template<class _Tp>
concept semiregular = copyable<_Tp> && default_initializable<_Tp>;
}}
namespace std { inline namespace __1 {
template<class _Tp>
concept regular = semiregular<_Tp> && equality_comparable<_Tp>;
}}
namespace std { inline namespace __1 {
template<class _Rp, class _Tp, class _Up>
concept relation =
  predicate<_Rp, _Tp, _Tp> && predicate<_Rp, _Up, _Up> &&
  predicate<_Rp, _Tp, _Up> && predicate<_Rp, _Up, _Tp>;
template<class _Rp, class _Tp, class _Up>
concept equivalence_relation = relation<_Rp, _Tp, _Up>;
template<class _Rp, class _Tp, class _Up>
concept strict_weak_order = relation<_Rp, _Tp, _Up>;
}}
namespace std { inline namespace __1 {
template<class _Tp, class _Up>
concept __partially_ordered_with =
  requires(__make_const_lvalue_ref<_Tp> __t, __make_const_lvalue_ref<_Up> __u) {
    { __t < __u } -> __boolean_testable;
    { __t > __u } -> __boolean_testable;
    { __t <= __u } -> __boolean_testable;
    { __t >= __u } -> __boolean_testable;
    { __u < __t } -> __boolean_testable;
    { __u > __t } -> __boolean_testable;
    { __u <= __t } -> __boolean_testable;
    { __u >= __t } -> __boolean_testable;
  };
template<class _Tp>
concept totally_ordered = equality_comparable<_Tp> && __partially_ordered_with<_Tp, _Tp>;
template<class _Tp, class _Up>
concept totally_ordered_with =
  totally_ordered<_Tp> && totally_ordered<_Up> &&
  equality_comparable_with<_Tp, _Up> &&
  totally_ordered<
    common_reference_t<
      __make_const_lvalue_ref<_Tp>,
      __make_const_lvalue_ref<_Up>>> &&
  __partially_ordered_with<_Tp, _Up>;
}}
namespace std { inline namespace __1 {
template <template <class...> class _Templ, class ..._Args, class = _Templ<_Args...> >
true_type __sfinae_test_impl(int);
template <template <class...> class, class ...>
false_type __sfinae_test_impl(...);
template <template <class ...> class _Templ, class ..._Args>
using _IsValidExpansion __attribute__((__nodebug__)) = decltype(std::__sfinae_test_impl<_Templ, _Args...>(0));
}}
namespace std { inline namespace __1 {
template <class _Tp>
using __test_for_primary_template = __enable_if_t<
    _IsSame<_Tp, typename _Tp::__primary_template>::value
  >;
template <class _Tp>
using __is_primary_template = _IsValidExpansion<
    __test_for_primary_template, _Tp
  >;
}}
namespace std { inline namespace __1 {
template<class> struct incrementable_traits {};
template<class _Tp>
requires is_object_v<_Tp>
struct incrementable_traits<_Tp*> {
  using difference_type = ptrdiff_t;
};
template<class _Ip>
struct incrementable_traits<const _Ip> : incrementable_traits<_Ip> {};
template<class _Tp>
concept __has_member_difference_type = requires { typename _Tp::difference_type; };
template<__has_member_difference_type _Tp>
struct incrementable_traits<_Tp> {
  using difference_type = typename _Tp::difference_type;
};
template<class _Tp>
concept __has_integral_minus =
  requires(const _Tp& __x, const _Tp& __y) {
    { __x - __y } -> integral;
  };
template<__has_integral_minus _Tp>
requires (!__has_member_difference_type<_Tp>)
struct incrementable_traits<_Tp> {
  using difference_type = make_signed_t<decltype(std::declval<_Tp>() - std::declval<_Tp>())>;
};
template <class>
struct iterator_traits;
template <class _Ip>
using iter_difference_t = typename conditional_t<__is_primary_template<iterator_traits<remove_cvref_t<_Ip> > >::value,
                                                 incrementable_traits<remove_cvref_t<_Ip> >,
                                                 iterator_traits<remove_cvref_t<_Ip> > >::difference_type;
}}
namespace std { inline namespace __1 {
template<class> struct __cond_value_type {};
template<class _Tp>
requires is_object_v<_Tp>
struct __cond_value_type<_Tp> { using value_type = remove_cv_t<_Tp>; };
template<class _Tp>
concept __has_member_value_type = requires { typename _Tp::value_type; };
template<class _Tp>
concept __has_member_element_type = requires { typename _Tp::element_type; };
template<class> struct indirectly_readable_traits {};
template<class _Ip>
requires is_array_v<_Ip>
struct indirectly_readable_traits<_Ip> {
  using value_type = remove_cv_t<remove_extent_t<_Ip>>;
};
template<class _Ip>
struct indirectly_readable_traits<const _Ip> : indirectly_readable_traits<_Ip> {};
template<class _Tp>
struct indirectly_readable_traits<_Tp*> : __cond_value_type<_Tp> {};
template<__has_member_value_type _Tp>
struct indirectly_readable_traits<_Tp>
  : __cond_value_type<typename _Tp::value_type> {};
template<__has_member_element_type _Tp>
struct indirectly_readable_traits<_Tp>
  : __cond_value_type<typename _Tp::element_type> {};
template<__has_member_value_type _Tp>
  requires __has_member_element_type<_Tp>
struct indirectly_readable_traits<_Tp> {};
template<__has_member_value_type _Tp>
  requires __has_member_element_type<_Tp> &&
           same_as<remove_cv_t<typename _Tp::element_type>,
                   remove_cv_t<typename _Tp::value_type>>
struct indirectly_readable_traits<_Tp>
  : __cond_value_type<typename _Tp::value_type> {};
template <class>
struct iterator_traits;
template <class _Ip>
using iter_value_t = typename conditional_t<__is_primary_template<iterator_traits<remove_cvref_t<_Ip> > >::value,
                                            indirectly_readable_traits<remove_cvref_t<_Ip> >,
                                            iterator_traits<remove_cvref_t<_Ip> > >::value_type;
}}
namespace std { inline namespace __1 {
template <class _Tp>
using __with_reference = _Tp&;
template <class _Tp>
concept __can_reference = requires {
  typename __with_reference<_Tp>;
};
template <class _Tp>
concept __dereferenceable = requires(_Tp& __t) {
  { *__t } -> __can_reference;
};
template<__dereferenceable _Tp>
using iter_reference_t = decltype(*std::declval<_Tp&>());
template <class _Iter>
struct __attribute__((__type_visibility__("default"))) iterator_traits;
struct __attribute__((__type_visibility__("default"))) input_iterator_tag {};
struct __attribute__((__type_visibility__("default"))) output_iterator_tag {};
struct __attribute__((__type_visibility__("default"))) forward_iterator_tag : public input_iterator_tag {};
struct __attribute__((__type_visibility__("default"))) bidirectional_iterator_tag : public forward_iterator_tag {};
struct __attribute__((__type_visibility__("default"))) random_access_iterator_tag : public bidirectional_iterator_tag {};
struct __attribute__((__type_visibility__("default"))) contiguous_iterator_tag : public random_access_iterator_tag {};
template <class _Iter>
struct __iter_traits_cache {
  using type = _If<
    __is_primary_template<iterator_traits<_Iter> >::value,
    _Iter,
    iterator_traits<_Iter>
  >;
};
template <class _Iter>
using _ITER_TRAITS = typename __iter_traits_cache<_Iter>::type;
struct __iter_concept_concept_test {
  template <class _Iter>
  using _Apply = typename _ITER_TRAITS<_Iter>::iterator_concept;
};
struct __iter_concept_category_test {
  template <class _Iter>
  using _Apply = typename _ITER_TRAITS<_Iter>::iterator_category;
};
struct __iter_concept_random_fallback {
  template <class _Iter>
  using _Apply = __enable_if_t<
                          __is_primary_template<iterator_traits<_Iter> >::value,
                          random_access_iterator_tag
                        >;
};
template <class _Iter, class _Tester> struct __test_iter_concept
    : _IsValidExpansion<_Tester::template _Apply, _Iter>,
      _Tester
{
};
template <class _Iter>
struct __iter_concept_cache {
  using type = _Or<
    __test_iter_concept<_Iter, __iter_concept_concept_test>,
    __test_iter_concept<_Iter, __iter_concept_category_test>,
    __test_iter_concept<_Iter, __iter_concept_random_fallback>
  >;
};
template <class _Iter>
using _ITER_CONCEPT = typename __iter_concept_cache<_Iter>::type::template _Apply<_Iter>;
template <class _Tp>
struct __has_iterator_typedefs
{
private:
    template <class _Up> static false_type __test(...);
    template <class _Up> static true_type __test(__void_t<typename _Up::iterator_category>* = nullptr,
                                                 __void_t<typename _Up::difference_type>* = nullptr,
                                                 __void_t<typename _Up::value_type>* = nullptr,
                                                 __void_t<typename _Up::reference>* = nullptr,
                                                 __void_t<typename _Up::pointer>* = nullptr);
public:
    static const bool value = decltype(__test<_Tp>(0,0,0,0,0))::value;
};
template <class _Tp>
struct __has_iterator_category
{
private:
    template <class _Up> static false_type __test(...);
    template <class _Up> static true_type __test(typename _Up::iterator_category* = nullptr);
public:
    static const bool value = decltype(__test<_Tp>(nullptr))::value;
};
template <class _Tp>
struct __has_iterator_concept
{
private:
    template <class _Up> static false_type __test(...);
    template <class _Up> static true_type __test(typename _Up::iterator_concept* = nullptr);
public:
    static const bool value = decltype(__test<_Tp>(nullptr))::value;
};
namespace __iterator_traits_detail {
template<class _Ip>
concept __cpp17_iterator =
  requires(_Ip __i) {
    { *__i } -> __can_reference;
    { ++__i } -> same_as<_Ip&>;
    { *__i++ } -> __can_reference;
  } &&
  copyable<_Ip>;
template<class _Ip>
concept __cpp17_input_iterator =
  __cpp17_iterator<_Ip> &&
  equality_comparable<_Ip> &&
  requires(_Ip __i) {
    typename incrementable_traits<_Ip>::difference_type;
    typename indirectly_readable_traits<_Ip>::value_type;
    typename common_reference_t<iter_reference_t<_Ip>&&,
                                typename indirectly_readable_traits<_Ip>::value_type&>;
    typename common_reference_t<decltype(*__i++)&&,
                                typename indirectly_readable_traits<_Ip>::value_type&>;
    requires signed_integral<typename incrementable_traits<_Ip>::difference_type>;
  };
template<class _Ip>
concept __cpp17_forward_iterator =
  __cpp17_input_iterator<_Ip> &&
  constructible_from<_Ip> &&
  is_lvalue_reference_v<iter_reference_t<_Ip>> &&
  same_as<remove_cvref_t<iter_reference_t<_Ip>>,
          typename indirectly_readable_traits<_Ip>::value_type> &&
  requires(_Ip __i) {
    { __i++ } -> convertible_to<_Ip const&>;
    { *__i++ } -> same_as<iter_reference_t<_Ip>>;
  };
template<class _Ip>
concept __cpp17_bidirectional_iterator =
  __cpp17_forward_iterator<_Ip> &&
  requires(_Ip __i) {
    { --__i } -> same_as<_Ip&>;
    { __i-- } -> convertible_to<_Ip const&>;
    { *__i-- } -> same_as<iter_reference_t<_Ip>>;
  };
template<class _Ip>
concept __cpp17_random_access_iterator =
  __cpp17_bidirectional_iterator<_Ip> &&
  totally_ordered<_Ip> &&
  requires(_Ip __i, typename incrementable_traits<_Ip>::difference_type __n) {
    { __i += __n } -> same_as<_Ip&>;
    { __i -= __n } -> same_as<_Ip&>;
    { __i + __n } -> same_as<_Ip>;
    { __n + __i } -> same_as<_Ip>;
    { __i - __n } -> same_as<_Ip>;
    { __i - __i } -> same_as<decltype(__n)>;
    { __i[__n] } -> convertible_to<iter_reference_t<_Ip>>;
  };
}
template<class _Ip>
concept __has_member_reference = requires { typename _Ip::reference; };
template<class _Ip>
concept __has_member_pointer = requires { typename _Ip::pointer; };
template<class _Ip>
concept __has_member_iterator_category = requires { typename _Ip::iterator_category; };
template<class _Ip>
concept __specifies_members = requires {
    typename _Ip::value_type;
    typename _Ip::difference_type;
    requires __has_member_reference<_Ip>;
    requires __has_member_iterator_category<_Ip>;
  };
template<class>
struct __iterator_traits_member_pointer_or_void {
  using type = void;
};
template<__has_member_pointer _Tp>
struct __iterator_traits_member_pointer_or_void<_Tp> {
  using type = typename _Tp::pointer;
};
template<class _Tp>
concept __cpp17_iterator_missing_members =
  !__specifies_members<_Tp> &&
  __iterator_traits_detail::__cpp17_iterator<_Tp>;
template<class _Tp>
concept __cpp17_input_iterator_missing_members =
  __cpp17_iterator_missing_members<_Tp> &&
  __iterator_traits_detail::__cpp17_input_iterator<_Tp>;
template<class>
struct __iterator_traits_member_pointer_or_arrow_or_void { using type = void; };
template<__has_member_pointer _Ip>
struct __iterator_traits_member_pointer_or_arrow_or_void<_Ip> { using type = typename _Ip::pointer; };
template<class _Ip>
  requires requires(_Ip& __i) { __i.operator->(); } && (!__has_member_pointer<_Ip>)
struct __iterator_traits_member_pointer_or_arrow_or_void<_Ip> {
  using type = decltype(std::declval<_Ip&>().operator->());
};
template<class _Ip>
struct __iterator_traits_member_reference { using type = iter_reference_t<_Ip>; };
template<__has_member_reference _Ip>
struct __iterator_traits_member_reference<_Ip> { using type = typename _Ip::reference; };
template<class _Ip>
struct __deduce_iterator_category {
  using type = input_iterator_tag;
};
template<__iterator_traits_detail::__cpp17_random_access_iterator _Ip>
struct __deduce_iterator_category<_Ip> {
  using type = random_access_iterator_tag;
};
template<__iterator_traits_detail::__cpp17_bidirectional_iterator _Ip>
struct __deduce_iterator_category<_Ip> {
  using type = bidirectional_iterator_tag;
};
template<__iterator_traits_detail::__cpp17_forward_iterator _Ip>
struct __deduce_iterator_category<_Ip> {
  using type = forward_iterator_tag;
};
template<class _Ip>
struct __iterator_traits_iterator_category : __deduce_iterator_category<_Ip> {};
template<__has_member_iterator_category _Ip>
struct __iterator_traits_iterator_category<_Ip> {
  using type = typename _Ip::iterator_category;
};
template<class>
struct __iterator_traits_difference_type { using type = void; };
template<class _Ip>
requires requires { typename incrementable_traits<_Ip>::difference_type; }
struct __iterator_traits_difference_type<_Ip> {
  using type = typename incrementable_traits<_Ip>::difference_type;
};
template<class>
struct __iterator_traits {};
template<__specifies_members _Ip>
struct __iterator_traits<_Ip> {
  using iterator_category = typename _Ip::iterator_category;
  using value_type = typename _Ip::value_type;
  using difference_type = typename _Ip::difference_type;
  using pointer = typename __iterator_traits_member_pointer_or_void<_Ip>::type;
  using reference = typename _Ip::reference;
};
template<__cpp17_input_iterator_missing_members _Ip>
struct __iterator_traits<_Ip> {
  using iterator_category = typename __iterator_traits_iterator_category<_Ip>::type;
  using value_type = typename indirectly_readable_traits<_Ip>::value_type;
  using difference_type = typename incrementable_traits<_Ip>::difference_type;
  using pointer = typename __iterator_traits_member_pointer_or_arrow_or_void<_Ip>::type;
  using reference = typename __iterator_traits_member_reference<_Ip>::type;
};
template<__cpp17_iterator_missing_members _Ip>
struct __iterator_traits<_Ip> {
  using iterator_category = output_iterator_tag;
  using value_type = void;
  using difference_type = typename __iterator_traits_difference_type<_Ip>::type;
  using pointer = void;
  using reference = void;
};
template<class _Ip>
struct iterator_traits : __iterator_traits<_Ip> {
  using __primary_template = iterator_traits;
};
template<class _Tp>
requires is_object_v<_Tp>
struct __attribute__((__type_visibility__("default"))) iterator_traits<_Tp*>
{
    typedef ptrdiff_t difference_type;
    typedef __remove_cv_t<_Tp> value_type;
    typedef _Tp* pointer;
    typedef _Tp& reference;
    typedef random_access_iterator_tag iterator_category;
    typedef contiguous_iterator_tag iterator_concept;
};
template <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>
struct __has_iterator_category_convertible_to
    : is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>
{};
template <class _Tp, class _Up>
struct __has_iterator_category_convertible_to<_Tp, _Up, false> : false_type {};
template <class _Tp, class _Up, bool = __has_iterator_concept<_Tp>::value>
struct __has_iterator_concept_convertible_to
    : is_convertible<typename _Tp::iterator_concept, _Up>
{};
template <class _Tp, class _Up>
struct __has_iterator_concept_convertible_to<_Tp, _Up, false> : false_type {};
template <class _Tp>
struct __is_cpp17_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};
template <class _Tp>
struct __is_cpp17_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {};
template <class _Tp>
struct __is_cpp17_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> {};
template <class _Tp>
struct __is_cpp17_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> {};
template <class _Tp>
struct __is_cpp17_contiguous_iterator : _Or<
    __has_iterator_category_convertible_to<_Tp, contiguous_iterator_tag>,
    __has_iterator_concept_convertible_to<_Tp, contiguous_iterator_tag>
> {};
template <class _Up>
struct __is_cpp17_contiguous_iterator<_Up*> : true_type {};
template <class _Iter>
class __wrap_iter;
template <class _Tp>
struct __is_exactly_cpp17_input_iterator
    : public integral_constant<bool,
         __has_iterator_category_convertible_to<_Tp, input_iterator_tag>::value &&
        !__has_iterator_category_convertible_to<_Tp, forward_iterator_tag>::value> {};
template <class _Tp>
struct __is_exactly_cpp17_forward_iterator
    : public integral_constant<bool,
         __has_iterator_category_convertible_to<_Tp, forward_iterator_tag>::value &&
        !__has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag>::value> {};
template <class _Tp>
struct __is_exactly_cpp17_bidirectional_iterator
    : public integral_constant<bool,
         __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag>::value &&
        !__has_iterator_category_convertible_to<_Tp, random_access_iterator_tag>::value> {};
template<class _InputIterator>
using __iter_value_type = typename iterator_traits<_InputIterator>::value_type;
template<class _InputIterator>
using __iter_key_type = __remove_const_t<typename iterator_traits<_InputIterator>::value_type::first_type>;
template<class _InputIterator>
using __iter_mapped_type = typename iterator_traits<_InputIterator>::value_type::second_type;
template<class _InputIterator>
using __iter_to_alloc_type = pair<
    typename add_const<typename iterator_traits<_InputIterator>::value_type::first_type>::type,
    typename iterator_traits<_InputIterator>::value_type::second_type>;
template <class _Iter>
using __iterator_category_type = typename iterator_traits<_Iter>::iterator_category;
template <class _Iter>
using __iterator_pointer_type = typename iterator_traits<_Iter>::pointer;
template <class _Iter>
using __iter_diff_t = typename iterator_traits<_Iter>::difference_type;
template<class _InputIterator>
using __iter_value_type = typename iterator_traits<_InputIterator>::value_type;
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __iter_move {
void iter_move();
template <class _Tp>
concept __unqualified_iter_move =
  __class_or_enum<remove_cvref_t<_Tp>> &&
  requires (_Tp&& __t) {
    iter_move(std::forward<_Tp>(__t));
  };
template<class _Tp>
concept __move_deref =
  !__unqualified_iter_move<_Tp> &&
  requires (_Tp&& __t) {
    *__t;
    requires is_lvalue_reference_v<decltype(*__t)>;
  };
template<class _Tp>
concept __just_deref =
  !__unqualified_iter_move<_Tp> &&
  !__move_deref<_Tp> &&
  requires (_Tp&& __t) {
    *__t;
    requires (!is_lvalue_reference_v<decltype(*__t)>);
  };
struct __fn {
  template<class _Ip>
    requires __unqualified_iter_move<_Ip>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr decltype(auto) operator()(_Ip&& __i) const
    noexcept(noexcept(iter_move(std::forward<_Ip>(__i))))
  {
    return iter_move(std::forward<_Ip>(__i));
  }
  template<class _Ip>
    requires __move_deref<_Ip>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr auto operator()(_Ip&& __i) const
    noexcept(noexcept(std::move(*std::forward<_Ip>(__i))))
    -> decltype( std::move(*std::forward<_Ip>(__i)))
    { return std::move(*std::forward<_Ip>(__i)); }
  template<class _Ip>
    requires __just_deref<_Ip>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr auto operator()(_Ip&& __i) const
    noexcept(noexcept(*std::forward<_Ip>(__i)))
    -> decltype( *std::forward<_Ip>(__i))
    { return *std::forward<_Ip>(__i); }
};
}
inline namespace __cpo {
  inline constexpr auto iter_move = __iter_move::__fn{};
}
}
template<__dereferenceable _Tp>
  requires requires(_Tp& __t) { { ranges::iter_move(__t) } -> __can_reference; }
using iter_rvalue_reference_t = decltype(ranges::iter_move(std::declval<_Tp&>()));
}}
namespace std { inline namespace __1 {
template <class _Tp>
inline constexpr
__attribute__((__no_sanitize__("cfi"))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp*
addressof(_Tp& __x) noexcept
{
    return __builtin_addressof(__x);
}
template <class _Tp> _Tp* addressof(const _Tp&&) noexcept = delete;
}}
namespace std { inline namespace __1 {
template <class _Tp, class = void>
struct __has_element_type : false_type {};
template <class _Tp>
struct __has_element_type<_Tp, __void_t<typename _Tp::element_type> > : true_type {};
template <class _Ptr, bool = __has_element_type<_Ptr>::value>
struct __pointer_traits_element_type;
template <class _Ptr>
struct __pointer_traits_element_type<_Ptr, true>
{
    typedef __attribute__((__nodebug__)) typename _Ptr::element_type type;
};
template <template <class, class...> class _Sp, class _Tp, class ..._Args>
struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>
{
    typedef __attribute__((__nodebug__)) typename _Sp<_Tp, _Args...>::element_type type;
};
template <template <class, class...> class _Sp, class _Tp, class ..._Args>
struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>
{
    typedef __attribute__((__nodebug__)) _Tp type;
};
template <class _Tp, class = void>
struct __has_difference_type : false_type {};
template <class _Tp>
struct __has_difference_type<_Tp, __void_t<typename _Tp::difference_type> > : true_type {};
template <class _Ptr, bool = __has_difference_type<_Ptr>::value>
struct __pointer_traits_difference_type
{
    typedef __attribute__((__nodebug__)) ptrdiff_t type;
};
template <class _Ptr>
struct __pointer_traits_difference_type<_Ptr, true>
{
    typedef __attribute__((__nodebug__)) typename _Ptr::difference_type type;
};
template <class _Tp, class _Up>
struct __has_rebind
{
private:
    template <class _Xp> static false_type __test(...);
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    template <class _Xp> static true_type __test(typename _Xp::template rebind<_Up>* = 0);
#pragma GCC diagnostic pop
public:
    static const bool value = decltype(__test<_Tp>(0))::value;
};
template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>
struct __pointer_traits_rebind
{
    typedef __attribute__((__nodebug__)) typename _Tp::template rebind<_Up> type;
};
template <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>
{
    typedef __attribute__((__nodebug__)) typename _Sp<_Tp, _Args...>::template rebind<_Up> type;
};
template <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>
{
    typedef _Sp<_Up, _Args...> type;
};
template <class _Ptr>
struct __attribute__((__type_visibility__("default"))) pointer_traits
{
    typedef _Ptr pointer;
    typedef typename __pointer_traits_element_type<pointer>::type element_type;
    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;
    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;
private:
    struct __nat {};
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    static pointer pointer_to(__conditional_t<is_void<element_type>::value, __nat, element_type>& __r)
        {return pointer::pointer_to(__r);}
};
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) pointer_traits<_Tp*>
{
    typedef _Tp* pointer;
    typedef _Tp element_type;
    typedef ptrdiff_t difference_type;
    template <class _Up> using rebind = _Up*;
private:
    struct __nat {};
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    static pointer pointer_to(__conditional_t<is_void<element_type>::value, __nat, element_type>& __r) noexcept
        {return std::addressof(__r);}
};
template <class _From, class _To>
using __rebind_pointer_t = typename pointer_traits<_From>::template rebind<_To>;
template <class _Pointer, class = void>
struct __to_address_helper;
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_Tp* __to_address(_Tp* __p) noexcept {
    static_assert(!is_function<_Tp>::value, "_Tp is a function type");
    return __p;
}
template <class _Pointer, class = void>
struct _HasToAddress : false_type {};
template <class _Pointer>
struct _HasToAddress<_Pointer,
    decltype((void)pointer_traits<_Pointer>::to_address(std::declval<const _Pointer&>()))
> : true_type {};
template <class _Pointer, class = void>
struct _HasArrow : false_type {};
template <class _Pointer>
struct _HasArrow<_Pointer,
    decltype((void)std::declval<const _Pointer&>().operator->())
> : true_type {};
template <class _Pointer>
struct _IsFancyPointer {
  static const bool value = _HasArrow<_Pointer>::value || _HasToAddress<_Pointer>::value;
};
template <class _Pointer, class = __enable_if_t<
    _And<is_class<_Pointer>, _IsFancyPointer<_Pointer> >::value
> >
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
typename decay<decltype(__to_address_helper<_Pointer>::__call(std::declval<const _Pointer&>()))>::type
__to_address(const _Pointer& __p) noexcept {
    return __to_address_helper<_Pointer>::__call(__p);
}
template <class _Pointer, class>
struct __to_address_helper {
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    static decltype(std::__to_address(std::declval<const _Pointer&>().operator->()))
    __call(const _Pointer& __p) noexcept {
        return std::__to_address(__p.operator->());
    }
};
template <class _Pointer>
struct __to_address_helper<_Pointer, decltype((void)pointer_traits<_Pointer>::to_address(std::declval<const _Pointer&>()))> {
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    static decltype(pointer_traits<_Pointer>::to_address(std::declval<const _Pointer&>()))
    __call(const _Pointer& __p) noexcept {
        return pointer_traits<_Pointer>::to_address(__p);
    }
};
template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
auto to_address(_Tp *__p) noexcept {
    return std::__to_address(__p);
}
template <class _Pointer>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
auto to_address(const _Pointer& __p) noexcept -> decltype(std::__to_address(__p)) {
    return std::__to_address(__p);
}
}}
namespace std { inline namespace __1 {
template<class _In>
concept __indirectly_readable_impl =
  requires(const _In __i) {
    typename iter_value_t<_In>;
    typename iter_reference_t<_In>;
    typename iter_rvalue_reference_t<_In>;
    { *__i } -> same_as<iter_reference_t<_In>>;
    { ranges::iter_move(__i) } -> same_as<iter_rvalue_reference_t<_In>>;
  } &&
  common_reference_with<iter_reference_t<_In>&&, iter_value_t<_In>&> &&
  common_reference_with<iter_reference_t<_In>&&, iter_rvalue_reference_t<_In>&&> &&
  common_reference_with<iter_rvalue_reference_t<_In>&&, const iter_value_t<_In>&>;
template<class _In>
concept indirectly_readable = __indirectly_readable_impl<remove_cvref_t<_In>>;
template<indirectly_readable _Tp>
using iter_common_reference_t = common_reference_t<iter_reference_t<_Tp>, iter_value_t<_Tp>&>;
template<class _Out, class _Tp>
concept indirectly_writable =
  requires(_Out&& __o, _Tp&& __t) {
    *__o = std::forward<_Tp>(__t);
    *std::forward<_Out>(__o) = std::forward<_Tp>(__t);
    const_cast<const iter_reference_t<_Out>&&>(*__o) = std::forward<_Tp>(__t);
    const_cast<const iter_reference_t<_Out>&&>(*std::forward<_Out>(__o)) = std::forward<_Tp>(__t);
  };
template<class _Tp>
concept __integer_like = integral<_Tp> && !same_as<_Tp, bool>;
template<class _Tp>
concept __signed_integer_like = signed_integral<_Tp>;
template<class _Ip>
concept weakly_incrementable =
  !same_as<_Ip, bool> &&
  movable<_Ip> &&
  requires(_Ip __i) {
    typename iter_difference_t<_Ip>;
    requires __signed_integer_like<iter_difference_t<_Ip>>;
    { ++__i } -> same_as<_Ip&>;
    __i++;
  };
template<class _Ip>
concept incrementable =
  regular<_Ip> &&
  weakly_incrementable<_Ip> &&
  requires(_Ip __i) {
    { __i++ } -> same_as<_Ip>;
  };
template<class _Ip>
concept input_or_output_iterator =
  requires(_Ip __i) {
    { *__i } -> __can_reference;
  } &&
  weakly_incrementable<_Ip>;
template<class _Sp, class _Ip>
concept sentinel_for =
  semiregular<_Sp> &&
  input_or_output_iterator<_Ip> &&
  __weakly_equality_comparable_with<_Sp, _Ip>;
template<class, class>
inline constexpr bool disable_sized_sentinel_for = false;
template<class _Sp, class _Ip>
concept sized_sentinel_for =
  sentinel_for<_Sp, _Ip> &&
  !disable_sized_sentinel_for<remove_cv_t<_Sp>, remove_cv_t<_Ip>> &&
  requires(const _Ip& __i, const _Sp& __s) {
    { __s - __i } -> same_as<iter_difference_t<_Ip>>;
    { __i - __s } -> same_as<iter_difference_t<_Ip>>;
  };
template<class _Ip>
concept input_iterator =
  input_or_output_iterator<_Ip> &&
  indirectly_readable<_Ip> &&
  requires { typename _ITER_CONCEPT<_Ip>; } &&
  derived_from<_ITER_CONCEPT<_Ip>, input_iterator_tag>;
template<class _Ip, class _Tp>
concept output_iterator =
  input_or_output_iterator<_Ip> &&
  indirectly_writable<_Ip, _Tp> &&
  requires (_Ip __it, _Tp&& __t) {
    *__it++ = std::forward<_Tp>(__t);
  };
template<class _Ip>
concept forward_iterator =
  input_iterator<_Ip> &&
  derived_from<_ITER_CONCEPT<_Ip>, forward_iterator_tag> &&
  incrementable<_Ip> &&
  sentinel_for<_Ip, _Ip>;
template<class _Ip>
concept bidirectional_iterator =
  forward_iterator<_Ip> &&
  derived_from<_ITER_CONCEPT<_Ip>, bidirectional_iterator_tag> &&
  requires(_Ip __i) {
    { --__i } -> same_as<_Ip&>;
    { __i-- } -> same_as<_Ip>;
  };
template<class _Ip>
concept random_access_iterator =
  bidirectional_iterator<_Ip> &&
  derived_from<_ITER_CONCEPT<_Ip>, random_access_iterator_tag> &&
  totally_ordered<_Ip> &&
  sized_sentinel_for<_Ip, _Ip> &&
  requires(_Ip __i, const _Ip __j, const iter_difference_t<_Ip> __n) {
    { __i += __n } -> same_as<_Ip&>;
    { __j + __n } -> same_as<_Ip>;
    { __n + __j } -> same_as<_Ip>;
    { __i -= __n } -> same_as<_Ip&>;
    { __j - __n } -> same_as<_Ip>;
    { __j[__n] } -> same_as<iter_reference_t<_Ip>>;
  };
template<class _Ip>
concept contiguous_iterator =
  random_access_iterator<_Ip> &&
  derived_from<_ITER_CONCEPT<_Ip>, contiguous_iterator_tag> &&
  is_lvalue_reference_v<iter_reference_t<_Ip>> &&
  same_as<iter_value_t<_Ip>, remove_cvref_t<iter_reference_t<_Ip>>> &&
  requires(const _Ip& __i) {
    { std::to_address(__i) } -> same_as<add_pointer_t<iter_reference_t<_Ip>>>;
  };
template<class _Ip>
concept __has_arrow = input_iterator<_Ip> && (is_pointer_v<_Ip> || requires(_Ip __i) { __i.operator->(); });
template<class _Fp, class _It>
concept indirectly_unary_invocable =
  indirectly_readable<_It> &&
  copy_constructible<_Fp> &&
  invocable<_Fp&, iter_value_t<_It>&> &&
  invocable<_Fp&, iter_reference_t<_It>> &&
  invocable<_Fp&, iter_common_reference_t<_It>> &&
  common_reference_with<
    invoke_result_t<_Fp&, iter_value_t<_It>&>,
    invoke_result_t<_Fp&, iter_reference_t<_It>>>;
template<class _Fp, class _It>
concept indirectly_regular_unary_invocable =
  indirectly_readable<_It> &&
  copy_constructible<_Fp> &&
  regular_invocable<_Fp&, iter_value_t<_It>&> &&
  regular_invocable<_Fp&, iter_reference_t<_It>> &&
  regular_invocable<_Fp&, iter_common_reference_t<_It>> &&
  common_reference_with<
    invoke_result_t<_Fp&, iter_value_t<_It>&>,
    invoke_result_t<_Fp&, iter_reference_t<_It>>>;
template<class _Fp, class _It>
concept indirect_unary_predicate =
  indirectly_readable<_It> &&
  copy_constructible<_Fp> &&
  predicate<_Fp&, iter_value_t<_It>&> &&
  predicate<_Fp&, iter_reference_t<_It>> &&
  predicate<_Fp&, iter_common_reference_t<_It>>;
template<class _Fp, class _It1, class _It2>
concept indirect_binary_predicate =
  indirectly_readable<_It1> && indirectly_readable<_It2> &&
  copy_constructible<_Fp> &&
  predicate<_Fp&, iter_value_t<_It1>&, iter_value_t<_It2>&> &&
  predicate<_Fp&, iter_value_t<_It1>&, iter_reference_t<_It2>> &&
  predicate<_Fp&, iter_reference_t<_It1>, iter_value_t<_It2>&> &&
  predicate<_Fp&, iter_reference_t<_It1>, iter_reference_t<_It2>> &&
  predicate<_Fp&, iter_common_reference_t<_It1>, iter_common_reference_t<_It2>>;
template<class _Fp, class _It1, class _It2 = _It1>
concept indirect_equivalence_relation =
  indirectly_readable<_It1> && indirectly_readable<_It2> &&
  copy_constructible<_Fp> &&
  equivalence_relation<_Fp&, iter_value_t<_It1>&, iter_value_t<_It2>&> &&
  equivalence_relation<_Fp&, iter_value_t<_It1>&, iter_reference_t<_It2>> &&
  equivalence_relation<_Fp&, iter_reference_t<_It1>, iter_value_t<_It2>&> &&
  equivalence_relation<_Fp&, iter_reference_t<_It1>, iter_reference_t<_It2>> &&
  equivalence_relation<_Fp&, iter_common_reference_t<_It1>, iter_common_reference_t<_It2>>;
template<class _Fp, class _It1, class _It2 = _It1>
concept indirect_strict_weak_order =
  indirectly_readable<_It1> && indirectly_readable<_It2> &&
  copy_constructible<_Fp> &&
  strict_weak_order<_Fp&, iter_value_t<_It1>&, iter_value_t<_It2>&> &&
  strict_weak_order<_Fp&, iter_value_t<_It1>&, iter_reference_t<_It2>> &&
  strict_weak_order<_Fp&, iter_reference_t<_It1>, iter_value_t<_It2>&> &&
  strict_weak_order<_Fp&, iter_reference_t<_It1>, iter_reference_t<_It2>> &&
  strict_weak_order<_Fp&, iter_common_reference_t<_It1>, iter_common_reference_t<_It2>>;
template<class _Fp, class... _Its>
  requires (indirectly_readable<_Its> && ...) && invocable<_Fp, iter_reference_t<_Its>...>
using indirect_result_t = invoke_result_t<_Fp, iter_reference_t<_Its>...>;
template<class _In, class _Out>
concept indirectly_movable =
  indirectly_readable<_In> &&
  indirectly_writable<_Out, iter_rvalue_reference_t<_In>>;
template<class _In, class _Out>
concept indirectly_movable_storable =
  indirectly_movable<_In, _Out> &&
  indirectly_writable<_Out, iter_value_t<_In>> &&
  movable<iter_value_t<_In>> &&
  constructible_from<iter_value_t<_In>, iter_rvalue_reference_t<_In>> &&
  assignable_from<iter_value_t<_In>&, iter_rvalue_reference_t<_In>>;
template<class _In, class _Out>
concept indirectly_copyable =
  indirectly_readable<_In> &&
  indirectly_writable<_Out, iter_reference_t<_In>>;
template<class _In, class _Out>
concept indirectly_copyable_storable =
  indirectly_copyable<_In, _Out> &&
  indirectly_writable<_Out, iter_value_t<_In>&> &&
  indirectly_writable<_Out, const iter_value_t<_In>&> &&
  indirectly_writable<_Out, iter_value_t<_In>&&> &&
  indirectly_writable<_Out, const iter_value_t<_In>&&> &&
  copyable<iter_value_t<_In>> &&
  constructible_from<iter_value_t<_In>, iter_reference_t<_In>> &&
  assignable_from<iter_value_t<_In>&, iter_reference_t<_In>>;
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _IterMaybeQualified>
consteval auto __get_iterator_concept() {
  using _Iter = __remove_cvref_t<_IterMaybeQualified>;
  if constexpr (contiguous_iterator<_Iter>)
    return contiguous_iterator_tag();
  else if constexpr (random_access_iterator<_Iter>)
    return random_access_iterator_tag();
  else if constexpr (bidirectional_iterator<_Iter>)
    return bidirectional_iterator_tag();
  else if constexpr (forward_iterator<_Iter>)
    return forward_iterator_tag();
  else if constexpr (input_iterator<_Iter>)
    return input_iterator_tag();
}
template <class _Iter>
using __iterator_concept = decltype(__get_iterator_concept<_Iter>());
}
}}

namespace std { inline namespace __1 {
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
int __convert_to_integral(int __val) { return __val; }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
unsigned __convert_to_integral(unsigned __val) { return __val; }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
long __convert_to_integral(long __val) { return __val; }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
unsigned long __convert_to_integral(unsigned long __val) { return __val; }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
long long __convert_to_integral(long long __val) { return __val; }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
unsigned long long __convert_to_integral(unsigned long long __val) {return __val; }
template<typename _Fp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
typename enable_if<is_floating_point<_Fp>::value, long long>::type
 __convert_to_integral(_Fp __val) { return __val; }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
__int128_t __convert_to_integral(__int128_t __val) { return __val; }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
__uint128_t __convert_to_integral(__uint128_t __val) { return __val; }
template <class _Tp, bool = is_enum<_Tp>::value>
struct __sfinae_underlying_type
{
    typedef typename underlying_type<_Tp>::type type;
    typedef decltype(((type)1) + 0) __promoted_type;
};
template <class _Tp>
struct __sfinae_underlying_type<_Tp, false> {};
template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
typename __sfinae_underlying_type<_Tp>::__promoted_type
__convert_to_integral(_Tp __val) { return __val; }
}}
namespace std { inline namespace __1 {
[[noreturn]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) inline void __libcpp_unreachable() {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(false))
#pragma clang diagnostic pop
    );
    __builtin_unreachable();
}
}}
typedef int __darwin_nl_item;
typedef int __darwin_wctrans_t;
typedef __uint32_t __darwin_wctype_t;

typedef enum {
 P_ALL,
 P_PID,
 P_PGID
} idtype_t;
typedef __darwin_pid_t pid_t;
typedef __darwin_id_t id_t;
typedef int sig_atomic_t;
struct __darwin_arm_exception_state
{
 __uint32_t __exception;
 __uint32_t __fsr;
 __uint32_t __far;
};
struct __darwin_arm_exception_state64
{
 __uint64_t __far;
 __uint32_t __esr;
 __uint32_t __exception;
};
struct __darwin_arm_thread_state
{
 __uint32_t __r[13];
 __uint32_t __sp;
 __uint32_t __lr;
 __uint32_t __pc;
 __uint32_t __cpsr;
};
struct __darwin_arm_thread_state64
{
 __uint64_t __x[29];
 __uint64_t __fp;
 __uint64_t __lr;
 __uint64_t __sp;
 __uint64_t __pc;
 __uint32_t __cpsr;
 __uint32_t __pad;
};
struct __darwin_arm_vfp_state
{
 __uint32_t __r[64];
 __uint32_t __fpscr;
};
struct __darwin_arm_neon_state64
{
 __uint128_t __v[32];
 __uint32_t __fpsr;
 __uint32_t __fpcr;
};
struct __darwin_arm_neon_state
{
 __uint128_t __v[16];
 __uint32_t __fpsr;
 __uint32_t __fpcr;
};
struct __arm_pagein_state
{
 int __pagein_error;
};
struct __arm_legacy_debug_state
{
 __uint32_t __bvr[16];
 __uint32_t __bcr[16];
 __uint32_t __wvr[16];
 __uint32_t __wcr[16];
};
struct __darwin_arm_debug_state32
{
 __uint32_t __bvr[16];
 __uint32_t __bcr[16];
 __uint32_t __wvr[16];
 __uint32_t __wcr[16];
 __uint64_t __mdscr_el1;
};
struct __darwin_arm_debug_state64
{
 __uint64_t __bvr[16];
 __uint64_t __bcr[16];
 __uint64_t __wvr[16];
 __uint64_t __wcr[16];
 __uint64_t __mdscr_el1;
};
struct __darwin_arm_cpmu_state64
{
 __uint64_t __ctrs[16];
};
struct __darwin_mcontext32
{
 struct __darwin_arm_exception_state __es;
 struct __darwin_arm_thread_state __ss;
 struct __darwin_arm_vfp_state __fs;
};
struct __darwin_mcontext64
{
 struct __darwin_arm_exception_state64 __es;
 struct __darwin_arm_thread_state64 __ss;
 struct __darwin_arm_neon_state64 __ns;
};
typedef struct __darwin_mcontext64 *mcontext_t;

typedef __darwin_pthread_attr_t pthread_attr_t;

struct __darwin_sigaltstack
{
 void *ss_sp;
 __darwin_size_t ss_size;
 int ss_flags;
};
typedef struct __darwin_sigaltstack stack_t;
struct __darwin_ucontext
{
 int uc_onstack;
 __darwin_sigset_t uc_sigmask;
 struct __darwin_sigaltstack uc_stack;
 struct __darwin_ucontext *uc_link;
 __darwin_size_t uc_mcsize;
 struct __darwin_mcontext64 *uc_mcontext;
};
typedef struct __darwin_ucontext ucontext_t;
typedef __darwin_sigset_t sigset_t;
typedef __darwin_uid_t uid_t;

union sigval {
 int sival_int;
 void *sival_ptr;
};
struct sigevent {
 int sigev_notify;
 int sigev_signo;
 union sigval sigev_value;
 void (*sigev_notify_function)(union sigval);
 pthread_attr_t *sigev_notify_attributes;
};
typedef struct __siginfo {
 int si_signo;
 int si_errno;
 int si_code;
 pid_t si_pid;
 uid_t si_uid;
 int si_status;
 void *si_addr;
 union sigval si_value;
 long si_band;
 unsigned long __pad[7];
} siginfo_t;
union __sigaction_u {
 void (*__sa_handler)(int);
 void (*__sa_sigaction)(int, struct __siginfo *,
     void *);
};
struct __sigaction {
 union __sigaction_u __sigaction_u;
 void (*sa_tramp)(void *, int, int, siginfo_t *, void *);
 sigset_t sa_mask;
 int sa_flags;
};
struct sigaction {
 union __sigaction_u __sigaction_u;
 sigset_t sa_mask;
 int sa_flags;
};
typedef void (*sig_t)(int);
struct sigvec {
 void (*sv_handler)(int);
 int sv_mask;
 int sv_flags;
};
struct sigstack {
 char *ss_sp;
 int ss_onstack;
};
extern "C" {
void(*signal(int, void (*)(int)))(int);
}
struct timeval
{
 __darwin_time_t tv_sec;
 __darwin_suseconds_t tv_usec;
};
typedef __uint64_t rlim_t;
struct rusage {
 struct timeval ru_utime;
 struct timeval ru_stime;
 long ru_maxrss;
 long ru_ixrss;
 long ru_idrss;
 long ru_isrss;
 long ru_minflt;
 long ru_majflt;
 long ru_nswap;
 long ru_inblock;
 long ru_oublock;
 long ru_msgsnd;
 long ru_msgrcv;
 long ru_nsignals;
 long ru_nvcsw;
 long ru_nivcsw;
};
typedef void *rusage_info_t;
struct rusage_info_v0 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
};
struct rusage_info_v1 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
};
struct rusage_info_v2 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
};
struct rusage_info_v3 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
 uint64_t ri_cpu_time_qos_default;
 uint64_t ri_cpu_time_qos_maintenance;
 uint64_t ri_cpu_time_qos_background;
 uint64_t ri_cpu_time_qos_utility;
 uint64_t ri_cpu_time_qos_legacy;
 uint64_t ri_cpu_time_qos_user_initiated;
 uint64_t ri_cpu_time_qos_user_interactive;
 uint64_t ri_billed_system_time;
 uint64_t ri_serviced_system_time;
};
struct rusage_info_v4 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
 uint64_t ri_cpu_time_qos_default;
 uint64_t ri_cpu_time_qos_maintenance;
 uint64_t ri_cpu_time_qos_background;
 uint64_t ri_cpu_time_qos_utility;
 uint64_t ri_cpu_time_qos_legacy;
 uint64_t ri_cpu_time_qos_user_initiated;
 uint64_t ri_cpu_time_qos_user_interactive;
 uint64_t ri_billed_system_time;
 uint64_t ri_serviced_system_time;
 uint64_t ri_logical_writes;
 uint64_t ri_lifetime_max_phys_footprint;
 uint64_t ri_instructions;
 uint64_t ri_cycles;
 uint64_t ri_billed_energy;
 uint64_t ri_serviced_energy;
 uint64_t ri_interval_max_phys_footprint;
 uint64_t ri_runnable_time;
};
struct rusage_info_v5 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
 uint64_t ri_cpu_time_qos_default;
 uint64_t ri_cpu_time_qos_maintenance;
 uint64_t ri_cpu_time_qos_background;
 uint64_t ri_cpu_time_qos_utility;
 uint64_t ri_cpu_time_qos_legacy;
 uint64_t ri_cpu_time_qos_user_initiated;
 uint64_t ri_cpu_time_qos_user_interactive;
 uint64_t ri_billed_system_time;
 uint64_t ri_serviced_system_time;
 uint64_t ri_logical_writes;
 uint64_t ri_lifetime_max_phys_footprint;
 uint64_t ri_instructions;
 uint64_t ri_cycles;
 uint64_t ri_billed_energy;
 uint64_t ri_serviced_energy;
 uint64_t ri_interval_max_phys_footprint;
 uint64_t ri_runnable_time;
 uint64_t ri_flags;
};
struct rusage_info_v6 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
 uint64_t ri_cpu_time_qos_default;
 uint64_t ri_cpu_time_qos_maintenance;
 uint64_t ri_cpu_time_qos_background;
 uint64_t ri_cpu_time_qos_utility;
 uint64_t ri_cpu_time_qos_legacy;
 uint64_t ri_cpu_time_qos_user_initiated;
 uint64_t ri_cpu_time_qos_user_interactive;
 uint64_t ri_billed_system_time;
 uint64_t ri_serviced_system_time;
 uint64_t ri_logical_writes;
 uint64_t ri_lifetime_max_phys_footprint;
 uint64_t ri_instructions;
 uint64_t ri_cycles;
 uint64_t ri_billed_energy;
 uint64_t ri_serviced_energy;
 uint64_t ri_interval_max_phys_footprint;
 uint64_t ri_runnable_time;
 uint64_t ri_flags;
 uint64_t ri_user_ptime;
 uint64_t ri_system_ptime;
 uint64_t ri_pinstructions;
 uint64_t ri_pcycles;
 uint64_t ri_energy_nj;
 uint64_t ri_penergy_nj;
 uint64_t ri_reserved[14];
};
typedef struct rusage_info_v6 rusage_info_current;
struct rlimit {
 rlim_t rlim_cur;
 rlim_t rlim_max;
};
struct proc_rlimit_control_wakeupmon {
 uint32_t wm_flags;
 int32_t wm_rate;
};
extern "C" {
int getpriority(int, id_t);
int getiopolicy_np(int, int) __attribute__((availability(macosx,introduced=10.5)));
int getrlimit(int, struct rlimit *) __asm("_" "getrlimit" );
int getrusage(int, struct rusage *);
int setpriority(int, id_t, int);
int setiopolicy_np(int, int, int) __attribute__((availability(macosx,introduced=10.5)));
int setrlimit(int, const struct rlimit *) __asm("_" "setrlimit" );
}
static inline
uint16_t
_OSSwapInt16(
 uint16_t _data
 )
{
 return (uint16_t)(_data << 8 | _data >> 8);
}
static inline
uint32_t
_OSSwapInt32(
 uint32_t _data
 )
{
 _data = __builtin_bswap32(_data);
 return _data;
}
static inline
uint64_t
_OSSwapInt64(
 uint64_t _data
 )
{
 return __builtin_bswap64(_data);
}
struct _OSUnalignedU16 {
 volatile uint16_t __val;
} __attribute__((__packed__));
struct _OSUnalignedU32 {
 volatile uint32_t __val;
} __attribute__((__packed__));
struct _OSUnalignedU64 {
 volatile uint64_t __val;
} __attribute__((__packed__));
static inline
uint16_t
OSReadSwapInt16(
 const volatile void * _base,
 uintptr_t _offset
 )
{
 return _OSSwapInt16(((struct _OSUnalignedU16 *)((uintptr_t)_base + _offset))->__val);
}
static inline
uint32_t
OSReadSwapInt32(
 const volatile void * _base,
 uintptr_t _offset
 )
{
 return _OSSwapInt32(((struct _OSUnalignedU32 *)((uintptr_t)_base + _offset))->__val);
}
static inline
uint64_t
OSReadSwapInt64(
 const volatile void * _base,
 uintptr_t _offset
 )
{
 return _OSSwapInt64(((struct _OSUnalignedU64 *)((uintptr_t)_base + _offset))->__val);
}
static inline
void
OSWriteSwapInt16(
 volatile void * _base,
 uintptr_t _offset,
 uint16_t _data
 )
{
 ((struct _OSUnalignedU16 *)((uintptr_t)_base + _offset))->__val = _OSSwapInt16(_data);
}
static inline
void
OSWriteSwapInt32(
 volatile void * _base,
 uintptr_t _offset,
 uint32_t _data
 )
{
 ((struct _OSUnalignedU32 *)((uintptr_t)_base + _offset))->__val = _OSSwapInt32(_data);
}
static inline
void
OSWriteSwapInt64(
 volatile void * _base,
 uintptr_t _offset,
 uint64_t _data
 )
{
 ((struct _OSUnalignedU64 *)((uintptr_t)_base + _offset))->__val = _OSSwapInt64(_data);
}
union wait {
 int w_status;
 struct {
  unsigned int w_Termsig:7,
      w_Coredump:1,
      w_Retcode:8,
      w_Filler:16;
 } w_T;
 struct {
  unsigned int w_Stopval:8,
      w_Stopsig:8,
      w_Filler:16;
 } w_S;
};
extern "C" {
pid_t wait(int *) __asm("_" "wait" );
pid_t waitpid(pid_t, int *, int) __asm("_" "waitpid" );
int waitid(idtype_t, id_t, siginfo_t *, int) __asm("_" "waitid" );
pid_t wait3(int *, int, struct rusage *);
pid_t wait4(pid_t, int *, int, struct rusage *);
}


extern "C" {
void *alloca(size_t);
}
typedef __darwin_ct_rune_t ct_rune_t;
typedef __darwin_rune_t rune_t;

typedef struct {
 int quot;
 int rem;
} div_t;
typedef struct {
 long quot;
 long rem;
} ldiv_t;
typedef struct {
 long long quot;
 long long rem;
} lldiv_t;
extern int __mb_cur_max;

extern "C" {
typedef unsigned long long malloc_type_id_t;
__attribute__((availability(macos,unavailable))) __attribute__((availability(ios,unavailable))) __attribute__((availability(tvos,unavailable))) __attribute__((availability(watchos,unavailable))) __attribute__((availability(visionos,unavailable))) void *malloc_type_malloc(size_t size, malloc_type_id_t type_id) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(1)));
__attribute__((availability(macos,unavailable))) __attribute__((availability(ios,unavailable))) __attribute__((availability(tvos,unavailable))) __attribute__((availability(watchos,unavailable))) __attribute__((availability(visionos,unavailable))) void *malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(1,2)));
__attribute__((availability(macos,unavailable))) __attribute__((availability(ios,unavailable))) __attribute__((availability(tvos,unavailable))) __attribute__((availability(watchos,unavailable))) __attribute__((availability(visionos,unavailable))) void malloc_type_free(void *ptr, malloc_type_id_t type_id);
__attribute__((availability(macos,unavailable))) __attribute__((availability(ios,unavailable))) __attribute__((availability(tvos,unavailable))) __attribute__((availability(watchos,unavailable))) __attribute__((availability(visionos,unavailable))) void *malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(2)));
__attribute__((availability(macos,unavailable))) __attribute__((availability(ios,unavailable))) __attribute__((availability(tvos,unavailable))) __attribute__((availability(watchos,unavailable))) __attribute__((availability(visionos,unavailable))) void *malloc_type_valloc(size_t size, malloc_type_id_t type_id) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(1)));
__attribute__((availability(macos,unavailable))) __attribute__((availability(ios,unavailable))) __attribute__((availability(tvos,unavailable))) __attribute__((availability(watchos,unavailable))) __attribute__((availability(visionos,unavailable))) void *malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(2)));
__attribute__((availability(macos,unavailable))) __attribute__((availability(ios,unavailable))) __attribute__((availability(tvos,unavailable))) __attribute__((availability(watchos,unavailable))) __attribute__((availability(visionos,unavailable))) int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id) ;
typedef struct _malloc_zone_t malloc_zone_t;
__attribute__((availability(macos,unavailable))) __attribute__((availability(ios,unavailable))) __attribute__((availability(tvos,unavailable))) __attribute__((availability(watchos,unavailable))) __attribute__((availability(visionos,unavailable))) void *malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(2)));
__attribute__((availability(macos,unavailable))) __attribute__((availability(ios,unavailable))) __attribute__((availability(tvos,unavailable))) __attribute__((availability(watchos,unavailable))) __attribute__((availability(visionos,unavailable))) void *malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(2,3)));
__attribute__((availability(macos,unavailable))) __attribute__((availability(ios,unavailable))) __attribute__((availability(tvos,unavailable))) __attribute__((availability(watchos,unavailable))) __attribute__((availability(visionos,unavailable))) void malloc_type_zone_free(malloc_zone_t *zone, void *ptr, malloc_type_id_t type_id);
__attribute__((availability(macos,unavailable))) __attribute__((availability(ios,unavailable))) __attribute__((availability(tvos,unavailable))) __attribute__((availability(watchos,unavailable))) __attribute__((availability(visionos,unavailable))) void *malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(3)));
__attribute__((availability(macos,unavailable))) __attribute__((availability(ios,unavailable))) __attribute__((availability(tvos,unavailable))) __attribute__((availability(watchos,unavailable))) __attribute__((availability(visionos,unavailable))) void *malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(2)));
__attribute__((availability(macos,unavailable))) __attribute__((availability(ios,unavailable))) __attribute__((availability(tvos,unavailable))) __attribute__((availability(watchos,unavailable))) __attribute__((availability(visionos,unavailable))) void *malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(3)));
}
extern "C" {
void *malloc(size_t __size) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(1))) ;
void *calloc(size_t __count, size_t __size) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(1,2))) ;
void free(void *);
void *realloc(void *__ptr, size_t __size) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(2))) ;
void *valloc(size_t) __attribute__((alloc_size(1))) ;
void *aligned_alloc(size_t __alignment, size_t __size) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(2))) __attribute__((availability(macosx,introduced=10.15))) __attribute__((availability(ios,introduced=13.0))) __attribute__((availability(tvos,introduced=13.0))) __attribute__((availability(watchos,introduced=6.0)));
int posix_memalign(void **__memptr, size_t __alignment, size_t __size) __attribute__((availability(macosx,introduced=10.6)));
}

extern "C" {
void abort(void) __attribute__((__cold__)) __attribute__((__noreturn__));
int abs(int) __attribute__((__const__));
int atexit(void (* _Nonnull)(void));
double atof(const char *);
int atoi(const char *);
long atol(const char *);
long long
  atoll(const char *);
void *bsearch(const void *__key, const void *__base, size_t __nel,
     size_t __width, int (* _Nonnull __compar)(const void *, const void *));
div_t div(int, int) __attribute__((__const__));
void exit(int) __attribute__((__noreturn__));
char *getenv(const char *);
long labs(long) __attribute__((__const__));
ldiv_t ldiv(long, long) __attribute__((__const__));
long long
  llabs(long long);
lldiv_t lldiv(long long, long long);
int mblen(const char *__s, size_t __n);
size_t mbstowcs(wchar_t * , const char * , size_t);
int mbtowc(wchar_t * , const char * , size_t);
void qsort(void *__base, size_t __nel, size_t __width,
     int (* _Nonnull __compar)(const void *, const void *));
int rand(void) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));
void srand(unsigned) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));
double strtod(const char *, char **) __asm("_" "strtod" );
float strtof(const char *, char **) __asm("_" "strtof" );
long strtol(const char *__str, char **__endptr, int __base);
long double
  strtold(const char *, char **);
long long
  strtoll(const char *__str, char **__endptr, int __base);
unsigned long
  strtoul(const char *__str, char **__endptr, int __base);
unsigned long long
  strtoull(const char *__str, char **__endptr, int __base);
__attribute__((__availability__(swift, unavailable, message="Use posix_spawn APIs or NSTask instead. (On iOS, process spawning is unavailable.)")))
__attribute__((availability(macos,introduced=10.0))) __attribute__((availability(ios,unavailable)))
__attribute__((availability(watchos,unavailable))) __attribute__((availability(tvos,unavailable)))
int system(const char *) __asm("_" "system" );
size_t wcstombs(char * , const wchar_t * , size_t);
int wctomb(char *, wchar_t);
void _Exit(int) __attribute__((__noreturn__));
long a64l(const char *);
double drand48(void);
char *ecvt(double, int, int *, int *);
double erand48(unsigned short[3]);
char *fcvt(double, int, int *, int *);
char *gcvt(double, int, char *);
int getsubopt(char **, char * const *, char **);
int grantpt(int);
char *initstate(unsigned, char *, size_t);
long jrand48(unsigned short[3]) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));
char *l64a(long);
void lcong48(unsigned short[7]);
long lrand48(void) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));
__attribute__((__deprecated__("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of mktemp(3), it is highly recommended that you use mkstemp(3) instead.")))
char *mktemp(char *);
int mkstemp(char *);
long mrand48(void) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));
long nrand48(unsigned short[3]) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));
int posix_openpt(int);
char *ptsname(int);
int ptsname_r(int fildes, char *buffer, size_t buflen) __attribute__((availability(macos,introduced=10.13.4))) __attribute__((availability(ios,introduced=11.3))) __attribute__((availability(tvos,introduced=11.3))) __attribute__((availability(watchos,introduced=4.3)));
int putenv(char *) __asm("_" "putenv" );
long random(void) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));
int rand_r(unsigned *) __attribute__((__availability__(swift, unavailable, message="Use arc4random instead.")));
char *realpath(const char * , char * ) __asm("_" "realpath" "$DARWIN_EXTSN");
unsigned short
 *seed48(unsigned short[3]);
int setenv(const char * __name, const char * __value, int __overwrite) __asm("_" "setenv" );
void setkey(const char *) __asm("_" "setkey" );
char *setstate(const char *);
void srand48(long);
void srandom(unsigned);
int unlockpt(int);
int unsetenv(const char *) __asm("_" "unsetenv" );
}
typedef __darwin_dev_t dev_t;
typedef __darwin_mode_t mode_t;
extern "C" {
uint32_t arc4random(void);
void arc4random_addrandom(unsigned char * , int )
    __attribute__((availability(macosx,introduced=10.0))) __attribute__((availability(macosx,deprecated=10.12,message="use arc4random_stir")))
    __attribute__((availability(ios,introduced=2.0))) __attribute__((availability(ios,deprecated=10.0,message="use arc4random_stir")))
    __attribute__((availability(tvos,introduced=2.0))) __attribute__((availability(tvos,deprecated=10.0,message="use arc4random_stir")))
    __attribute__((availability(watchos,introduced=1.0))) __attribute__((availability(watchos,deprecated=3.0,message="use arc4random_stir")));
void arc4random_buf(void * __buf, size_t __nbytes) __attribute__((availability(macosx,introduced=10.7)));
void arc4random_stir(void);
uint32_t
  arc4random_uniform(uint32_t __upper_bound) __attribute__((availability(macosx,introduced=10.7)));
int atexit_b(void (^ _Nonnull)(void)) __attribute__((availability(macosx,introduced=10.6)));
void *bsearch_b(const void *__key, const void *__base, size_t __nel,
     size_t __width, int (^ _Nonnull __compar)(const void *, const void *) __attribute__((__noescape__)))
     __attribute__((availability(macosx,introduced=10.6)));
char *cgetcap(char *, const char *, int);
int cgetclose(void);
int cgetent(char **, char **, const char *);
int cgetfirst(char **, char **);
int cgetmatch(const char *, const char *);
int cgetnext(char **, char **);
int cgetnum(char *, const char *, long *);
int cgetset(const char *);
int cgetstr(char *, const char *, char **);
int cgetustr(char *, const char *, char **);
int daemon(int, int) __asm("_" "daemon" ) __attribute__((availability(macosx,introduced=10.0,deprecated=10.5,message="Use posix_spawn APIs instead."))) __attribute__((availability(watchos,unavailable))) __attribute__((availability(tvos,unavailable)));
char *devname(dev_t, mode_t);
char *devname_r(dev_t, mode_t, char *buf, int len);
char *getbsize(int *, long *);
int getloadavg(double [], int);
const char
 *getprogname(void);
void setprogname(const char *);
int heapsort(void *__base, size_t __nel, size_t __width,
     int (* _Nonnull __compar)(const void *, const void *));
int heapsort_b(void *__base, size_t __nel, size_t __width,
     int (^ _Nonnull __compar)(const void *, const void *) __attribute__((__noescape__)))
     __attribute__((availability(macosx,introduced=10.6)));
int mergesort(void *__base, size_t __nel, size_t __width,
     int (* _Nonnull __compar)(const void *, const void *));
int mergesort_b(void *__base, size_t __nel, size_t __width,
     int (^ _Nonnull __compar)(const void *, const void *) __attribute__((__noescape__)))
     __attribute__((availability(macosx,introduced=10.6)));
void psort(void *__base, size_t __nel, size_t __width,
     int (* _Nonnull __compar)(const void *, const void *))
     __attribute__((availability(macosx,introduced=10.6)));
void psort_b(void *__base, size_t __nel, size_t __width,
     int (^ _Nonnull __compar)(const void *, const void *) __attribute__((__noescape__)))
     __attribute__((availability(macosx,introduced=10.6)));
void psort_r(void *__base, size_t __nel, size_t __width, void *,
     int (* _Nonnull __compar)(void *, const void *, const void *))
     __attribute__((availability(macosx,introduced=10.6)));
void qsort_b(void *__base, size_t __nel, size_t __width,
     int (^ _Nonnull __compar)(const void *, const void *) __attribute__((__noescape__)))
     __attribute__((availability(macosx,introduced=10.6)));
void qsort_r(void *__base, size_t __nel, size_t __width, void *,
     int (* _Nonnull __compar)(void *, const void *, const void *));
int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table,
     unsigned __endbyte);
int rpmatch(const char *)
 __attribute__((availability(macos,introduced=10.15))) __attribute__((availability(ios,introduced=13.0))) __attribute__((availability(tvos,introduced=13.0))) __attribute__((availability(watchos,introduced=6.0)));
int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table,
     unsigned __endbyte);
void sranddev(void);
void srandomdev(void);
void *reallocf(void *__ptr, size_t __size) __attribute__((alloc_size(2)));
long long
 strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
 __attribute__((availability(macos,introduced=11.0))) __attribute__((availability(ios,introduced=14.0))) __attribute__((availability(tvos,introduced=14.0))) __attribute__((availability(watchos,introduced=7.0)));
long long
  strtoq(const char *__str, char **__endptr, int __base);
unsigned long long
  strtouq(const char *__str, char **__endptr, int __base);
extern char *suboptarg;
}
extern "C" {
}
extern "C++" {
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long abs(long __x) noexcept {
  return __builtin_labs(__x);
}
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long long abs(long long __x) noexcept {
  return __builtin_llabs(__x);
}
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float abs(float __lcpp_x) noexcept {
  return __builtin_fabsf(__lcpp_x);
}
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double abs(double __lcpp_x) noexcept {
  return __builtin_fabs(__lcpp_x);
}
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double
abs(long double __lcpp_x) noexcept {
  return __builtin_fabsl(__lcpp_x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) ldiv_t div(long __x, long __y) noexcept {
  return ::ldiv(__x, __y);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) lldiv_t div(long long __x,
                                             long long __y) noexcept {
  return ::lldiv(__x, __y);
}
}
namespace std { inline namespace __1 {
using ::size_t __attribute__((__using_if_exists__));
using ::div_t __attribute__((__using_if_exists__));
using ::ldiv_t __attribute__((__using_if_exists__));
using ::lldiv_t __attribute__((__using_if_exists__));
using ::atof __attribute__((__using_if_exists__));
using ::atoi __attribute__((__using_if_exists__));
using ::atol __attribute__((__using_if_exists__));
using ::atoll __attribute__((__using_if_exists__));
using ::strtod __attribute__((__using_if_exists__));
using ::strtof __attribute__((__using_if_exists__));
using ::strtold __attribute__((__using_if_exists__));
using ::strtol __attribute__((__using_if_exists__));
using ::strtoll __attribute__((__using_if_exists__));
using ::strtoul __attribute__((__using_if_exists__));
using ::strtoull __attribute__((__using_if_exists__));
using ::rand __attribute__((__using_if_exists__));
using ::srand __attribute__((__using_if_exists__));
using ::calloc __attribute__((__using_if_exists__));
using ::free __attribute__((__using_if_exists__));
using ::malloc __attribute__((__using_if_exists__));
using ::realloc __attribute__((__using_if_exists__));
using ::abort __attribute__((__using_if_exists__));
using ::atexit __attribute__((__using_if_exists__));
using ::exit __attribute__((__using_if_exists__));
using ::_Exit __attribute__((__using_if_exists__));
using ::getenv __attribute__((__using_if_exists__));
using ::system __attribute__((__using_if_exists__));
using ::bsearch __attribute__((__using_if_exists__));
using ::qsort __attribute__((__using_if_exists__));
using ::abs __attribute__((__using_if_exists__));
using ::labs __attribute__((__using_if_exists__));
using ::llabs __attribute__((__using_if_exists__));
using ::div __attribute__((__using_if_exists__));
using ::ldiv __attribute__((__using_if_exists__));
using ::lldiv __attribute__((__using_if_exists__));
using ::mblen __attribute__((__using_if_exists__));
using ::mbtowc __attribute__((__using_if_exists__));
using ::wctomb __attribute__((__using_if_exists__));
using ::mbstowcs __attribute__((__using_if_exists__));
using ::wcstombs __attribute__((__using_if_exists__));
using ::at_quick_exit __attribute__((__using_if_exists__));
using ::quick_exit __attribute__((__using_if_exists__));
using ::aligned_alloc __attribute__((__using_if_exists__));
}}
namespace std { inline namespace __1 {
enum float_round_style
{
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
};
enum float_denorm_style
{
    denorm_indeterminate = -1,
    denorm_absent = 0,
    denorm_present = 1
};
template <class _Tp, bool = is_arithmetic<_Tp>::value>
class __libcpp_numeric_limits
{
protected:
    typedef _Tp type;
    static constexpr const bool is_specialized = false;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type min() noexcept {return type();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type max() noexcept {return type();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type lowest() noexcept {return type();}
    static constexpr const int digits = 0;
    static constexpr const int digits10 = 0;
    static constexpr const int max_digits10 = 0;
    static constexpr const bool is_signed = false;
    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 0;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type epsilon() noexcept {return type();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type round_error() noexcept {return type();}
    static constexpr const int min_exponent = 0;
    static constexpr const int min_exponent10 = 0;
    static constexpr const int max_exponent = 0;
    static constexpr const int max_exponent10 = 0;
    static constexpr const bool has_infinity = false;
    static constexpr const bool has_quiet_NaN = false;
    static constexpr const bool has_signaling_NaN = false;
    static constexpr const float_denorm_style has_denorm = denorm_absent;
    static constexpr const bool has_denorm_loss = false;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type infinity() noexcept {return type();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type quiet_NaN() noexcept {return type();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type signaling_NaN() noexcept {return type();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type denorm_min() noexcept {return type();}
    static constexpr const bool is_iec559 = false;
    static constexpr const bool is_bounded = false;
    static constexpr const bool is_modulo = false;
    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_toward_zero;
};
template <class _Tp, int __digits, bool _IsSigned>
struct __libcpp_compute_min
{
    static constexpr const _Tp value = _Tp(_Tp(1) << __digits);
};
template <class _Tp, int __digits>
struct __libcpp_compute_min<_Tp, __digits, false>
{
    static constexpr const _Tp value = _Tp(0);
};
template <class _Tp>
class __libcpp_numeric_limits<_Tp, true>
{
protected:
    typedef _Tp type;
    static constexpr const bool is_specialized = true;
    static constexpr const bool is_signed = type(-1) < type(0);
    static constexpr const int digits = static_cast<int>(sizeof(type) * 8 - is_signed);
    static constexpr const int digits10 = digits * 3 / 10;
    static constexpr const int max_digits10 = 0;
    static constexpr const type __min = __libcpp_compute_min<type, digits, is_signed>::value;
    static constexpr const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type min() noexcept {return __min;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type max() noexcept {return __max;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type lowest() noexcept {return min();}
    static constexpr const bool is_integer = true;
    static constexpr const bool is_exact = true;
    static constexpr const int radix = 2;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type epsilon() noexcept {return type(0);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type round_error() noexcept {return type(0);}
    static constexpr const int min_exponent = 0;
    static constexpr const int min_exponent10 = 0;
    static constexpr const int max_exponent = 0;
    static constexpr const int max_exponent10 = 0;
    static constexpr const bool has_infinity = false;
    static constexpr const bool has_quiet_NaN = false;
    static constexpr const bool has_signaling_NaN = false;
    static constexpr const float_denorm_style has_denorm = denorm_absent;
    static constexpr const bool has_denorm_loss = false;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type infinity() noexcept {return type(0);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type quiet_NaN() noexcept {return type(0);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type signaling_NaN() noexcept {return type(0);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type denorm_min() noexcept {return type(0);}
    static constexpr const bool is_iec559 = false;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = !std::is_signed<_Tp>::value;
    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_toward_zero;
};
template <>
class __libcpp_numeric_limits<bool, true>
{
protected:
    typedef bool type;
    static constexpr const bool is_specialized = true;
    static constexpr const bool is_signed = false;
    static constexpr const int digits = 1;
    static constexpr const int digits10 = 0;
    static constexpr const int max_digits10 = 0;
    static constexpr const type __min = false;
    static constexpr const type __max = true;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type min() noexcept {return __min;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type max() noexcept {return __max;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type lowest() noexcept {return min();}
    static constexpr const bool is_integer = true;
    static constexpr const bool is_exact = true;
    static constexpr const int radix = 2;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type epsilon() noexcept {return type(0);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type round_error() noexcept {return type(0);}
    static constexpr const int min_exponent = 0;
    static constexpr const int min_exponent10 = 0;
    static constexpr const int max_exponent = 0;
    static constexpr const int max_exponent10 = 0;
    static constexpr const bool has_infinity = false;
    static constexpr const bool has_quiet_NaN = false;
    static constexpr const bool has_signaling_NaN = false;
    static constexpr const float_denorm_style has_denorm = denorm_absent;
    static constexpr const bool has_denorm_loss = false;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type infinity() noexcept {return type(0);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type quiet_NaN() noexcept {return type(0);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type signaling_NaN() noexcept {return type(0);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type denorm_min() noexcept {return type(0);}
    static constexpr const bool is_iec559 = false;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;
    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = false;
    static constexpr const float_round_style round_style = round_toward_zero;
};
template <>
class __libcpp_numeric_limits<float, true>
{
protected:
    typedef float type;
    static constexpr const bool is_specialized = true;
    static constexpr const bool is_signed = true;
    static constexpr const int digits = 24;
    static constexpr const int digits10 = 6;
    static constexpr const int max_digits10 = 2+(digits * 30103l)/100000l;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type min() noexcept {return 1.17549435e-38F;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type max() noexcept {return 3.40282347e+38F;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type lowest() noexcept {return -max();}
    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 2;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type epsilon() noexcept {return 1.19209290e-7F;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type round_error() noexcept {return 0.5F;}
    static constexpr const int min_exponent = (-125);
    static constexpr const int min_exponent10 = (-37);
    static constexpr const int max_exponent = 128;
    static constexpr const int max_exponent10 = 38;
    static constexpr const bool has_infinity = true;
    static constexpr const bool has_quiet_NaN = true;
    static constexpr const bool has_signaling_NaN = true;
    static constexpr const float_denorm_style has_denorm = denorm_present;
    static constexpr const bool has_denorm_loss = false;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type infinity() noexcept {return __builtin_huge_valf();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type quiet_NaN() noexcept {return __builtin_nanf("");}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type signaling_NaN() noexcept {return __builtin_nansf("");}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type denorm_min() noexcept {return 1.40129846e-45F;}
    static constexpr const bool is_iec559 = true;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;
    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = true;
    static constexpr const float_round_style round_style = round_to_nearest;
};
template <>
class __libcpp_numeric_limits<double, true>
{
protected:
    typedef double type;
    static constexpr const bool is_specialized = true;
    static constexpr const bool is_signed = true;
    static constexpr const int digits = 53;
    static constexpr const int digits10 = 15;
    static constexpr const int max_digits10 = 2+(digits * 30103l)/100000l;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type min() noexcept {return 2.2250738585072014e-308;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type max() noexcept {return 1.7976931348623157e+308;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type lowest() noexcept {return -max();}
    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 2;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type epsilon() noexcept {return 2.2204460492503131e-16;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type round_error() noexcept {return 0.5;}
    static constexpr const int min_exponent = (-1021);
    static constexpr const int min_exponent10 = (-307);
    static constexpr const int max_exponent = 1024;
    static constexpr const int max_exponent10 = 308;
    static constexpr const bool has_infinity = true;
    static constexpr const bool has_quiet_NaN = true;
    static constexpr const bool has_signaling_NaN = true;
    static constexpr const float_denorm_style has_denorm = denorm_present;
    static constexpr const bool has_denorm_loss = false;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type infinity() noexcept {return __builtin_huge_val();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type quiet_NaN() noexcept {return __builtin_nan("");}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type signaling_NaN() noexcept {return __builtin_nans("");}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type denorm_min() noexcept {return 4.9406564584124654e-324;}
    static constexpr const bool is_iec559 = true;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;
    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = true;
    static constexpr const float_round_style round_style = round_to_nearest;
};
template <>
class __libcpp_numeric_limits<long double, true>
{
protected:
    typedef long double type;
    static constexpr const bool is_specialized = true;
    static constexpr const bool is_signed = true;
    static constexpr const int digits = 53;
    static constexpr const int digits10 = 15;
    static constexpr const int max_digits10 = 2+(digits * 30103l)/100000l;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type min() noexcept {return 2.2250738585072014e-308L;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type max() noexcept {return 1.7976931348623157e+308L;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type lowest() noexcept {return -max();}
    static constexpr const bool is_integer = false;
    static constexpr const bool is_exact = false;
    static constexpr const int radix = 2;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type epsilon() noexcept {return 2.2204460492503131e-16L;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type round_error() noexcept {return 0.5L;}
    static constexpr const int min_exponent = (-1021);
    static constexpr const int min_exponent10 = (-307);
    static constexpr const int max_exponent = 1024;
    static constexpr const int max_exponent10 = 308;
    static constexpr const bool has_infinity = true;
    static constexpr const bool has_quiet_NaN = true;
    static constexpr const bool has_signaling_NaN = true;
    static constexpr const float_denorm_style has_denorm = denorm_present;
    static constexpr const bool has_denorm_loss = false;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type infinity() noexcept {return __builtin_huge_vall();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type quiet_NaN() noexcept {return __builtin_nanl("");}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type signaling_NaN() noexcept {return __builtin_nansl("");}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type denorm_min() noexcept {return 4.9406564584124654e-324L;}
    static constexpr const bool is_iec559 = true;
    static constexpr const bool is_bounded = true;
    static constexpr const bool is_modulo = false;
    static constexpr const bool traps = false;
    static constexpr const bool tinyness_before = true;
    static constexpr const float_round_style round_style = round_to_nearest;
};
template <class _Tp>
class __attribute__((__type_visibility__("default"))) numeric_limits
    : private __libcpp_numeric_limits<__remove_cv_t<_Tp> >
{
    typedef __libcpp_numeric_limits<__remove_cv_t<_Tp> > __base;
    typedef typename __base::type type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type min() noexcept {return __base::min();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type max() noexcept {return __base::max();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type lowest() noexcept {return __base::lowest();}
    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type round_error() noexcept {return __base::round_error();}
    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;
    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type denorm_min() noexcept {return __base::denorm_min();}
    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;
    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<_Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<_Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<_Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<_Tp>::round_style;
template <class _Tp>
class __attribute__((__type_visibility__("default"))) numeric_limits<const _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type min() noexcept {return __base::min();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type max() noexcept {return __base::max();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type lowest() noexcept {return __base::lowest();}
    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type round_error() noexcept {return __base::round_error();}
    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;
    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type denorm_min() noexcept {return __base::denorm_min();}
    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;
    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const _Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<const _Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<const _Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<const _Tp>::round_style;
template <class _Tp>
class __attribute__((__type_visibility__("default"))) numeric_limits<volatile _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type min() noexcept {return __base::min();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type max() noexcept {return __base::max();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type lowest() noexcept {return __base::lowest();}
    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type round_error() noexcept {return __base::round_error();}
    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;
    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type denorm_min() noexcept {return __base::denorm_min();}
    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;
    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<volatile _Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<volatile _Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<volatile _Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<volatile _Tp>::round_style;
template <class _Tp>
class __attribute__((__type_visibility__("default"))) numeric_limits<const volatile _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static constexpr const bool is_specialized = __base::is_specialized;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type min() noexcept {return __base::min();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type max() noexcept {return __base::max();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type lowest() noexcept {return __base::lowest();}
    static constexpr const int digits = __base::digits;
    static constexpr const int digits10 = __base::digits10;
    static constexpr const int max_digits10 = __base::max_digits10;
    static constexpr const bool is_signed = __base::is_signed;
    static constexpr const bool is_integer = __base::is_integer;
    static constexpr const bool is_exact = __base::is_exact;
    static constexpr const int radix = __base::radix;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type epsilon() noexcept {return __base::epsilon();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type round_error() noexcept {return __base::round_error();}
    static constexpr const int min_exponent = __base::min_exponent;
    static constexpr const int min_exponent10 = __base::min_exponent10;
    static constexpr const int max_exponent = __base::max_exponent;
    static constexpr const int max_exponent10 = __base::max_exponent10;
    static constexpr const bool has_infinity = __base::has_infinity;
    static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
    static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
    static constexpr const float_denorm_style has_denorm = __base::has_denorm;
    static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type infinity() noexcept {return __base::infinity();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type quiet_NaN() noexcept {return __base::quiet_NaN();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type signaling_NaN() noexcept {return __base::signaling_NaN();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr type denorm_min() noexcept {return __base::denorm_min();}
    static constexpr const bool is_iec559 = __base::is_iec559;
    static constexpr const bool is_bounded = __base::is_bounded;
    static constexpr const bool is_modulo = __base::is_modulo;
    static constexpr const bool traps = __base::traps;
    static constexpr const bool tinyness_before = __base::tinyness_before;
    static constexpr const float_round_style round_style = __base::round_style;
};
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_specialized;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::digits;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::digits10;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::max_digits10;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_signed;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_integer;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_exact;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::radix;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::min_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::min_exponent10;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::max_exponent;
template <class _Tp>
    constexpr const int numeric_limits<const volatile _Tp>::max_exponent10;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_infinity;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_quiet_NaN;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_signaling_NaN;
template <class _Tp>
    constexpr const float_denorm_style numeric_limits<const volatile _Tp>::has_denorm;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::has_denorm_loss;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_iec559;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_bounded;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::is_modulo;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::traps;
template <class _Tp>
    constexpr const bool numeric_limits<const volatile _Tp>::tinyness_before;
template <class _Tp>
    constexpr const float_round_style numeric_limits<const volatile _Tp>::round_style;
}}
namespace std { inline namespace __1 {
template <class _InputIter>
// added by concept-synth, original LN: 4826
requires
requires (_InputIter x0) { ++x0; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void __advance(_InputIter& __i, typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag) {
  for (; __n > 0; --__n)
    ++__i;
}
template <class _BiDirIter>
// added by concept-synth, original LN: 4832
requires
(
 requires (_BiDirIter x0) { --x0; } &&
 requires (_BiDirIter x0) { ++x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void __advance(_BiDirIter& __i, typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag) {
  if (__n >= 0)
    for (; __n > 0; --__n)
      ++__i;
  else
    for (; __n < 0; ++__n)
      --__i;
}
template <class _RandIter>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void __advance(_RandIter& __i, typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag) {
  __i += __n;
}
template <
    class _InputIter, class _Distance,
    class _IntegralDistance = decltype(std::__convert_to_integral(std::declval<_Distance>())),
    class = __enable_if_t<is_integral<_IntegralDistance>::value> >
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void advance(_InputIter& __i, _Distance __orig_n) {
  typedef typename iterator_traits<_InputIter>::difference_type _Difference;
  _Difference __n = static_cast<_Difference>(std::__convert_to_integral(__orig_n));
  (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
  __builtin_assume(static_cast<bool>(__n >= 0 || __is_cpp17_bidirectional_iterator<_InputIter>::value))
#pragma clang diagnostic pop
  );
  std::__advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());
}
namespace ranges {
namespace __advance {
struct __fn {
private:
  template <class _Ip>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  static constexpr void __advance_forward(_Ip& __i, iter_difference_t<_Ip> __n) {
    while (__n > 0) {
      --__n;
      ++__i;
    }
  }
  template <class _Ip>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  static constexpr void __advance_backward(_Ip& __i, iter_difference_t<_Ip> __n) {
    while (__n < 0) {
      ++__n;
      --__i;
    }
  }
public:
  template <input_or_output_iterator _Ip>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr void operator()(_Ip& __i, iter_difference_t<_Ip> __n) const {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(__n >= 0 || bidirectional_iterator<_Ip>))
#pragma clang diagnostic pop
    );
    if constexpr (random_access_iterator<_Ip>) {
      __i += __n;
      return;
    } else if constexpr (bidirectional_iterator<_Ip>) {
      __advance_forward(__i, __n);
      __advance_backward(__i, __n);
      return;
    } else {
      __advance_forward(__i, __n);
      return;
    }
  }
  template <input_or_output_iterator _Ip, sentinel_for<_Ip> _Sp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr void operator()(_Ip& __i, _Sp __bound_sentinel) const {
    if constexpr (assignable_from<_Ip&, _Sp>) {
      __i = std::move(__bound_sentinel);
    }
    else if constexpr (sized_sentinel_for<_Sp, _Ip>) {
      (*this)(__i, __bound_sentinel - __i);
    }
    else {
      while (__i != __bound_sentinel) {
        ++__i;
      }
    }
  }
  template <input_or_output_iterator _Ip, sentinel_for<_Ip> _Sp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr iter_difference_t<_Ip> operator()(_Ip& __i, iter_difference_t<_Ip> __n,
                                                                    _Sp __bound_sentinel) const {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>((__n >= 0) || (bidirectional_iterator<_Ip> && same_as<_Ip, _Sp>)))
#pragma clang diagnostic pop
    );
    if constexpr (sized_sentinel_for<_Sp, _Ip>) {
      auto __magnitude_geq = [](auto __a, auto __b) {
        return __a == 0 ? __b == 0 :
               __a > 0 ? __a >= __b :
                          __a <= __b;
      };
      if (const auto __M = __bound_sentinel - __i; __magnitude_geq(__n, __M)) {
        (*this)(__i, __bound_sentinel);
        return __n - __M;
      }
      (*this)(__i, __n);
      return 0;
    } else {
      while (__i != __bound_sentinel && __n > 0) {
        ++__i;
        --__n;
      }
      if constexpr (bidirectional_iterator<_Ip> && same_as<_Ip, _Sp>) {
        while (__i != __bound_sentinel && __n < 0) {
          --__i;
          ++__n;
        }
      }
      return __n;
    }
    __libcpp_unreachable();
  }
};
}
inline namespace __cpo {
  inline constexpr auto advance = __advance::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class>
inline constexpr bool enable_borrowed_range = false;
}
}}
namespace std { inline namespace __1 {
namespace ranges {
  template <class _Tp>
  concept __can_borrow =
    is_lvalue_reference_v<_Tp> || enable_borrowed_range<remove_cvref_t<_Tp>>;
}
namespace ranges {
namespace __begin {
  template <class _Tp>
  concept __member_begin =
    __can_borrow<_Tp> &&
    __workaround_52970<_Tp> &&
    requires(_Tp&& __t) {
      { static_cast<typename decay<decltype((__t.begin()))>::type>(__t.begin()) } -> input_or_output_iterator;
    };
  void begin(auto&) = delete;
  void begin(const auto&) = delete;
  template <class _Tp>
  concept __unqualified_begin =
    !__member_begin<_Tp> &&
    __can_borrow<_Tp> &&
    __class_or_enum<remove_cvref_t<_Tp>> &&
    requires(_Tp && __t) {
      { static_cast<typename decay<decltype((begin(__t)))>::type>(begin(__t)) } -> input_or_output_iterator;
    };
  struct __fn {
    template <class _Tp>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr auto operator()(_Tp (&__t)[]) const noexcept
      requires (sizeof(_Tp) >= 0)
    {
      return __t + 0;
    }
    template <class _Tp, size_t _Np>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr auto operator()(_Tp (&__t)[_Np]) const noexcept
      requires (sizeof(_Tp) >= 0)
    {
      return __t + 0;
    }
    template <class _Tp>
      requires __member_begin<_Tp>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(static_cast<typename decay<decltype((__t.begin()))>::type>(__t.begin())))
    {
      return static_cast<typename decay<decltype((__t.begin()))>::type>(__t.begin());
    }
    template <class _Tp>
      requires __unqualified_begin<_Tp>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(static_cast<typename decay<decltype((begin(__t)))>::type>(begin(__t))))
    {
      return static_cast<typename decay<decltype((begin(__t)))>::type>(begin(__t));
    }
    void operator()(auto&&) const = delete;
  };
}
inline namespace __cpo {
  inline constexpr auto begin = __begin::__fn{};
}
}
namespace ranges {
  template <class _Tp>
  using iterator_t = decltype(ranges::begin(std::declval<_Tp&>()));
}
namespace ranges {
namespace __end {
  template <class _Tp>
  concept __member_end =
    __can_borrow<_Tp> &&
    __workaround_52970<_Tp> &&
    requires(_Tp&& __t) {
      typename iterator_t<_Tp>;
      { static_cast<typename decay<decltype((__t.end()))>::type>(__t.end()) } -> sentinel_for<iterator_t<_Tp>>;
    };
  void end(auto&) = delete;
  void end(const auto&) = delete;
  template <class _Tp>
  concept __unqualified_end =
    !__member_end<_Tp> &&
    __can_borrow<_Tp> &&
    __class_or_enum<remove_cvref_t<_Tp>> &&
    requires(_Tp && __t) {
      typename iterator_t<_Tp>;
      { static_cast<typename decay<decltype((end(__t)))>::type>(end(__t)) } -> sentinel_for<iterator_t<_Tp>>;
    };
  struct __fn {
    template <class _Tp, size_t _Np>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr auto operator()(_Tp (&__t)[_Np]) const noexcept
      requires (sizeof(_Tp) >= 0)
    {
      return __t + _Np;
    }
    template <class _Tp>
      requires __member_end<_Tp>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(static_cast<typename decay<decltype((__t.end()))>::type>(__t.end())))
    {
      return static_cast<typename decay<decltype((__t.end()))>::type>(__t.end());
    }
    template <class _Tp>
      requires __unqualified_end<_Tp>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(static_cast<typename decay<decltype((end(__t)))>::type>(end(__t))))
    {
      return static_cast<typename decay<decltype((end(__t)))>::type>(end(__t));
    }
    void operator()(auto&&) const = delete;
  };
}
inline namespace __cpo {
  inline constexpr auto end = __end::__fn{};
}
}
namespace ranges {
namespace __cbegin {
  struct __fn {
    template <class _Tp>
      requires is_lvalue_reference_v<_Tp&&>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(ranges::begin(static_cast<const remove_reference_t<_Tp>&>(__t))))
      -> decltype( ranges::begin(static_cast<const remove_reference_t<_Tp>&>(__t)))
      { return ranges::begin(static_cast<const remove_reference_t<_Tp>&>(__t)); }
    template <class _Tp>
      requires is_rvalue_reference_v<_Tp&&>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(ranges::begin(static_cast<const _Tp&&>(__t))))
      -> decltype( ranges::begin(static_cast<const _Tp&&>(__t)))
      { return ranges::begin(static_cast<const _Tp&&>(__t)); }
  };
}
inline namespace __cpo {
  inline constexpr auto cbegin = __cbegin::__fn{};
}
}
namespace ranges {
namespace __cend {
  struct __fn {
    template <class _Tp>
      requires is_lvalue_reference_v<_Tp&&>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(ranges::end(static_cast<const remove_reference_t<_Tp>&>(__t))))
      -> decltype( ranges::end(static_cast<const remove_reference_t<_Tp>&>(__t)))
      { return ranges::end(static_cast<const remove_reference_t<_Tp>&>(__t)); }
    template <class _Tp>
      requires is_rvalue_reference_v<_Tp&&>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(ranges::end(static_cast<const _Tp&&>(__t))))
      -> decltype( ranges::end(static_cast<const _Tp&&>(__t)))
      { return ranges::end(static_cast<const _Tp&&>(__t)); }
  };
}
inline namespace __cpo {
  inline constexpr auto cend = __cend::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __data {
  template <class _Tp>
  concept __ptr_to_object = is_pointer_v<_Tp> && is_object_v<remove_pointer_t<_Tp>>;
  template <class _Tp>
  concept __member_data =
    __can_borrow<_Tp> &&
    __workaround_52970<_Tp> &&
    requires(_Tp&& __t) {
      { static_cast<typename decay<decltype((__t.data()))>::type>(__t.data()) } -> __ptr_to_object;
    };
  template <class _Tp>
  concept __ranges_begin_invocable =
    !__member_data<_Tp> &&
    __can_borrow<_Tp> &&
    requires(_Tp&& __t) {
      { ranges::begin(__t) } -> contiguous_iterator;
    };
  struct __fn {
    template <__member_data _Tp>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr auto operator()(_Tp&& __t) const
        noexcept(noexcept(__t.data())) {
      return __t.data();
    }
    template<__ranges_begin_invocable _Tp>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr auto operator()(_Tp&& __t) const
        noexcept(noexcept(std::to_address(ranges::begin(__t)))) {
      return std::to_address(ranges::begin(__t));
    }
  };
}
inline namespace __cpo {
  inline constexpr auto data = __data::__fn{};
}
}
namespace ranges {
namespace __cdata {
  struct __fn {
    template <class _Tp>
      requires is_lvalue_reference_v<_Tp&&>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(ranges::data(static_cast<const remove_reference_t<_Tp>&>(__t))))
      -> decltype( ranges::data(static_cast<const remove_reference_t<_Tp>&>(__t)))
      { return ranges::data(static_cast<const remove_reference_t<_Tp>&>(__t)); }
    template <class _Tp>
      requires is_rvalue_reference_v<_Tp&&>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr auto operator()(_Tp&& __t) const
      noexcept(noexcept(ranges::data(static_cast<const _Tp&&>(__t))))
      -> decltype( ranges::data(static_cast<const _Tp&&>(__t)))
      { return ranges::data(static_cast<const _Tp&&>(__t)); }
  };
}
inline namespace __cpo {
  inline constexpr auto cdata = __cdata::__fn{};
}
}
}}

namespace std { inline namespace __1 {
namespace ranges {
struct view_base { };
template<class _Derived>
  requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>
class view_interface;
template<class _Op, class _Yp>
  requires is_convertible_v<_Op*, view_interface<_Yp>*>
void __is_derived_from_view_interface(const _Op*, const view_interface<_Yp>*);
template <class _Tp>
inline constexpr bool enable_view = derived_from<_Tp, view_base> ||
  requires { ranges::__is_derived_from_view_interface((_Tp*)nullptr, (_Tp*)nullptr); };
}
}}
namespace std { inline namespace __1 {
namespace ranges {
  template<class>
  inline constexpr bool disable_sized_range = false;
}
namespace ranges {
namespace __size {
void size(auto&) = delete;
void size(const auto&) = delete;
template <class _Tp>
concept __size_enabled = !disable_sized_range<remove_cvref_t<_Tp>>;
template <class _Tp>
concept __member_size =
  __size_enabled<_Tp> &&
  __workaround_52970<_Tp> &&
  requires(_Tp&& __t) {
    { static_cast<typename decay<decltype((__t.size()))>::type>(__t.size()) } -> __integer_like;
  };
template <class _Tp>
concept __unqualified_size =
  __size_enabled<_Tp> &&
  !__member_size<_Tp> &&
  __class_or_enum<remove_cvref_t<_Tp>> &&
  requires(_Tp&& __t) {
    { static_cast<typename decay<decltype((size(__t)))>::type>(size(__t)) } -> __integer_like;
  };
template <class _Tp>
concept __difference =
  !__member_size<_Tp> &&
  !__unqualified_size<_Tp> &&
  __class_or_enum<remove_cvref_t<_Tp>> &&
  requires(_Tp&& __t) {
    { ranges::begin(__t) } -> forward_iterator;
    { ranges::end(__t) } -> sized_sentinel_for<decltype(ranges::begin(std::declval<_Tp>()))>;
  };
struct __fn {
  template <class _Tp, size_t _Sz>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr size_t operator()(_Tp (&&)[_Sz]) const noexcept {
    return _Sz;
  }
  template <class _Tp, size_t _Sz>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr size_t operator()(_Tp (&)[_Sz]) const noexcept {
    return _Sz;
  }
  template <__member_size _Tp>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __integer_like auto operator()(_Tp&& __t) const
      noexcept(noexcept(static_cast<typename decay<decltype((__t.size()))>::type>(__t.size()))) {
    return static_cast<typename decay<decltype((__t.size()))>::type>(__t.size());
  }
  template <__unqualified_size _Tp>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __integer_like auto operator()(_Tp&& __t) const
      noexcept(noexcept(static_cast<typename decay<decltype((size(__t)))>::type>(size(__t)))) {
    return static_cast<typename decay<decltype((size(__t)))>::type>(size(__t));
  }
  template <__difference _Tp>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr auto operator()(_Tp&& __t) const
    noexcept(noexcept(std::__to_unsigned_like(ranges::end(__t) - ranges::begin(__t))))
    -> decltype( std::__to_unsigned_like(ranges::end(__t) - ranges::begin(__t)))
    { return std::__to_unsigned_like(ranges::end(__t) - ranges::begin(__t));
  }
};
}
inline namespace __cpo {
  inline constexpr auto size = __size::__fn{};
}
}
namespace ranges {
namespace __ssize {
struct __fn {
  template<class _Tp>
    requires requires (_Tp&& __t) { ranges::size(__t); }
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr integral auto operator()(_Tp&& __t) const
    noexcept(noexcept(ranges::size(__t))) {
    using _Signed = make_signed_t<decltype(ranges::size(__t))>;
    if constexpr (sizeof(ptrdiff_t) > sizeof(_Signed))
      return static_cast<ptrdiff_t>(ranges::size(__t));
    else
      return static_cast<_Signed>(ranges::size(__t));
  }
};
}
inline namespace __cpo {
  inline constexpr auto ssize = __ssize::__fn{};
}
}
}}
namespace std
{
template<class _Ep>
class __attribute__((__type_visibility__("default"))) initializer_list
{
    const _Ep* __begin_;
    size_t __size_;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr
    initializer_list(const _Ep* __b, size_t __s) noexcept
        : __begin_(__b),
          __size_(__s)
        {}
public:
    typedef _Ep value_type;
    typedef const _Ep& reference;
    typedef const _Ep& const_reference;
    typedef size_t size_type;
    typedef const _Ep* iterator;
    typedef const _Ep* const_iterator;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr
    initializer_list() noexcept : __begin_(nullptr), __size_(0) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr
    size_t size() const noexcept {return __size_;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr
    const _Ep* begin() const noexcept {return __begin_;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr
    const _Ep* end() const noexcept {return __begin_ + __size_;}
};
template<class _Ep>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr
const _Ep*
begin(initializer_list<_Ep> __il) noexcept
{
    return __il.begin();
}
template<class _Ep>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr
const _Ep*
end(initializer_list<_Ep> __il) noexcept
{
    return __il.end();
}
}
namespace std { inline namespace __1 {
namespace ranges {
  template <class _Tp>
  concept range = requires(_Tp& __t) {
    ranges::begin(__t);
    ranges::end(__t);
  };
  template <class _Tp>
  concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;
  template<class _Range>
  concept borrowed_range = range<_Range> &&
    (is_lvalue_reference_v<_Range> || enable_borrowed_range<remove_cvref_t<_Range>>);
  template <range _Rp>
  using sentinel_t = decltype(ranges::end(std::declval<_Rp&>()));
  template <range _Rp>
  using range_difference_t = iter_difference_t<iterator_t<_Rp>>;
  template <range _Rp>
  using range_value_t = iter_value_t<iterator_t<_Rp>>;
  template <range _Rp>
  using range_reference_t = iter_reference_t<iterator_t<_Rp>>;
  template <range _Rp>
  using range_rvalue_reference_t = iter_rvalue_reference_t<iterator_t<_Rp>>;
  template <class _Tp>
  concept sized_range = range<_Tp> && requires(_Tp& __t) { ranges::size(__t); };
  template<sized_range _Rp>
  using range_size_t = decltype(ranges::size(std::declval<_Rp&>()));
  template <class _Tp>
  concept view =
    range<_Tp> &&
    movable<_Tp> &&
    enable_view<_Tp>;
  template <class _Range>
  concept __simple_view =
    view<_Range> && range<const _Range> &&
    same_as<iterator_t<_Range>, iterator_t<const _Range>> &&
    same_as<sentinel_t<_Range>, sentinel_t<const _Range>>;
  template <class _Rp, class _Tp>
  concept output_range = range<_Rp> && output_iterator<iterator_t<_Rp>, _Tp>;
  template <class _Tp>
  concept forward_range = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;
  template <class _Tp>
  concept bidirectional_range = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;
  template <class _Tp>
  concept random_access_range =
      bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;
  template<class _Tp>
  concept contiguous_range =
    random_access_range<_Tp> &&
    contiguous_iterator<iterator_t<_Tp>> &&
    requires(_Tp& __t) {
      { ranges::data(__t) } -> same_as<add_pointer_t<range_reference_t<_Tp>>>;
    };
  template <class _Tp>
  concept common_range = range<_Tp> && same_as<iterator_t<_Tp>, sentinel_t<_Tp>>;
  template <class _Tp>
  inline constexpr bool __is_std_initializer_list = false;
  template <class _Ep>
  inline constexpr bool __is_std_initializer_list<initializer_list<_Ep>> = true;
  template <class _Tp>
  concept viewable_range =
    range<_Tp> &&
    ((view<remove_cvref_t<_Tp>> && constructible_from<remove_cvref_t<_Tp>, _Tp>) ||
     (!view<remove_cvref_t<_Tp>> &&
      (is_lvalue_reference_v<_Tp> ||
       (movable<remove_reference_t<_Tp>> && !__is_std_initializer_list<remove_cvref_t<_Tp>>))));
}
}}
namespace std { inline namespace __1 {
template <class _InputIter>
// added by concept-synth, original LN: 5408
requires
(
 requires (_InputIter x0) { ++x0; } &&
 requires (_InputIter x0, _InputIter x1) { x0 != x1; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
typename iterator_traits<_InputIter>::difference_type
__distance(_InputIter __first, _InputIter __last, input_iterator_tag)
{
    typename iterator_traits<_InputIter>::difference_type __r(0);
    for (; __first != __last; ++__first)
        ++__r;
    return __r;
}
template <class _RandIter>
// added by concept-synth, original LN: 5418
requires
requires (_RandIter x0, _RandIter x1) { x0 - x1; }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
typename iterator_traits<_RandIter>::difference_type
__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)
{
    return __last - __first;
}
template <class _InputIter>
// added by concept-synth, original LN: 5425
requires
(
 (
  requires (_InputIter x0) { ++x0; } &&
  requires (_InputIter x0, _InputIter x1) { x0 != x1; }
 ) ||
 requires (_InputIter x0, _InputIter x1) { x0 - x1; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
typename iterator_traits<_InputIter>::difference_type
distance(_InputIter __first, _InputIter __last)
{
    return std::__distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());
}
namespace ranges {
namespace __distance {
struct __fn {
  template<class _Ip, sentinel_for<_Ip> _Sp>
    requires (!sized_sentinel_for<_Sp, _Ip>)
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr iter_difference_t<_Ip> operator()(_Ip __first, _Sp __last) const {
    iter_difference_t<_Ip> __n = 0;
    while (__first != __last) {
      ++__first;
      ++__n;
    }
    return __n;
  }
  template<class _Ip, sized_sentinel_for<decay_t<_Ip>> _Sp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr iter_difference_t<_Ip> operator()(_Ip&& __first, _Sp __last) const {
    if constexpr (sized_sentinel_for<_Sp, __remove_cvref_t<_Ip>>) {
      return __last - __first;
    } else {
      return __last - decay_t<_Ip>(__first);
    }
  }
  template<range _Rp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr range_difference_t<_Rp> operator()(_Rp&& __r) const {
    if constexpr (sized_range<_Rp>) {
      return static_cast<range_difference_t<_Rp>>(ranges::size(__r));
    } else {
      return operator()(ranges::begin(__r), ranges::end(__r));
    }
  }
};
}
inline namespace __cpo {
  inline constexpr auto distance = __distance::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __iter_swap {
  template<class _I1, class _I2>
  void iter_swap(_I1, _I2) = delete;
  template<class _T1, class _T2>
  concept __unqualified_iter_swap =
    (__class_or_enum<remove_cvref_t<_T1>> || __class_or_enum<remove_cvref_t<_T2>>) &&
    requires (_T1&& __x, _T2&& __y) {
      iter_swap(std::forward<_T1>(__x), std::forward<_T2>(__y));
    };
  template<class _T1, class _T2>
  concept __readable_swappable =
    indirectly_readable<_T1> && indirectly_readable<_T2> &&
    swappable_with<iter_reference_t<_T1>, iter_reference_t<_T2>>;
  struct __fn {
    template <class _T1, class _T2>
      requires __unqualified_iter_swap<_T1, _T2>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr void operator()(_T1&& __x, _T2&& __y) const
      noexcept(noexcept(iter_swap(std::forward<_T1>(__x), std::forward<_T2>(__y))))
    {
      (void)iter_swap(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
    template <class _T1, class _T2>
      requires (!__unqualified_iter_swap<_T1, _T2>) &&
               __readable_swappable<_T1, _T2>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr void operator()(_T1&& __x, _T2&& __y) const
      noexcept(noexcept(ranges::swap(*std::forward<_T1>(__x), *std::forward<_T2>(__y))))
    {
      ranges::swap(*std::forward<_T1>(__x), *std::forward<_T2>(__y));
    }
    template <class _T1, class _T2>
      requires (!__unqualified_iter_swap<_T1, _T2> &&
                !__readable_swappable<_T1, _T2>) &&
               indirectly_movable_storable<_T1, _T2> &&
               indirectly_movable_storable<_T2, _T1>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr void operator()(_T1&& __x, _T2&& __y) const
      noexcept(noexcept(iter_value_t<_T2>(ranges::iter_move(__y))) &&
               noexcept(*__y = ranges::iter_move(__x)) &&
               noexcept(*std::forward<_T1>(__x) = std::declval<iter_value_t<_T2>>()))
    {
      iter_value_t<_T2> __old(ranges::iter_move(__y));
      *__y = ranges::iter_move(__x);
      *std::forward<_T1>(__x) = std::move(__old);
    }
  };
}
inline namespace __cpo {
  inline constexpr auto iter_swap = __iter_swap::__fn{};
}
}
template<class _I1, class _I2 = _I1>
concept indirectly_swappable =
  indirectly_readable<_I1> && indirectly_readable<_I2> &&
  requires(const _I1 __i1, const _I2 __i2) {
    ranges::iter_swap(__i1, __i1);
    ranges::iter_swap(__i2, __i2);
    ranges::iter_swap(__i1, __i2);
    ranges::iter_swap(__i2, __i1);
  };
}}

namespace std { inline namespace __1 {
template <class _InputIter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    typename enable_if<__is_cpp17_input_iterator<_InputIter>::value, _InputIter>::type
    next(_InputIter __x, typename iterator_traits<_InputIter>::difference_type __n = 1) {
  (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
  __builtin_assume(static_cast<bool>(__n >= 0 || __is_cpp17_bidirectional_iterator<_InputIter>::value))
#pragma clang diagnostic pop
  );
  std::advance(__x, __n);
  return __x;
}
namespace ranges {
namespace __next {
struct __fn {
  template <input_or_output_iterator _Ip>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr _Ip operator()(_Ip __x) const {
    ++__x;
    return __x;
  }
  template <input_or_output_iterator _Ip>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr _Ip operator()(_Ip __x, iter_difference_t<_Ip> __n) const {
    ranges::advance(__x, __n);
    return __x;
  }
  template <input_or_output_iterator _Ip, sentinel_for<_Ip> _Sp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Ip operator()(_Ip __x, _Sp __bound_sentinel) const {
    ranges::advance(__x, __bound_sentinel);
    return __x;
  }
  template <input_or_output_iterator _Ip, sentinel_for<_Ip> _Sp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Ip operator()(_Ip __x, iter_difference_t<_Ip> __n, _Sp __bound_sentinel) const {
    ranges::advance(__x, __n, __bound_sentinel);
    return __x;
  }
};
}
inline namespace __cpo {
  inline constexpr auto next = __next::__fn{};
}
}
}}
namespace std { inline namespace __1 {
template <class _InputIter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    typename enable_if<__is_cpp17_input_iterator<_InputIter>::value, _InputIter>::type
    prev(_InputIter __x, typename iterator_traits<_InputIter>::difference_type __n = 1) {
  (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
  __builtin_assume(static_cast<bool>(__n <= 0 || __is_cpp17_bidirectional_iterator<_InputIter>::value))
#pragma clang diagnostic pop
  );
  std::advance(__x, -__n);
  return __x;
}
namespace ranges {
namespace __prev {
struct __fn {
  template <bidirectional_iterator _Ip>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr _Ip operator()(_Ip __x) const {
    --__x;
    return __x;
  }
  template <bidirectional_iterator _Ip>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr _Ip operator()(_Ip __x, iter_difference_t<_Ip> __n) const {
    ranges::advance(__x, -__n);
    return __x;
  }
  template <bidirectional_iterator _Ip>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Ip operator()(_Ip __x, iter_difference_t<_Ip> __n, _Ip __bound_iter) const {
    ranges::advance(__x, -__n, __bound_iter);
    return __x;
  }
};
}
inline namespace __cpo {
  inline constexpr auto prev = __prev::__fn{};
}
}
}}
namespace std { inline namespace __1 {
template <class _AlgPolicy> struct _IterOps;
struct _RangeAlgPolicy {};
template <>
struct _IterOps<_RangeAlgPolicy> {
  template <class _Iter>
  using __value_type = iter_value_t<_Iter>;
  template <class _Iter>
  using __iterator_category = ranges::__iterator_concept<_Iter>;
  template <class _Iter>
  using __difference_type = iter_difference_t<_Iter>;
  static constexpr auto advance = ranges::advance;
  static constexpr auto distance = ranges::distance;
  static constexpr auto __iter_move = ranges::iter_move;
  static constexpr auto iter_swap = ranges::iter_swap;
  static constexpr auto next = ranges::next;
  static constexpr auto prev = ranges::prev;
  static constexpr auto __advance_to = ranges::advance;
};
struct _ClassicAlgPolicy {};
template <>
struct _IterOps<_ClassicAlgPolicy> {
  template <class _Iter>
  using __value_type = typename iterator_traits<_Iter>::value_type;
  template <class _Iter>
  using __iterator_category = typename iterator_traits<_Iter>::iterator_category;
  template <class _Iter>
  using __difference_type = typename iterator_traits<_Iter>::difference_type;
  template <class _Iter, class _Distance>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  static void advance(_Iter& __iter, _Distance __count) {
    std::advance(__iter, __count);
  }
  template <class _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  static typename iterator_traits<_Iter>::difference_type distance(_Iter __first, _Iter __last) {
    return std::distance(__first, __last);
  }
  template <class _Iter>
  using __deref_t = decltype(*std::declval<_Iter&>());
  template <class _Iter>
  using __move_t = decltype(std::move(*std::declval<_Iter&>()));
  template <class _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  static void __validate_iter_reference() {
    static_assert(is_same<__deref_t<_Iter>, typename iterator_traits<__remove_cvref_t<_Iter> >::reference>::value,
        "It looks like your iterator's `iterator_traits<It>::reference` does not match the return type of "
        "dereferencing the iterator, i.e., calling `*it`. This is undefined behavior according to [input.iterators] "
        "and can lead to dangling reference issues at runtime, so we are flagging this.");
  }
  template <class _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr static
  __enable_if_t<
      is_reference<__deref_t<_Iter> >::value,
      __move_t<_Iter> >
  __iter_move(_Iter&& __i) {
    __validate_iter_reference<_Iter>();
    return std::move(*std::forward<_Iter>(__i));
  }
  template <class _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr static
  __enable_if_t<
      !is_reference<__deref_t<_Iter> >::value,
      __deref_t<_Iter> >
  __iter_move(_Iter&& __i) {
    __validate_iter_reference<_Iter>();
    return *std::forward<_Iter>(__i);
  }
  template <class _Iter1, class _Iter2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  static void iter_swap(_Iter1&& __a, _Iter2&& __b) {
    std::iter_swap(std::forward<_Iter1>(__a), std::forward<_Iter2>(__b));
  }
  template <class _Iterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr
  _Iterator next(_Iterator, _Iterator __last) {
    return __last;
  }
  template <class _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr
  __remove_cvref_t<_Iter> next(_Iter&& __it,
                          typename iterator_traits<__remove_cvref_t<_Iter> >::difference_type __n = 1) {
    return std::next(std::forward<_Iter>(__it), __n);
  }
  template <class _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr
  __remove_cvref_t<_Iter> prev(_Iter&& __iter,
                 typename iterator_traits<__remove_cvref_t<_Iter> >::difference_type __n = 1) {
    return std::prev(std::forward<_Iter>(__iter), __n);
  }
  template <class _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr
  void __advance_to(_Iter& __first, _Iter __last) {
    __first = __last;
  }
};
}}
namespace std { inline namespace __1 {
template <class _Iter, class _Sent, class _BinaryPredicate>
// added by concept-synth, original LN: 5721
requires
(
 requires (_Iter x0) { *x0; } &&
 requires (_Iter x0) { ++x0; } &&
 requires (_Iter x0, _Sent x1) { x0 == x1; }
) &&
requires (_BinaryPredicate f, _Iter x0, _Iter x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
(
 requires (_Sent x0, _Iter x1) { ++x1 != x0; } &&
 requires (_Sent x0, _Iter x1) { x1 == x0; }
)
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Iter
__adjacent_find(_Iter __first, _Sent __last, _BinaryPredicate&& __pred) {
  if (__first == __last)
    return __first;
  _Iter __i = __first;
  while (++__i != __last) {
    if (__pred(*__first, *__i))
      return __first;
    __first = __i;
  }
  return __i;
}
template <class _ForwardIterator, class _BinaryPredicate>
// added by concept-synth, original LN: 5734
requires
(
 requires (_ForwardIterator x0, _ForwardIterator x1) { ++x1 != x0; } &&
 requires (_ForwardIterator x0, _ForwardIterator x1) { x1 == x0; } &&
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0, _ForwardIterator x1) { x0 == x1; }
) &&
requires (_BinaryPredicate f, _ForwardIterator x0, _ForwardIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _ForwardIterator
adjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred) {
  return std::__adjacent_find(std::move(__first), std::move(__last), __pred);
}
template <class _ForwardIterator>
// added by concept-synth, original LN: 5739
requires
(
 requires (_ForwardIterator x0, _ForwardIterator x1) { ++x1 != x0; } &&
 requires (_ForwardIterator x0, _ForwardIterator x1) { x1 == x0; } &&
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0, _ForwardIterator x1) { x0 == x1; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _ForwardIterator
adjacent_find(_ForwardIterator __first, _ForwardIterator __last) {
  return std::adjacent_find(std::move(__first), std::move(__last), __equal_to());
}
}}
namespace std { inline namespace __1 {
template <class _InputIterator, class _Predicate>
// added by concept-synth, original LN: 5746
requires
requires (_Predicate f, _InputIterator x0) { f(*x0); } &&
(
 requires (_InputIterator x0) { ++x0; } &&
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0, _InputIterator x1) { x0 != x1; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool
all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (!__pred(*__first))
      return false;
  return true;
}
}}
namespace std { inline namespace __1 {
template <class _InputIterator, class _Predicate>
// added by concept-synth, original LN: 5756
requires
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; } &&
 requires (_InputIterator x0, _InputIterator x1) { x0 != x1; }
) &&
requires (_Predicate f, _InputIterator x0) { {f(*x0)} -> std::convertible_to<bool>; }
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool
any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (__pred(*__first))
      return true;
  return false;
}
}}
namespace std { inline namespace __1 {
template <class _Compare>
struct __debug_less
{
    _Compare &__comp_;
    constexpr
    __debug_less(_Compare& __c) : __comp_(__c) {}
    template <class _Tp, class _Up>
    constexpr
    bool operator()(const _Tp& __x, const _Up& __y)
    {
        bool __r = __comp_(__x, __y);
        if (__r)
            __do_compare_assert(0, __y, __x);
        return __r;
    }
    template <class _Tp, class _Up>
    constexpr
    bool operator()(_Tp& __x, _Up& __y)
    {
        bool __r = __comp_(__x, __y);
        if (__r)
            __do_compare_assert(0, __y, __x);
        return __r;
    }
    template <class _LHS, class _RHS>
    constexpr
    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    decltype((void)std::declval<_Compare&>()(
        std::declval<_LHS &>(), std::declval<_RHS &>()))
    __do_compare_assert(int, _LHS & __l, _RHS & __r) {
        ((void)0);
        (void)__l;
        (void)__r;
    }
    template <class _LHS, class _RHS>
    constexpr
    inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    void __do_compare_assert(long, _LHS &, _RHS &) {}
};
template <class _Comp>
using __comp_ref_type = _Comp&;
}}
namespace std { inline namespace __1 {
template <typename _Integral>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
typename enable_if
<
    is_integral<_Integral>::value,
    _Integral
>::type
__half_positive(_Integral __value)
{
    return static_cast<_Integral>(static_cast<__make_unsigned_t<_Integral> >(__value) / 2);
}
template <typename _Tp>
// added by concept-synth, original LN: 5820
requires
requires (_Tp x0, int x1) { x0 / x1; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
typename enable_if
<
    !is_integral<_Tp>::value,
    _Tp
>::type
__half_positive(_Tp __value)
{
    return __value / 2;
}
}}
namespace std { inline namespace __1 {
struct __identity {
  template <class _Tp>
  [[nodiscard]] constexpr _Tp&& operator()(_Tp&& __t) const noexcept {
    return std::forward<_Tp>(__t);
  }
  using is_transparent = void;
};
struct identity {
    template<class _Tp>
    [[nodiscard]] constexpr _Tp&& operator()(_Tp&& __t) const noexcept
    {
        return std::forward<_Tp>(__t);
    }
    using is_transparent = void;
};
}}
namespace std { inline namespace __1 {
template <class _AlgPolicy, class _Iter, class _Sent, class _Type, class _Proj, class _Comp>
// added by concept-synth, original LN: 5850
requires
(
 requires (_Iter x0) { ++x0; } &&
 requires (_Iter x0) { *x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_Iter __lower_bound_impl(_Iter __first, _Sent __last, const _Type& __value, _Comp& __comp, _Proj& __proj) {
  auto __len = _IterOps<_AlgPolicy>::distance(__first, __last);
  while (__len != 0) {
    auto __l2 = std::__half_positive(__len);
    _Iter __m = __first;
    _IterOps<_AlgPolicy>::advance(__m, __l2);
    if (std::__invoke(__comp, std::__invoke(__proj, *__m), __value)) {
      __first = ++__m;
      __len -= __l2 + 1;
    } else {
      __len = __l2;
    }
  }
  return __first;
}
template <class _ForwardIterator, class _Tp, class _Compare>
// added by concept-synth, original LN: 5867
requires
(
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0) { *x0; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_ForwardIterator lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value, _Compare __comp) {
  static_assert(__is_callable<_Compare, decltype(*__first), const _Tp&>::value,
                "The comparator has to be callable");
  auto __proj = std::__identity();
  return std::__lower_bound_impl<_ClassicAlgPolicy>(__first, __last, __value, __comp, __proj);
}
template <class _ForwardIterator, class _Tp>
// added by concept-synth, original LN: 5875
requires
(
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0) { *x0; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_ForwardIterator lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value) {
  return std::lower_bound(__first, __last, __value,
                          __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}
}}
namespace std { inline namespace __1 {
template <class _ForwardIterator, class _Tp, class _Compare>
// added by concept-synth, original LN: 5883
requires
requires (_Compare f, _Tp x0, _ForwardIterator x1) { f(x0, *x1); } &&
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0, _ForwardIterator x1) { x0 != x1; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
[[nodiscard]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool
binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value, _Compare __comp)
{
    __first = std::lower_bound<_ForwardIterator, _Tp, __comp_ref_type<_Compare> >(__first, __last, __value, __comp);
    return __first != __last && !__comp(__value, *__first);
}
template <class _ForwardIterator, class _Tp>
// added by concept-synth, original LN: 5892
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0, _ForwardIterator x1) { x0 != x1; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
[[nodiscard]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool
binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
{
    return std::binary_search(__first, __last, __value,
                              __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}
}}
namespace std { inline namespace __1 {
template<class _Tp, class _Compare>
// added by concept-synth, original LN: 5903
requires
requires (_Compare f, _Tp x0, _Tp x1) { f(x0, x1); }
[[nodiscard]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
const _Tp&
clamp(const _Tp& __v, const _Tp& __lo, const _Tp& __hi, _Compare __comp)
{
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(!__comp(__hi, __lo)))
#pragma clang diagnostic pop
    );
    return __comp(__v, __lo) ? __lo : __comp(__hi, __v) ? __hi : __v;
}
template<class _Tp>
[[nodiscard]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
const _Tp&
clamp(const _Tp& __v, const _Tp& __lo, const _Tp& __hi)
{
    return std::clamp(__v, __lo, __hi, __less<_Tp>());
}
}}
namespace std { inline namespace __1 {
template <class _Iter, bool = __is_cpp17_contiguous_iterator<_Iter>::value>
struct __unwrap_iter_impl {
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Iter __rewrap(_Iter, _Iter __iter) { return __iter; }
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Iter __unwrap(_Iter __i) noexcept { return __i; }
};
template <class _Iter>
struct __unwrap_iter_impl<_Iter, true> {
  using _ToAddressT = decltype(std::__to_address(std::declval<_Iter>()));
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Iter __rewrap(_Iter __orig_iter, _ToAddressT __unwrapped_iter) {
    return __orig_iter + (__unwrapped_iter - std::__to_address(__orig_iter));
  }
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _ToAddressT __unwrap(_Iter __i) noexcept {
    return std::__to_address(__i);
  }
};
template<class _Iter,
         class _Impl = __unwrap_iter_impl<_Iter>,
         __enable_if_t<is_copy_constructible<_Iter>::value, int> = 0>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
decltype(_Impl::__unwrap(std::declval<_Iter>())) __unwrap_iter(_Iter __i) noexcept {
  return _Impl::__unwrap(__i);
}
template <class _OrigIter, class _Iter, class _Impl = __unwrap_iter_impl<_OrigIter> >
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _OrigIter __rewrap_iter(_OrigIter __orig_iter, _Iter __iter) noexcept {
  return _Impl::__rewrap(std::move(__orig_iter), std::move(__iter));
}
}}
namespace std { inline namespace __1 {
enum class __attribute__((__type_visibility__("default"))) _OrdResult : signed char {
  __less = -1,
  __equiv = 0,
  __greater = 1
};
enum class __attribute__((__type_visibility__("default"))) _NCmpResult : signed char {
  __unordered = -127
};
class partial_ordering;
class weak_ordering;
class strong_ordering;
template<class _Tp, class... _Args>
inline constexpr bool __one_of_v = (is_same_v<_Tp, _Args> || ...);
struct _CmpUnspecifiedParam {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  _CmpUnspecifiedParam(int _CmpUnspecifiedParam::*) noexcept {}
  template<class _Tp, class = enable_if_t<!__one_of_v<_Tp, int, partial_ordering, weak_ordering, strong_ordering>>>
  _CmpUnspecifiedParam(_Tp) = delete;
};
class partial_ordering {
  using _ValueT = signed char;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  explicit constexpr partial_ordering(_OrdResult __v) noexcept
      : __value_(_ValueT(__v)) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  explicit constexpr partial_ordering(_NCmpResult __v) noexcept
      : __value_(_ValueT(__v)) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr bool __is_ordered() const noexcept {
    return __value_ != _ValueT(_NCmpResult::__unordered);
  }
public:
  static const partial_ordering less;
  static const partial_ordering equivalent;
  static const partial_ordering greater;
  static const partial_ordering unordered;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator==(partial_ordering, partial_ordering) noexcept = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator==(partial_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__is_ordered() && __v.__value_ == 0;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator< (partial_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__is_ordered() && __v.__value_ < 0;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator<=(partial_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__is_ordered() && __v.__value_ <= 0;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator> (partial_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__is_ordered() && __v.__value_ > 0;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator>=(partial_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__is_ordered() && __v.__value_ >= 0;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator< (_CmpUnspecifiedParam, partial_ordering __v) noexcept {
    return __v.__is_ordered() && 0 < __v.__value_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator<=(_CmpUnspecifiedParam, partial_ordering __v) noexcept {
    return __v.__is_ordered() && 0 <= __v.__value_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator> (_CmpUnspecifiedParam, partial_ordering __v) noexcept {
    return __v.__is_ordered() && 0 > __v.__value_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator>=(_CmpUnspecifiedParam, partial_ordering __v) noexcept {
    return __v.__is_ordered() && 0 >= __v.__value_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr partial_ordering operator<=>(partial_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr partial_ordering operator<=>(_CmpUnspecifiedParam, partial_ordering __v) noexcept {
    return __v < 0 ? partial_ordering::greater : (__v > 0 ? partial_ordering::less : __v);
  }
private:
  _ValueT __value_;
};
inline constexpr partial_ordering partial_ordering::less(_OrdResult::__less);
inline constexpr partial_ordering partial_ordering::equivalent(_OrdResult::__equiv);
inline constexpr partial_ordering partial_ordering::greater(_OrdResult::__greater);
inline constexpr partial_ordering partial_ordering::unordered(_NCmpResult ::__unordered);
class weak_ordering {
  using _ValueT = signed char;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  explicit constexpr weak_ordering(_OrdResult __v) noexcept : __value_(_ValueT(__v)) {}
public:
  static const weak_ordering less;
  static const weak_ordering equivalent;
  static const weak_ordering greater;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr operator partial_ordering() const noexcept {
    return __value_ == 0 ? partial_ordering::equivalent
        : (__value_ < 0 ? partial_ordering::less : partial_ordering::greater);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator==(weak_ordering, weak_ordering) noexcept = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator==(weak_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ == 0;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator< (weak_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ < 0;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator<=(weak_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ <= 0;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator> (weak_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ > 0;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator>=(weak_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ >= 0;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator< (_CmpUnspecifiedParam, weak_ordering __v) noexcept {
    return 0 < __v.__value_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator<=(_CmpUnspecifiedParam, weak_ordering __v) noexcept {
    return 0 <= __v.__value_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator> (_CmpUnspecifiedParam, weak_ordering __v) noexcept {
    return 0 > __v.__value_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator>=(_CmpUnspecifiedParam, weak_ordering __v) noexcept {
    return 0 >= __v.__value_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr weak_ordering operator<=>(weak_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr weak_ordering operator<=>(_CmpUnspecifiedParam, weak_ordering __v) noexcept {
    return __v < 0 ? weak_ordering::greater : (__v > 0 ? weak_ordering::less : __v);
  }
private:
  _ValueT __value_;
};
inline constexpr weak_ordering weak_ordering::less(_OrdResult::__less);
inline constexpr weak_ordering weak_ordering::equivalent(_OrdResult::__equiv);
inline constexpr weak_ordering weak_ordering::greater(_OrdResult::__greater);
class strong_ordering {
  using _ValueT = signed char;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  explicit constexpr strong_ordering(_OrdResult __v) noexcept : __value_(_ValueT(__v)) {}
public:
  static const strong_ordering less;
  static const strong_ordering equal;
  static const strong_ordering equivalent;
  static const strong_ordering greater;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr operator partial_ordering() const noexcept {
    return __value_ == 0 ? partial_ordering::equivalent
        : (__value_ < 0 ? partial_ordering::less : partial_ordering::greater);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr operator weak_ordering() const noexcept {
    return __value_ == 0 ? weak_ordering::equivalent
        : (__value_ < 0 ? weak_ordering::less : weak_ordering::greater);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator==(strong_ordering, strong_ordering) noexcept = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator==(strong_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ == 0;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator< (strong_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ < 0;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator<=(strong_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ <= 0;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator> (strong_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ > 0;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator>=(strong_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v.__value_ >= 0;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator< (_CmpUnspecifiedParam, strong_ordering __v) noexcept {
    return 0 < __v.__value_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator<=(_CmpUnspecifiedParam, strong_ordering __v) noexcept {
    return 0 <= __v.__value_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator> (_CmpUnspecifiedParam, strong_ordering __v) noexcept {
    return 0 > __v.__value_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator>=(_CmpUnspecifiedParam, strong_ordering __v) noexcept {
    return 0 >= __v.__value_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr strong_ordering operator<=>(strong_ordering __v, _CmpUnspecifiedParam) noexcept {
    return __v;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr strong_ordering operator<=>(_CmpUnspecifiedParam, strong_ordering __v) noexcept {
    return __v < 0 ? strong_ordering::greater : (__v > 0 ? strong_ordering::less : __v);
  }
private:
  _ValueT __value_;
};
inline constexpr strong_ordering strong_ordering::less(_OrdResult::__less);
inline constexpr strong_ordering strong_ordering::equal(_OrdResult::__equiv);
inline constexpr strong_ordering strong_ordering::equivalent(_OrdResult::__equiv);
inline constexpr strong_ordering strong_ordering::greater(_OrdResult::__greater);
template <class _Tp>
concept __comparison_category = __one_of_v<_Tp, partial_ordering, weak_ordering, strong_ordering>;
}}
namespace std { inline namespace __1 {
namespace __comp_detail {
enum _ClassifyCompCategory : unsigned {
  _None,
  _PartialOrd,
  _WeakOrd,
  _StrongOrd,
  _CCC_Size
};
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr _ClassifyCompCategory __type_to_enum() noexcept {
  if (is_same_v<_Tp, partial_ordering>)
    return _PartialOrd;
  if (is_same_v<_Tp, weak_ordering>)
    return _WeakOrd;
  if (is_same_v<_Tp, strong_ordering>)
    return _StrongOrd;
  return _None;
}
template <size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr _ClassifyCompCategory
__compute_comp_type(const _ClassifyCompCategory (&__types)[_Size]) {
  int __seen[_CCC_Size] = {};
  for (auto __type : __types)
    ++__seen[__type];
  if (__seen[_None])
    return _None;
  if (__seen[_PartialOrd])
    return _PartialOrd;
  if (__seen[_WeakOrd])
    return _WeakOrd;
  return _StrongOrd;
}
template <class ..._Ts, bool _False = false>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr auto __get_comp_type() {
  using _CCC = _ClassifyCompCategory;
  constexpr _CCC __type_kinds[] = {_StrongOrd, __type_to_enum<_Ts>()...};
  constexpr _CCC _Cat = __comp_detail::__compute_comp_type(__type_kinds);
  if constexpr (_Cat == _None)
    return void();
  else if constexpr (_Cat == _PartialOrd)
    return partial_ordering::equivalent;
  else if constexpr (_Cat == _WeakOrd)
    return weak_ordering::equivalent;
  else if constexpr (_Cat == _StrongOrd)
    return strong_ordering::equivalent;
  else
    static_assert(_False, "unhandled case");
}
}
template<class... _Ts>
struct __attribute__((__type_visibility__("default"))) common_comparison_category {
  using type = decltype(__comp_detail::__get_comp_type<_Ts...>());
};
template<class... _Ts>
using common_comparison_category_t = typename common_comparison_category<_Ts...>::type;
}}
namespace std { inline namespace __1 {
template<class _Tp, class _Cat>
concept __compares_as =
  same_as<common_comparison_category_t<_Tp, _Cat>, _Cat>;
template<class _Tp, class _Cat = partial_ordering>
concept three_way_comparable =
  __weakly_equality_comparable_with<_Tp, _Tp> &&
  __partially_ordered_with<_Tp, _Tp> &&
  requires(__make_const_lvalue_ref<_Tp> __a, __make_const_lvalue_ref<_Tp> __b) {
    { __a <=> __b } -> __compares_as<_Cat>;
  };
template<class _Tp, class _Up, class _Cat = partial_ordering>
concept three_way_comparable_with =
  three_way_comparable<_Tp, _Cat> &&
  three_way_comparable<_Up, _Cat> &&
  common_reference_with<__make_const_lvalue_ref<_Tp>, __make_const_lvalue_ref<_Up>> &&
  three_way_comparable<common_reference_t<__make_const_lvalue_ref<_Tp>, __make_const_lvalue_ref<_Up>>, _Cat> &&
  __weakly_equality_comparable_with<_Tp, _Up> &&
  __partially_ordered_with<_Tp, _Up> &&
  requires(__make_const_lvalue_ref<_Tp> __t, __make_const_lvalue_ref<_Up> __u) {
    { __t <=> __u } -> __compares_as<_Cat>;
    { __u <=> __t } -> __compares_as<_Cat>;
  };
}}
namespace std { inline namespace __1 {
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) inline constexpr auto __synth_three_way =
  []<class _Tp, class _Up>(const _Tp& __t, const _Up& __u)
    requires requires {
      { __t < __u } -> __boolean_testable;
      { __u < __t } -> __boolean_testable;
    }
  {
    if constexpr (three_way_comparable_with<_Tp, _Up>) {
      return __t <=> __u;
    } else {
      if (__t < __u) return weak_ordering::less;
      if (__u < __t) return weak_ordering::greater;
      return weak_ordering::equivalent;
    }
  };
template <class _Tp, class _Up = _Tp>
using __synth_three_way_result = decltype(std::__synth_three_way(std::declval<_Tp&>(), std::declval<_Up&>()));
}}

namespace std { inline namespace __1 {
template <class _Tp>
struct __unwrap_reference { typedef __attribute__((__nodebug__)) _Tp type; };
template <class _Tp>
class reference_wrapper;
template <class _Tp>
struct __unwrap_reference<reference_wrapper<_Tp> > { typedef __attribute__((__nodebug__)) _Tp& type; };
template <class _Tp>
struct decay;
template <class _Tp>
struct unwrap_reference : __unwrap_reference<_Tp> { };
template <class _Tp>
using unwrap_reference_t = typename unwrap_reference<_Tp>::type;
template <class _Tp>
struct unwrap_ref_decay : unwrap_reference<typename decay<_Tp>::type> { };
template <class _Tp>
using unwrap_ref_decay_t = typename unwrap_ref_decay<_Tp>::type;
template <class _Tp>
struct __unwrap_ref_decay
    : unwrap_ref_decay<_Tp>
{ };
}}
namespace std { inline namespace __1 {
template <class _Tp, size_t _Size>
struct __attribute__((__type_visibility__("default"))) array;
}}

namespace std { inline namespace __1 {
namespace ranges {
enum class __attribute__((__type_visibility__("default"))) subrange_kind : bool { unsized, sized };
template <input_or_output_iterator _Iter, sentinel_for<_Iter> _Sent, subrange_kind _Kind>
  requires(_Kind == subrange_kind::sized || !sized_sentinel_for<_Sent, _Iter>)
class __attribute__((__type_visibility__("default"))) subrange;
}
}}
namespace std { inline namespace __1 {
template <class...>
class __attribute__((__type_visibility__("default"))) tuple;
}}
namespace std { inline namespace __1 {
template <size_t...> struct __tuple_indices;
template <class _IdxType, _IdxType... _Values>
struct __integer_sequence {
  template <template <class _OIdxType, _OIdxType...> class _ToIndexSeq, class _ToIndexType>
  using __convert = _ToIndexSeq<_ToIndexType, _Values...>;
  template <size_t _Sp>
  using __to_tuple_indices = __tuple_indices<(_Values + _Sp)...>;
};
template <size_t _Ep, size_t _Sp>
using __make_indices_imp =
    typename __make_integer_seq<__integer_sequence, size_t, _Ep - _Sp>::template
    __to_tuple_indices<_Sp>;
template<class _Tp, _Tp... _Ip>
struct __attribute__((__type_visibility__("default"))) integer_sequence
{
    typedef _Tp value_type;
    static_assert( is_integral<_Tp>::value,
                  "std::integer_sequence can only be instantiated with an integral type" );
    static
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr
    size_t
    size() noexcept { return sizeof...(_Ip); }
};
template<size_t... _Ip>
    using index_sequence = integer_sequence<size_t, _Ip...>;
template <class _Tp, _Tp _Ep>
using __make_integer_sequence __attribute__((__nodebug__)) = __make_integer_seq<integer_sequence, _Tp, _Ep>;
template<class _Tp, _Tp _Np>
    using make_integer_sequence = __make_integer_sequence<_Tp, _Np>;
template<size_t _Np>
    using make_index_sequence = make_integer_sequence<size_t, _Np>;
template<class... _Tp>
    using index_sequence_for = make_index_sequence<sizeof...(_Tp)>;
template <size_t... _Index, class _Function>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr void __for_each_index_sequence(index_sequence<_Index...>, _Function __func) {
    (__func.template operator()<_Index>(), ...);
}
}}
namespace std { inline namespace __1 {
template <size_t...> struct __tuple_indices {};
template <size_t _Ep, size_t _Sp = 0>
struct __make_tuple_indices
{
    static_assert(_Sp <= _Ep, "__make_tuple_indices input error");
    typedef __make_indices_imp<_Ep, _Sp> type;
};
}}
namespace std { inline namespace __1 {
template <class ..._Tp> struct __tuple_types {};
}}
namespace std { inline namespace __1 {
template <size_t _Ip, class _Tp> struct __attribute__((__type_visibility__("default"))) tuple_element;
template <size_t _Ip, class _Tp>
struct __attribute__((__type_visibility__("default"))) tuple_element<_Ip, const _Tp>
{
    typedef __attribute__((__nodebug__)) typename add_const<typename tuple_element<_Ip, _Tp>::type>::type type;
};
template <size_t _Ip, class _Tp>
struct __attribute__((__type_visibility__("default"))) tuple_element<_Ip, volatile _Tp>
{
    typedef __attribute__((__nodebug__)) typename add_volatile<typename tuple_element<_Ip, _Tp>::type>::type type;
};
template <size_t _Ip, class _Tp>
struct __attribute__((__type_visibility__("default"))) tuple_element<_Ip, const volatile _Tp>
{
    typedef __attribute__((__nodebug__)) typename add_cv<typename tuple_element<_Ip, _Tp>::type>::type type;
};
template <size_t _Ip, class ..._Types>
struct __attribute__((__type_visibility__("default"))) tuple_element<_Ip, __tuple_types<_Types...> >
{
    static_assert(_Ip < sizeof...(_Types), "tuple_element index out of range");
    typedef __attribute__((__nodebug__)) __type_pack_element<_Ip, _Types...> type;
};
template <size_t _Ip, class ..._Tp>
using tuple_element_t __attribute__((__nodebug__)) = typename tuple_element <_Ip, _Tp...>::type;
}}
namespace std { inline namespace __1 {
template <size_t _Ip, class ..._Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(tuple<_Tp...>&) noexcept;
template <size_t _Ip, class ..._Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
const typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(const tuple<_Tp...>&) noexcept;
template <size_t _Ip, class ..._Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(tuple<_Tp...>&&) noexcept;
template <size_t _Ip, class ..._Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
const typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(const tuple<_Tp...>&&) noexcept;
template <size_t _Ip, class _T1, class _T2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(pair<_T1, _T2>&) noexcept;
template <size_t _Ip, class _T1, class _T2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(const pair<_T1, _T2>&) noexcept;
template <size_t _Ip, class _T1, class _T2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(pair<_T1, _T2>&&) noexcept;
template <size_t _Ip, class _T1, class _T2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(const pair<_T1, _T2>&&) noexcept;
template <size_t _Ip, class _Tp, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_Tp&
get(array<_Tp, _Size>&) noexcept;
template <size_t _Ip, class _Tp, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
const _Tp&
get(const array<_Tp, _Size>&) noexcept;
template <size_t _Ip, class _Tp, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_Tp&&
get(array<_Tp, _Size>&&) noexcept;
template <size_t _Ip, class _Tp, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
const _Tp&&
get(const array<_Tp, _Size>&&) noexcept;
namespace ranges {
template <size_t _Index, class _Iter, class _Sent, subrange_kind _Kind>
  requires((_Index == 0 && copyable<_Iter>) || _Index == 1)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr auto get(const subrange<_Iter, _Sent, _Kind>& __subrange);
template <size_t _Index, class _Iter, class _Sent, subrange_kind _Kind>
  requires(_Index < 2)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr auto get(subrange<_Iter, _Sent, _Kind>&& __subrange);
}
using ranges::get;
}}

namespace std { inline namespace __1 {
template <bool _ApplyLV, bool _ApplyConst, bool _ApplyVolatile>
struct __apply_cv_mf;
template <>
struct __apply_cv_mf<false, false, false> {
  template <class _Tp> using __apply = _Tp;
};
template <>
struct __apply_cv_mf<false, true, false> {
  template <class _Tp> using __apply __attribute__((__nodebug__)) = const _Tp;
};
template <>
struct __apply_cv_mf<false, false, true> {
  template <class _Tp> using __apply __attribute__((__nodebug__)) = volatile _Tp;
};
template <>
struct __apply_cv_mf<false, true, true> {
  template <class _Tp> using __apply __attribute__((__nodebug__)) = const volatile _Tp;
};
template <>
struct __apply_cv_mf<true, false, false> {
  template <class _Tp> using __apply __attribute__((__nodebug__)) = _Tp&;
};
template <>
struct __apply_cv_mf<true, true, false> {
  template <class _Tp> using __apply __attribute__((__nodebug__)) = const _Tp&;
};
template <>
struct __apply_cv_mf<true, false, true> {
  template <class _Tp> using __apply __attribute__((__nodebug__)) = volatile _Tp&;
};
template <>
struct __apply_cv_mf<true, true, true> {
  template <class _Tp> using __apply __attribute__((__nodebug__)) = const volatile _Tp&;
};
template <class _Tp, class _RawTp = __libcpp_remove_reference_t<_Tp> >
using __apply_cv_t __attribute__((__nodebug__)) = __apply_cv_mf<
    is_lvalue_reference<_Tp>::value,
    is_const<_RawTp>::value,
    is_volatile<_RawTp>::value>;
}}
namespace std { inline namespace __1 {
template <class _Tp> struct __attribute__((__type_visibility__("default"))) tuple_size;
template <class _Tp, class...>
using __enable_if_tuple_size_imp = _Tp;
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) tuple_size<__enable_if_tuple_size_imp<
    const _Tp,
    __enable_if_t<!is_volatile<_Tp>::value>,
    integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) tuple_size<__enable_if_tuple_size_imp<
    volatile _Tp,
    __enable_if_t<!is_const<_Tp>::value>,
    integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) tuple_size<__enable_if_tuple_size_imp<
    const volatile _Tp,
    integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};
template <class ..._Tp>
struct __attribute__((__type_visibility__("default"))) tuple_size<tuple<_Tp...> >
    : public integral_constant<size_t, sizeof...(_Tp)>
{
};
template <class ..._Tp>
struct __attribute__((__type_visibility__("default"))) tuple_size<__tuple_types<_Tp...> >
    : public integral_constant<size_t, sizeof...(_Tp)>
{
};
}}
namespace std { inline namespace __1 {
template <class _TupleTypes, class _TupleIndices>
struct __make_tuple_types_flat;
template <template <class...> class _Tuple, class ..._Types, size_t ..._Idx>
struct __make_tuple_types_flat<_Tuple<_Types...>, __tuple_indices<_Idx...>> {
  template <class _Tp, class _ApplyFn = __apply_cv_t<_Tp>>
  using __apply_quals __attribute__((__nodebug__)) = __tuple_types<
      typename _ApplyFn::template __apply<__type_pack_element<_Idx, _Types...>>...
    >;
};
template <class _Vt, size_t _Np, size_t ..._Idx>
struct __make_tuple_types_flat<array<_Vt, _Np>, __tuple_indices<_Idx...>> {
  template <size_t>
  using __value_type = _Vt;
  template <class _Tp, class _ApplyFn = __apply_cv_t<_Tp>>
  using __apply_quals = __tuple_types<
      typename _ApplyFn::template __apply<__value_type<_Idx>>...
    >;
};
template <class _Tp, size_t _Ep = tuple_size<__libcpp_remove_reference_t<_Tp> >::value,
          size_t _Sp = 0,
          bool _SameSize = (_Ep == tuple_size<__libcpp_remove_reference_t<_Tp> >::value)>
struct __make_tuple_types
{
    static_assert(_Sp <= _Ep, "__make_tuple_types input error");
    using _RawTp = __remove_cv_t<__libcpp_remove_reference_t<_Tp> >;
    using _Maker = __make_tuple_types_flat<_RawTp, typename __make_tuple_indices<_Ep, _Sp>::type>;
    using type = typename _Maker::template __apply_quals<_Tp>;
};
template <class ..._Types, size_t _Ep>
struct __make_tuple_types<tuple<_Types...>, _Ep, 0, true> {
  typedef __attribute__((__nodebug__)) __tuple_types<_Types...> type;
};
template <class ..._Types, size_t _Ep>
struct __make_tuple_types<__tuple_types<_Types...>, _Ep, 0, true> {
  typedef __attribute__((__nodebug__)) __tuple_types<_Types...> type;
};
}}

namespace std { inline namespace __1 {
template <class _Tp> struct __tuple_like_ext : false_type {};
template <class _Tp> struct __tuple_like_ext<const _Tp> : public __tuple_like_ext<_Tp> {};
template <class _Tp> struct __tuple_like_ext<volatile _Tp> : public __tuple_like_ext<_Tp> {};
template <class _Tp> struct __tuple_like_ext<const volatile _Tp> : public __tuple_like_ext<_Tp> {};
template <class... _Tp> struct __tuple_like_ext<tuple<_Tp...> > : true_type {};
template <class _T1, class _T2> struct __tuple_like_ext<pair<_T1, _T2> > : true_type {};
template <class _Tp, size_t _Size> struct __tuple_like_ext<array<_Tp, _Size> > : true_type {};
template <class... _Tp> struct __tuple_like_ext<__tuple_types<_Tp...> > : true_type {};
}}
namespace std { inline namespace __1 {
template <bool ..._Preds>
struct __all_dummy;
template <bool ..._Pred>
struct __all : _IsSame<__all_dummy<_Pred...>, __all_dummy<((void)_Pred, true)...>> {};
struct __tuple_sfinae_base {
  template <template <class, class...> class _Trait,
            class ..._LArgs, class ..._RArgs>
  static auto __do_test(__tuple_types<_LArgs...>, __tuple_types<_RArgs...>)
    -> __all<__enable_if_t<_Trait<_LArgs, _RArgs>::value, bool>{true}...>;
  template <template <class...> class>
  static auto __do_test(...) -> false_type;
  template <class _FromArgs, class _ToArgs>
  using __constructible = decltype(__do_test<is_constructible>(_ToArgs{}, _FromArgs{}));
  template <class _FromArgs, class _ToArgs>
  using __convertible = decltype(__do_test<is_convertible>(_FromArgs{}, _ToArgs{}));
  template <class _FromArgs, class _ToArgs>
  using __assignable = decltype(__do_test<is_assignable>(_ToArgs{}, _FromArgs{}));
};
template <class _Tp, class _Up, bool = __tuple_like_ext<__libcpp_remove_reference_t<_Tp> >::value,
                                bool = __tuple_like_ext<_Up>::value>
struct __tuple_convertible
    : public false_type {};
template <class _Tp, class _Up>
struct __tuple_convertible<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__convertible<
      typename __make_tuple_types<_Tp>::type
    , typename __make_tuple_types<_Up>::type
    >
{};
template <class _Tp, class _Up, bool = __tuple_like_ext<__libcpp_remove_reference_t<_Tp> >::value,
                                bool = __tuple_like_ext<_Up>::value>
struct __tuple_constructible
    : public false_type {};
template <class _Tp, class _Up>
struct __tuple_constructible<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__constructible<
      typename __make_tuple_types<_Tp>::type
    , typename __make_tuple_types<_Up>::type
    >
{};
template <class _Tp, class _Up, bool = __tuple_like_ext<__libcpp_remove_reference_t<_Tp> >::value,
                                bool = __tuple_like_ext<_Up>::value>
struct __tuple_assignable
    : public false_type {};
template <class _Tp, class _Up>
struct __tuple_assignable<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__assignable<
      typename __make_tuple_types<_Tp>::type
    , typename __make_tuple_types<_Up&>::type
    >
{};
template <size_t _Ip, class ..._Tp>
struct __attribute__((__type_visibility__("default"))) tuple_element<_Ip, tuple<_Tp...> >
{
    typedef __attribute__((__nodebug__)) typename tuple_element<_Ip, __tuple_types<_Tp...> >::type type;
};
template <bool _IsTuple, class _SizeTrait, size_t _Expected>
struct __tuple_like_with_size_imp : false_type {};
template <class _SizeTrait, size_t _Expected>
struct __tuple_like_with_size_imp<true, _SizeTrait, _Expected>
    : integral_constant<bool, _SizeTrait::value == _Expected> {};
template <class _Tuple, size_t _ExpectedSize, class _RawTuple = __libcpp_remove_reference_t<_Tuple> >
using __tuple_like_with_size __attribute__((__nodebug__)) = __tuple_like_with_size_imp<
                                   __tuple_like_ext<_RawTuple>::value,
                                   tuple_size<_RawTuple>, _ExpectedSize
                              >;
struct __attribute__((__visibility__("default"))) __check_tuple_constructor_fail {
    static constexpr bool __enable_explicit_default() { return false; }
    static constexpr bool __enable_implicit_default() { return false; }
    template <class ...>
    static constexpr bool __enable_explicit() { return false; }
    template <class ...>
    static constexpr bool __enable_implicit() { return false; }
    template <class ...>
    static constexpr bool __enable_assign() { return false; }
};
template <bool _CanCopy, bool _CanMove>
struct __sfinae_ctor_base {};
template <>
struct __sfinae_ctor_base<false, false> {
  __sfinae_ctor_base() = default;
  __sfinae_ctor_base(__sfinae_ctor_base const&) = delete;
  __sfinae_ctor_base(__sfinae_ctor_base &&) = delete;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base const&) = default;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base&&) = default;
};
template <>
struct __sfinae_ctor_base<true, false> {
  __sfinae_ctor_base() = default;
  __sfinae_ctor_base(__sfinae_ctor_base const&) = default;
  __sfinae_ctor_base(__sfinae_ctor_base &&) = delete;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base const&) = default;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base&&) = default;
};
template <>
struct __sfinae_ctor_base<false, true> {
  __sfinae_ctor_base() = default;
  __sfinae_ctor_base(__sfinae_ctor_base const&) = delete;
  __sfinae_ctor_base(__sfinae_ctor_base &&) = default;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base const&) = default;
  __sfinae_ctor_base& operator=(__sfinae_ctor_base&&) = default;
};
template <bool _CanCopy, bool _CanMove>
struct __sfinae_assign_base {};
template <>
struct __sfinae_assign_base<false, false> {
  __sfinae_assign_base() = default;
  __sfinae_assign_base(__sfinae_assign_base const&) = default;
  __sfinae_assign_base(__sfinae_assign_base &&) = default;
  __sfinae_assign_base& operator=(__sfinae_assign_base const&) = delete;
  __sfinae_assign_base& operator=(__sfinae_assign_base&&) = delete;
};
template <>
struct __sfinae_assign_base<true, false> {
  __sfinae_assign_base() = default;
  __sfinae_assign_base(__sfinae_assign_base const&) = default;
  __sfinae_assign_base(__sfinae_assign_base &&) = default;
  __sfinae_assign_base& operator=(__sfinae_assign_base const&) = default;
  __sfinae_assign_base& operator=(__sfinae_assign_base&&) = delete;
};
template <>
struct __sfinae_assign_base<false, true> {
  __sfinae_assign_base() = default;
  __sfinae_assign_base(__sfinae_assign_base const&) = default;
  __sfinae_assign_base(__sfinae_assign_base &&) = default;
  __sfinae_assign_base& operator=(__sfinae_assign_base const&) = delete;
  __sfinae_assign_base& operator=(__sfinae_assign_base&&) = default;
};
}}
namespace std { inline namespace __1 {
struct __attribute__((__type_visibility__("default"))) piecewise_construct_t { explicit piecewise_construct_t() = default; };
             constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();
}}
namespace std { inline namespace __1 {
template <class _T1, class _T2>
struct __attribute__((__type_visibility__("default"))) pair
{
    typedef _T1 first_type;
    typedef _T2 second_type;
    _T1 first;
    _T2 second;
    pair(pair const&) = default;
    pair(pair&&) = default;
    struct _CheckArgs {
      template <int&...>
      static constexpr bool __enable_explicit_default() {
          return is_default_constructible<_T1>::value
              && is_default_constructible<_T2>::value
              && !__enable_implicit_default<>();
      }
      template <int&...>
      static constexpr bool __enable_implicit_default() {
          return __is_implicitly_default_constructible<_T1>::value
              && __is_implicitly_default_constructible<_T2>::value;
      }
      template <class _U1, class _U2>
      static constexpr bool __is_pair_constructible() {
          return is_constructible<first_type, _U1>::value
              && is_constructible<second_type, _U2>::value;
      }
      template <class _U1, class _U2>
      static constexpr bool __is_implicit() {
          return is_convertible<_U1, first_type>::value
              && is_convertible<_U2, second_type>::value;
      }
      template <class _U1, class _U2>
      static constexpr bool __enable_explicit() {
          return __is_pair_constructible<_U1, _U2>() && !__is_implicit<_U1, _U2>();
      }
      template <class _U1, class _U2>
      static constexpr bool __enable_implicit() {
          return __is_pair_constructible<_U1, _U2>() && __is_implicit<_U1, _U2>();
      }
    };
    template <bool _MaybeEnable>
    using _CheckArgsDep __attribute__((__nodebug__)) = typename conditional<
      _MaybeEnable, _CheckArgs, __check_tuple_constructor_fail>::type;
    struct _CheckTupleLikeConstructor {
        template <class _Tuple>
        static constexpr bool __enable_implicit() {
            return __tuple_convertible<_Tuple, pair>::value;
        }
        template <class _Tuple>
        static constexpr bool __enable_explicit() {
            return __tuple_constructible<_Tuple, pair>::value
               && !__tuple_convertible<_Tuple, pair>::value;
        }
        template <class _Tuple>
        static constexpr bool __enable_assign() {
            return __tuple_assignable<_Tuple, pair>::value;
        }
    };
    template <class _Tuple>
    using _CheckTLC __attribute__((__nodebug__)) = __conditional_t<
        __tuple_like_with_size<_Tuple, 2>::value
            && !is_same<typename decay<_Tuple>::type, pair>::value,
        _CheckTupleLikeConstructor,
        __check_tuple_constructor_fail
    >;
    template<bool _Dummy = true, typename enable_if<
            _CheckArgsDep<_Dummy>::__enable_explicit_default()
    >::type* = nullptr>
    explicit __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    pair() noexcept(is_nothrow_default_constructible<first_type>::value && is_nothrow_default_constructible<second_type>::value)
        : first(), second() {}
    template<bool _Dummy = true, typename enable_if<
            _CheckArgsDep<_Dummy>::__enable_implicit_default()
    >::type* = nullptr>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    pair() noexcept(is_nothrow_default_constructible<first_type>::value && is_nothrow_default_constructible<second_type>::value)
        : first(), second() {}
    template <bool _Dummy = true, typename enable_if<
             _CheckArgsDep<_Dummy>::template __enable_explicit<_T1 const&, _T2 const&>()
    >::type* = nullptr>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    explicit pair(_T1 const& __t1, _T2 const& __t2)
        noexcept(is_nothrow_copy_constructible<first_type>::value && is_nothrow_copy_constructible<second_type>::value)
        : first(__t1), second(__t2) {}
    template<bool _Dummy = true, typename enable_if<
            _CheckArgsDep<_Dummy>::template __enable_implicit<_T1 const&, _T2 const&>()
    >::type* = nullptr>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    pair(_T1 const& __t1, _T2 const& __t2)
        noexcept(is_nothrow_copy_constructible<first_type>::value && is_nothrow_copy_constructible<second_type>::value)
        : first(__t1), second(__t2) {}
    template <
        class _U1, class _U2,
        typename enable_if<_CheckArgs::template __enable_explicit<_U1, _U2>()>::type* = nullptr
    >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    explicit pair(_U1&& __u1, _U2&& __u2)
        noexcept((is_nothrow_constructible<first_type, _U1>::value && is_nothrow_constructible<second_type, _U2>::value))
        : first(std::forward<_U1>(__u1)), second(std::forward<_U2>(__u2)) {}
    template <
        class _U1, class _U2,
        typename enable_if<_CheckArgs::template __enable_implicit<_U1, _U2>()>::type* = nullptr
    >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    pair(_U1&& __u1, _U2&& __u2)
        noexcept((is_nothrow_constructible<first_type, _U1>::value && is_nothrow_constructible<second_type, _U2>::value))
        : first(std::forward<_U1>(__u1)), second(std::forward<_U2>(__u2)) {}
    template<class _U1, class _U2, typename enable_if<
            _CheckArgs::template __enable_explicit<_U1 const&, _U2 const&>()
    >::type* = nullptr>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    explicit pair(pair<_U1, _U2> const& __p)
        noexcept((is_nothrow_constructible<first_type, _U1 const&>::value && is_nothrow_constructible<second_type, _U2 const&>::value))
        : first(__p.first), second(__p.second) {}
    template<class _U1, class _U2, typename enable_if<
            _CheckArgs::template __enable_implicit<_U1 const&, _U2 const&>()
    >::type* = nullptr>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    pair(pair<_U1, _U2> const& __p)
        noexcept((is_nothrow_constructible<first_type, _U1 const&>::value && is_nothrow_constructible<second_type, _U2 const&>::value))
        : first(__p.first), second(__p.second) {}
    template<class _U1, class _U2, typename enable_if<
            _CheckArgs::template __enable_explicit<_U1, _U2>()
    >::type* = nullptr>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    explicit pair(pair<_U1, _U2>&&__p)
        noexcept((is_nothrow_constructible<first_type, _U1&&>::value && is_nothrow_constructible<second_type, _U2&&>::value))
        : first(std::forward<_U1>(__p.first)), second(std::forward<_U2>(__p.second)) {}
    template<class _U1, class _U2, typename enable_if<
            _CheckArgs::template __enable_implicit<_U1, _U2>()
    >::type* = nullptr>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    pair(pair<_U1, _U2>&& __p)
        noexcept((is_nothrow_constructible<first_type, _U1&&>::value && is_nothrow_constructible<second_type, _U2&&>::value))
        : first(std::forward<_U1>(__p.first)), second(std::forward<_U2>(__p.second)) {}
    template<class _Tuple, typename enable_if<
            _CheckTLC<_Tuple>::template __enable_explicit<_Tuple>()
    >::type* = nullptr>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    explicit pair(_Tuple&& __p)
        : first(std::get<0>(std::forward<_Tuple>(__p))),
          second(std::get<1>(std::forward<_Tuple>(__p))) {}
    template<class _Tuple, typename enable_if<
            _CheckTLC<_Tuple>::template __enable_implicit<_Tuple>()
    >::type* = nullptr>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    pair(_Tuple&& __p)
        : first(std::get<0>(std::forward<_Tuple>(__p))),
          second(std::get<1>(std::forward<_Tuple>(__p))) {}
    template <class... _Args1, class... _Args2>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    pair(piecewise_construct_t __pc,
         tuple<_Args1...> __first_args, tuple<_Args2...> __second_args)
        noexcept((is_nothrow_constructible<first_type, _Args1...>::value && is_nothrow_constructible<second_type, _Args2...>::value))
        : pair(__pc, __first_args, __second_args,
                typename __make_tuple_indices<sizeof...(_Args1)>::type(),
                typename __make_tuple_indices<sizeof...(_Args2) >::type()) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    pair& operator=(__conditional_t<
                        is_copy_assignable<first_type>::value &&
                        is_copy_assignable<second_type>::value,
                    pair, __nat> const& __p)
        noexcept(is_nothrow_copy_assignable<first_type>::value && is_nothrow_copy_assignable<second_type>::value)
    {
        first = __p.first;
        second = __p.second;
        return *this;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    pair& operator=(__conditional_t<
                        is_move_assignable<first_type>::value &&
                        is_move_assignable<second_type>::value,
                    pair, __nat>&& __p)
        noexcept(is_nothrow_move_assignable<first_type>::value && is_nothrow_move_assignable<second_type>::value)
    {
        first = std::forward<first_type>(__p.first);
        second = std::forward<second_type>(__p.second);
        return *this;
    }
    template <class _Tuple, typename enable_if<
            _CheckTLC<_Tuple>::template __enable_assign<_Tuple>()
     >::type* = nullptr>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    pair& operator=(_Tuple&& __p) {
        first = std::get<0>(std::forward<_Tuple>(__p));
        second = std::get<1>(std::forward<_Tuple>(__p));
        return *this;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    void
    swap(pair& __p) noexcept(__is_nothrow_swappable<first_type>::value && __is_nothrow_swappable<second_type>::value)
    {
        using std::swap;
        swap(first, __p.first);
        swap(second, __p.second);
    }
private:
    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    pair(piecewise_construct_t,
         tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,
         __tuple_indices<_I1...>, __tuple_indices<_I2...>);
};
template<class _T1, class _T2>
pair(_T1, _T2) -> pair<_T1, _T2>;
template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool
operator==(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    return __x.first == __y.first && __x.second == __y.second;
}
template <class _T1, class _T2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
common_comparison_category_t<
        __synth_three_way_result<_T1>,
        __synth_three_way_result<_T2> >
operator<=>(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
{
    if (auto __c = std::__synth_three_way(__x.first, __y.first); __c != 0) {
      return __c;
    }
    return std::__synth_three_way(__x.second, __y.second);
}
template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
typename enable_if
<
    __is_swappable<_T1>::value &&
    __is_swappable<_T2>::value,
    void
>::type
swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
                     noexcept((__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value))
{
    __x.swap(__y);
}
template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
pair<typename __unwrap_ref_decay<_T1>::type, typename __unwrap_ref_decay<_T2>::type>
make_pair(_T1&& __t1, _T2&& __t2)
{
    return pair<typename __unwrap_ref_decay<_T1>::type, typename __unwrap_ref_decay<_T2>::type>
               (std::forward<_T1>(__t1), std::forward<_T2>(__t2));
}
template <class _T1, class _T2>
  struct __attribute__((__type_visibility__("default"))) tuple_size<pair<_T1, _T2> >
    : public integral_constant<size_t, 2> {};
template <size_t _Ip, class _T1, class _T2>
struct __attribute__((__type_visibility__("default"))) tuple_element<_Ip, pair<_T1, _T2> >
{
    static_assert(_Ip < 2, "Index out of bounds in std::tuple_element<std::pair<T1, T2>>");
};
template <class _T1, class _T2>
struct __attribute__((__type_visibility__("default"))) tuple_element<0, pair<_T1, _T2> >
{
    typedef __attribute__((__nodebug__)) _T1 type;
};
template <class _T1, class _T2>
struct __attribute__((__type_visibility__("default"))) tuple_element<1, pair<_T1, _T2> >
{
    typedef __attribute__((__nodebug__)) _T2 type;
};
template <size_t _Ip> struct __get_pair;
template <>
struct __get_pair<0>
{
    template <class _T1, class _T2>
    static
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    _T1&
    get(pair<_T1, _T2>& __p) noexcept {return __p.first;}
    template <class _T1, class _T2>
    static
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    const _T1&
    get(const pair<_T1, _T2>& __p) noexcept {return __p.first;}
    template <class _T1, class _T2>
    static
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    _T1&&
    get(pair<_T1, _T2>&& __p) noexcept {return std::forward<_T1>(__p.first);}
    template <class _T1, class _T2>
    static
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    const _T1&&
    get(const pair<_T1, _T2>&& __p) noexcept {return std::forward<const _T1>(__p.first);}
};
template <>
struct __get_pair<1>
{
    template <class _T1, class _T2>
    static
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    _T2&
    get(pair<_T1, _T2>& __p) noexcept {return __p.second;}
    template <class _T1, class _T2>
    static
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    const _T2&
    get(const pair<_T1, _T2>& __p) noexcept {return __p.second;}
    template <class _T1, class _T2>
    static
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    _T2&&
    get(pair<_T1, _T2>&& __p) noexcept {return std::forward<_T2>(__p.second);}
    template <class _T1, class _T2>
    static
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    const _T2&&
    get(const pair<_T1, _T2>&& __p) noexcept {return std::forward<const _T2>(__p.second);}
};
template <size_t _Ip, class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(pair<_T1, _T2>& __p) noexcept
{
    return __get_pair<_Ip>::get(__p);
}
template <size_t _Ip, class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&
get(const pair<_T1, _T2>& __p) noexcept
{
    return __get_pair<_Ip>::get(__p);
}
template <size_t _Ip, class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(pair<_T1, _T2>&& __p) noexcept
{
    return __get_pair<_Ip>::get(std::move(__p));
}
template <size_t _Ip, class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
const typename tuple_element<_Ip, pair<_T1, _T2> >::type&&
get(const pair<_T1, _T2>&& __p) noexcept
{
    return __get_pair<_Ip>::get(std::move(__p));
}
template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr _T1 & get(pair<_T1, _T2>& __p) noexcept
{
    return __get_pair<0>::get(__p);
}
template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr _T1 const & get(pair<_T1, _T2> const& __p) noexcept
{
    return __get_pair<0>::get(__p);
}
template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr _T1 && get(pair<_T1, _T2>&& __p) noexcept
{
    return __get_pair<0>::get(std::move(__p));
}
template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr _T1 const && get(pair<_T1, _T2> const&& __p) noexcept
{
    return __get_pair<0>::get(std::move(__p));
}
template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr _T1 & get(pair<_T2, _T1>& __p) noexcept
{
    return __get_pair<1>::get(__p);
}
template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr _T1 const & get(pair<_T2, _T1> const& __p) noexcept
{
    return __get_pair<1>::get(__p);
}
template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr _T1 && get(pair<_T2, _T1>&& __p) noexcept
{
    return __get_pair<1>::get(std::move(__p));
}
template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr _T1 const && get(pair<_T2, _T1> const&& __p) noexcept
{
    return __get_pair<1>::get(std::move(__p));
}
}}
namespace std { inline namespace __1 {
template <class _Iter, class _Sent>
struct __unwrap_range_impl {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr auto __unwrap(_Iter __first, _Sent __sent)
    requires random_access_iterator<_Iter> && sized_sentinel_for<_Sent, _Iter>
  {
    auto __last = ranges::next(__first, __sent);
    return pair{std::__unwrap_iter(std::move(__first)), std::__unwrap_iter(std::move(__last))};
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr auto __unwrap(_Iter __first, _Sent __last) {
    return pair{std::move(__first), std::move(__last)};
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr auto
  __rewrap(_Iter __orig_iter, decltype(std::__unwrap_iter(__orig_iter)) __iter)
    requires random_access_iterator<_Iter> && sized_sentinel_for<_Sent, _Iter>
  {
    return std::__rewrap_iter(std::move(__orig_iter), std::move(__iter));
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr auto __rewrap(const _Iter&, _Iter __iter)
    requires (!(random_access_iterator<_Iter> && sized_sentinel_for<_Sent, _Iter>))
  {
    return __iter;
  }
};
template <class _Iter>
struct __unwrap_range_impl<_Iter, _Iter> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr auto __unwrap(_Iter __first, _Iter __last) {
    return pair{std::__unwrap_iter(std::move(__first)), std::__unwrap_iter(std::move(__last))};
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr auto
  __rewrap(_Iter __orig_iter, decltype(std::__unwrap_iter(__orig_iter)) __iter) {
    return std::__rewrap_iter(std::move(__orig_iter), std::move(__iter));
  }
};
template <class _Iter, class _Sent>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr auto __unwrap_range(_Iter __first, _Sent __last) {
  return __unwrap_range_impl<_Iter, _Sent>::__unwrap(std::move(__first), std::move(__last));
}
template <
    class _Sent,
    class _Iter,
    class _Unwrapped = decltype(std::__unwrap_range(std::declval<_Iter>(), std::declval<_Sent>()))>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Iter __rewrap_range(_Iter __orig_iter, _Unwrapped __iter) {
  return __unwrap_range_impl<_Iter, _Sent>::__rewrap(std::move(__orig_iter), std::move(__iter));
}
}}
namespace std { inline namespace __1 {
template <class _From, class _To>
struct __is_always_bitcastable {
  using _UnqualFrom = __remove_cv_t<_From>;
  using _UnqualTo = __remove_cv_t<_To>;
  static const bool value =
    (is_same<_UnqualFrom, _UnqualTo>::value && is_trivially_copyable<_UnqualFrom>::value) ||
    (
      sizeof(_From) == sizeof(_To) &&
      is_integral<_From>::value &&
      is_integral<_To>::value &&
      !is_same<_UnqualTo, bool>::value
    );
};
}}
namespace std { inline namespace __1 {
template <class _From, class _To>
struct __can_lower_copy_assignment_to_memmove {
  static const bool value =
    __is_always_bitcastable<_From, _To>::value &&
    is_trivially_assignable<_To&, const _From&>::value &&
    !is_volatile<_From>::value &&
    !is_volatile<_To>::value;
};
template <class _From, class _To>
struct __can_lower_move_assignment_to_memmove {
  static const bool value =
    __is_always_bitcastable<_From, _To>::value &&
    is_trivially_assignable<_To&, _From&&>::value &&
    !is_volatile<_From>::value &&
    !is_volatile<_To>::value;
};
template <class _In, class _Out>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_In*, _Out*>
__copy_trivial_impl(_In* __first, _In* __last, _Out* __result) {
  const size_t __n = static_cast<size_t>(__last - __first);
  ::__builtin_memmove(__result, __first, __n * sizeof(_Out));
  return std::make_pair(__last, __result + __n);
}
template <class _In, class _Out>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_In*, _Out*>
__copy_backward_trivial_impl(_In* __first, _In* __last, _Out* __result) {
  const size_t __n = static_cast<size_t>(__last - __first);
  __result -= __n;
  ::__builtin_memmove(__result, __first, __n * sizeof(_Out));
  return std::make_pair(__last, __result);
}
template <class _F1, class _F2>
struct __overload : _F1, _F2 {
  using _F1::operator();
  using _F2::operator();
};
template <class _InIter, class _Sent, class _OutIter, class = void>
struct __can_rewrap : false_type {};
template <class _InIter, class _Sent, class _OutIter>
struct __can_rewrap<_InIter,
                    _Sent,
                    _OutIter,
                    __enable_if_t< is_copy_constructible<_InIter>::value &&
                                   is_copy_constructible<_OutIter>::value > > : true_type {};
template <class _Algorithm,
          class _InIter,
          class _Sent,
          class _OutIter,
          __enable_if_t<__can_rewrap<_InIter, _Sent, _OutIter>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_InIter, _OutIter>
__unwrap_and_dispatch(_InIter __first, _Sent __last, _OutIter __out_first) {
  auto __range = std::__unwrap_range(__first, std::move(__last));
  auto __result = _Algorithm()(std::move(__range.first), std::move(__range.second), std::__unwrap_iter(__out_first));
  return std::make_pair(std::__rewrap_range<_Sent>(std::move(__first), std::move(__result.first)),
                                 std::__rewrap_iter(std::move(__out_first), std::move(__result.second)));
}
template <class _Algorithm,
          class _InIter,
          class _Sent,
          class _OutIter,
          __enable_if_t<!__can_rewrap<_InIter, _Sent, _OutIter>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_InIter, _OutIter>
__unwrap_and_dispatch(_InIter __first, _Sent __last, _OutIter __out_first) {
  return _Algorithm()(std::move(__first), std::move(__last), std::move(__out_first));
}
template <class _IterOps, class _InValue, class _OutIter, class = void>
struct __can_copy_without_conversion : false_type {};
template <class _IterOps, class _InValue, class _OutIter>
struct __can_copy_without_conversion<
    _IterOps,
    _InValue,
    _OutIter,
    __enable_if_t<is_same<_InValue, typename _IterOps::template __value_type<_OutIter> >::value> > : true_type {};
template <class _AlgPolicy,
          class _NaiveAlgorithm,
          class _OptimizedAlgorithm,
          class _InIter,
          class _Sent,
          class _OutIter>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_InIter, _OutIter>
__dispatch_copy_or_move(_InIter __first, _Sent __last, _OutIter __out_first) {
  if (__libcpp_is_constant_evaluated()) {
    using _InValue = typename _IterOps<_AlgPolicy>::template __value_type<_InIter>;
    if (!is_trivially_copyable<_InValue>::value ||
        !__can_copy_without_conversion<_IterOps<_AlgPolicy>, _InValue, _OutIter>::value) {
      return std::__unwrap_and_dispatch<_NaiveAlgorithm>(std::move(__first), std::move(__last), std::move(__out_first));
    }
  }
  using _Algorithm = __overload<_NaiveAlgorithm, _OptimizedAlgorithm>;
  return std::__unwrap_and_dispatch<_Algorithm>(std::move(__first), std::move(__last), std::move(__out_first));
}
}}

namespace std { inline namespace __1 {
template <class _Comp, class _Iter, class _Sent, class _Proj>
// added by concept-synth, original LN: 7267
requires
(
 requires (_Iter x0) { *x0; } &&
 requires (_Iter x0) { ++x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_Iter __min_element(_Iter __first, _Sent __last, _Comp __comp, _Proj& __proj) {
  if (__first == __last)
    return __first;
  _Iter __i = __first;
  while (++__i != __last)
    if (std::__invoke(__comp, std::__invoke(__proj, *__i), std::__invoke(__proj, *__first)))
      __first = __i;
  return __first;
}
template <class _Comp, class _Iter, class _Sent>
// added by concept-synth, original LN: 7278
requires
(
 requires (_Iter x0) { *x0; } &&
 requires (_Iter x0) { ++x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_Iter __min_element(_Iter __first, _Sent __last, _Comp __comp) {
  auto __proj = __identity();
  return std::__min_element<_Comp>(std::move(__first), std::move(__last), __comp, __proj);
}
template <class _ForwardIterator, class _Compare>
// added by concept-synth, original LN: 7284
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
  static_assert(__is_cpp17_forward_iterator<_ForwardIterator>::value,
      "std::min_element requires a ForwardIterator");
  static_assert(__is_callable<_Compare, decltype(*__first), decltype(*__first)>::value,
              "The comparator has to be callable");
  return std::__min_element<__comp_ref_type<_Compare> >(std::move(__first), std::move(__last), __comp);
}
template <class _ForwardIterator>
// added by concept-synth, original LN: 7294
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::min_element(__first, __last,
              __less<typename iterator_traits<_ForwardIterator>::value_type>());
}
}}

namespace std { inline namespace __1 {
template <class _Tp, class _Compare>
// added by concept-synth, original LN: 7304
requires
requires (_Compare f, _Tp x0, _Tp x1) { f(x0, x1); }
[[nodiscard]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
const _Tp&
min(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__b, __a) ? __b : __a;
}
template <class _Tp>
[[nodiscard]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
const _Tp&
min(const _Tp& __a, const _Tp& __b)
{
    return std::min(__a, __b, __less<_Tp>());
}
template<class _Tp, class _Compare>
[[nodiscard]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_Tp
min(initializer_list<_Tp> __t, _Compare __comp)
{
    return *std::__min_element<__comp_ref_type<_Compare> >(__t.begin(), __t.end(), __comp);
}
template<class _Tp>
[[nodiscard]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_Tp
min(initializer_list<_Tp> __t)
{
    return *std::min_element(__t.begin(), __t.end(), __less<_Tp>());
}
}}

namespace std { inline namespace __1 {
template <class _Iterator>
struct __segmented_iterator_traits;
template <class _Tp, size_t = 0>
struct __has_specialization : false_type {};
template <class _Tp>
struct __has_specialization<_Tp, sizeof(_Tp) * 0> : true_type {};
template <class _Iterator>
using __is_segmented_iterator = __has_specialization<__segmented_iterator_traits<_Iterator> >;
}}

namespace std { inline namespace __1 {
template <class, class _InIter, class _Sent, class _OutIter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_InIter, _OutIter> __copy(_InIter, _Sent, _OutIter);
template <class _AlgPolicy>
struct __copy_loop {
  template <class _InIter, class _Sent, class _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_InIter, _OutIter>
  operator()(_InIter __first, _Sent __last, _OutIter __result) const {
    while (__first != __last) {
      *__result = *__first;
      ++__first;
      ++__result;
    }
    return std::make_pair(std::move(__first), std::move(__result));
  }
  template <class _InIter, class _OutIter, __enable_if_t<__is_segmented_iterator<_InIter>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_InIter, _OutIter>
  operator()(_InIter __first, _InIter __last, _OutIter __result) const {
    using _Traits = __segmented_iterator_traits<_InIter>;
    auto __sfirst = _Traits::__segment(__first);
    auto __slast = _Traits::__segment(__last);
    if (__sfirst == __slast) {
      auto __iters = std::__copy<_AlgPolicy>(_Traits::__local(__first), _Traits::__local(__last), std::move(__result));
      return std::make_pair(__last, std::move(__iters.second));
    }
    __result = std::__copy<_AlgPolicy>(_Traits::__local(__first), _Traits::__end(__sfirst), std::move(__result)).second;
    ++__sfirst;
    while (__sfirst != __slast) {
      __result =
          std::__copy<_AlgPolicy>(_Traits::__begin(__sfirst), _Traits::__end(__sfirst), std::move(__result)).second;
      ++__sfirst;
    }
    __result =
        std::__copy<_AlgPolicy>(_Traits::__begin(__sfirst), _Traits::__local(__last), std::move(__result)).second;
    return std::make_pair(__last, std::move(__result));
  }
  template <class _InIter,
            class _OutIter,
            __enable_if_t<__is_cpp17_random_access_iterator<_InIter>::value &&
                              !__is_segmented_iterator<_InIter>::value && __is_segmented_iterator<_OutIter>::value,
                          int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_InIter, _OutIter>
  operator()(_InIter __first, _InIter __last, _OutIter __result) {
    using _Traits = __segmented_iterator_traits<_OutIter>;
    using _DiffT = typename common_type<__iter_diff_t<_InIter>, __iter_diff_t<_OutIter> >::type;
    if (__first == __last)
      return std::make_pair(std::move(__first), std::move(__result));
    auto __local_first = _Traits::__local(__result);
    auto __segment_iterator = _Traits::__segment(__result);
    while (true) {
      auto __local_last = _Traits::__end(__segment_iterator);
      auto __size = std::min<_DiffT>(__local_last - __local_first, __last - __first);
      auto __iters = std::__copy<_AlgPolicy>(__first, __first + __size, __local_first);
      __first = std::move(__iters.first);
      if (__first == __last)
        return std::make_pair(std::move(__first), _Traits::__compose(__segment_iterator, std::move(__iters.second)));
      __local_first = _Traits::__begin(++__segment_iterator);
    }
  }
};
struct __copy_trivial {
  template <class _In, class _Out,
            __enable_if_t<__can_lower_copy_assignment_to_memmove<_In, _Out>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_In*, _Out*>
  operator()(_In* __first, _In* __last, _Out* __result) const {
    return std::__copy_trivial_impl(__first, __last, __result);
  }
};
template <class _AlgPolicy, class _InIter, class _Sent, class _OutIter>
pair<_InIter, _OutIter> inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
__copy(_InIter __first, _Sent __last, _OutIter __result) {
  return std::__dispatch_copy_or_move<_AlgPolicy, __copy_loop<_AlgPolicy>, __copy_trivial>(
      std::move(__first), std::move(__last), std::move(__result));
}
template <class _InputIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _OutputIterator
copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result) {
  return std::__copy<_ClassicAlgPolicy>(__first, __last, __result).second;
}
}}

namespace std { inline namespace __1 {
template <class _AlgPolicy, class _InIter, class _Sent, class _OutIter>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_InIter, _OutIter>
__copy_backward(_InIter __first, _Sent __last, _OutIter __result);
template <class _AlgPolicy>
struct __copy_backward_loop {
  template <class _InIter, class _Sent, class _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_InIter, _OutIter>
  operator()(_InIter __first, _Sent __last, _OutIter __result) const {
    auto __last_iter = _IterOps<_AlgPolicy>::next(__first, __last);
    auto __original_last_iter = __last_iter;
    while (__first != __last_iter) {
      *--__result = *--__last_iter;
    }
    return std::make_pair(std::move(__original_last_iter), std::move(__result));
  }
  template <class _InIter, class _OutIter, __enable_if_t<__is_segmented_iterator<_InIter>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_InIter, _OutIter>
  operator()(_InIter __first, _InIter __last, _OutIter __result) const {
    using _Traits = __segmented_iterator_traits<_InIter>;
    auto __sfirst = _Traits::__segment(__first);
    auto __slast = _Traits::__segment(__last);
    if (__sfirst == __slast) {
      auto __iters =
          std::__copy_backward<_AlgPolicy>(_Traits::__local(__first), _Traits::__local(__last), std::move(__result));
      return std::make_pair(__last, __iters.second);
    }
    __result =
        std::__copy_backward<_AlgPolicy>(_Traits::__begin(__slast), _Traits::__local(__last), std::move(__result))
            .second;
    --__slast;
    while (__sfirst != __slast) {
      __result =
          std::__copy_backward<_AlgPolicy>(_Traits::__begin(__slast), _Traits::__end(__slast), std::move(__result))
              .second;
      --__slast;
    }
    __result = std::__copy_backward<_AlgPolicy>(_Traits::__local(__first), _Traits::__end(__slast), std::move(__result))
                   .second;
    return std::make_pair(__last, std::move(__result));
  }
  template <class _InIter,
            class _OutIter,
            __enable_if_t<__is_cpp17_random_access_iterator<_InIter>::value &&
                              !__is_segmented_iterator<_InIter>::value && __is_segmented_iterator<_OutIter>::value,
                          int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_InIter, _OutIter>
  operator()(_InIter __first, _InIter __last, _OutIter __result) {
    using _Traits = __segmented_iterator_traits<_OutIter>;
    auto __orig_last = __last;
    auto __segment_iterator = _Traits::__segment(__result);
    if (__first == __last)
      return std::make_pair(__first, __result);
    auto __local_last = _Traits::__local(__result);
    while (true) {
      using _DiffT = typename common_type<__iter_diff_t<_InIter>, __iter_diff_t<_OutIter> >::type;
      auto __local_first = _Traits::__begin(__segment_iterator);
      auto __size = std::min<_DiffT>(__local_last - __local_first, __last - __first);
      auto __iter = std::__copy_backward<_AlgPolicy>(__last - __size, __last, __local_last).second;
      __last -= __size;
      if (__first == __last)
        return std::make_pair(std::move(__orig_last), _Traits::__compose(__segment_iterator, std::move(__iter)));
      --__segment_iterator;
      __local_last = _Traits::__end(__segment_iterator);
    }
  }
};
struct __copy_backward_trivial {
  template <class _In, class _Out,
            __enable_if_t<__can_lower_copy_assignment_to_memmove<_In, _Out>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_In*, _Out*>
  operator()(_In* __first, _In* __last, _Out* __result) const {
    return std::__copy_backward_trivial_impl(__first, __last, __result);
  }
};
template <class _AlgPolicy, class _BidirectionalIterator1, class _Sentinel, class _BidirectionalIterator2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_BidirectionalIterator1, _BidirectionalIterator2>
__copy_backward(_BidirectionalIterator1 __first, _Sentinel __last, _BidirectionalIterator2 __result) {
  return std::__dispatch_copy_or_move<_AlgPolicy, __copy_backward_loop<_AlgPolicy>, __copy_backward_trivial>(
      std::move(__first), std::move(__last), std::move(__result));
}
template <class _BidirectionalIterator1, class _BidirectionalIterator2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_BidirectionalIterator2
copy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
              _BidirectionalIterator2 __result)
{
  static_assert(std::is_copy_constructible<_BidirectionalIterator1>::value &&
                std::is_copy_constructible<_BidirectionalIterator1>::value, "Iterators must be copy constructible.");
  return std::__copy_backward<_ClassicAlgPolicy>(
      std::move(__first), std::move(__last), std::move(__result)).second;
}
}}
namespace std { inline namespace __1 {
template<class _InputIterator, class _OutputIterator, class _Predicate>
// added by concept-synth, original LN: 7524
requires
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
) &&
requires (_Predicate f, _InputIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_OutputIterator
copy_if(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result, _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (__pred(*__first))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}
}}
namespace std { inline namespace __1 {
template<class _InputIterator, class _Size, class _OutputIterator>
// added by concept-synth, original LN: 7542
requires
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
) &&
(
 requires (_InputIterator x0) { ++x0; } &&
 requires (_InputIterator x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
typename enable_if
<
    __is_cpp17_input_iterator<_InputIterator>::value &&
   !__is_cpp17_random_access_iterator<_InputIterator>::value,
    _OutputIterator
>::type
copy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)
{
    typedef decltype(std::__convert_to_integral(__orig_n)) _IntegralSize;
    _IntegralSize __n = __orig_n;
    if (__n > 0)
    {
        *__result = *__first;
        ++__result;
        for (--__n; __n > 0; --__n)
        {
            ++__first;
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}
template<class _InputIterator, class _Size, class _OutputIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
typename enable_if
<
    __is_cpp17_random_access_iterator<_InputIterator>::value,
    _OutputIterator
>::type
copy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result)
{
    typedef typename iterator_traits<_InputIterator>::difference_type difference_type;
    typedef decltype(std::__convert_to_integral(__orig_n)) _IntegralSize;
    _IntegralSize __n = __orig_n;
    return std::copy(__first, __first + difference_type(__n), __result);
}
}}
namespace std { inline namespace __1 {
template <class _InputIterator, class _Tp>
// added by concept-synth, original LN: 7583
requires
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value) {
  typename iterator_traits<_InputIterator>::difference_type __r(0);
  for (; __first != __last; ++__first)
    if (*__first == __value)
      ++__r;
  return __r;
}
}}
namespace std { inline namespace __1 {
template <class _InputIterator, class _Predicate>
// added by concept-synth, original LN: 7595
requires
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
) &&
requires (_Predicate f, _InputIterator x0) { {f(*x0)} -> std::convertible_to<bool>; }
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  typename iterator_traits<_InputIterator>::difference_type __r(0);
  for (; __first != __last; ++__first)
    if (__pred(*__first))
      ++__r;
  return __r;
}
}}
namespace std { inline namespace __1 {
template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
// added by concept-synth, original LN: 7607
requires
requires (_BinaryPredicate f, _InputIterator1 x0, _InputIterator2 x1) { f(*x0, *x1); } &&
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
) &&
(
 requires (_InputIterator2 x0) { *x0; } &&
 requires (_InputIterator2 x0) { ++x0; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred) {
  for (; __first1 != __last1; ++__first1, (void)++__first2)
    if (!__pred(*__first1, *__first2))
      return false;
  return true;
}
template <class _InputIterator1, class _InputIterator2>
// added by concept-synth, original LN: 7615
requires
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
) &&
(
 requires (_InputIterator2 x0) { *x0; } &&
 requires (_InputIterator2 x0) { ++x0; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2) {
  return std::equal(__first1, __last1, __first2, __equal_to());
}
template <class _BinaryPredicate, class _InputIterator1, class _InputIterator2>
// added by concept-synth, original LN: 7620
requires
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
) &&
requires (_BinaryPredicate f, _InputIterator1 x0, _InputIterator2 x1) { f(*x0, *x1); } &&
(
 requires (_InputIterator2 x0) { *x0; } &&
 requires (_InputIterator2 x0) { ++x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool
__equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,
        _BinaryPredicate __pred, input_iterator_tag, input_iterator_tag) {
  for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void)++__first2)
    if (!__pred(*__first1, *__first2))
      return false;
  return __first1 == __last1 && __first2 == __last2;
}
template <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>
// added by concept-synth, original LN: 7629
requires
(
 requires (_RandomAccessIterator1 x0) { *x0; } &&
 requires (_RandomAccessIterator1 x0) { ++x0; } &&
 (
  (
   requires (_RandomAccessIterator1 x0) { ++x0; } &&
   requires (_RandomAccessIterator1 x0, _RandomAccessIterator1 x1) { x0 != x1; }
  ) ||
  requires (_RandomAccessIterator1 x0, _RandomAccessIterator1 x1) { x0 - x1; }
 )
) &&
requires (_BinaryPredicate f, _RandomAccessIterator1 x0, _RandomAccessIterator2 x1) { f(*x0, *x1); } &&
(
 requires (_RandomAccessIterator2 x0) { *x0; } &&
 requires (_RandomAccessIterator2 x0) { ++x0; } &&
 (
  (
   requires (_RandomAccessIterator2 x0) { ++x0; } &&
   requires (_RandomAccessIterator2 x0, _RandomAccessIterator2 x1) { x0 != x1; }
  ) ||
  requires (_RandomAccessIterator2 x0, _RandomAccessIterator2 x1) { x0 - x1; }
 )
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool
__equal(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1, _RandomAccessIterator2 __first2,
        _RandomAccessIterator2 __last2, _BinaryPredicate __pred, random_access_iterator_tag,
        random_access_iterator_tag) {
  if (std::distance(__first1, __last1) != std::distance(__first2, __last2))
    return false;
  return std::equal<_RandomAccessIterator1, _RandomAccessIterator2,
                      _BinaryPredicate&>(__first1, __last1, __first2, __pred);
}
template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
// added by concept-synth, original LN: 7639
requires
requires (_BinaryPredicate f, _InputIterator1 x0, _InputIterator2 x1) { f(*x0, *x1); } &&
(
 (
  requires (_InputIterator1 x0) { *x0; } &&
  requires (_InputIterator1 x0) { ++x0; }
 ) ||
 (
  requires (_InputIterator1 x0) { *x0; } &&
  requires (_InputIterator1 x0) { ++x0; } &&
  (
   (
    requires (_InputIterator1 x0) { ++x0; } &&
    requires (_InputIterator1 x0, _InputIterator1 x1) { x0 != x1; }
   ) ||
   requires (_InputIterator1 x0, _InputIterator1 x1) { x0 - x1; }
  )
 )
) &&
(
 (
  requires (_InputIterator2 x0) { *x0; } &&
  requires (_InputIterator2 x0) { ++x0; }
 ) ||
 (
  requires (_InputIterator2 x0) { *x0; } &&
  requires (_InputIterator2 x0) { ++x0; } &&
  (
   (
    requires (_InputIterator2 x0) { ++x0; } &&
    requires (_InputIterator2 x0, _InputIterator2 x1) { x0 != x1; }
   ) ||
   requires (_InputIterator2 x0, _InputIterator2 x1) { x0 - x1; }
  )
 )
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,
      _BinaryPredicate __pred) {
  return std::__equal<_BinaryPredicate&>(
      __first1, __last1, __first2, __last2, __pred, typename iterator_traits<_InputIterator1>::iterator_category(),
      typename iterator_traits<_InputIterator2>::iterator_category());
}
template <class _InputIterator1, class _InputIterator2>
// added by concept-synth, original LN: 7647
requires
(
 (
  requires (_InputIterator2 x0) { *x0; } &&
  requires (_InputIterator2 x0) { ++x0; }
 ) ||
 (
  requires (_InputIterator2 x0) { *x0; } &&
  requires (_InputIterator2 x0) { ++x0; } &&
  (
   (
    requires (_InputIterator2 x0) { ++x0; } &&
    requires (_InputIterator2 x0, _InputIterator2 x1) { x0 != x1; }
   ) ||
   requires (_InputIterator2 x0, _InputIterator2 x1) { x0 - x1; }
  )
 )
) &&
(
 (
  requires (_InputIterator1 x0) { *x0; } &&
  requires (_InputIterator1 x0) { ++x0; }
 ) ||
 (
  requires (_InputIterator1 x0) { *x0; } &&
  requires (_InputIterator1 x0) { ++x0; } &&
  (
   (
    requires (_InputIterator1 x0) { ++x0; } &&
    requires (_InputIterator1 x0, _InputIterator1 x1) { x0 != x1; }
   ) ||
   requires (_InputIterator1 x0, _InputIterator1 x1) { x0 - x1; }
  )
 )
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool
equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2) {
  return std::__equal(
      __first1,
      __last1,
      __first2,
      __last2,
      __equal_to(),
      typename iterator_traits<_InputIterator1>::iterator_category(),
      typename iterator_traits<_InputIterator2>::iterator_category());
}
}}
namespace std { inline namespace __1 {
template <class _AlgPolicy, class _Compare, class _Iter, class _Sent, class _Tp, class _Proj>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Iter
__upper_bound(_Iter __first, _Sent __last, const _Tp& __value, _Compare&& __comp, _Proj&& __proj) {
  auto __len = _IterOps<_AlgPolicy>::distance(__first, __last);
  while (__len != 0) {
    auto __half_len = std::__half_positive(__len);
    auto __mid = _IterOps<_AlgPolicy>::next(__first, __half_len);
    if (std::__invoke(__comp, __value, std::__invoke(__proj, *__mid)))
      __len = __half_len;
    else {
      __first = ++__mid;
      __len -= __half_len + 1;
    }
  }
  return __first;
}
template <class _ForwardIterator, class _Tp, class _Compare>
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _ForwardIterator
upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value, _Compare __comp) {
  static_assert(is_copy_constructible<_ForwardIterator>::value,
                "Iterator has to be copy constructible");
  return std::__upper_bound<_ClassicAlgPolicy>(
      std::move(__first), std::move(__last), __value, std::move(__comp), std::__identity());
}
template <class _ForwardIterator, class _Tp>
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _ForwardIterator
upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value) {
  return std::upper_bound(
      std::move(__first),
      std::move(__last),
      __value,
      __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());
}
}}
namespace std { inline namespace __1 {
template <class _AlgPolicy, class _Compare, class _Iter, class _Sent, class _Tp, class _Proj>
// added by concept-synth, original LN: 7696
requires
(
 requires (_Iter x0) { ++x0; } &&
 requires (_Iter x0) { *x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_Iter, _Iter>
__equal_range(_Iter __first, _Sent __last, const _Tp& __value, _Compare&& __comp, _Proj&& __proj) {
  auto __len = _IterOps<_AlgPolicy>::distance(__first, __last);
  _Iter __end = _IterOps<_AlgPolicy>::next(__first, __last);
  while (__len != 0) {
    auto __half_len = std::__half_positive(__len);
    _Iter __mid = _IterOps<_AlgPolicy>::next(__first, __half_len);
    if (std::__invoke(__comp, std::__invoke(__proj, *__mid), __value)) {
      __first = ++__mid;
      __len -= __half_len + 1;
    } else if (std::__invoke(__comp, __value, std::__invoke(__proj, *__mid))) {
      __end = __mid;
      __len = __half_len;
    } else {
      _Iter __mp1 = __mid;
      return pair<_Iter, _Iter>(
          std::__lower_bound_impl<_AlgPolicy>(__first, __mid, __value, __comp, __proj),
          std::__upper_bound<_AlgPolicy>(++__mp1, __end, __value, __comp, __proj));
    }
  }
  return pair<_Iter, _Iter>(__first, __first);
}
template <class _ForwardIterator, class _Tp, class _Compare>
// added by concept-synth, original LN: 7719
requires
(
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0) { *x0; }
)
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_ForwardIterator, _ForwardIterator>
equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value, _Compare __comp) {
  static_assert(__is_callable<_Compare, decltype(*__first), const _Tp&>::value,
                "The comparator has to be callable");
  static_assert(is_copy_constructible<_ForwardIterator>::value,
                "Iterator has to be copy constructible");
  return std::__equal_range<_ClassicAlgPolicy>(
      std::move(__first),
      std::move(__last),
      __value,
      static_cast<__comp_ref_type<_Compare> >(__comp),
      std::__identity());
}
template <class _ForwardIterator, class _Tp>
// added by concept-synth, original LN: 7733
requires
(
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0) { *x0; }
)
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_ForwardIterator, _ForwardIterator>
equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value) {
  return std::equal_range(
      std::move(__first),
      std::move(__last),
      __value,
      __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}
}}
namespace std { inline namespace __1 {
template <class _OutputIterator, class _Size, class _Tp>
// added by concept-synth, original LN: 7744
requires
requires (_Size x0) { --x0; } &&
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_OutputIterator
__fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)
{
    for (; __n > 0; ++__first, (void) --__n)
        *__first = __value;
    return __first;
}
template <class _OutputIterator, class _Size, class _Tp>
// added by concept-synth, original LN: 7753
requires
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_OutputIterator
fill_n(_OutputIterator __first, _Size __n, const _Tp& __value)
{
   return std::__fill_n(__first, std::__convert_to_integral(__n), __value);
}
}}
namespace std { inline namespace __1 {
template <class _ForwardIterator, class _Tp>
// added by concept-synth, original LN: 7762
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void
__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value, forward_iterator_tag)
{
    for (; __first != __last; ++__first)
        *__first = __value;
}
template <class _RandomAccessIterator, class _Tp>
// added by concept-synth, original LN: 7770
requires
(
 requires (_RandomAccessIterator x0, _RandomAccessIterator x1) { x0 - x1; } &&
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { ++x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void
__fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp& __value, random_access_iterator_tag)
{
    std::fill_n(__first, __last - __first, __value);
}
template <class _ForwardIterator, class _Tp>
// added by concept-synth, original LN: 7777
requires
(
 (
  requires (_ForwardIterator x0) { *x0; } &&
  requires (_ForwardIterator x0) { ++x0; }
 ) ||
 (
  requires (_ForwardIterator x0, _ForwardIterator x1) { x0 - x1; } &&
  requires (_ForwardIterator x0) { *x0; } &&
  requires (_ForwardIterator x0) { ++x0; }
 )
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void
fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
{
    std::__fill(__first, __last, __value, typename iterator_traits<_ForwardIterator>::iterator_category());
}
}}

namespace std { inline namespace __1 {
template <class _InputIterator, class _Tp>
// added by concept-synth, original LN: 7787
requires
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _InputIterator
find(_InputIterator __first, _InputIterator __last, const _Tp& __value) {
  for (; __first != __last; ++__first)
    if (*__first == __value)
      break;
  return __first;
}
}}
namespace std { inline namespace __1 {
template <class _AlgPolicy,
          class _Iter1, class _Sent1,
          class _Iter2, class _Sent2,
          class _Pred,
          class _Proj1,
          class _Proj2>
// added by concept-synth, original LN: 7797
requires
(
 requires (_Iter1 x0) { ++x0; } &&
 requires (_Iter1 x0) { *x0; }
) &&
(
 requires (_Iter2 x0) { ++x0; } &&
 requires (_Iter2 x0) { *x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
pair<_Iter1, _Iter1> __search_forward_impl(_Iter1 __first1, _Sent1 __last1,
                                           _Iter2 __first2, _Sent2 __last2,
                                           _Pred& __pred,
                                           _Proj1& __proj1,
                                           _Proj2& __proj2) {
  if (__first2 == __last2)
    return std::make_pair(__first1, __first1);
  while (true) {
    while (true) {
      if (__first1 == __last1) {
        _IterOps<_AlgPolicy>::__advance_to(__first1, __last1);
        return std::make_pair(__first1, __first1);
      }
      if (std::__invoke(__pred, std::__invoke(__proj1, *__first1), std::__invoke(__proj2, *__first2)))
        break;
      ++__first1;
    }
    _Iter1 __m1 = __first1;
    _Iter2 __m2 = __first2;
    while (true) {
      if (++__m2 == __last2)
        return std::make_pair(__first1, ++__m1);
      if (++__m1 == __last1) {
        return std::make_pair(__m1, __m1);
      }
      if (!std::__invoke(__pred, std::__invoke(__proj1, *__m1), std::__invoke(__proj2, *__m2)))
      {
        ++__first1;
        break;
      }
    }
  }
}
template <class _AlgPolicy,
          class _Iter1, class _Sent1,
          class _Iter2, class _Sent2,
          class _Pred,
          class _Proj1,
          class _Proj2,
          class _DiffT1,
          class _DiffT2>
// added by concept-synth, original LN: 7837
requires
requires (_DiffT1 x0, _Iter1 x1) { x1 + x0; } &&
(
 requires (_Iter2 x0) { ++x0; } &&
 requires (_Iter2 x0) { *x0; }
) &&
(
 requires (_Iter1 x0) { ++x0; } &&
 requires (_Iter1 x0) { *x0; } &&
 requires (_Iter1 x0, _DiffT1 x1) { x0 + x1; }
) &&
requires (_DiffT2 x0, int x1) { x0 - x1; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
pair<_Iter1, _Iter1> __search_random_access_impl(_Iter1 __first1, _Sent1 __last1,
                                                 _Iter2 __first2, _Sent2 __last2,
                                                 _Pred& __pred,
                                                 _Proj1& __proj1,
                                                 _Proj2& __proj2,
                                                 _DiffT1 __size1,
                                                 _DiffT2 __size2) {
  const _Iter1 __s = __first1 + __size1 - _DiffT1(__size2 - 1);
  while (true) {
    while (true) {
      if (__first1 == __s) {
        _IterOps<_AlgPolicy>::__advance_to(__first1, __last1);
        return std::make_pair(__first1, __first1);
      }
      if (std::__invoke(__pred, std::__invoke(__proj1, *__first1), std::__invoke(__proj2, *__first2)))
        break;
      ++__first1;
    }
    _Iter1 __m1 = __first1;
    _Iter2 __m2 = __first2;
    while (true) {
      if (++__m2 == __last2)
        return std::make_pair(__first1, __first1 + _DiffT1(__size2));
      ++__m1;
      if (!std::__invoke(__pred, std::__invoke(__proj1, *__m1), std::__invoke(__proj2, *__m2))) {
        ++__first1;
        break;
      }
    }
  }
}
template <class _Iter1, class _Sent1,
          class _Iter2, class _Sent2,
          class _Pred,
          class _Proj1,
          class _Proj2>
// added by concept-synth, original LN: 7877
requires
(
 requires (_Iter2 x0) { ++x0; } &&
 requires (_Iter2 x0) { *x0; } &&
 requires (_Iter2 x0, _Sent2 x1) { x1 - x0; }
) &&
requires (_Sent2 x0, _Iter2 x1) { x0 - x1; } &&
requires (_Sent1 x0, _Iter1 x1) { x0 - x1; } &&
(
 requires (_Iter1 x0) { ++x0; } &&
 requires (_Iter1 x0) { *x0; } &&
 requires (_Iter1 x0, _Sent1 x1) { x1 - x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
pair<_Iter1, _Iter1> __search_impl(_Iter1 __first1, _Sent1 __last1,
                                   _Iter2 __first2, _Sent2 __last2,
                                   _Pred& __pred,
                                   _Proj1& __proj1,
                                   _Proj2& __proj2,
                                   __enable_if_t<__is_cpp17_random_access_iterator<_Iter1>::value
                                              && __is_cpp17_random_access_iterator<_Iter2>::value>* = nullptr) {
  auto __size2 = __last2 - __first2;
  if (__size2 == 0)
    return std::make_pair(__first1, __first1);
  auto __size1 = __last1 - __first1;
  if (__size1 < __size2) {
    return std::make_pair(__last1, __last1);
  }
  return std::__search_random_access_impl<_ClassicAlgPolicy>(__first1, __last1,
                                                             __first2, __last2,
                                                             __pred,
                                                             __proj1,
                                                             __proj2,
                                                             __size1,
                                                             __size2);
}
template <class _Iter1, class _Sent1,
          class _Iter2, class _Sent2,
          class _Pred,
          class _Proj1,
          class _Proj2>
// added by concept-synth, original LN: 7905
requires
(
 requires (_Iter1 x0) { ++x0; } &&
 requires (_Iter1 x0) { *x0; }
) &&
(
 requires (_Iter2 x0) { ++x0; } &&
 requires (_Iter2 x0) { *x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
pair<_Iter1, _Iter1> __search_impl(_Iter1 __first1, _Sent1 __last1,
                                   _Iter2 __first2, _Sent2 __last2,
                                   _Pred& __pred,
                                   _Proj1& __proj1,
                                   _Proj2& __proj2,
                                   __enable_if_t<__is_cpp17_forward_iterator<_Iter1>::value
                                              && __is_cpp17_forward_iterator<_Iter2>::value
                                              && !(__is_cpp17_random_access_iterator<_Iter1>::value
                                                && __is_cpp17_random_access_iterator<_Iter2>::value)>* = nullptr) {
  return std::__search_forward_impl<_ClassicAlgPolicy>(__first1, __last1,
                                                       __first2, __last2,
                                                       __pred,
                                                       __proj1,
                                                       __proj2);
}
template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
// added by concept-synth, original LN: 7926
requires
(
 (
  (
   requires (_ForwardIterator1 x0) { ++x0; } &&
   requires (_ForwardIterator1 x0) { *x0; } &&
   requires (_ForwardIterator1 x0, _ForwardIterator1 x1) { x1 - x0; }
  ) ||
  (
   requires (_ForwardIterator1 x0) { ++x0; } &&
   requires (_ForwardIterator1 x0) { *x0; }
  )
 ) &&
 requires (_ForwardIterator1 x0) { *x0; }
) &&
(
 (
  (
   requires (_ForwardIterator2 x0) { ++x0; } &&
   requires (_ForwardIterator2 x0) { *x0; } &&
   requires (_ForwardIterator2 x0, _ForwardIterator2 x1) { x1 - x0; }
  ) ||
  (
   requires (_ForwardIterator2 x0) { ++x0; } &&
   requires (_ForwardIterator2 x0) { *x0; }
  )
 ) &&
 requires (_ForwardIterator2 x0) { *x0; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_ForwardIterator1 search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                         _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                         _BinaryPredicate __pred) {
  static_assert(__is_callable<_BinaryPredicate, decltype(*__first1), decltype(*__first2)>::value,
                "BinaryPredicate has to be callable");
  auto __proj = __identity();
  return std::__search_impl(__first1, __last1, __first2, __last2, __pred, __proj, __proj).first;
}
template <class _ForwardIterator1, class _ForwardIterator2>
// added by concept-synth, original LN: 7936
requires
(
 (
  (
   requires (_ForwardIterator1 x0) { ++x0; } &&
   requires (_ForwardIterator1 x0) { *x0; } &&
   requires (_ForwardIterator1 x0, _ForwardIterator1 x1) { x1 - x0; }
  ) ||
  (
   requires (_ForwardIterator1 x0) { ++x0; } &&
   requires (_ForwardIterator1 x0) { *x0; }
  )
 ) &&
 requires (_ForwardIterator1 x0) { *x0; }
) &&
(
 (
  (
   requires (_ForwardIterator2 x0) { ++x0; } &&
   requires (_ForwardIterator2 x0) { *x0; } &&
   requires (_ForwardIterator2 x0, _ForwardIterator2 x1) { x1 - x0; }
  ) ||
  (
   requires (_ForwardIterator2 x0) { ++x0; } &&
   requires (_ForwardIterator2 x0) { *x0; }
  )
 ) &&
 requires (_ForwardIterator2 x0) { *x0; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_ForwardIterator1 search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                         _ForwardIterator2 __first2, _ForwardIterator2 __last2) {
  return std::search(__first1, __last1, __first2, __last2, __equal_to());
}
template <class _ForwardIterator, class _Searcher>
// added by concept-synth, original LN: 7942
requires
requires (_Searcher f, _ForwardIterator x0, _ForwardIterator x1) { f(x0, x1); }
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _ForwardIterator
search(_ForwardIterator __f, _ForwardIterator __l, const _Searcher& __s) {
  return __s(__f, __l).first;
}
}}
namespace std { inline namespace __1 {
template<class, class, class>
struct __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __compare_three_way_result { };
template<class _Tp, class _Up>
struct __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __compare_three_way_result<_Tp, _Up, decltype(
  std::declval<__make_const_lvalue_ref<_Tp>>() <=> std::declval<__make_const_lvalue_ref<_Up>>(), void()
)> {
    using type = decltype(std::declval<__make_const_lvalue_ref<_Tp>>() <=> std::declval<__make_const_lvalue_ref<_Up>>());
};
template<class _Tp, class _Up = _Tp>
struct __attribute__((__type_visibility__("default"))) compare_three_way_result : __compare_three_way_result<_Tp, _Up, void> { };
template<class _Tp, class _Up = _Tp>
using compare_three_way_result_t = typename compare_three_way_result<_Tp, _Up>::type;
}}
namespace std { inline namespace __1 {
template<class _Category, class _Tp, class _Distance = ptrdiff_t,
         class _Pointer = _Tp*, class _Reference = _Tp&>
struct __attribute__((__type_visibility__("default"))) __attribute__((deprecated)) iterator
{
    typedef _Tp value_type;
    typedef _Distance difference_type;
    typedef _Pointer pointer;
    typedef _Reference reference;
    typedef _Category iterator_category;
};
}}
namespace std { inline namespace __1 {
template<class _Tp, class _Up>
concept __different_from = !same_as<remove_cvref_t<_Tp>, remove_cvref_t<_Up>>;
}}
namespace std { inline namespace __1 {
namespace ranges {
struct dangling {
  dangling() = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr dangling(auto&&...) noexcept {}
};
template <range _Rp>
using borrowed_iterator_t = _If<borrowed_range<_Rp>, iterator_t<_Rp>, dangling>;
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __empty {
  template <class _Tp>
  concept __member_empty =
    __workaround_52970<_Tp> &&
    requires(_Tp&& __t) {
      bool(__t.empty());
    };
  template<class _Tp>
  concept __can_invoke_size =
    !__member_empty<_Tp> &&
    requires(_Tp&& __t) { ranges::size(__t); };
  template <class _Tp>
  concept __can_compare_begin_end =
    !__member_empty<_Tp> &&
    !__can_invoke_size<_Tp> &&
    requires(_Tp&& __t) {
      bool(ranges::begin(__t) == ranges::end(__t));
      { ranges::begin(__t) } -> forward_iterator;
    };
  struct __fn {
    template <__member_empty _Tp>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool operator()(_Tp&& __t) const
        noexcept(noexcept(bool(__t.empty()))) {
      return bool(__t.empty());
    }
    template <__can_invoke_size _Tp>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool operator()(_Tp&& __t) const
        noexcept(noexcept(ranges::size(__t))) {
      return ranges::size(__t) == 0;
    }
    template<__can_compare_begin_end _Tp>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool operator()(_Tp&& __t) const
        noexcept(noexcept(bool(ranges::begin(__t) == ranges::end(__t)))) {
      return ranges::begin(__t) == ranges::end(__t);
    }
  };
}
inline namespace __cpo {
  inline constexpr auto empty = __empty::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template<class _Derived>
  requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>
class view_interface {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr _Derived& __derived() noexcept {
    static_assert(sizeof(_Derived) && derived_from<_Derived, view_interface> && view<_Derived>);
    return static_cast<_Derived&>(*this);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr _Derived const& __derived() const noexcept {
    static_assert(sizeof(_Derived) && derived_from<_Derived, view_interface> && view<_Derived>);
    return static_cast<_Derived const&>(*this);
  }
public:
  template<class _D2 = _Derived>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool empty()
    requires forward_range<_D2>
  {
    return ranges::begin(__derived()) == ranges::end(__derived());
  }
  template<class _D2 = _Derived>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool empty() const
    requires forward_range<const _D2>
  {
    return ranges::begin(__derived()) == ranges::end(__derived());
  }
  template<class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr explicit operator bool()
    requires requires (_D2& __t) { ranges::empty(__t); }
  {
    return !ranges::empty(__derived());
  }
  template<class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr explicit operator bool() const
    requires requires (const _D2& __t) { ranges::empty(__t); }
  {
    return !ranges::empty(__derived());
  }
  template<class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr auto data()
    requires contiguous_iterator<iterator_t<_D2>>
  {
    return std::to_address(ranges::begin(__derived()));
  }
  template<class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr auto data() const
    requires range<const _D2> && contiguous_iterator<iterator_t<const _D2>>
  {
    return std::to_address(ranges::begin(__derived()));
  }
  template<class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr auto size()
    requires forward_range<_D2> && sized_sentinel_for<sentinel_t<_D2>, iterator_t<_D2>>
  {
    return std::__to_unsigned_like(ranges::end(__derived()) - ranges::begin(__derived()));
  }
  template<class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr auto size() const
    requires forward_range<const _D2> && sized_sentinel_for<sentinel_t<const _D2>, iterator_t<const _D2>>
  {
    return std::__to_unsigned_like(ranges::end(__derived()) - ranges::begin(__derived()));
  }
  template<class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr decltype(auto) front()
    requires forward_range<_D2>
  {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(!empty()))
#pragma clang diagnostic pop
    );
    return *ranges::begin(__derived());
  }
  template<class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr decltype(auto) front() const
    requires forward_range<const _D2>
  {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(!empty()))
#pragma clang diagnostic pop
    );
    return *ranges::begin(__derived());
  }
  template<class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr decltype(auto) back()
    requires bidirectional_range<_D2> && common_range<_D2>
  {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(!empty()))
#pragma clang diagnostic pop
    );
    return *ranges::prev(ranges::end(__derived()));
  }
  template<class _D2 = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr decltype(auto) back() const
    requires bidirectional_range<const _D2> && common_range<const _D2>
  {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(!empty()))
#pragma clang diagnostic pop
    );
    return *ranges::prev(ranges::end(__derived()));
  }
  template<random_access_range _RARange = _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr decltype(auto) operator[](range_difference_t<_RARange> __index)
  {
    return ranges::begin(__derived())[__index];
  }
  template<random_access_range _RARange = const _Derived>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr decltype(auto) operator[](range_difference_t<_RARange> __index) const
  {
    return ranges::begin(__derived())[__index];
  }
};
}
}}
namespace std { inline namespace __1 {
template <class _Tp>
struct __tuple_like_impl : false_type {};
template <class... _Tp>
struct __tuple_like_impl<tuple<_Tp...> > : true_type {};
template <class _T1, class _T2>
struct __tuple_like_impl<pair<_T1, _T2> > : true_type {};
template <class _Tp, size_t _Size>
struct __tuple_like_impl<array<_Tp, _Size> > : true_type {};
template <class _Ip, class _Sp, ranges::subrange_kind _Kp>
struct __tuple_like_impl<ranges::subrange<_Ip, _Sp, _Kp> > : true_type {};
template <class _Tp>
concept __tuple_like = __tuple_like_impl<remove_cvref_t<_Tp>>::value;
}}
namespace std { inline namespace __1 {
template <class _Tp>
concept __pair_like = __tuple_like<_Tp> && tuple_size<remove_cvref_t<_Tp>>::value == 2;
}}
namespace std { inline namespace __1 {
namespace ranges {
  template<class _From, class _To>
  concept __uses_nonqualification_pointer_conversion =
    is_pointer_v<_From> && is_pointer_v<_To> &&
    !convertible_to<remove_pointer_t<_From>(*)[], remove_pointer_t<_To>(*)[]>;
  template<class _From, class _To>
  concept __convertible_to_non_slicing =
    convertible_to<_From, _To> &&
    !__uses_nonqualification_pointer_conversion<decay_t<_From>, decay_t<_To>>;
  template<class _Pair, class _Iter, class _Sent>
  concept __pair_like_convertible_from =
    !range<_Pair> && __pair_like<_Pair> &&
    constructible_from<_Pair, _Iter, _Sent> &&
    __convertible_to_non_slicing<_Iter, tuple_element_t<0, _Pair>> &&
    convertible_to<_Sent, tuple_element_t<1, _Pair>>;
  template<input_or_output_iterator _Iter, sentinel_for<_Iter> _Sent = _Iter,
           subrange_kind _Kind = sized_sentinel_for<_Sent, _Iter>
             ? subrange_kind::sized
             : subrange_kind::unsized>
    requires (_Kind == subrange_kind::sized || !sized_sentinel_for<_Sent, _Iter>)
  class __attribute__((__type_visibility__("default"))) subrange
    : public view_interface<subrange<_Iter, _Sent, _Kind>>
  {
  public:
    static constexpr bool _StoreSize = (_Kind == subrange_kind::sized && !sized_sentinel_for<_Sent, _Iter>);
  private:
    static constexpr bool _MustProvideSizeAtConstruction = !_StoreSize;
    struct _Empty { constexpr _Empty(auto) noexcept { } };
    using _Size = conditional_t<_StoreSize, make_unsigned_t<iter_difference_t<_Iter>>, _Empty>;
    [[no_unique_address]] _Iter __begin_ = _Iter();
    [[no_unique_address]] _Sent __end_ = _Sent();
    [[no_unique_address]] _Size __size_ = 0;
  public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    subrange() requires default_initializable<_Iter> = default;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr subrange(__convertible_to_non_slicing<_Iter> auto __iter, _Sent __sent)
      requires _MustProvideSizeAtConstruction
      : __begin_(std::move(__iter)), __end_(std::move(__sent))
    { }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr subrange(__convertible_to_non_slicing<_Iter> auto __iter, _Sent __sent,
                       make_unsigned_t<iter_difference_t<_Iter>> __n)
      requires (_Kind == subrange_kind::sized)
      : __begin_(std::move(__iter)), __end_(std::move(__sent)), __size_(__n)
    {
      if constexpr (sized_sentinel_for<_Sent, _Iter>)
        (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
        __builtin_assume(static_cast<bool>((__end_ - __begin_) == static_cast<iter_difference_t<_Iter>>(__n)))
#pragma clang diagnostic pop
        );
    }
    template<__different_from<subrange> _Range>
      requires borrowed_range<_Range> &&
               __convertible_to_non_slicing<iterator_t<_Range>, _Iter> &&
               convertible_to<sentinel_t<_Range>, _Sent>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr subrange(_Range&& __range)
      requires (!_StoreSize)
      : subrange(ranges::begin(__range), ranges::end(__range))
    { }
    template<__different_from<subrange> _Range>
      requires borrowed_range<_Range> &&
               __convertible_to_non_slicing<iterator_t<_Range>, _Iter> &&
               convertible_to<sentinel_t<_Range>, _Sent>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr subrange(_Range&& __range)
      requires _StoreSize && sized_range<_Range>
      : subrange(__range, ranges::size(__range))
    { }
    template<borrowed_range _Range>
      requires __convertible_to_non_slicing<iterator_t<_Range>, _Iter> &&
               convertible_to<sentinel_t<_Range>, _Sent>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr subrange(_Range&& __range, make_unsigned_t<iter_difference_t<_Iter>> __n)
      requires (_Kind == subrange_kind::sized)
      : subrange(ranges::begin(__range), ranges::end(__range), __n)
    { }
    template<__different_from<subrange> _Pair>
      requires __pair_like_convertible_from<_Pair, const _Iter&, const _Sent&>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr operator _Pair() const {
      return _Pair(__begin_, __end_);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr _Iter begin() const requires copyable<_Iter> {
      return __begin_;
    }
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Iter begin() requires (!copyable<_Iter>) {
      return std::move(__begin_);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr _Sent end() const {
      return __end_;
    }
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool empty() const {
      return __begin_ == __end_;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr make_unsigned_t<iter_difference_t<_Iter>> size() const
      requires (_Kind == subrange_kind::sized)
    {
      if constexpr (_StoreSize)
        return __size_;
      else
        return std::__to_unsigned_like(__end_ - __begin_);
    }
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr subrange next(iter_difference_t<_Iter> __n = 1) const&
      requires forward_iterator<_Iter>
    {
      auto __tmp = *this;
      __tmp.advance(__n);
      return __tmp;
    }
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr subrange next(iter_difference_t<_Iter> __n = 1) && {
      advance(__n);
      return std::move(*this);
    }
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr subrange prev(iter_difference_t<_Iter> __n = 1) const
      requires bidirectional_iterator<_Iter>
    {
      auto __tmp = *this;
      __tmp.advance(-__n);
      return __tmp;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr subrange& advance(iter_difference_t<_Iter> __n) {
      if constexpr (bidirectional_iterator<_Iter>) {
        if (__n < 0) {
          ranges::advance(__begin_, __n);
          if constexpr (_StoreSize)
            __size_ += std::__to_unsigned_like(-__n);
          return *this;
        }
      }
      auto __d = __n - ranges::advance(__begin_, __n, __end_);
      if constexpr (_StoreSize)
        __size_ -= std::__to_unsigned_like(__d);
      return *this;
    }
  };
  template<input_or_output_iterator _Iter, sentinel_for<_Iter> _Sent>
  subrange(_Iter, _Sent) -> subrange<_Iter, _Sent>;
  template<input_or_output_iterator _Iter, sentinel_for<_Iter> _Sent>
  subrange(_Iter, _Sent, make_unsigned_t<iter_difference_t<_Iter>>)
    -> subrange<_Iter, _Sent, subrange_kind::sized>;
  template<borrowed_range _Range>
  subrange(_Range&&) -> subrange<iterator_t<_Range>, sentinel_t<_Range>,
                                 (sized_range<_Range> || sized_sentinel_for<sentinel_t<_Range>, iterator_t<_Range>>)
                                   ? subrange_kind::sized : subrange_kind::unsized>;
  template<borrowed_range _Range>
  subrange(_Range&&, make_unsigned_t<range_difference_t<_Range>>)
    -> subrange<iterator_t<_Range>, sentinel_t<_Range>, subrange_kind::sized>;
  template<size_t _Index, class _Iter, class _Sent, subrange_kind _Kind>
    requires ((_Index == 0 && copyable<_Iter>) || _Index == 1)
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr auto get(const subrange<_Iter, _Sent, _Kind>& __subrange) {
    if constexpr (_Index == 0)
      return __subrange.begin();
    else
      return __subrange.end();
  }
  template<size_t _Index, class _Iter, class _Sent, subrange_kind _Kind>
    requires (_Index < 2)
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr auto get(subrange<_Iter, _Sent, _Kind>&& __subrange) {
    if constexpr (_Index == 0)
      return __subrange.begin();
    else
      return __subrange.end();
  }
  template<class _Ip, class _Sp, subrange_kind _Kp>
  inline constexpr bool enable_borrowed_range<subrange<_Ip, _Sp, _Kp>> = true;
  template<range _Rp>
  using borrowed_subrange_t = _If<borrowed_range<_Rp>, subrange<iterator_t<_Rp>>, dangling>;
}
using ranges::get;
template<class _Ip, class _Sp, ranges::subrange_kind _Kp>
struct tuple_size<ranges::subrange<_Ip, _Sp, _Kp>> : integral_constant<size_t, 2> {};
template<class _Ip, class _Sp, ranges::subrange_kind _Kp>
struct tuple_element<0, ranges::subrange<_Ip, _Sp, _Kp>> {
  using type = _Ip;
};
template<class _Ip, class _Sp, ranges::subrange_kind _Kp>
struct tuple_element<1, ranges::subrange<_Ip, _Sp, _Kp>> {
  using type = _Sp;
};
template<class _Ip, class _Sp, ranges::subrange_kind _Kp>
struct tuple_element<0, const ranges::subrange<_Ip, _Sp, _Kp>> {
  using type = _Ip;
};
template<class _Ip, class _Sp, ranges::subrange_kind _Kp>
struct tuple_element<1, const ranges::subrange<_Ip, _Sp, _Kp>> {
  using type = _Sp;
};
}}
namespace std { inline namespace __1 {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Iter>
class __attribute__((__type_visibility__("default"))) reverse_iterator
    : public iterator<typename iterator_traits<_Iter>::iterator_category,
                      typename iterator_traits<_Iter>::value_type,
                      typename iterator_traits<_Iter>::difference_type,
                      typename iterator_traits<_Iter>::pointer,
                      typename iterator_traits<_Iter>::reference>
{
#pragma GCC diagnostic pop
private:
    _Iter __t_;
    static_assert(__is_cpp17_bidirectional_iterator<_Iter>::value || bidirectional_iterator<_Iter>,
        "reverse_iterator<It> requires It to be a bidirectional iterator.");
protected:
    _Iter current;
public:
    using iterator_type = _Iter;
    using iterator_category = _If<__is_cpp17_random_access_iterator<_Iter>::value,
                                  random_access_iterator_tag,
                                  typename iterator_traits<_Iter>::iterator_category>;
    using pointer = typename iterator_traits<_Iter>::pointer;
    using iterator_concept = _If<random_access_iterator<_Iter>, random_access_iterator_tag, bidirectional_iterator_tag>;
    using value_type = iter_value_t<_Iter>;
    using difference_type = iter_difference_t<_Iter>;
    using reference = iter_reference_t<_Iter>;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    reverse_iterator() : __t_(), current() {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    explicit reverse_iterator(_Iter __x) : __t_(__x), current(__x) {}
    template <class _Up, class = __enable_if_t<
        !is_same<_Up, _Iter>::value && is_convertible<_Up const&, _Iter>::value
    > >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    reverse_iterator(const reverse_iterator<_Up>& __u)
        : __t_(__u.base()), current(__u.base())
    { }
    template <class _Up, class = __enable_if_t<
        !is_same<_Up, _Iter>::value &&
        is_convertible<_Up const&, _Iter>::value &&
        is_assignable<_Iter&, _Up const&>::value
    > >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    reverse_iterator& operator=(const reverse_iterator<_Up>& __u) {
        __t_ = current = __u.base();
        return *this;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    _Iter base() const {return current;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    reference operator*() const {_Iter __tmp = current; return *--__tmp;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr pointer operator->() const
      requires is_pointer_v<_Iter> || requires(const _Iter __i) { __i.operator->(); }
    {
      if constexpr (is_pointer_v<_Iter>) {
        return std::prev(current);
      } else {
        return std::prev(current).operator->();
      }
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    reverse_iterator& operator++() {--current; return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    reverse_iterator operator++(int) {reverse_iterator __tmp(*this); --current; return __tmp;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    reverse_iterator& operator--() {++current; return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    reverse_iterator operator--(int) {reverse_iterator __tmp(*this); ++current; return __tmp;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    reverse_iterator operator+(difference_type __n) const {return reverse_iterator(current - __n);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    reverse_iterator& operator+=(difference_type __n) {current -= __n; return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    reverse_iterator operator-(difference_type __n) const {return reverse_iterator(current + __n);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    reverse_iterator& operator-=(difference_type __n) {current += __n; return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    reference operator[](difference_type __n) const {return *(*this + __n);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) friend constexpr
    iter_rvalue_reference_t<_Iter> iter_move(const reverse_iterator& __i)
      noexcept(is_nothrow_copy_constructible_v<_Iter> &&
          noexcept(ranges::iter_move(--std::declval<_Iter&>()))) {
      auto __tmp = __i.base();
      return ranges::iter_move(--__tmp);
    }
    template <indirectly_swappable<_Iter> _Iter2>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) friend constexpr
    void iter_swap(const reverse_iterator& __x, const reverse_iterator<_Iter2>& __y)
      noexcept(is_nothrow_copy_constructible_v<_Iter> &&
          is_nothrow_copy_constructible_v<_Iter2> &&
          noexcept(ranges::iter_swap(--std::declval<_Iter&>(), --std::declval<_Iter2&>()))) {
      auto __xtmp = __x.base();
      auto __ytmp = __y.base();
      ranges::iter_swap(--__xtmp, --__ytmp);
    }
};
template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool
operator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
    requires requires {
      { __x.base() == __y.base() } -> convertible_to<bool>;
    }
{
    return __x.base() == __y.base();
}
template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool
operator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
    requires requires {
        { __x.base() > __y.base() } -> convertible_to<bool>;
      }
{
    return __x.base() > __y.base();
}
template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool
operator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
    requires requires {
      { __x.base() != __y.base() } -> convertible_to<bool>;
    }
{
    return __x.base() != __y.base();
}
template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool
operator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
    requires requires {
        { __x.base() < __y.base() } -> convertible_to<bool>;
      }
{
    return __x.base() < __y.base();
}
template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool
operator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
    requires requires {
        { __x.base() <= __y.base() } -> convertible_to<bool>;
      }
{
    return __x.base() <= __y.base();
}
template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool
operator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
    requires requires {
        { __x.base() >= __y.base() } -> convertible_to<bool>;
      }
{
    return __x.base() >= __y.base();
}
template <class _Iter1, three_way_comparable_with<_Iter1> _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
compare_three_way_result_t<_Iter1, _Iter2>
operator<=>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
{
    return __y.base() <=> __x.base();
}
template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
auto
operator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
-> decltype(__y.base() - __x.base())
{
    return __y.base() - __x.base();
}
template <class _Iter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
reverse_iterator<_Iter>
operator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)
{
    return reverse_iterator<_Iter>(__x.base() - __n);
}
template <class _Iter1, class _Iter2>
  requires (!sized_sentinel_for<_Iter1, _Iter2>)
inline constexpr bool disable_sized_sentinel_for<reverse_iterator<_Iter1>, reverse_iterator<_Iter2>> = true;
template <class _Iter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
reverse_iterator<_Iter> make_reverse_iterator(_Iter __i)
{
    return reverse_iterator<_Iter>(__i);
}
template <class _Iter>
class __unconstrained_reverse_iterator {
  _Iter __iter_;
public:
  static_assert(__is_cpp17_bidirectional_iterator<_Iter>::value || bidirectional_iterator<_Iter>);
  using iterator_type = _Iter;
  using iterator_category =
      _If<__is_cpp17_random_access_iterator<_Iter>::value, random_access_iterator_tag, __iterator_category_type<_Iter>>;
  using pointer = __iterator_pointer_type<_Iter>;
  using value_type = iter_value_t<_Iter>;
  using difference_type = iter_difference_t<_Iter>;
  using reference = iter_reference_t<_Iter>;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __unconstrained_reverse_iterator() = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __unconstrained_reverse_iterator(const __unconstrained_reverse_iterator&) = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr explicit __unconstrained_reverse_iterator(_Iter __iter) : __iter_(__iter) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Iter base() const { return __iter_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr reference operator*() const {
    auto __tmp = __iter_;
    return *--__tmp;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pointer operator->() const {
    if constexpr (is_pointer_v<_Iter>) {
      return std::prev(__iter_);
    } else {
      return std::prev(__iter_).operator->();
    }
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) friend constexpr
  iter_rvalue_reference_t<_Iter> iter_move(const __unconstrained_reverse_iterator& __i)
    noexcept(is_nothrow_copy_constructible_v<_Iter> &&
        noexcept(ranges::iter_move(--std::declval<_Iter&>()))) {
    auto __tmp = __i.base();
    return ranges::iter_move(--__tmp);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __unconstrained_reverse_iterator& operator++() {
    --__iter_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __unconstrained_reverse_iterator operator++(int) {
    auto __tmp = *this;
    --__iter_;
    return __tmp;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __unconstrained_reverse_iterator& operator--() {
    ++__iter_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __unconstrained_reverse_iterator operator--(int) {
    auto __tmp = *this;
    ++__iter_;
    return __tmp;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __unconstrained_reverse_iterator& operator+=(difference_type __n) {
    __iter_ -= __n;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __unconstrained_reverse_iterator& operator-=(difference_type __n) {
    __iter_ += __n;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __unconstrained_reverse_iterator operator+(difference_type __n) const {
    return __unconstrained_reverse_iterator(__iter_ - __n);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __unconstrained_reverse_iterator operator-(difference_type __n) const {
    return __unconstrained_reverse_iterator(__iter_ + __n);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr difference_type operator-(const __unconstrained_reverse_iterator& __other) const {
    return __other.__iter_ - __iter_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr auto operator[](difference_type __n) const { return *(*this + __n); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) friend constexpr bool
  operator==(const __unconstrained_reverse_iterator& __lhs, const __unconstrained_reverse_iterator& __rhs) {
    return __lhs.base() == __rhs.base();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) friend constexpr bool
  operator!=(const __unconstrained_reverse_iterator& __lhs, const __unconstrained_reverse_iterator& __rhs) {
    return __lhs.base() != __rhs.base();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) friend constexpr bool
  operator<(const __unconstrained_reverse_iterator& __lhs, const __unconstrained_reverse_iterator& __rhs) {
    return __lhs.base() > __rhs.base();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) friend constexpr bool
  operator>(const __unconstrained_reverse_iterator& __lhs, const __unconstrained_reverse_iterator& __rhs) {
    return __lhs.base() < __rhs.base();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) friend constexpr bool
  operator<=(const __unconstrained_reverse_iterator& __lhs, const __unconstrained_reverse_iterator& __rhs) {
    return __lhs.base() >= __rhs.base();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) friend constexpr bool
  operator>=(const __unconstrained_reverse_iterator& __lhs, const __unconstrained_reverse_iterator& __rhs) {
    return __lhs.base() <= __rhs.base();
  }
};
template <template <class> class _RevIter1, template <class> class _RevIter2, class _Iter>
struct __unwrap_reverse_iter_impl {
  using _UnwrappedIter = decltype(__unwrap_iter_impl<_Iter>::__unwrap(std::declval<_Iter>()));
  using _ReverseWrapper = _RevIter1<_RevIter2<_Iter> >;
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _ReverseWrapper
  __rewrap(_ReverseWrapper __orig_iter, _UnwrappedIter __unwrapped_iter) {
    return _ReverseWrapper(
        _RevIter2<_Iter>(__unwrap_iter_impl<_Iter>::__rewrap(__orig_iter.base().base(), __unwrapped_iter)));
  }
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _UnwrappedIter __unwrap(_ReverseWrapper __i) noexcept {
    return __unwrap_iter_impl<_Iter>::__unwrap(__i.base().base());
  }
};
template <ranges::bidirectional_range _Range>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr ranges::
    subrange<reverse_iterator<ranges::iterator_t<_Range>>, reverse_iterator<ranges::iterator_t<_Range>>>
    __reverse_range(_Range&& __range) {
  auto __first = ranges::begin(__range);
  return {std::make_reverse_iterator(ranges::next(__first, ranges::end(__range))), std::make_reverse_iterator(__first)};
}
template <class _Iter, bool __b>
struct __unwrap_iter_impl<reverse_iterator<reverse_iterator<_Iter> >, __b>
    : __unwrap_reverse_iter_impl<reverse_iterator, reverse_iterator, _Iter> {};
template <class _Iter, bool __b>
struct __unwrap_iter_impl<reverse_iterator<__unconstrained_reverse_iterator<_Iter>>, __b>
    : __unwrap_reverse_iter_impl<reverse_iterator, __unconstrained_reverse_iterator, _Iter> {};
template <class _Iter, bool __b>
struct __unwrap_iter_impl<__unconstrained_reverse_iterator<reverse_iterator<_Iter>>, __b>
    : __unwrap_reverse_iter_impl<__unconstrained_reverse_iterator, reverse_iterator, _Iter> {};
template <class _Iter, bool __b>
struct __unwrap_iter_impl<__unconstrained_reverse_iterator<__unconstrained_reverse_iterator<_Iter>>, __b>
    : __unwrap_reverse_iter_impl<__unconstrained_reverse_iterator, __unconstrained_reverse_iterator, _Iter> {};
}}
namespace std { inline namespace __1 {
template <
    class _AlgPolicy,
    class _Iter1,
    class _Sent1,
    class _Iter2,
    class _Sent2,
    class _Pred,
    class _Proj1,
    class _Proj2>
// added by concept-synth, original LN: 8706
requires
(
 requires (_Iter1 x0) { ++x0; } &&
 requires (_Iter1 x0) { *x0; }
) &&
(
 requires (_Iter2 x0) { ++x0; } &&
 requires (_Iter2 x0) { *x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) inline constexpr pair<_Iter1, _Iter1> __find_end_impl(
    _Iter1 __first1,
    _Sent1 __last1,
    _Iter2 __first2,
    _Sent2 __last2,
    _Pred& __pred,
    _Proj1& __proj1,
    _Proj2& __proj2,
    forward_iterator_tag,
    forward_iterator_tag) {
  _Iter1 __match_first = _IterOps<_AlgPolicy>::next(__first1, __last1);
  _Iter1 __match_last = __match_first;
  if (__first2 == __last2)
    return pair<_Iter1, _Iter1>(__match_last, __match_last);
  while (true) {
    while (true) {
      if (__first1 == __last1)
        return pair<_Iter1, _Iter1>(__match_first, __match_last);
      if (std::__invoke(__pred, std::__invoke(__proj1, *__first1), std::__invoke(__proj2, *__first2)))
        break;
      ++__first1;
    }
    _Iter1 __m1 = __first1;
    _Iter2 __m2 = __first2;
    while (true) {
      if (++__m2 == __last2) {
        __match_first = __first1;
        __match_last = ++__m1;
        ++__first1;
        break;
      }
      if (++__m1 == __last1)
        return pair<_Iter1, _Iter1>(__match_first, __match_last);
      if (!std::__invoke(__pred, std::__invoke(__proj1, *__m1), std::__invoke(__proj2, *__m2)))
      {
        ++__first1;
        break;
      }
    }
  }
}
template <
    class _IterOps,
    class _Pred,
    class _Iter1,
    class _Sent1,
    class _Iter2,
    class _Sent2,
    class _Proj1,
    class _Proj2>
// added by concept-synth, original LN: 8756
requires
requires (_Iter1 x0) { --x0; } &&
(
 requires (_Iter2 x0) { *x0; } &&
 requires (_Iter2 x0) { --x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Iter1 __find_end(
    _Iter1 __first1,
    _Sent1 __sent1,
    _Iter2 __first2,
    _Sent2 __sent2,
    _Pred& __pred,
    _Proj1& __proj1,
    _Proj2& __proj2,
    bidirectional_iterator_tag,
    bidirectional_iterator_tag) {
  auto __last1 = _IterOps::next(__first1, __sent1);
  auto __last2 = _IterOps::next(__first2, __sent2);
  if (__first2 == __last2)
    return __last1;
  _Iter1 __l1 = __last1;
  _Iter2 __l2 = __last2;
  --__l2;
  while (true) {
    while (true) {
      if (__first1 == __l1)
        return __last1;
      if (std::__invoke(__pred, std::__invoke(__proj1, *--__l1), std::__invoke(__proj2, *__l2)))
        break;
    }
    _Iter1 __m1 = __l1;
    _Iter2 __m2 = __l2;
    while (true) {
      if (__m2 == __first2)
        return __m1;
      if (__m1 == __first1)
        return __last1;
      if (!std::__invoke(__pred, std::__invoke(__proj1, *--__m1), std::__invoke(__proj2, *--__m2)))
      {
        break;
      }
    }
  }
}
template <
    class _AlgPolicy,
    class _Pred,
    class _Iter1,
    class _Sent1,
    class _Iter2,
    class _Sent2,
    class _Proj1,
    class _Proj2>
// added by concept-synth, original LN: 8803
requires
requires (_Iter1 x0) { --x0; } &&
(
 requires (_Iter2 x0) { *x0; } &&
 requires (_Iter2 x0) { --x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Iter1 __find_end(
    _Iter1 __first1,
    _Sent1 __sent1,
    _Iter2 __first2,
    _Sent2 __sent2,
    _Pred& __pred,
    _Proj1& __proj1,
    _Proj2& __proj2,
    random_access_iterator_tag,
    random_access_iterator_tag) {
  typedef typename iterator_traits<_Iter1>::difference_type _D1;
  auto __last1 = _IterOps<_AlgPolicy>::next(__first1, __sent1);
  auto __last2 = _IterOps<_AlgPolicy>::next(__first2, __sent2);
  auto __len2 = __last2 - __first2;
  if (__len2 == 0)
    return __last1;
  auto __len1 = __last1 - __first1;
  if (__len1 < __len2)
    return __last1;
  const _Iter1 __s = __first1 + _D1(__len2 - 1);
  _Iter1 __l1 = __last1;
  _Iter2 __l2 = __last2;
  --__l2;
  while (true) {
    while (true) {
      if (__s == __l1)
        return __last1;
      if (std::__invoke(__pred, std::__invoke(__proj1, *--__l1), std::__invoke(__proj2, *__l2)))
        break;
    }
    _Iter1 __m1 = __l1;
    _Iter2 __m2 = __l2;
    while (true) {
      if (__m2 == __first2)
        return __m1;
      if (!std::__invoke(__pred, std::__invoke(__proj1, *--__m1), std::__invoke(*--__m2))) {
        break;
      }
    }
  }
}
template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
// added by concept-synth, original LN: 8853
requires
(
 requires (_ForwardIterator2 x0) { ++x0; } &&
 requires (_ForwardIterator2 x0) { *x0; }
) &&
(
 requires (_ForwardIterator1 x0) { ++x0; } &&
 requires (_ForwardIterator1 x0) { *x0; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_ForwardIterator1 __find_end_classic(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                                     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                                     _BinaryPredicate& __pred) {
  auto __proj = __identity();
  return std::__find_end_impl<_ClassicAlgPolicy>(
             __first1,
             __last1,
             __first2,
             __last2,
             __pred,
             __proj,
             __proj,
             typename iterator_traits<_ForwardIterator1>::iterator_category(),
             typename iterator_traits<_ForwardIterator2>::iterator_category())
      .first;
}
template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
// added by concept-synth, original LN: 8871
requires
(
 requires (_ForwardIterator2 x0) { ++x0; } &&
 requires (_ForwardIterator2 x0) { *x0; }
) &&
(
 requires (_ForwardIterator1 x0) { ++x0; } &&
 requires (_ForwardIterator1 x0) { *x0; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_ForwardIterator1 find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                           _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                           _BinaryPredicate __pred) {
  return std::__find_end_classic(__first1, __last1, __first2, __last2, __pred);
}
template <class _ForwardIterator1, class _ForwardIterator2>
// added by concept-synth, original LN: 8878
requires
(
 requires (_ForwardIterator2 x0) { ++x0; } &&
 requires (_ForwardIterator2 x0) { *x0; }
) &&
(
 requires (_ForwardIterator1 x0) { ++x0; } &&
 requires (_ForwardIterator1 x0) { *x0; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_ForwardIterator1 find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                           _ForwardIterator2 __first2, _ForwardIterator2 __last2) {
  return std::find_end(__first1, __last1, __first2, __last2, __equal_to());
}
}}
namespace std { inline namespace __1 {
template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
// added by concept-synth, original LN: 8886
requires
requires (_BinaryPredicate f, _ForwardIterator1 x0, _ForwardIterator2 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
(
 requires (_ForwardIterator1 x0) { *x0; } &&
 requires (_ForwardIterator1 x0) { ++x0; }
) &&
(
 requires (_ForwardIterator2 x0) { *x0; } &&
 requires (_ForwardIterator2 x0) { ++x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr _ForwardIterator1 __find_first_of_ce(_ForwardIterator1 __first1,
                                                                   _ForwardIterator1 __last1,
                                                                   _ForwardIterator2 __first2,
                                                                   _ForwardIterator2 __last2,
                                                                   _BinaryPredicate&& __pred) {
  for (; __first1 != __last1; ++__first1)
    for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
      if (__pred(*__first1, *__j))
        return __first1;
  return __last1;
}
template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
// added by concept-synth, original LN: 8899
requires
requires (_BinaryPredicate f, _ForwardIterator1 x0, _ForwardIterator2 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
(
 requires (_ForwardIterator2 x0) { *x0; } &&
 requires (_ForwardIterator2 x0) { ++x0; }
) &&
(
 requires (_ForwardIterator1 x0) { *x0; } &&
 requires (_ForwardIterator1 x0) { ++x0; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _ForwardIterator1
find_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
              _ForwardIterator2 __last2, _BinaryPredicate __pred) {
  return std::__find_first_of_ce(__first1, __last1, __first2, __last2, __pred);
}
template <class _ForwardIterator1, class _ForwardIterator2>
// added by concept-synth, original LN: 8905
requires
(
 requires (_ForwardIterator1 x0) { *x0; } &&
 requires (_ForwardIterator1 x0) { ++x0; }
) &&
(
 requires (_ForwardIterator2 x0) { *x0; } &&
 requires (_ForwardIterator2 x0) { ++x0; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _ForwardIterator1 find_first_of(
    _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2) {
  return std::__find_first_of_ce(__first1, __last1, __first2, __last2, __equal_to());
}
}}
namespace std { inline namespace __1 {
template <class _InputIterator, class _Predicate>
// added by concept-synth, original LN: 8912
requires
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
) &&
requires (_Predicate f, _InputIterator x0) { {f(*x0)} -> std::convertible_to<bool>; }
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _InputIterator
find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (__pred(*__first))
      break;
  return __first;
}
}}
namespace std { inline namespace __1 {
template <class _InputIterator, class _Predicate>
// added by concept-synth, original LN: 8922
requires
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
) &&
requires (_Predicate f, _InputIterator x0) { f(*x0); }
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _InputIterator
find_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (!__pred(*__first))
      break;
  return __first;
}
}}
namespace std { inline namespace __1 {
template <class _InputIterator, class _Function>
// added by concept-synth, original LN: 8932
requires
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
) &&
requires (_Function f, _InputIterator x0) { f(*x0); }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Function for_each(_InputIterator __first,
                                                                                  _InputIterator __last,
                                                                                  _Function __f) {
  for (; __first != __last; ++__first)
    __f(*__first);
  return __f;
}
}}
namespace std { inline namespace __1 {
template <class _InputIterator, class _Size, class _Function>
// added by concept-synth, original LN: 8942
requires
requires (_Function f, _InputIterator x0) { f(*x0); } &&
(
 requires (_InputIterator x0) { ++x0; } &&
 requires (_InputIterator x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _InputIterator for_each_n(_InputIterator __first,
                                                                                         _Size __orig_n,
                                                                                         _Function __f) {
  typedef decltype(std::__convert_to_integral(__orig_n)) _IntegralSize;
  _IntegralSize __n = __orig_n;
  while (__n > 0) {
    __f(*__first);
    ++__first;
    --__n;
  }
  return __first;
}
}}
namespace std { inline namespace __1 {
template <class _ForwardIterator, class _Generator>
// added by concept-synth, original LN: 8957
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
) &&
requires (_Generator f) { f(); }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void
generate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)
{
    for (; __first != __last; ++__first)
        *__first = __gen();
}
}}
namespace std { inline namespace __1 {
template <class _OutputIterator, class _Size, class _Generator>
// added by concept-synth, original LN: 8967
requires
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
) &&
requires (_Generator f) { f(); }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_OutputIterator
generate_n(_OutputIterator __first, _Size __orig_n, _Generator __gen)
{
    typedef decltype(std::__convert_to_integral(__orig_n)) _IntegralSize;
    _IntegralSize __n = __orig_n;
    for (; __n > 0; ++__first, (void) --__n)
        *__first = __gen();
    return __first;
}
}}

namespace std { inline namespace __1 {
namespace ranges {
template <class _InIter1>
struct in_found_result {
  [[no_unique_address]] _InIter1 in;
  bool found;
  template <class _InIter2>
    requires convertible_to<const _InIter1&, _InIter2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr operator in_found_result<_InIter2>() const & {
    return {in, found};
  }
  template <class _InIter2>
    requires convertible_to<_InIter1, _InIter2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr operator in_found_result<_InIter2>() && {
    return {std::move(in), found};
  }
};
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _InIter1, class _Func1>
struct in_fun_result {
  [[no_unique_address]] _InIter1 in;
  [[no_unique_address]] _Func1 fun;
  template <class _InIter2, class _Func2>
    requires convertible_to<const _InIter1&, _InIter2> && convertible_to<const _Func1&, _Func2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr operator in_fun_result<_InIter2, _Func2>() const & {
    return {in, fun};
  }
  template <class _InIter2, class _Func2>
    requires convertible_to<_InIter1, _InIter2> && convertible_to<_Func1, _Func2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr operator in_fun_result<_InIter2, _Func2>() && {
    return {std::move(in), std::move(fun)};
  }
};
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _InIter1, class _InIter2, class _OutIter1>
struct in_in_out_result {
  [[no_unique_address]] _InIter1 in1;
  [[no_unique_address]] _InIter2 in2;
  [[no_unique_address]] _OutIter1 out;
  template <class _InIter3, class _InIter4, class _OutIter2>
    requires convertible_to<const _InIter1&, _InIter3>
          && convertible_to<const _InIter2&, _InIter4> && convertible_to<const _OutIter1&, _OutIter2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  operator in_in_out_result<_InIter3, _InIter4, _OutIter2>() const& {
    return {in1, in2, out};
  }
  template <class _InIter3, class _InIter4, class _OutIter2>
    requires convertible_to<_InIter1, _InIter3>
          && convertible_to<_InIter2, _InIter4> && convertible_to<_OutIter1, _OutIter2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  operator in_in_out_result<_InIter3, _InIter4, _OutIter2>() && {
    return {std::move(in1), std::move(in2), std::move(out)};
  }
};
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _InIter1, class _InIter2>
struct in_in_result {
  [[no_unique_address]] _InIter1 in1;
  [[no_unique_address]] _InIter2 in2;
  template <class _InIter3, class _InIter4>
    requires convertible_to<const _InIter1&, _InIter3> && convertible_to<const _InIter2&, _InIter4>
   __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
   operator in_in_result<_InIter3, _InIter4>() const & {
    return {in1, in2};
  }
  template <class _InIter3, class _InIter4>
    requires convertible_to<_InIter1, _InIter3> && convertible_to<_InIter2, _InIter4>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  operator in_in_result<_InIter3, _InIter4>() && {
    return {std::move(in1), std::move(in2)};
  }
};
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _InIter1, class _OutIter1, class _OutIter2>
struct in_out_out_result {
  [[no_unique_address]] _InIter1 in;
  [[no_unique_address]] _OutIter1 out1;
  [[no_unique_address]] _OutIter2 out2;
  template <class _InIter2, class _OutIter3, class _OutIter4>
    requires convertible_to<const _InIter1&, _InIter2>
          && convertible_to<const _OutIter1&, _OutIter3> && convertible_to<const _OutIter2&, _OutIter4>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  operator in_out_out_result<_InIter2, _OutIter3, _OutIter4>() const& {
    return {in, out1, out2};
  }
  template <class _InIter2, class _OutIter3, class _OutIter4>
    requires convertible_to<_InIter1, _InIter2>
          && convertible_to<_OutIter1, _OutIter3> && convertible_to<_OutIter2, _OutIter4>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  operator in_out_out_result<_InIter2, _OutIter3, _OutIter4>() && {
    return {std::move(in), std::move(out1), std::move(out2)};
  }
};
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template<class _InIter1, class _OutIter1>
struct in_out_result {
  [[no_unique_address]] _InIter1 in;
  [[no_unique_address]] _OutIter1 out;
  template <class _InIter2, class _OutIter2>
    requires convertible_to<const _InIter1&, _InIter2> && convertible_to<const _OutIter1&, _OutIter2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr operator in_out_result<_InIter2, _OutIter2>() const & {
    return {in, out};
  }
  template <class _InIter2, class _OutIter2>
    requires convertible_to<_InIter1, _InIter2> && convertible_to<_OutIter1, _OutIter2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr operator in_out_result<_InIter2, _OutIter2>() && {
    return {std::move(in), std::move(out)};
  }
};
}
}}
namespace std { inline namespace __1 {
template <class _Iter1, class _Sent1, class _Iter2, class _Sent2, class _Comp, class _Proj1, class _Proj2>
// added by concept-synth, original LN: 9109
requires
(
 requires (_Iter1 x0) { *x0; } &&
 requires (_Iter1 x0) { ++x0; }
) &&
(
 requires (_Iter2 x0) { ++x0; } &&
 requires (_Iter2 x0) { *x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool
__includes(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,
           _Comp&& __comp, _Proj1&& __proj1, _Proj2&& __proj2) {
  for (; __first2 != __last2; ++__first1) {
    if (__first1 == __last1 || std::__invoke(
          __comp, std::__invoke(__proj2, *__first2), std::__invoke(__proj1, *__first1)))
      return false;
    if (!std::__invoke(__comp, std::__invoke(__proj1, *__first1), std::__invoke(__proj2, *__first2)))
      ++__first2;
  }
  return true;
}
template <class _InputIterator1, class _InputIterator2, class _Compare>
// added by concept-synth, original LN: 9122
requires
(
 requires (_InputIterator2 x0) { ++x0; } &&
 requires (_InputIterator2 x0) { *x0; }
) &&
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool includes(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _Compare __comp) {
  static_assert(__is_callable<_Compare, decltype(*__first1), decltype(*__first2)>::value,
      "Comparator has to be callable");
  return std::__includes(
      std::move(__first1),
      std::move(__last1),
      std::move(__first2),
      std::move(__last2),
      static_cast<__comp_ref_type<_Compare> >(__comp),
      __identity(),
      __identity());
}
template <class _InputIterator1, class _InputIterator2>
// added by concept-synth, original LN: 9140
requires
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
) &&
(
 requires (_InputIterator2 x0) { ++x0; } &&
 requires (_InputIterator2 x0) { *x0; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool
includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2) {
  return std::includes(
      std::move(__first1),
      std::move(__last1),
      std::move(__first2),
      std::move(__last2),
      __less<typename iterator_traits<_InputIterator1>::value_type,
             typename iterator_traits<_InputIterator2>::value_type>());
}
}}

namespace std { inline namespace __1 {
template <class _AlgPolicy, class _InIter, class _Sent, class _OutIter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_InIter, _OutIter>
__move(_InIter __first, _Sent __last, _OutIter __result);
template <class _AlgPolicy>
struct __move_loop {
  template <class _InIter, class _Sent, class _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_InIter, _OutIter>
  operator()(_InIter __first, _Sent __last, _OutIter __result) const {
    while (__first != __last) {
      *__result = _IterOps<_AlgPolicy>::__iter_move(__first);
      ++__first;
      ++__result;
    }
    return std::make_pair(std::move(__first), std::move(__result));
  }
  template <class _InIter, class _OutIter, __enable_if_t<__is_segmented_iterator<_InIter>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_InIter, _OutIter>
  operator()(_InIter __first, _InIter __last, _OutIter __result) const {
    using _Traits = __segmented_iterator_traits<_InIter>;
    auto __sfirst = _Traits::__segment(__first);
    auto __slast = _Traits::__segment(__last);
    if (__sfirst == __slast) {
      auto __iters = std::__move<_AlgPolicy>(_Traits::__local(__first), _Traits::__local(__last), std::move(__result));
      return std::make_pair(__last, std::move(__iters.second));
    }
    __result = std::__move<_AlgPolicy>(_Traits::__local(__first), _Traits::__end(__sfirst), std::move(__result)).second;
    ++__sfirst;
    while (__sfirst != __slast) {
      __result =
          std::__move<_AlgPolicy>(_Traits::__begin(__sfirst), _Traits::__end(__sfirst), std::move(__result)).second;
      ++__sfirst;
    }
    __result =
        std::__move<_AlgPolicy>(_Traits::__begin(__sfirst), _Traits::__local(__last), std::move(__result)).second;
    return std::make_pair(__last, std::move(__result));
  }
  template <class _InIter,
            class _OutIter,
            __enable_if_t<__is_cpp17_random_access_iterator<_InIter>::value &&
                              !__is_segmented_iterator<_InIter>::value && __is_segmented_iterator<_OutIter>::value,
                          int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_InIter, _OutIter>
  operator()(_InIter __first, _InIter __last, _OutIter __result) {
    using _Traits = __segmented_iterator_traits<_OutIter>;
    using _DiffT = typename common_type<__iter_diff_t<_InIter>, __iter_diff_t<_OutIter> >::type;
    if (__first == __last)
      return std::make_pair(std::move(__first), std::move(__result));
    auto __local_first = _Traits::__local(__result);
    auto __segment_iterator = _Traits::__segment(__result);
    while (true) {
      auto __local_last = _Traits::__end(__segment_iterator);
      auto __size = std::min<_DiffT>(__local_last - __local_first, __last - __first);
      auto __iters = std::__move<_AlgPolicy>(__first, __first + __size, __local_first);
      __first = std::move(__iters.first);
      if (__first == __last)
        return std::make_pair(std::move(__first), _Traits::__compose(__segment_iterator, std::move(__iters.second)));
      __local_first = _Traits::__begin(++__segment_iterator);
    }
  }
};
struct __move_trivial {
  template <class _In, class _Out,
            __enable_if_t<__can_lower_move_assignment_to_memmove<_In, _Out>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_In*, _Out*>
  operator()(_In* __first, _In* __last, _Out* __result) const {
    return std::__copy_trivial_impl(__first, __last, __result);
  }
};
template <class _AlgPolicy, class _InIter, class _Sent, class _OutIter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_InIter, _OutIter>
__move(_InIter __first, _Sent __last, _OutIter __result) {
  return std::__dispatch_copy_or_move<_AlgPolicy, __move_loop<_AlgPolicy>, __move_trivial>(
      std::move(__first), std::move(__last), std::move(__result));
}
template <class _InputIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _OutputIterator
move(_InputIterator __first, _InputIterator __last, _OutputIterator __result) {
  static_assert(is_copy_constructible<_InputIterator>::value, "Iterators has to be copy constructible.");
  static_assert(is_copy_constructible<_OutputIterator>::value, "The output iterator has to be copy constructible.");
  return std::__move<_ClassicAlgPolicy>(std::move(__first), std::move(__last), std::move(__result)).second;
}
}}

namespace std { inline namespace __1 {
template <class _AlgPolicy, class _BidirectionalIterator1, class _Sentinel, class _BidirectionalIterator2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_BidirectionalIterator1, _BidirectionalIterator2>
__move_backward(_BidirectionalIterator1 __first, _Sentinel __last, _BidirectionalIterator2 __result);
template <class _AlgPolicy>
struct __move_backward_loop {
  template <class _InIter, class _Sent, class _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_InIter, _OutIter>
  operator()(_InIter __first, _Sent __last, _OutIter __result) const {
    auto __last_iter = _IterOps<_AlgPolicy>::next(__first, __last);
    auto __original_last_iter = __last_iter;
    while (__first != __last_iter) {
      *--__result = _IterOps<_AlgPolicy>::__iter_move(--__last_iter);
    }
    return std::make_pair(std::move(__original_last_iter), std::move(__result));
  }
  template <class _InIter, class _OutIter, __enable_if_t<__is_segmented_iterator<_InIter>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_InIter, _OutIter>
  operator()(_InIter __first, _InIter __last, _OutIter __result) const {
    using _Traits = __segmented_iterator_traits<_InIter>;
    auto __sfirst = _Traits::__segment(__first);
    auto __slast = _Traits::__segment(__last);
    if (__sfirst == __slast) {
      auto __iters =
          std::__move_backward<_AlgPolicy>(_Traits::__local(__first), _Traits::__local(__last), std::move(__result));
      return std::make_pair(__last, __iters.second);
    }
    __result =
        std::__move_backward<_AlgPolicy>(_Traits::__begin(__slast), _Traits::__local(__last), std::move(__result))
            .second;
    --__slast;
    while (__sfirst != __slast) {
      __result =
          std::__move_backward<_AlgPolicy>(_Traits::__begin(__slast), _Traits::__end(__slast), std::move(__result))
              .second;
      --__slast;
    }
    __result = std::__move_backward<_AlgPolicy>(_Traits::__local(__first), _Traits::__end(__slast), std::move(__result))
                   .second;
    return std::make_pair(__last, std::move(__result));
  }
  template <class _InIter,
            class _OutIter,
            __enable_if_t<__is_cpp17_random_access_iterator<_InIter>::value &&
                              !__is_segmented_iterator<_InIter>::value && __is_segmented_iterator<_OutIter>::value,
                          int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_InIter, _OutIter>
  operator()(_InIter __first, _InIter __last, _OutIter __result) {
    using _Traits = __segmented_iterator_traits<_OutIter>;
    using _DiffT = typename common_type<__iter_diff_t<_InIter>, __iter_diff_t<_OutIter> >::type;
    if (__first == __last)
      return std::make_pair(__first, __result);
    auto __orig_last = __last;
    auto __local_last = _Traits::__local(__result);
    auto __segment_iterator = _Traits::__segment(__result);
    while (true) {
      auto __local_first = _Traits::__begin(__segment_iterator);
      auto __size = std::min<_DiffT>(__local_last - __local_first, __last - __first);
      auto __iter = std::__move_backward<_AlgPolicy>(__last - __size, __last, __local_last).second;
      __last -= __size;
      if (__first == __last)
        return std::make_pair(std::move(__orig_last), _Traits::__compose(__segment_iterator, std::move(__iter)));
      __local_last = _Traits::__end(--__segment_iterator);
    }
  }
};
struct __move_backward_trivial {
  template <class _In, class _Out,
            __enable_if_t<__can_lower_move_assignment_to_memmove<_In, _Out>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_In*, _Out*>
  operator()(_In* __first, _In* __last, _Out* __result) const {
    return std::__copy_backward_trivial_impl(__first, __last, __result);
  }
};
template <class _AlgPolicy, class _BidirectionalIterator1, class _Sentinel, class _BidirectionalIterator2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_BidirectionalIterator1, _BidirectionalIterator2>
__move_backward(_BidirectionalIterator1 __first, _Sentinel __last, _BidirectionalIterator2 __result) {
  static_assert(std::is_copy_constructible<_BidirectionalIterator1>::value &&
                std::is_copy_constructible<_BidirectionalIterator1>::value, "Iterators must be copy constructible.");
  return std::__dispatch_copy_or_move<_AlgPolicy, __move_backward_loop<_AlgPolicy>, __move_backward_trivial>(
      std::move(__first), std::move(__last), std::move(__result));
}
template <class _BidirectionalIterator1, class _BidirectionalIterator2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _BidirectionalIterator2
move_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last, _BidirectionalIterator2 __result) {
  return std::__move_backward<_ClassicAlgPolicy>(std::move(__first), std::move(__last), std::move(__result)).second;
}
}}
namespace std { inline namespace __1 {
template <class _AlgPolicy, class _ForwardIterator1, class _Sentinel1, class _ForwardIterator2, class _Sentinel2>
// added by concept-synth, original LN: 9326
requires
requires (_ForwardIterator1 x0) { ++x0; } &&
requires (_ForwardIterator2 x0) { ++x0; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
pair<_ForwardIterator1, _ForwardIterator2>
__swap_ranges(_ForwardIterator1 __first1, _Sentinel1 __last1, _ForwardIterator2 __first2, _Sentinel2 __last2) {
  while (__first1 != __last1 && __first2 != __last2) {
    _IterOps<_AlgPolicy>::iter_swap(__first1, __first2);
    ++__first1;
    ++__first2;
  }
  return pair<_ForwardIterator1, _ForwardIterator2>(std::move(__first1), std::move(__first2));
}
template <class _AlgPolicy, class _ForwardIterator1, class _Sentinel1, class _ForwardIterator2>
// added by concept-synth, original LN: 9337
requires
requires (_ForwardIterator1 x0) { ++x0; } &&
requires (_ForwardIterator2 x0) { ++x0; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
pair<_ForwardIterator1, _ForwardIterator2>
__swap_ranges(_ForwardIterator1 __first1, _Sentinel1 __last1, _ForwardIterator2 __first2) {
  while (__first1 != __last1) {
    _IterOps<_AlgPolicy>::iter_swap(__first1, __first2);
    ++__first1;
    ++__first2;
  }
  return pair<_ForwardIterator1, _ForwardIterator2>(std::move(__first1), std::move(__first2));
}
template <class _ForwardIterator1, class _ForwardIterator2>
// added by concept-synth, original LN: 9348
requires
requires (_ForwardIterator2 x0) { ++x0; } &&
requires (_ForwardIterator1 x0) { ++x0; }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _ForwardIterator2
swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2) {
  return std::__swap_ranges<_ClassicAlgPolicy>(
      std::move(__first1), std::move(__last1), std::move(__first2)).second;
}
}}
namespace std { inline namespace __1 {
template <class _AlgPolicy, class _ForwardIterator>
// added by concept-synth, original LN: 9356
requires
requires (_ForwardIterator x0) { *x0; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _ForwardIterator
__rotate_left(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
    using _Ops = _IterOps<_AlgPolicy>;
    value_type __tmp = _Ops::__iter_move(__first);
    _ForwardIterator __lm1 = std::__move<_AlgPolicy>(
        _Ops::next(__first), __last, __first).second;
    *__lm1 = std::move(__tmp);
    return __lm1;
}
template <class _AlgPolicy, class _BidirectionalIterator>
// added by concept-synth, original LN: 9368
requires
requires (_BidirectionalIterator x0) { *x0; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _BidirectionalIterator
__rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    using _Ops = _IterOps<_AlgPolicy>;
    _BidirectionalIterator __lm1 = _Ops::prev(__last);
    value_type __tmp = _Ops::__iter_move(__lm1);
    _BidirectionalIterator __fp1 = std::__move_backward<_AlgPolicy>(__first, __lm1, std::move(__last)).second;
    *__first = std::move(__tmp);
    return __fp1;
}
template <class _AlgPolicy, class _ForwardIterator>
// added by concept-synth, original LN: 9380
requires
requires (_ForwardIterator x0) { ++x0; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _ForwardIterator
__rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)
{
    _ForwardIterator __i = __middle;
    while (true)
    {
        _IterOps<_AlgPolicy>::iter_swap(__first, __i);
        ++__first;
        if (++__i == __last)
            break;
        if (__first == __middle)
            __middle = __i;
    }
    _ForwardIterator __r = __first;
    if (__first != __middle)
    {
        __i = __middle;
        while (true)
        {
            _IterOps<_AlgPolicy>::iter_swap(__first, __i);
            ++__first;
            if (++__i == __last)
            {
                if (__first == __middle)
                    break;
                __i = __middle;
            }
            else if (__first == __middle)
                __middle = __i;
        }
    }
    return __r;
}
template<typename _Integral>
// added by concept-synth, original LN: 9414
requires
requires (_Integral x0, _Integral x1) { x0 % x1; }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr _Integral
__algo_gcd(_Integral __x, _Integral __y)
{
    do
    {
        _Integral __t = __x % __y;
        __x = __y;
        __y = __t;
    } while (__y);
    return __x;
}
template <class _AlgPolicy, typename _RandomAccessIterator>
// added by concept-synth, original LN: 9427
requires
(
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _RandomAccessIterator
__rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    using _Ops = _IterOps<_AlgPolicy>;
    const difference_type __m1 = __middle - __first;
    const difference_type __m2 = _Ops::distance(__middle, __last);
    if (__m1 == __m2)
    {
        std::__swap_ranges<_AlgPolicy>(__first, __middle, __middle, __last);
        return __middle;
    }
    const difference_type __g = std::__algo_gcd(__m1, __m2);
    for (_RandomAccessIterator __p = __first + __g; __p != __first;)
    {
        value_type __t(_Ops::__iter_move(--__p));
        _RandomAccessIterator __p1 = __p;
        _RandomAccessIterator __p2 = __p1 + __m1;
        do
        {
            *__p1 = _Ops::__iter_move(__p2);
            __p1 = __p2;
            const difference_type __d = _Ops::distance(__p2, __last);
            if (__m1 < __d)
                __p2 += __m1;
            else
                __p2 = __first + (__m1 - __d);
        } while (__p2 != __p);
        *__p1 = std::move(__t);
    }
    return __first + __m2;
}
template <class _AlgPolicy, class _ForwardIterator>
// added by concept-synth, original LN: 9461
requires
(
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr _ForwardIterator
__rotate_impl(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,
         std::forward_iterator_tag)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
    if (is_trivially_move_assignable<value_type>::value)
    {
        if (_IterOps<_AlgPolicy>::next(__first) == __middle)
            return std::__rotate_left<_AlgPolicy>(__first, __last);
    }
    return std::__rotate_forward<_AlgPolicy>(__first, __middle, __last);
}
template <class _AlgPolicy, class _BidirectionalIterator>
// added by concept-synth, original LN: 9475
requires
(
 requires (_BidirectionalIterator x0) { *x0; } &&
 requires (_BidirectionalIterator x0) { ++x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr _BidirectionalIterator
__rotate_impl(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
         bidirectional_iterator_tag)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    if (is_trivially_move_assignable<value_type>::value)
    {
        if (_IterOps<_AlgPolicy>::next(__first) == __middle)
            return std::__rotate_left<_AlgPolicy>(__first, __last);
        if (_IterOps<_AlgPolicy>::next(__middle) == __last)
            return std::__rotate_right<_AlgPolicy>(__first, __last);
    }
    return std::__rotate_forward<_AlgPolicy>(__first, __middle, __last);
}
template <class _AlgPolicy, class _RandomAccessIterator>
// added by concept-synth, original LN: 9491
requires
(
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr _RandomAccessIterator
__rotate_impl(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
         random_access_iterator_tag)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    if (is_trivially_move_assignable<value_type>::value)
    {
        if (_IterOps<_AlgPolicy>::next(__first) == __middle)
            return std::__rotate_left<_AlgPolicy>(__first, __last);
        if (_IterOps<_AlgPolicy>::next(__middle) == __last)
            return std::__rotate_right<_AlgPolicy>(__first, __last);
        return std::__rotate_gcd<_AlgPolicy>(__first, __middle, __last);
    }
    return std::__rotate_forward<_AlgPolicy>(__first, __middle, __last);
}
template <class _AlgPolicy, class _Iterator, class _Sentinel>
// added by concept-synth, original LN: 9508
requires
(
 (
  requires (_Iterator x0) { ++x0; } &&
  requires (_Iterator x0) { *x0; }
 ) ||
 (
  requires (_Iterator x0) { *x0; } &&
  requires (_Iterator x0) { ++x0; }
 ) ||
 (
  requires (_Iterator x0) { *x0; } &&
  requires (_Iterator x0) { ++x0; } &&
  requires (_Iterator x0) { --x0; }
 )
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
pair<_Iterator, _Iterator>
__rotate(_Iterator __first, _Iterator __middle, _Sentinel __last) {
  using _Ret = pair<_Iterator, _Iterator>;
  _Iterator __last_iter = _IterOps<_AlgPolicy>::next(__middle, __last);
  if (__first == __middle)
      return _Ret(__last_iter, __last_iter);
  if (__middle == __last)
      return _Ret(std::move(__first), std::move(__last_iter));
  using _IterCategory = typename _IterOps<_AlgPolicy>::template __iterator_category<_Iterator>;
  auto __result = std::__rotate_impl<_AlgPolicy>(
      std::move(__first), std::move(__middle), __last_iter, _IterCategory());
  return _Ret(std::move(__result), std::move(__last_iter));
}
template <class _ForwardIterator>
// added by concept-synth, original LN: 9523
requires
(
 (
  requires (_ForwardIterator x0) { ++x0; } &&
  requires (_ForwardIterator x0) { *x0; }
 ) ||
 (
  requires (_ForwardIterator x0) { *x0; } &&
  requires (_ForwardIterator x0) { ++x0; }
 ) ||
 (
  requires (_ForwardIterator x0) { *x0; } &&
  requires (_ForwardIterator x0) { ++x0; } &&
  requires (_ForwardIterator x0) { --x0; }
 )
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr _ForwardIterator
rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)
{
  return std::__rotate<_ClassicAlgPolicy>(
      std::move(__first), std::move(__middle), std::move(__last)).first;
}
}}
namespace std { inline namespace __1 {
struct __destruct_n
{
private:
    size_t __size_;
    template <class _Tp>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void __process(_Tp* __p, false_type) noexcept
        {for (size_t __i = 0; __i < __size_; ++__i, ++__p) __p->~_Tp();}
    template <class _Tp>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void __process(_Tp*, true_type) noexcept
        {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void __incr(false_type) noexcept
        {++__size_;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void __incr(true_type) noexcept
        {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void __set(size_t __s, false_type) noexcept
        {__size_ = __s;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void __set(size_t, true_type) noexcept
        {}
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) explicit __destruct_n(size_t __s) noexcept
        : __size_(__s) {}
    template <class _Tp>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void __incr() noexcept
        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}
    template <class _Tp>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void __set(size_t __s, _Tp*) noexcept
        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}
    template <class _Tp>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void operator()(_Tp* __p) noexcept
        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}
};
}}
namespace std
{
class __attribute__((__visibility__("default"))) exception {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) exception() noexcept {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) exception(const exception&) noexcept = default;
  virtual ~exception() noexcept;
  virtual const char* what() const noexcept;
};
class __attribute__((__visibility__("default"))) bad_exception : public exception {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bad_exception() noexcept {}
  ~bad_exception() noexcept override;
  const char* what() const noexcept override;
};
typedef void (*terminate_handler)();
__attribute__((__visibility__("default"))) terminate_handler set_terminate(terminate_handler) noexcept;
__attribute__((__visibility__("default"))) terminate_handler get_terminate() noexcept;
[[noreturn]] __attribute__((__visibility__("default"))) void terminate() noexcept;
__attribute__((__visibility__("default"))) bool uncaught_exception() noexcept;
__attribute__((__visibility__("default"))) __attribute__((availability(macos,strict,introduced=10.12))) __attribute__((availability(ios,strict,introduced=10.0))) __attribute__((availability(tvos,strict,introduced=10.0))) __attribute__((availability(watchos,strict,introduced=3.0))) int uncaught_exceptions() noexcept;
class __attribute__((__visibility__("default"))) exception_ptr;
__attribute__((__visibility__("default"))) exception_ptr current_exception() noexcept;
[[noreturn]] __attribute__((__visibility__("default"))) void rethrow_exception(exception_ptr);
class __attribute__((__visibility__("default"))) exception_ptr
{
    void* __ptr_;
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) exception_ptr() noexcept : __ptr_() {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) exception_ptr(nullptr_t) noexcept : __ptr_() {}
    exception_ptr(const exception_ptr&) noexcept;
    exception_ptr& operator=(const exception_ptr&) noexcept;
    ~exception_ptr() noexcept;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) explicit operator bool() const noexcept
    {return __ptr_ != nullptr;}
    friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool operator==(const exception_ptr& __x, const exception_ptr& __y) noexcept
        {return __x.__ptr_ == __y.__ptr_;}
    friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool operator!=(const exception_ptr& __x, const exception_ptr& __y) noexcept
        {return !(__x == __y);}
    friend __attribute__((__visibility__("default"))) exception_ptr current_exception() noexcept;
    friend __attribute__((__visibility__("default"))) void rethrow_exception(exception_ptr);
};
template<class _Ep>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) exception_ptr
make_exception_ptr(_Ep __e) noexcept
{
    try
    {
        throw __e;
    }
    catch (...)
    {
        return current_exception();
    }
}
class __attribute__((__visibility__("default"))) nested_exception
{
    exception_ptr __ptr_;
public:
    nested_exception() noexcept;
    virtual ~nested_exception() noexcept;
    [[noreturn]] void rethrow_nested() const;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) exception_ptr nested_ptr() const noexcept {return __ptr_;}
};
template <class _Tp>
struct __nested
    : public _Tp,
      public nested_exception
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) explicit __nested(const _Tp& __t) : _Tp(__t) {}
};
template <class _Tp, class _Up, bool>
struct __throw_with_nested;
template <class _Tp, class _Up>
struct __throw_with_nested<_Tp, _Up, true> {
    [[noreturn]] static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void
    __do_throw(_Tp&& __t)
    {
        throw __nested<_Up>(static_cast<_Tp&&>(__t));
    }
};
template <class _Tp, class _Up>
struct __throw_with_nested<_Tp, _Up, false> {
    [[noreturn]] static inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void
    __do_throw(_Tp&& __t)
    {
        throw static_cast<_Tp&&>(__t);
    }
};
template <class _Tp>
[[noreturn]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void
throw_with_nested(_Tp&& __t)
{
    typedef typename decay<_Tp>::type _Up;
    static_assert( is_copy_constructible<_Up>::value, "type thrown must be CopyConstructible");
    __throw_with_nested<_Tp, _Up,
        is_class<_Up>::value &&
        !is_base_of<nested_exception, _Up>::value &&
        !__libcpp_is_final<_Up>::value>::
            __do_throw(static_cast<_Tp&&>(__t));
}
template <class _From, class _To>
struct __can_dynamic_cast : _BoolConstant<
              is_polymorphic<_From>::value &&
                 (!is_base_of<_To, _From>::value ||
                   is_convertible<const _From*, const _To*>::value)> {};
template <class _Ep>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void
rethrow_if_nested(const _Ep& __e,
                  __enable_if_t< __can_dynamic_cast<_Ep, nested_exception>::value>* = 0)
{
    const nested_exception* __nep = dynamic_cast<const nested_exception*>(std::addressof(__e));
    if (__nep)
        __nep->rethrow_nested();
}
template <class _Ep>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void
rethrow_if_nested(const _Ep&,
                  __enable_if_t<!__can_dynamic_cast<_Ep, nested_exception>::value>* = 0)
{
}
}
namespace std
{
struct __attribute__((__visibility__("default"))) nothrow_t { explicit nothrow_t() = default; };
extern __attribute__((__visibility__("default"))) const nothrow_t nothrow;
class __attribute__((__visibility__("default"))) bad_alloc
    : public exception
{
public:
    bad_alloc() noexcept;
    ~bad_alloc() noexcept override;
    const char* what() const noexcept override;
};
class __attribute__((__visibility__("default"))) bad_array_new_length
    : public bad_alloc
{
public:
    bad_array_new_length() noexcept;
    ~bad_array_new_length() noexcept override;
    const char* what() const noexcept override;
};
typedef void (*new_handler)();
__attribute__((__visibility__("default"))) new_handler set_new_handler(new_handler) noexcept;
__attribute__((__visibility__("default"))) new_handler get_new_handler() noexcept;
[[noreturn]] __attribute__((__visibility__("default"))) void __throw_bad_alloc();
[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void __throw_bad_array_new_length()
{
    throw bad_array_new_length();
}
enum class __attribute__((__type_visibility__("default"))) align_val_t : size_t { };
struct destroying_delete_t {
  explicit destroying_delete_t() = default;
};
inline constexpr destroying_delete_t destroying_delete{};
}
[[nodiscard]] __attribute__((__visibility__("default"))) void* operator new(std::size_t __sz) ;
[[nodiscard]] __attribute__((__visibility__("default"))) void* operator new(std::size_t __sz, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__((__visibility__("default"))) void operator delete(void* __p) noexcept;
__attribute__((__visibility__("default"))) void operator delete(void* __p, const std::nothrow_t&) noexcept;
__attribute__((__visibility__("default"))) __attribute__((availability(macos,strict,introduced=10.12))) __attribute__((availability(ios,strict,introduced=10.0))) __attribute__((availability(tvos,strict,introduced=10.0))) __attribute__((availability(watchos,strict,introduced=3.0))) void operator delete(void* __p, std::size_t __sz) noexcept;
[[nodiscard]] __attribute__((__visibility__("default"))) void* operator new[](std::size_t __sz) ;
[[nodiscard]] __attribute__((__visibility__("default"))) void* operator new[](std::size_t __sz, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__((__visibility__("default"))) void operator delete[](void* __p) noexcept;
__attribute__((__visibility__("default"))) void operator delete[](void* __p, const std::nothrow_t&) noexcept;
__attribute__((__visibility__("default"))) __attribute__((availability(macos,strict,introduced=10.12))) __attribute__((availability(ios,strict,introduced=10.0))) __attribute__((availability(tvos,strict,introduced=10.0))) __attribute__((availability(watchos,strict,introduced=3.0))) void operator delete[](void* __p, std::size_t __sz) noexcept;
[[nodiscard]] __attribute__((__visibility__("default"))) void* operator new(std::size_t __sz, std::align_val_t) ;
[[nodiscard]] __attribute__((__visibility__("default"))) void* operator new(std::size_t __sz, std::align_val_t, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__((__visibility__("default"))) void operator delete(void* __p, std::align_val_t) noexcept;
__attribute__((__visibility__("default"))) void operator delete(void* __p, std::align_val_t, const std::nothrow_t&) noexcept;
__attribute__((__visibility__("default"))) __attribute__((availability(macos,strict,introduced=10.12))) __attribute__((availability(ios,strict,introduced=10.0))) __attribute__((availability(tvos,strict,introduced=10.0))) __attribute__((availability(watchos,strict,introduced=3.0))) void operator delete(void* __p, std::size_t __sz, std::align_val_t) noexcept;
[[nodiscard]] __attribute__((__visibility__("default"))) void* operator new[](std::size_t __sz, std::align_val_t) ;
[[nodiscard]] __attribute__((__visibility__("default"))) void* operator new[](std::size_t __sz, std::align_val_t, const std::nothrow_t&) noexcept __attribute__((__malloc__));
__attribute__((__visibility__("default"))) void operator delete[](void* __p, std::align_val_t) noexcept;
__attribute__((__visibility__("default"))) void operator delete[](void* __p, std::align_val_t, const std::nothrow_t&) noexcept;
__attribute__((__visibility__("default"))) __attribute__((availability(macos,strict,introduced=10.12))) __attribute__((availability(ios,strict,introduced=10.0))) __attribute__((availability(tvos,strict,introduced=10.0))) __attribute__((availability(watchos,strict,introduced=3.0))) void operator delete[](void* __p, std::size_t __sz, std::align_val_t) noexcept;
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void* operator new (std::size_t, void* __p) noexcept {return __p;}
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void* operator new[](std::size_t, void* __p) noexcept {return __p;}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void operator delete (void*, void*) noexcept {}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void operator delete[](void*, void*) noexcept {}
namespace std { inline namespace __1 {
constexpr inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool __is_overaligned_for_new(size_t __align) noexcept {
  return __align > 16UL;
}
template <class ..._Args>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void* __libcpp_operator_new(_Args ...__args) {
  return __builtin_operator_new(__args...);
}
template <class ..._Args>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void __libcpp_operator_delete(_Args ...__args) {
  __builtin_operator_delete(__args...);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void *__libcpp_allocate(size_t __size, size_t __align) {
  if (__is_overaligned_for_new(__align)) {
    const align_val_t __align_val = static_cast<align_val_t>(__align);
    return __libcpp_operator_new(__size, __align_val);
  }
  (void)__align;
  return __libcpp_operator_new(__size);
}
template <class ..._Args>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void __do_deallocate_handle_size(void *__ptr, size_t __size, _Args ...__args) {
  (void)__size;
  return std::__libcpp_operator_delete(__ptr, __args...);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void __libcpp_deallocate(void* __ptr, size_t __size, size_t __align) {
    if (__is_overaligned_for_new(__align)) {
      const align_val_t __align_val = static_cast<align_val_t>(__align);
      return __do_deallocate_handle_size(__ptr, __size, __align_val);
    } else {
      return __do_deallocate_handle_size(__ptr, __size);
    }
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void __libcpp_deallocate_unsized(void* __ptr, size_t __align) {
    if (__is_overaligned_for_new(__align)) {
      const align_val_t __align_val = static_cast<align_val_t>(__align);
      return __libcpp_operator_delete(__ptr, __align_val);
    } else {
      return __libcpp_operator_delete(__ptr);
    }
}
template <class _Tp>
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr _Tp* __launder(_Tp* __p) noexcept
{
    static_assert (!(is_function<_Tp>::value), "can't launder functions" );
    static_assert (!(is_same<void, __remove_cv_t<_Tp> >::value), "can't launder cv-void" );
    return __builtin_launder(__p);
}
template <class _Tp>
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr _Tp* launder(_Tp* __p) noexcept
{
    return std::__launder(__p);
}
}}
namespace std { inline namespace __1 {
template <class _Tp>
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__no_sanitize__("cfi"))) __attribute__((deprecated))
pair<_Tp*, ptrdiff_t>
get_temporary_buffer(ptrdiff_t __n) noexcept
{
    pair<_Tp*, ptrdiff_t> __r(0, 0);
    const ptrdiff_t __m = (~ptrdiff_t(0) ^
                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * 8 - 1)))
                           / sizeof(_Tp);
    if (__n > __m)
        __n = __m;
    while (__n > 0)
    {
    if (__is_overaligned_for_new(alignof(_Tp)))
        {
            align_val_t __al =
                align_val_t(alignment_of<_Tp>::value);
            __r.first = static_cast<_Tp*>(::operator new(
                __n * sizeof(_Tp), __al, nothrow));
        } else {
            __r.first = static_cast<_Tp*>(::operator new(
                __n * sizeof(_Tp), nothrow));
        }
        if (__r.first)
        {
            __r.second = __n;
            break;
        }
        __n /= 2;
    }
    return __r;
}
template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((deprecated))
void return_temporary_buffer(_Tp* __p) noexcept
{
  std::__libcpp_deallocate_unsized((void*)__p, alignof(_Tp));
}
struct __return_temporary_buffer
{
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    template <class _Tp>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void operator()(_Tp* __p) const {std::return_temporary_buffer(__p);}
#pragma GCC diagnostic pop
};
}}
namespace std { inline namespace __1 {
struct __attribute__((__type_visibility__("default"))) compare_three_way
{
    template<class _T1, class _T2>
        requires three_way_comparable_with<_T1, _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) <=> std::forward<_T2>(__u)))
        { return std::forward<_T1>(__t) <=> std::forward<_T2>(__u); }
    using is_transparent = void;
};
}}
namespace std { inline namespace __1 {
template <class _Arg, class _Result> struct __unary_function_keep_layout_base {
};
template <class _Arg, class _Result>
using __unary_function = __unary_function_keep_layout_base<_Arg, _Result>;
}}
extern "C" {
void *memchr(const void *__s, int __c, size_t __n);
int memcmp(const void *__s1, const void *__s2, size_t __n);
void *memcpy(void *__dst, const void *__src, size_t __n);
void *memmove(void *__dst, const void *__src, size_t __len);
void *memset(void *__b, int __c, size_t __len);
char *strcat(char *__s1, const char *__s2);
char *strchr(const char *__s, int __c);
int strcmp(const char *__s1, const char *__s2);
int strcoll(const char *__s1, const char *__s2);
char *strcpy(char *__dst, const char *__src);
size_t strcspn(const char *__s, const char *__charset);
char *strerror(int __errnum) __asm("_" "strerror" );
size_t strlen(const char *__s);
char *strncat(char *__s1, const char *__s2, size_t __n);
int strncmp(const char *__s1, const char *__s2, size_t __n);
char *strncpy(char *__dst, const char *__src, size_t __n);
char *strpbrk(const char *__s, const char *__charset);
char *strrchr(const char *__s, int __c);
size_t strspn(const char *__s, const char *__charset);
char *strstr(const char *__big, const char *__little);
char *strtok(char *__str, const char *__sep);
size_t strxfrm(char *__s1, const char *__s2, size_t __n);
}
extern "C" {
char *strtok_r(char *__str, const char *__sep, char **__lasts);
}
extern "C" {
int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen);
char *strdup(const char *__s1);
void *memccpy(void *__dst, const void *__src, int __c, size_t __n);
}
extern "C" {
char *stpcpy(char *__dst, const char *__src);
char *stpncpy(char *__dst, const char *__src, size_t __n) __attribute__((availability(macosx,introduced=10.7)));
char *strndup(const char *__s1, size_t __n) __attribute__((availability(macosx,introduced=10.7)));
size_t strnlen(const char *__s1, size_t __n) __attribute__((availability(macosx,introduced=10.7)));
char *strsignal(int __sig);
}
typedef __darwin_ssize_t ssize_t;

extern "C" {
void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len) __attribute__((availability(macosx,introduced=10.7)));
void memset_pattern4(void *__b, const void *__pattern4, size_t __len) __attribute__((availability(macosx,introduced=10.5)));
void memset_pattern8(void *__b, const void *__pattern8, size_t __len) __attribute__((availability(macosx,introduced=10.5)));
void memset_pattern16(void *__b, const void *__pattern16, size_t __len) __attribute__((availability(macosx,introduced=10.5)));
char *strcasestr(const char *__big, const char *__little);
char *strnstr(const char *__big, const char *__little, size_t __len);
size_t strlcat(char *__dst, const char *__source, size_t __size);
size_t strlcpy(char *__dst, const char *__source, size_t __size);
void strmode(int __mode, char *__bp);
char *strsep(char **__stringp, const char *__delim);
void swab(const void * , void * , ssize_t);
__attribute__((availability(macosx,introduced=10.12.1))) __attribute__((availability(ios,introduced=10.1)))
__attribute__((availability(tvos,introduced=10.0.1))) __attribute__((availability(watchos,introduced=3.1)))
int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len);
__attribute__((availability(macosx,introduced=11.0))) __attribute__((availability(ios,introduced=14.0)))
__attribute__((availability(tvos,introduced=14.0))) __attribute__((availability(watchos,introduced=7.0)))
int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen);
}

extern "C" {
int bcmp(const void *, const void *, size_t) ;
void bcopy(const void *, void *, size_t) ;
void bzero(void *, size_t) ;
char *index(const char *, int) ;
char *rindex(const char *, int) ;
int ffs(int);
int strcasecmp(const char *, const char *);
int strncasecmp(const char *, const char *, size_t);
}
extern "C" {
int ffsl(long) __attribute__((availability(macosx,introduced=10.5)));
int ffsll(long long) __attribute__((availability(macosx,introduced=10.9)));
int fls(int) __attribute__((availability(macosx,introduced=10.5)));
int flsl(long) __attribute__((availability(macosx,introduced=10.5)));
int flsll(long long) __attribute__((availability(macosx,introduced=10.9)));
}
extern "C++" {
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__enable_if__(true, ""))) const char* strchr(const char* __s, int __c) {
  return __builtin_strchr(__s, __c);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__enable_if__(true, ""))) char* strchr(char* __s, int __c) {
  return __builtin_strchr(__s, __c);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__enable_if__(true, ""))) const char* strpbrk(const char* __s1, const char* __s2) {
  return __builtin_strpbrk(__s1, __s2);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__enable_if__(true, ""))) char* strpbrk(char* __s1, const char* __s2) {
  return __builtin_strpbrk(__s1, __s2);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__enable_if__(true, ""))) const char* strrchr(const char* __s, int __c) {
  return __builtin_strrchr(__s, __c);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__enable_if__(true, ""))) char* strrchr(char* __s, int __c) {
  return __builtin_strrchr(__s, __c);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__enable_if__(true, ""))) const void* memchr(const void* __s, int __c, size_t __n) {
  return __builtin_memchr(__s, __c, __n);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__enable_if__(true, ""))) void* memchr(void* __s, int __c, size_t __n) {
  return __builtin_memchr(__s, __c, __n);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__enable_if__(true, ""))) const char* strstr(const char* __s1, const char* __s2) {
  return __builtin_strstr(__s1, __s2);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__enable_if__(true, ""))) char* strstr(char* __s1, const char* __s2) {
  return __builtin_strstr(__s1, __s2);
}
}
namespace std { inline namespace __1 {
using ::size_t __attribute__((__using_if_exists__));
using ::memcpy __attribute__((__using_if_exists__));
using ::memmove __attribute__((__using_if_exists__));
using ::strcpy __attribute__((__using_if_exists__));
using ::strncpy __attribute__((__using_if_exists__));
using ::strcat __attribute__((__using_if_exists__));
using ::strncat __attribute__((__using_if_exists__));
using ::memcmp __attribute__((__using_if_exists__));
using ::strcmp __attribute__((__using_if_exists__));
using ::strncmp __attribute__((__using_if_exists__));
using ::strcoll __attribute__((__using_if_exists__));
using ::strxfrm __attribute__((__using_if_exists__));
using ::memchr __attribute__((__using_if_exists__));
using ::strchr __attribute__((__using_if_exists__));
using ::strcspn __attribute__((__using_if_exists__));
using ::strpbrk __attribute__((__using_if_exists__));
using ::strrchr __attribute__((__using_if_exists__));
using ::strspn __attribute__((__using_if_exists__));
using ::strstr __attribute__((__using_if_exists__));
using ::strtok __attribute__((__using_if_exists__));
using ::memset __attribute__((__using_if_exists__));
using ::strerror __attribute__((__using_if_exists__));
using ::strlen __attribute__((__using_if_exists__));
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr size_t __constexpr_strlen(const char* __str) {
  return __builtin_strlen(__str);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr int
__constexpr_memcmp(const _Tp* __lhs, const _Tp* __rhs, size_t __count) {
  return __builtin_memcmp(__lhs, __rhs, __count);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr const char*
__constexpr_char_memchr(const char* __str, int __char, size_t __count) {
  return __builtin_char_memchr(__str, __char, __count);
}
}}
namespace std { inline namespace __1 {
template <class _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Size
__loadword(const void* __p)
{
    _Size __r;
    std::memcpy(&__r, __p, sizeof(__r));
    return __r;
}
template <class _Size, size_t = sizeof(_Size)*8>
struct __murmur2_or_cityhash;
template <class _Size>
struct __murmur2_or_cityhash<_Size, 32>
{
    inline _Size operator()(const void* __key, _Size __len)
         __attribute__((__no_sanitize__("unsigned-integer-overflow")));
};
template <class _Size>
_Size
__murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len)
{
    const _Size __m = 0x5bd1e995;
    const _Size __r = 24;
    _Size __h = __len;
    const unsigned char* __data = static_cast<const unsigned char*>(__key);
    for (; __len >= 4; __data += 4, __len -= 4)
    {
        _Size __k = std::__loadword<_Size>(__data);
        __k *= __m;
        __k ^= __k >> __r;
        __k *= __m;
        __h *= __m;
        __h ^= __k;
    }
    switch (__len)
    {
    case 3:
        __h ^= static_cast<_Size>(__data[2] << 16);
        [[fallthrough]];
    case 2:
        __h ^= static_cast<_Size>(__data[1] << 8);
        [[fallthrough]];
    case 1:
        __h ^= __data[0];
        __h *= __m;
    }
    __h ^= __h >> 13;
    __h *= __m;
    __h ^= __h >> 15;
    return __h;
}
template <class _Size>
struct __murmur2_or_cityhash<_Size, 64>
{
    inline _Size operator()(const void* __key, _Size __len) __attribute__((__no_sanitize__("unsigned-integer-overflow")));
 private:
  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;
  static const _Size __k1 = 0xb492b66fbe98f273ULL;
  static const _Size __k2 = 0x9ae16a3b2f90404fULL;
  static const _Size __k3 = 0xc949d7c7509e6557ULL;
  static _Size __rotate(_Size __val, int __shift) {
    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));
  }
  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {
    return (__val >> __shift) | (__val << (64 - __shift));
  }
  static _Size __shift_mix(_Size __val) {
    return __val ^ (__val >> 47);
  }
  static _Size __hash_len_16(_Size __u, _Size __v)
     __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    const _Size __mul = 0x9ddfea08eb382d69ULL;
    _Size __a = (__u ^ __v) * __mul;
    __a ^= (__a >> 47);
    _Size __b = (__v ^ __a) * __mul;
    __b ^= (__b >> 47);
    __b *= __mul;
    return __b;
  }
  static _Size __hash_len_0_to_16(const char* __s, _Size __len)
     __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    if (__len > 8) {
      const _Size __a = std::__loadword<_Size>(__s);
      const _Size __b = std::__loadword<_Size>(__s + __len - 8);
      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;
    }
    if (__len >= 4) {
      const uint32_t __a = std::__loadword<uint32_t>(__s);
      const uint32_t __b = std::__loadword<uint32_t>(__s + __len - 4);
      return __hash_len_16(__len + (__a << 3), __b);
    }
    if (__len > 0) {
      const unsigned char __a = static_cast<unsigned char>(__s[0]);
      const unsigned char __b = static_cast<unsigned char>(__s[__len >> 1]);
      const unsigned char __c = static_cast<unsigned char>(__s[__len - 1]);
      const uint32_t __y = static_cast<uint32_t>(__a) +
                           (static_cast<uint32_t>(__b) << 8);
      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);
      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;
    }
    return __k2;
  }
  static _Size __hash_len_17_to_32(const char *__s, _Size __len)
     __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    const _Size __a = std::__loadword<_Size>(__s) * __k1;
    const _Size __b = std::__loadword<_Size>(__s + 8);
    const _Size __c = std::__loadword<_Size>(__s + __len - 8) * __k2;
    const _Size __d = std::__loadword<_Size>(__s + __len - 16) * __k0;
    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,
                         __a + __rotate(__b ^ __k3, 20) - __c + __len);
  }
  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(
      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b)
        __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    __a += __w;
    __b = __rotate(__b + __a + __z, 21);
    const _Size __c = __a;
    __a += __x;
    __a += __y;
    __b += __rotate(__a, 44);
    return pair<_Size, _Size>(__a + __z, __b + __c);
  }
  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(
      const char* __s, _Size __a, _Size __b)
    __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    return __weak_hash_len_32_with_seeds(std::__loadword<_Size>(__s),
                                         std::__loadword<_Size>(__s + 8),
                                         std::__loadword<_Size>(__s + 16),
                                         std::__loadword<_Size>(__s + 24),
                                         __a,
                                         __b);
  }
  static _Size __hash_len_33_to_64(const char *__s, size_t __len)
    __attribute__((__no_sanitize__("unsigned-integer-overflow")))
  {
    _Size __z = std::__loadword<_Size>(__s + 24);
    _Size __a = std::__loadword<_Size>(__s) +
                (__len + std::__loadword<_Size>(__s + __len - 16)) * __k0;
    _Size __b = __rotate(__a + __z, 52);
    _Size __c = __rotate(__a, 37);
    __a += std::__loadword<_Size>(__s + 8);
    __c += __rotate(__a, 7);
    __a += std::__loadword<_Size>(__s + 16);
    _Size __vf = __a + __z;
    _Size __vs = __b + __rotate(__a, 31) + __c;
    __a = std::__loadword<_Size>(__s + 16) + std::__loadword<_Size>(__s + __len - 32);
    __z += std::__loadword<_Size>(__s + __len - 8);
    __b = __rotate(__a + __z, 52);
    __c = __rotate(__a, 37);
    __a += std::__loadword<_Size>(__s + __len - 24);
    __c += __rotate(__a, 7);
    __a += std::__loadword<_Size>(__s + __len - 16);
    _Size __wf = __a + __z;
    _Size __ws = __b + __rotate(__a, 31) + __c;
    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);
    return __shift_mix(__r * __k0 + __vs) * __k2;
  }
};
template <class _Size>
_Size
__murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len)
{
  const char* __s = static_cast<const char*>(__key);
  if (__len <= 32) {
    if (__len <= 16) {
      return __hash_len_0_to_16(__s, __len);
    } else {
      return __hash_len_17_to_32(__s, __len);
    }
  } else if (__len <= 64) {
    return __hash_len_33_to_64(__s, __len);
  }
  _Size __x = std::__loadword<_Size>(__s + __len - 40);
  _Size __y = std::__loadword<_Size>(__s + __len - 16) +
              std::__loadword<_Size>(__s + __len - 56);
  _Size __z = __hash_len_16(std::__loadword<_Size>(__s + __len - 48) + __len,
                          std::__loadword<_Size>(__s + __len - 24));
  pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);
  pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);
  __x = __x * __k1 + std::__loadword<_Size>(__s);
  __len = (__len - 1) & ~static_cast<_Size>(63);
  do {
    __x = __rotate(__x + __y + __v.first + std::__loadword<_Size>(__s + 8), 37) * __k1;
    __y = __rotate(__y + __v.second + std::__loadword<_Size>(__s + 48), 42) * __k1;
    __x ^= __w.second;
    __y += __v.first + std::__loadword<_Size>(__s + 40);
    __z = __rotate(__z + __w.first, 33) * __k1;
    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);
    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,
                                        __y + std::__loadword<_Size>(__s + 16));
    std::swap(__z, __x);
    __s += 64;
    __len -= 64;
  } while (__len != 0);
  return __hash_len_16(
      __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,
      __hash_len_16(__v.second, __w.second) + __x);
}
template <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>
struct __scalar_hash;
template <class _Tp>
struct __scalar_hash<_Tp, 0>
    : public __unary_function<_Tp, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            size_t __a;
        } __u;
        __u.__a = 0;
        __u.__t = __v;
        return __u.__a;
    }
};
template <class _Tp>
struct __scalar_hash<_Tp, 1>
    : public __unary_function<_Tp, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            size_t __a;
        } __u;
        __u.__t = __v;
        return __u.__a;
    }
};
template <class _Tp>
struct __scalar_hash<_Tp, 2>
    : public __unary_function<_Tp, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
            } __s;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};
template <class _Tp>
struct __scalar_hash<_Tp, 3>
    : public __unary_function<_Tp, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
                size_t __c;
            } __s;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};
template <class _Tp>
struct __scalar_hash<_Tp, 4>
    : public __unary_function<_Tp, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    size_t operator()(_Tp __v) const noexcept
    {
        union
        {
            _Tp __t;
            struct
            {
                size_t __a;
                size_t __b;
                size_t __c;
                size_t __d;
            } __s;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};
struct _PairT {
  size_t first;
  size_t second;
};
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
inline size_t __hash_combine(size_t __lhs, size_t __rhs) noexcept {
    typedef __scalar_hash<_PairT> _HashT;
    const _PairT __p = {__lhs, __rhs};
    return _HashT()(__p);
}
template<class _Tp>
struct __attribute__((__type_visibility__("default"))) hash<_Tp*>
    : public __unary_function<_Tp*, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    size_t operator()(_Tp* __v) const noexcept
    {
        union
        {
            _Tp* __t;
            size_t __a;
        } __u;
        __u.__t = __v;
        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
    }
};
template <>
struct __attribute__((__type_visibility__("default"))) hash<bool>
    : public __unary_function<bool, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    size_t operator()(bool __v) const noexcept {return static_cast<size_t>(__v);}
};
template <>
struct __attribute__((__type_visibility__("default"))) hash<char>
    : public __unary_function<char, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    size_t operator()(char __v) const noexcept {return static_cast<size_t>(__v);}
};
template <>
struct __attribute__((__type_visibility__("default"))) hash<signed char>
    : public __unary_function<signed char, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    size_t operator()(signed char __v) const noexcept {return static_cast<size_t>(__v);}
};
template <>
struct __attribute__((__type_visibility__("default"))) hash<unsigned char>
    : public __unary_function<unsigned char, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    size_t operator()(unsigned char __v) const noexcept {return static_cast<size_t>(__v);}
};
template <>
struct __attribute__((__type_visibility__("default"))) hash<char8_t>
    : public __unary_function<char8_t, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    size_t operator()(char8_t __v) const noexcept {return static_cast<size_t>(__v);}
};
template <>
struct __attribute__((__type_visibility__("default"))) hash<char16_t>
    : public __unary_function<char16_t, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    size_t operator()(char16_t __v) const noexcept {return static_cast<size_t>(__v);}
};
template <>
struct __attribute__((__type_visibility__("default"))) hash<char32_t>
    : public __unary_function<char32_t, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    size_t operator()(char32_t __v) const noexcept {return static_cast<size_t>(__v);}
};
template <>
struct __attribute__((__type_visibility__("default"))) hash<wchar_t>
    : public __unary_function<wchar_t, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    size_t operator()(wchar_t __v) const noexcept {return static_cast<size_t>(__v);}
};
template <>
struct __attribute__((__type_visibility__("default"))) hash<short>
    : public __unary_function<short, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    size_t operator()(short __v) const noexcept {return static_cast<size_t>(__v);}
};
template <>
struct __attribute__((__type_visibility__("default"))) hash<unsigned short>
    : public __unary_function<unsigned short, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    size_t operator()(unsigned short __v) const noexcept {return static_cast<size_t>(__v);}
};
template <>
struct __attribute__((__type_visibility__("default"))) hash<int>
    : public __unary_function<int, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    size_t operator()(int __v) const noexcept {return static_cast<size_t>(__v);}
};
template <>
struct __attribute__((__type_visibility__("default"))) hash<unsigned int>
    : public __unary_function<unsigned int, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    size_t operator()(unsigned int __v) const noexcept {return static_cast<size_t>(__v);}
};
template <>
struct __attribute__((__type_visibility__("default"))) hash<long>
    : public __unary_function<long, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    size_t operator()(long __v) const noexcept {return static_cast<size_t>(__v);}
};
template <>
struct __attribute__((__type_visibility__("default"))) hash<unsigned long>
    : public __unary_function<unsigned long, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    size_t operator()(unsigned long __v) const noexcept {return static_cast<size_t>(__v);}
};
template <>
struct __attribute__((__type_visibility__("default"))) hash<long long>
    : public __scalar_hash<long long>
{
};
template <>
struct __attribute__((__type_visibility__("default"))) hash<unsigned long long>
    : public __scalar_hash<unsigned long long>
{
};
template <>
struct __attribute__((__type_visibility__("default"))) hash<__int128_t>
    : public __scalar_hash<__int128_t>
{
};
template <>
struct __attribute__((__type_visibility__("default"))) hash<__uint128_t>
    : public __scalar_hash<__uint128_t>
{
};
template <>
struct __attribute__((__type_visibility__("default"))) hash<float>
    : public __scalar_hash<float>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    size_t operator()(float __v) const noexcept
    {
       if (__v == 0.0f)
           return 0;
        return __scalar_hash<float>::operator()(__v);
    }
};
template <>
struct __attribute__((__type_visibility__("default"))) hash<double>
    : public __scalar_hash<double>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    size_t operator()(double __v) const noexcept
    {
       if (__v == 0.0)
           return 0;
        return __scalar_hash<double>::operator()(__v);
    }
};
template <>
struct __attribute__((__type_visibility__("default"))) hash<long double>
    : public __scalar_hash<long double>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    size_t operator()(long double __v) const noexcept
    {
        if (__v == 0.0L)
            return 0;
        return __scalar_hash<long double>::operator()(__v);
    }
};
template <class _Tp, bool = is_enum<_Tp>::value>
struct __attribute__((__type_visibility__("default"))) __enum_hash
    : public __unary_function<_Tp, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    size_t operator()(_Tp __v) const noexcept
    {
        typedef typename underlying_type<_Tp>::type type;
        return hash<type>()(static_cast<type>(__v));
    }
};
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) __enum_hash<_Tp, false> {
    __enum_hash() = delete;
    __enum_hash(__enum_hash const&) = delete;
    __enum_hash& operator=(__enum_hash const&) = delete;
};
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) hash : public __enum_hash<_Tp>
{
};
template <>
struct __attribute__((__type_visibility__("default"))) hash<nullptr_t>
  : public __unary_function<nullptr_t, size_t>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    size_t operator()(nullptr_t) const noexcept {
        return 662607004ull;
    }
};
template <class _Key, class _Hash>
using __check_hash_requirements __attribute__((__nodebug__)) = integral_constant<bool,
    is_copy_constructible<_Hash>::value &&
    is_move_constructible<_Hash>::value &&
    __invokable_r<size_t, _Hash, _Key const&>::value
>;
template <class _Key, class _Hash = hash<_Key> >
using __has_enabled_hash __attribute__((__nodebug__)) = integral_constant<bool,
    __check_hash_requirements<_Key, _Hash>::value &&
    is_default_constructible<_Hash>::value
>;
template <class _Type, class>
using __enable_hash_helper_imp __attribute__((__nodebug__)) = _Type;
template <class _Type, class ..._Keys>
using __enable_hash_helper __attribute__((__nodebug__)) = __enable_hash_helper_imp<_Type,
  typename enable_if<__all<__has_enabled_hash<_Keys>::value...>::value>::type
>;
}}
namespace std { inline namespace __1 {
template <class _Arg1, class _Arg2, class _Result> struct __binary_function_keep_layout_base {
};
template <class _Arg1, class _Arg2, class _Result>
using __binary_function = __binary_function_keep_layout_base<_Arg1, _Arg2, _Result>;
}}
namespace std { inline namespace __1 {
template <class _Tp = void>
struct __attribute__((__type_visibility__("default"))) plus
    : __binary_function<_Tp, _Tp, _Tp>
{
    typedef _Tp __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x + __y;}
};
template <class ..._Tag> plus(typename _Tag::__allow_ctad...) -> plus<_Tag...>;
template <>
struct __attribute__((__type_visibility__("default"))) plus<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) + std::forward<_T2>(__u)))
        -> decltype( std::forward<_T1>(__t) + std::forward<_T2>(__u))
        { return std::forward<_T1>(__t) + std::forward<_T2>(__u); }
    typedef void is_transparent;
};
template <class _Tp = void>
struct __attribute__((__type_visibility__("default"))) minus
    : __binary_function<_Tp, _Tp, _Tp>
{
    typedef _Tp __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x - __y;}
};
template <class ..._Tag> minus(typename _Tag::__allow_ctad...) -> minus<_Tag...>;
template <>
struct __attribute__((__type_visibility__("default"))) minus<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) - std::forward<_T2>(__u)))
        -> decltype( std::forward<_T1>(__t) - std::forward<_T2>(__u))
        { return std::forward<_T1>(__t) - std::forward<_T2>(__u); }
    typedef void is_transparent;
};
template <class _Tp = void>
struct __attribute__((__type_visibility__("default"))) multiplies
    : __binary_function<_Tp, _Tp, _Tp>
{
    typedef _Tp __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x * __y;}
};
template <class ..._Tag> multiplies(typename _Tag::__allow_ctad...) -> multiplies<_Tag...>;
template <>
struct __attribute__((__type_visibility__("default"))) multiplies<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) * std::forward<_T2>(__u)))
        -> decltype( std::forward<_T1>(__t) * std::forward<_T2>(__u))
        { return std::forward<_T1>(__t) * std::forward<_T2>(__u); }
    typedef void is_transparent;
};
template <class _Tp = void>
struct __attribute__((__type_visibility__("default"))) divides
    : __binary_function<_Tp, _Tp, _Tp>
{
    typedef _Tp __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x / __y;}
};
template <class ..._Tag> divides(typename _Tag::__allow_ctad...) -> divides<_Tag...>;
template <>
struct __attribute__((__type_visibility__("default"))) divides<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) / std::forward<_T2>(__u)))
        -> decltype( std::forward<_T1>(__t) / std::forward<_T2>(__u))
        { return std::forward<_T1>(__t) / std::forward<_T2>(__u); }
    typedef void is_transparent;
};
template <class _Tp = void>
struct __attribute__((__type_visibility__("default"))) modulus
    : __binary_function<_Tp, _Tp, _Tp>
{
    typedef _Tp __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x % __y;}
};
template <class ..._Tag> modulus(typename _Tag::__allow_ctad...) -> modulus<_Tag...>;
template <>
struct __attribute__((__type_visibility__("default"))) modulus<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) % std::forward<_T2>(__u)))
        -> decltype( std::forward<_T1>(__t) % std::forward<_T2>(__u))
        { return std::forward<_T1>(__t) % std::forward<_T2>(__u); }
    typedef void is_transparent;
};
template <class _Tp = void>
struct __attribute__((__type_visibility__("default"))) negate
    : __unary_function<_Tp, _Tp>
{
    typedef _Tp __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp operator()(const _Tp& __x) const
        {return -__x;}
};
template <class ..._Tag> negate(typename _Tag::__allow_ctad...) -> negate<_Tag...>;
template <>
struct __attribute__((__type_visibility__("default"))) negate<void>
{
    template <class _Tp>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    auto operator()(_Tp&& __x) const
        noexcept(noexcept(- std::forward<_Tp>(__x)))
        -> decltype( - std::forward<_Tp>(__x))
        { return - std::forward<_Tp>(__x); }
    typedef void is_transparent;
};
template <class _Tp = void>
struct __attribute__((__type_visibility__("default"))) bit_and
    : __binary_function<_Tp, _Tp, _Tp>
{
    typedef _Tp __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x & __y;}
};
template <class ..._Tag> bit_and(typename _Tag::__allow_ctad...) -> bit_and<_Tag...>;
template <>
struct __attribute__((__type_visibility__("default"))) bit_and<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) & std::forward<_T2>(__u)))
        -> decltype( std::forward<_T1>(__t) & std::forward<_T2>(__u))
        { return std::forward<_T1>(__t) & std::forward<_T2>(__u); }
    typedef void is_transparent;
};
template <class _Tp = void>
struct __attribute__((__type_visibility__("default"))) bit_not
    : __unary_function<_Tp, _Tp>
{
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp operator()(const _Tp& __x) const
        {return ~__x;}
};
template <class ..._Tag> bit_not(typename _Tag::__allow_ctad...) -> bit_not<_Tag...>;
template <>
struct __attribute__((__type_visibility__("default"))) bit_not<void>
{
    template <class _Tp>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    auto operator()(_Tp&& __x) const
        noexcept(noexcept(~std::forward<_Tp>(__x)))
        -> decltype( ~std::forward<_Tp>(__x))
        { return ~std::forward<_Tp>(__x); }
    typedef void is_transparent;
};
template <class _Tp = void>
struct __attribute__((__type_visibility__("default"))) bit_or
    : __binary_function<_Tp, _Tp, _Tp>
{
    typedef _Tp __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x | __y;}
};
template <class ..._Tag> bit_or(typename _Tag::__allow_ctad...) -> bit_or<_Tag...>;
template <>
struct __attribute__((__type_visibility__("default"))) bit_or<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) | std::forward<_T2>(__u)))
        -> decltype( std::forward<_T1>(__t) | std::forward<_T2>(__u))
        { return std::forward<_T1>(__t) | std::forward<_T2>(__u); }
    typedef void is_transparent;
};
template <class _Tp = void>
struct __attribute__((__type_visibility__("default"))) bit_xor
    : __binary_function<_Tp, _Tp, _Tp>
{
    typedef _Tp __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp operator()(const _Tp& __x, const _Tp& __y) const
        {return __x ^ __y;}
};
template <class ..._Tag> bit_xor(typename _Tag::__allow_ctad...) -> bit_xor<_Tag...>;
template <>
struct __attribute__((__type_visibility__("default"))) bit_xor<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) ^ std::forward<_T2>(__u)))
        -> decltype( std::forward<_T1>(__t) ^ std::forward<_T2>(__u))
        { return std::forward<_T1>(__t) ^ std::forward<_T2>(__u); }
    typedef void is_transparent;
};
template <class _Tp = void>
struct __attribute__((__type_visibility__("default"))) equal_to
    : __binary_function<_Tp, _Tp, bool>
{
    typedef bool __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x == __y;}
};
template <class ..._Tag> equal_to(typename _Tag::__allow_ctad...) -> equal_to<_Tag...>;
template <>
struct __attribute__((__type_visibility__("default"))) equal_to<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) == std::forward<_T2>(__u)))
        -> decltype( std::forward<_T1>(__t) == std::forward<_T2>(__u))
        { return std::forward<_T1>(__t) == std::forward<_T2>(__u); }
    typedef void is_transparent;
};
template <class _Tp = void>
struct __attribute__((__type_visibility__("default"))) not_equal_to
    : __binary_function<_Tp, _Tp, bool>
{
    typedef bool __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x != __y;}
};
template <class ..._Tag> not_equal_to(typename _Tag::__allow_ctad...) -> not_equal_to<_Tag...>;
template <>
struct __attribute__((__type_visibility__("default"))) not_equal_to<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) != std::forward<_T2>(__u)))
        -> decltype( std::forward<_T1>(__t) != std::forward<_T2>(__u))
        { return std::forward<_T1>(__t) != std::forward<_T2>(__u); }
    typedef void is_transparent;
};
template <class _Tp = void>
struct __attribute__((__type_visibility__("default"))) less
    : __binary_function<_Tp, _Tp, bool>
{
    typedef bool __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x < __y;}
};
template <class ..._Tag> less(typename _Tag::__allow_ctad...) -> less<_Tag...>;
template <>
struct __attribute__((__type_visibility__("default"))) less<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) < std::forward<_T2>(__u)))
        -> decltype( std::forward<_T1>(__t) < std::forward<_T2>(__u))
        { return std::forward<_T1>(__t) < std::forward<_T2>(__u); }
    typedef void is_transparent;
};
template <class _Tp = void>
struct __attribute__((__type_visibility__("default"))) less_equal
    : __binary_function<_Tp, _Tp, bool>
{
    typedef bool __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x <= __y;}
};
template <class ..._Tag> less_equal(typename _Tag::__allow_ctad...) -> less_equal<_Tag...>;
template <>
struct __attribute__((__type_visibility__("default"))) less_equal<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) <= std::forward<_T2>(__u)))
        -> decltype( std::forward<_T1>(__t) <= std::forward<_T2>(__u))
        { return std::forward<_T1>(__t) <= std::forward<_T2>(__u); }
    typedef void is_transparent;
};
template <class _Tp = void>
struct __attribute__((__type_visibility__("default"))) greater_equal
    : __binary_function<_Tp, _Tp, bool>
{
    typedef bool __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x >= __y;}
};
template <class ..._Tag> greater_equal(typename _Tag::__allow_ctad...) -> greater_equal<_Tag...>;
template <>
struct __attribute__((__type_visibility__("default"))) greater_equal<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) >= std::forward<_T2>(__u)))
        -> decltype( std::forward<_T1>(__t) >= std::forward<_T2>(__u))
        { return std::forward<_T1>(__t) >= std::forward<_T2>(__u); }
    typedef void is_transparent;
};
template <class _Tp = void>
struct __attribute__((__type_visibility__("default"))) greater
    : __binary_function<_Tp, _Tp, bool>
{
    typedef bool __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x > __y;}
};
template <class ..._Tag> greater(typename _Tag::__allow_ctad...) -> greater<_Tag...>;
template <>
struct __attribute__((__type_visibility__("default"))) greater<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) > std::forward<_T2>(__u)))
        -> decltype( std::forward<_T1>(__t) > std::forward<_T2>(__u))
        { return std::forward<_T1>(__t) > std::forward<_T2>(__u); }
    typedef void is_transparent;
};
template <class _Tp = void>
struct __attribute__((__type_visibility__("default"))) logical_and
    : __binary_function<_Tp, _Tp, bool>
{
    typedef bool __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x && __y;}
};
template <class ..._Tag> logical_and(typename _Tag::__allow_ctad...) -> logical_and<_Tag...>;
template <>
struct __attribute__((__type_visibility__("default"))) logical_and<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) && std::forward<_T2>(__u)))
        -> decltype( std::forward<_T1>(__t) && std::forward<_T2>(__u))
        { return std::forward<_T1>(__t) && std::forward<_T2>(__u); }
    typedef void is_transparent;
};
template <class _Tp = void>
struct __attribute__((__type_visibility__("default"))) logical_not
    : __unary_function<_Tp, bool>
{
    typedef bool __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool operator()(const _Tp& __x) const
        {return !__x;}
};
template <class ..._Tag> logical_not(typename _Tag::__allow_ctad...) -> logical_not<_Tag...>;
template <>
struct __attribute__((__type_visibility__("default"))) logical_not<void>
{
    template <class _Tp>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    auto operator()(_Tp&& __x) const
        noexcept(noexcept(!std::forward<_Tp>(__x)))
        -> decltype( !std::forward<_Tp>(__x))
        { return !std::forward<_Tp>(__x); }
    typedef void is_transparent;
};
template <class _Tp = void>
struct __attribute__((__type_visibility__("default"))) logical_or
    : __binary_function<_Tp, _Tp, bool>
{
    typedef bool __result_type;
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool operator()(const _Tp& __x, const _Tp& __y) const
        {return __x || __y;}
};
template <class ..._Tag> logical_or(typename _Tag::__allow_ctad...) -> logical_or<_Tag...>;
template <>
struct __attribute__((__type_visibility__("default"))) logical_or<void>
{
    template <class _T1, class _T2>
    constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    auto operator()(_T1&& __t, _T2&& __u) const
        noexcept(noexcept(std::forward<_T1>(__t) || std::forward<_T2>(__u)))
        -> decltype( std::forward<_T1>(__t) || std::forward<_T2>(__u))
        { return std::forward<_T1>(__t) || std::forward<_T2>(__u); }
    typedef void is_transparent;
};
}}
namespace std { inline namespace __1 {
template <class _Tp, size_t _Np>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_Tp*
begin(_Tp (&__array)[_Np])
{
    return __array;
}
template <class _Tp, size_t _Np>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_Tp*
end(_Tp (&__array)[_Np])
{
    return __array + _Np;
}
template <class _Cp>
// added by concept-synth, original LN: 10977
requires
requires (_Cp o) { o.begin(); }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
auto
begin(_Cp& __c) -> decltype(__c.begin())
{
    return __c.begin();
}
template <class _Cp>
// added by concept-synth, original LN: 10984
requires
requires (_Cp o) { o.begin(); }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
auto
begin(const _Cp& __c) -> decltype(__c.begin())
{
    return __c.begin();
}
template <class _Cp>
// added by concept-synth, original LN: 10991
requires
requires (_Cp o) { o.end(); }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
auto
end(_Cp& __c) -> decltype(__c.end())
{
    return __c.end();
}
template <class _Cp>
// added by concept-synth, original LN: 10998
requires
requires (_Cp o) { o.end(); }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
auto
end(const _Cp& __c) -> decltype(__c.end())
{
    return __c.end();
}
template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
auto cbegin(const _Cp& __c) -> decltype(std::begin(__c))
{
    return std::begin(__c);
}
template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
auto cend(const _Cp& __c) -> decltype(std::end(__c))
{
    return std::end(__c);
}
}}

namespace std { inline namespace __1 {
template <typename _Tp>
__attribute__((__always_inline__)) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr void* __voidify(_Tp& __from) {
  return const_cast<void*>(static_cast<const volatile void*>(std::addressof(__from)));
}
}}
namespace std { inline namespace __1 {
template <class _Tp, class... _Args, class = decltype(::new(std::declval<void*>()) _Tp(std::declval<_Args>()...))>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Tp* construct_at(_Tp* __location, _Args&&... __args) {
  (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
  __builtin_assume(static_cast<bool>(__location != nullptr))
#pragma clang diagnostic pop
  );
  return ::new (std::__voidify(*__location)) _Tp(std::forward<_Args>(__args)...);
}
template <class _Tp, class... _Args, class = decltype(::new(std::declval<void*>()) _Tp(std::declval<_Args>()...))>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Tp* __construct_at(_Tp* __location, _Args&&... __args) {
  return std::construct_at(__location, std::forward<_Args>(__args)...);
}
template <class _ForwardIterator>
// added by concept-synth, original LN: 11065
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_ForwardIterator __destroy(_ForwardIterator, _ForwardIterator);
template <class _Tp, typename enable_if<!is_array<_Tp>::value, int>::type = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void __destroy_at(_Tp* __loc) {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(__loc != nullptr))
#pragma clang diagnostic pop
    );
    __loc->~_Tp();
}
template <class _Tp, typename enable_if<is_array<_Tp>::value, int>::type = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void __destroy_at(_Tp* __loc) {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(__loc != nullptr))
#pragma clang diagnostic pop
    );
    std::__destroy(std::begin(*__loc), std::end(*__loc));
}
template <class _ForwardIterator>
// added by concept-synth, original LN: 11065
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_ForwardIterator __destroy(_ForwardIterator __first, _ForwardIterator __last) {
    for (; __first != __last; ++__first)
        std::__destroy_at(std::addressof(*__first));
    return __first;
}
template <class _BidirectionalIterator>
// added by concept-synth, original LN: 11072
requires
(
 requires (_BidirectionalIterator x0) { *x0; } &&
 requires (_BidirectionalIterator x0) { --x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_BidirectionalIterator __reverse_destroy(_BidirectionalIterator __first, _BidirectionalIterator __last) {
    while (__last != __first) {
        --__last;
        std::__destroy_at(std::addressof(*__last));
    }
    return __last;
}
template <class _Tp, enable_if_t<!is_array_v<_Tp>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void destroy_at(_Tp* __loc) {
    std::__destroy_at(__loc);
}
template <class _Tp, enable_if_t<is_array_v<_Tp>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void destroy_at(_Tp* __loc) {
  std::__destroy_at(__loc);
}
template <class _ForwardIterator>
// added by concept-synth, original LN: 11091
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void destroy(_ForwardIterator __first, _ForwardIterator __last) {
  (void)std::__destroy(std::move(__first), std::move(__last));
}
template <class _ForwardIterator, class _Size>
// added by concept-synth, original LN: 11096
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
) &&
requires (_Size x0) { --x0; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_ForwardIterator destroy_n(_ForwardIterator __first, _Size __n) {
    for (; __n > 0; (void)++__first, --__n)
        std::__destroy_at(std::addressof(*__first));
    return __first;
}
}}

namespace std { inline namespace __1 {
template <class _Tp, class = void> struct __has_pointer : false_type { }; template <class _Tp> struct __has_pointer<_Tp, __void_t<typename _Tp:: pointer > > : true_type { };
template <class _Tp, class _Alloc,
          class _RawAlloc = __libcpp_remove_reference_t<_Alloc>,
          bool = __has_pointer<_RawAlloc>::value>
struct __pointer {
    using type __attribute__((__nodebug__)) = typename _RawAlloc::pointer;
};
template <class _Tp, class _Alloc, class _RawAlloc>
struct __pointer<_Tp, _Alloc, _RawAlloc, false> {
    using type __attribute__((__nodebug__)) = _Tp*;
};
template <class _Tp, class = void> struct __has_const_pointer : false_type { }; template <class _Tp> struct __has_const_pointer<_Tp, __void_t<typename _Tp:: const_pointer > > : true_type { };
template <class _Tp, class _Ptr, class _Alloc,
          bool = __has_const_pointer<_Alloc>::value>
struct __const_pointer {
    using type __attribute__((__nodebug__)) = typename _Alloc::const_pointer;
};
template <class _Tp, class _Ptr, class _Alloc>
struct __const_pointer<_Tp, _Ptr, _Alloc, false> {
    using type __attribute__((__nodebug__)) = typename pointer_traits<_Ptr>::template rebind<const _Tp>;
};
template <class _Tp, class = void> struct __has_void_pointer : false_type { }; template <class _Tp> struct __has_void_pointer<_Tp, __void_t<typename _Tp:: void_pointer > > : true_type { };
template <class _Ptr, class _Alloc,
          bool = __has_void_pointer<_Alloc>::value>
struct __void_pointer {
    using type __attribute__((__nodebug__)) = typename _Alloc::void_pointer;
};
template <class _Ptr, class _Alloc>
struct __void_pointer<_Ptr, _Alloc, false> {
    using type __attribute__((__nodebug__)) = typename pointer_traits<_Ptr>::template rebind<void>;
};
template <class _Tp, class = void> struct __has_const_void_pointer : false_type { }; template <class _Tp> struct __has_const_void_pointer<_Tp, __void_t<typename _Tp:: const_void_pointer > > : true_type { };
template <class _Ptr, class _Alloc,
          bool = __has_const_void_pointer<_Alloc>::value>
struct __const_void_pointer {
    using type __attribute__((__nodebug__)) = typename _Alloc::const_void_pointer;
};
template <class _Ptr, class _Alloc>
struct __const_void_pointer<_Ptr, _Alloc, false> {
    using type __attribute__((__nodebug__)) = typename pointer_traits<_Ptr>::template rebind<const void>;
};
template <class _Tp, class = void> struct __has_size_type : false_type { }; template <class _Tp> struct __has_size_type<_Tp, __void_t<typename _Tp:: size_type > > : true_type { };
template <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>
struct __size_type : make_unsigned<_DiffType> { };
template <class _Alloc, class _DiffType>
struct __size_type<_Alloc, _DiffType, true> {
    using type __attribute__((__nodebug__)) = typename _Alloc::size_type;
};
template <class _Tp, class = void> struct __has_alloc_traits_difference_type : false_type { }; template <class _Tp> struct __has_alloc_traits_difference_type<_Tp, __void_t<typename _Tp:: difference_type > > : true_type { };
template <class _Alloc, class _Ptr, bool = __has_alloc_traits_difference_type<_Alloc>::value>
struct __alloc_traits_difference_type {
    using type __attribute__((__nodebug__)) = typename pointer_traits<_Ptr>::difference_type;
};
template <class _Alloc, class _Ptr>
struct __alloc_traits_difference_type<_Alloc, _Ptr, true> {
    using type __attribute__((__nodebug__)) = typename _Alloc::difference_type;
};
template <class _Tp, class = void> struct __has_propagate_on_container_copy_assignment : false_type { }; template <class _Tp> struct __has_propagate_on_container_copy_assignment<_Tp, __void_t<typename _Tp:: propagate_on_container_copy_assignment > > : true_type { };
template <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>
struct __propagate_on_container_copy_assignment : false_type { };
template <class _Alloc>
struct __propagate_on_container_copy_assignment<_Alloc, true> {
    using type __attribute__((__nodebug__)) = typename _Alloc::propagate_on_container_copy_assignment;
};
template <class _Tp, class = void> struct __has_propagate_on_container_move_assignment : false_type { }; template <class _Tp> struct __has_propagate_on_container_move_assignment<_Tp, __void_t<typename _Tp:: propagate_on_container_move_assignment > > : true_type { };
template <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>
struct __propagate_on_container_move_assignment : false_type { };
template <class _Alloc>
struct __propagate_on_container_move_assignment<_Alloc, true> {
    using type __attribute__((__nodebug__)) = typename _Alloc::propagate_on_container_move_assignment;
};
template <class _Tp, class = void> struct __has_propagate_on_container_swap : false_type { }; template <class _Tp> struct __has_propagate_on_container_swap<_Tp, __void_t<typename _Tp:: propagate_on_container_swap > > : true_type { };
template <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>
struct __propagate_on_container_swap : false_type { };
template <class _Alloc>
struct __propagate_on_container_swap<_Alloc, true> {
    using type __attribute__((__nodebug__)) = typename _Alloc::propagate_on_container_swap;
};
template <class _Tp, class = void> struct __has_is_always_equal : false_type { }; template <class _Tp> struct __has_is_always_equal<_Tp, __void_t<typename _Tp:: is_always_equal > > : true_type { };
template <class _Alloc, bool = __has_is_always_equal<_Alloc>::value>
struct __is_always_equal : is_empty<_Alloc> { };
template <class _Alloc>
struct __is_always_equal<_Alloc, true> {
    using type __attribute__((__nodebug__)) = typename _Alloc::is_always_equal;
};
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Tp, class _Up, class = void>
struct __has_rebind_other : false_type { };
template <class _Tp, class _Up>
struct __has_rebind_other<_Tp, _Up, __void_t<typename _Tp::template rebind<_Up>::other> > : true_type { };
template <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>
struct __allocator_traits_rebind {
  static_assert(__has_rebind_other<_Tp, _Up>::value, "This allocator has to implement rebind");
  using type __attribute__((__nodebug__)) = typename _Tp::template rebind<_Up>::other;
};
template <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true> {
    using type __attribute__((__nodebug__)) = typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other;
};
template <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false> {
    using type __attribute__((__nodebug__)) = _Alloc<_Up, _Args...>;
};
#pragma GCC diagnostic pop
template<class _Alloc, class _Tp>
using __allocator_traits_rebind_t = typename __allocator_traits_rebind<_Alloc, _Tp>::type;
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Alloc, class _SizeType, class _ConstVoidPtr, class = void>
struct __has_allocate_hint : false_type { };
template <class _Alloc, class _SizeType, class _ConstVoidPtr>
struct __has_allocate_hint<_Alloc, _SizeType, _ConstVoidPtr, decltype(
    (void)std::declval<_Alloc>().allocate(std::declval<_SizeType>(), std::declval<_ConstVoidPtr>())
)> : true_type { };
template <class, class _Alloc, class ..._Args>
struct __has_construct_impl : false_type { };
template <class _Alloc, class ..._Args>
struct __has_construct_impl<decltype(
    (void)std::declval<_Alloc>().construct(std::declval<_Args>()...)
), _Alloc, _Args...> : true_type { };
template <class _Alloc, class ..._Args>
struct __has_construct : __has_construct_impl<void, _Alloc, _Args...> { };
template <class _Alloc, class _Pointer, class = void>
struct __has_destroy : false_type { };
template <class _Alloc, class _Pointer>
struct __has_destroy<_Alloc, _Pointer, decltype(
    (void)std::declval<_Alloc>().destroy(std::declval<_Pointer>())
)> : true_type { };
template <class _Alloc, class = void>
struct __has_max_size : false_type { };
template <class _Alloc>
struct __has_max_size<_Alloc, decltype(
    (void)std::declval<_Alloc&>().max_size()
)> : true_type { };
template <class _Alloc, class = void>
struct __has_select_on_container_copy_construction : false_type { };
template <class _Alloc>
struct __has_select_on_container_copy_construction<_Alloc, decltype(
    (void)std::declval<_Alloc>().select_on_container_copy_construction()
)> : true_type { };
#pragma GCC diagnostic pop
template <class _Alloc>
struct __attribute__((__type_visibility__("default"))) allocator_traits
{
    using allocator_type = _Alloc;
    using value_type = typename allocator_type::value_type;
    using pointer = typename __pointer<value_type, allocator_type>::type;
    using const_pointer = typename __const_pointer<value_type, pointer, allocator_type>::type;
    using void_pointer = typename __void_pointer<pointer, allocator_type>::type;
    using const_void_pointer = typename __const_void_pointer<pointer, allocator_type>::type;
    using difference_type = typename __alloc_traits_difference_type<allocator_type, pointer>::type;
    using size_type = typename __size_type<allocator_type, difference_type>::type;
    using propagate_on_container_copy_assignment = typename __propagate_on_container_copy_assignment<allocator_type>::type;
    using propagate_on_container_move_assignment = typename __propagate_on_container_move_assignment<allocator_type>::type;
    using propagate_on_container_swap = typename __propagate_on_container_swap<allocator_type>::type;
    using is_always_equal = typename __is_always_equal<allocator_type>::type;
    template <class _Tp>
    using rebind_alloc = __allocator_traits_rebind_t<allocator_type, _Tp>;
    template <class _Tp>
    using rebind_traits = allocator_traits<rebind_alloc<_Tp> >;
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    static pointer allocate(allocator_type& __a, size_type __n) {
        return __a.allocate(__n);
    }
    template <class _Ap = _Alloc, class =
        __enable_if_t<__has_allocate_hint<_Ap, size_type, const_void_pointer>::value> >
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint) {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
        return __a.allocate(__n, __hint);
#pragma GCC diagnostic pop
    }
    template <class _Ap = _Alloc, class = void, class =
        __enable_if_t<!__has_allocate_hint<_Ap, size_type, const_void_pointer>::value> >
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer) {
        return __a.allocate(__n);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    static void deallocate(allocator_type& __a, pointer __p, size_type __n) noexcept {
        __a.deallocate(__p, __n);
    }
    template <class _Tp, class... _Args, class =
        __enable_if_t<__has_construct<allocator_type, _Tp*, _Args...>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args) {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
        __a.construct(__p, std::forward<_Args>(__args)...);
#pragma GCC diagnostic pop
    }
    template <class _Tp, class... _Args, class = void, class =
        __enable_if_t<!__has_construct<allocator_type, _Tp*, _Args...>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    static void construct(allocator_type&, _Tp* __p, _Args&&... __args) {
        std::construct_at(__p, std::forward<_Args>(__args)...);
    }
    template <class _Tp, class =
        __enable_if_t<__has_destroy<allocator_type, _Tp*>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    static void destroy(allocator_type& __a, _Tp* __p) {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
        __a.destroy(__p);
#pragma GCC diagnostic pop
    }
    template <class _Tp, class = void, class =
        __enable_if_t<!__has_destroy<allocator_type, _Tp*>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    static void destroy(allocator_type&, _Tp* __p) {
        std::destroy_at(__p);
    }
    template <class _Ap = _Alloc, class =
        __enable_if_t<__has_max_size<const _Ap>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    static size_type max_size(const allocator_type& __a) noexcept {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
        return __a.max_size();
#pragma GCC diagnostic pop
    }
    template <class _Ap = _Alloc, class = void, class =
        __enable_if_t<!__has_max_size<const _Ap>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    static size_type max_size(const allocator_type&) noexcept {
        return numeric_limits<size_type>::max() / sizeof(value_type);
    }
    template <class _Ap = _Alloc, class =
        __enable_if_t<__has_select_on_container_copy_construction<const _Ap>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    static allocator_type select_on_container_copy_construction(const allocator_type& __a) {
        return __a.select_on_container_copy_construction();
    }
    template <class _Ap = _Alloc, class = void, class =
        __enable_if_t<!__has_select_on_container_copy_construction<const _Ap>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    static allocator_type select_on_container_copy_construction(const allocator_type& __a) {
        return __a;
    }
};
template <class _Traits, class _Tp>
using __rebind_alloc __attribute__((__nodebug__)) = typename _Traits::template rebind_alloc<_Tp>;
template <class _Tp>
struct __is_default_allocator : false_type { };
template <class> class allocator;
template <class _Tp>
struct __is_default_allocator<allocator<_Tp> > : true_type { };
template <class _Alloc, class = void>
struct __is_cpp17_move_insertable
    : is_move_constructible<typename _Alloc::value_type>
{ };
template <class _Alloc>
struct __is_cpp17_move_insertable<_Alloc, __enable_if_t<
    !__is_default_allocator<_Alloc>::value &&
    __has_construct<_Alloc, typename _Alloc::value_type*, typename _Alloc::value_type&&>::value
> > : true_type { };
template <class _Alloc, class = void>
struct __is_cpp17_copy_insertable
    : integral_constant<bool,
        is_copy_constructible<typename _Alloc::value_type>::value &&
        __is_cpp17_move_insertable<_Alloc>::value
    >
{ };
template <class _Alloc>
struct __is_cpp17_copy_insertable<_Alloc, __enable_if_t<
    !__is_default_allocator<_Alloc>::value &&
    __has_construct<_Alloc, typename _Alloc::value_type*, const typename _Alloc::value_type&>::value
> >
    : __is_cpp17_move_insertable<_Alloc>
{ };
}}
namespace std { inline namespace __1 {
struct __default_init_tag {};
struct __value_init_tag {};
template <class _Tp, int _Idx, bool _CanBeEmptyBase = is_empty<_Tp>::value && !__libcpp_is_final<_Tp>::value>
struct __compressed_pair_elem {
  using _ParamT = _Tp;
  using reference = _Tp&;
  using const_reference = const _Tp&;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr explicit __compressed_pair_elem(__default_init_tag) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr explicit __compressed_pair_elem(__value_init_tag) : __value_() {}
  template <class _Up, class = __enable_if_t<!is_same<__compressed_pair_elem, typename decay<_Up>::type>::value> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  explicit __compressed_pair_elem(_Up&& __u) : __value_(std::forward<_Up>(__u)) {}
  template <class... _Args, size_t... _Indices>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  explicit __compressed_pair_elem(piecewise_construct_t, tuple<_Args...> __args, __tuple_indices<_Indices...>)
      : __value_(std::forward<_Args>(std::get<_Indices>(__args))...) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr reference __get() noexcept { return __value_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr const_reference __get() const noexcept { return __value_; }
private:
  _Tp __value_;
};
template <class _Tp, int _Idx>
struct __compressed_pair_elem<_Tp, _Idx, true> : private _Tp {
  using _ParamT = _Tp;
  using reference = _Tp&;
  using const_reference = const _Tp&;
  using __value_type = _Tp;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr explicit __compressed_pair_elem() = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr explicit __compressed_pair_elem(__default_init_tag) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr explicit __compressed_pair_elem(__value_init_tag) : __value_type() {}
  template <class _Up, class = __enable_if_t<!is_same<__compressed_pair_elem, typename decay<_Up>::type>::value> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  explicit __compressed_pair_elem(_Up&& __u) : __value_type(std::forward<_Up>(__u)) {}
  template <class... _Args, size_t... _Indices>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  __compressed_pair_elem(piecewise_construct_t, tuple<_Args...> __args, __tuple_indices<_Indices...>)
      : __value_type(std::forward<_Args>(std::get<_Indices>(__args))...) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr reference __get() noexcept { return *this; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr const_reference __get() const noexcept { return *this; }
};
template <class _T1, class _T2>
class __compressed_pair : private __compressed_pair_elem<_T1, 0>,
                          private __compressed_pair_elem<_T2, 1> {
public:
  static_assert((!is_same<_T1, _T2>::value),
    "__compressed_pair cannot be instantiated when T1 and T2 are the same type; "
    "The current implementation is NOT ABI-compatible with the previous implementation for this configuration");
  using _Base1 __attribute__((__nodebug__)) = __compressed_pair_elem<_T1, 0>;
  using _Base2 __attribute__((__nodebug__)) = __compressed_pair_elem<_T2, 1>;
  template <bool _Dummy = true,
    class = __enable_if_t<
        __dependent_type<is_default_constructible<_T1>, _Dummy>::value &&
        __dependent_type<is_default_constructible<_T2>, _Dummy>::value
    >
  >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  explicit __compressed_pair() : _Base1(__value_init_tag()), _Base2(__value_init_tag()) {}
  template <class _U1, class _U2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  explicit __compressed_pair(_U1&& __t1, _U2&& __t2) : _Base1(std::forward<_U1>(__t1)), _Base2(std::forward<_U2>(__t2)) {}
  template <class... _Args1, class... _Args2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  explicit __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,
                             tuple<_Args2...> __second_args)
      : _Base1(__pc, std::move(__first_args), typename __make_tuple_indices<sizeof...(_Args1)>::type()),
        _Base2(__pc, std::move(__second_args), typename __make_tuple_indices<sizeof...(_Args2)>::type()) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  typename _Base1::reference first() noexcept {
    return static_cast<_Base1&>(*this).__get();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  typename _Base1::const_reference first() const noexcept {
    return static_cast<_Base1 const&>(*this).__get();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  typename _Base2::reference second() noexcept {
    return static_cast<_Base2&>(*this).__get();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  typename _Base2::const_reference second() const noexcept {
    return static_cast<_Base2 const&>(*this).__get();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr static
  _Base1* __get_first_base(__compressed_pair* __pair) noexcept {
    return static_cast<_Base1*>(__pair);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr static
  _Base2* __get_second_base(__compressed_pair* __pair) noexcept {
    return static_cast<_Base2*>(__pair);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  void swap(__compressed_pair& __x)
      noexcept(__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value) {
    using std::swap;
    swap(first(), __x.first());
    swap(second(), __x.second());
  }
};
template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void swap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)
    noexcept(__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value) {
  __x.swap(__y);
}
}}
namespace std { inline namespace __1 {
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) default_delete {
    static_assert(!is_function<_Tp>::value,
                  "default_delete cannot be instantiated for function types");
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr default_delete() noexcept = default;
  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) default_delete(
      const default_delete<_Up>&, typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* = 0) noexcept {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void operator()(_Tp* __ptr) const noexcept {
    static_assert(sizeof(_Tp) >= 0, "cannot delete an incomplete type");
    static_assert(!is_void<_Tp>::value, "cannot delete an incomplete type");
    delete __ptr;
  }
};
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) default_delete<_Tp[]> {
private:
  template <class _Up>
  struct _EnableIfConvertible
      : enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value> {};
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr default_delete() noexcept = default;
  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  default_delete(const default_delete<_Up[]>&, typename _EnableIfConvertible<_Up>::type* = 0) noexcept {}
  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) typename _EnableIfConvertible<_Up>::type
  operator()(_Up* __ptr) const noexcept {
    static_assert(sizeof(_Up) >= 0, "cannot delete an incomplete type");
    delete[] __ptr;
  }
};
template <class _Deleter>
struct __unique_ptr_deleter_sfinae {
  static_assert(!is_reference<_Deleter>::value, "incorrect specialization");
  typedef const _Deleter& __lval_ref_type;
  typedef _Deleter&& __good_rval_ref_type;
  typedef true_type __enable_rval_overload;
};
template <class _Deleter>
struct __unique_ptr_deleter_sfinae<_Deleter const&> {
  typedef const _Deleter& __lval_ref_type;
  typedef const _Deleter&& __bad_rval_ref_type;
  typedef false_type __enable_rval_overload;
};
template <class _Deleter>
struct __unique_ptr_deleter_sfinae<_Deleter&> {
  typedef _Deleter& __lval_ref_type;
  typedef _Deleter&& __bad_rval_ref_type;
  typedef false_type __enable_rval_overload;
};
template <class _Tp, class _Dp = default_delete<_Tp> >
class __attribute__((__type_visibility__("default"))) unique_ptr {
public:
  typedef _Tp element_type;
  typedef _Dp deleter_type;
  typedef __attribute__((__nodebug__)) typename __pointer<_Tp, deleter_type>::type pointer;
  static_assert(!is_rvalue_reference<deleter_type>::value,
                "the specified deleter type cannot be an rvalue reference");
private:
  __compressed_pair<pointer, deleter_type> __ptr_;
  struct __nat { int __for_bool_; };
  typedef __attribute__((__nodebug__)) __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;
  template <bool _Dummy>
  using _LValRefType __attribute__((__nodebug__)) =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;
  template <bool _Dummy>
  using _GoodRValRefType __attribute__((__nodebug__)) =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;
  template <bool _Dummy>
  using _BadRValRefType __attribute__((__nodebug__)) =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;
  template <bool _Dummy, class _Deleter = typename __dependent_type<
                             __type_identity<deleter_type>, _Dummy>::type>
  using _EnableIfDeleterDefaultConstructible __attribute__((__nodebug__)) =
      typename enable_if<is_default_constructible<_Deleter>::value &&
                         !is_pointer<_Deleter>::value>::type;
  template <class _ArgType>
  using _EnableIfDeleterConstructible __attribute__((__nodebug__)) =
      typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;
  template <class _UPtr, class _Up>
  using _EnableIfMoveConvertible __attribute__((__nodebug__)) = typename enable_if<
      is_convertible<typename _UPtr::pointer, pointer>::value &&
      !is_array<_Up>::value
  >::type;
  template <class _UDel>
  using _EnableIfDeleterConvertible __attribute__((__nodebug__)) = typename enable_if<
      (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||
      (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)
    >::type;
  template <class _UDel>
  using _EnableIfDeleterAssignable = typename enable_if<
      is_assignable<_Dp&, _UDel&&>::value
    >::type;
public:
  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr unique_ptr() noexcept : __ptr_(__value_init_tag(), __value_init_tag()) {}
  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr unique_ptr(nullptr_t) noexcept : __ptr_(__value_init_tag(), __value_init_tag()) {}
  template <bool _Dummy = true, class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) explicit unique_ptr(pointer __p) noexcept
      : __ptr_(__p, __value_init_tag()) {}
  template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) unique_ptr(pointer __p, _LValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, __d) {}
  template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  unique_ptr(pointer __p, _GoodRValRefType<_Dummy> __d) noexcept : __ptr_(__p, std::move(__d)) {
    static_assert(!is_reference<deleter_type>::value,
                  "rvalue deleter bound to reference");
  }
  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy> > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  unique_ptr(pointer __p, _BadRValRefType<_Dummy> __d) = delete;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) unique_ptr(unique_ptr&& __u) noexcept
      : __ptr_(__u.release(), std::forward<deleter_type>(__u.get_deleter())) {}
  template <class _Up,
            class _Ep,
            class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
            class = _EnableIfDeleterConvertible<_Ep> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
      : __ptr_(__u.release(), std::forward<_Ep>(__u.get_deleter())) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) unique_ptr& operator=(unique_ptr&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::forward<deleter_type>(__u.get_deleter());
    return *this;
  }
  template <class _Up,
            class _Ep,
            class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
            class = _EnableIfDeleterAssignable<_Ep> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) unique_ptr& operator=(unique_ptr<_Up, _Ep>&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::forward<_Ep>(__u.get_deleter());
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) ~unique_ptr() { reset(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) unique_ptr& operator=(nullptr_t) noexcept {
    reset();
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __add_lvalue_reference_t<_Tp> operator*() const {
    return *__ptr_.first();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) pointer operator->() const noexcept {
    return __ptr_.first();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) pointer get() const noexcept { return __ptr_.first(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) deleter_type& get_deleter() noexcept {
    return __ptr_.second();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) const deleter_type& get_deleter() const noexcept {
    return __ptr_.second();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) explicit operator bool() const noexcept {
    return __ptr_.first() != nullptr;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) pointer release() noexcept {
    pointer __t = __ptr_.first();
    __ptr_.first() = pointer();
    return __t;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void reset(pointer __p = pointer()) noexcept {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = __p;
    if (__tmp)
      __ptr_.second()(__tmp);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void swap(unique_ptr& __u) noexcept {
    __ptr_.swap(__u.__ptr_);
  }
};
template <class _Tp, class _Dp>
class __attribute__((__type_visibility__("default"))) unique_ptr<_Tp[], _Dp> {
public:
  typedef _Tp element_type;
  typedef _Dp deleter_type;
  typedef typename __pointer<_Tp, deleter_type>::type pointer;
private:
  __compressed_pair<pointer, deleter_type> __ptr_;
  template <class _From>
  struct _CheckArrayPointerConversion : is_same<_From, pointer> {};
  template <class _FromElem>
  struct _CheckArrayPointerConversion<_FromElem*>
      : integral_constant<bool,
          is_same<_FromElem*, pointer>::value ||
            (is_same<pointer, element_type*>::value &&
             is_convertible<_FromElem(*)[], element_type(*)[]>::value)
      >
  {};
  typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;
  template <bool _Dummy>
  using _LValRefType __attribute__((__nodebug__)) =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;
  template <bool _Dummy>
  using _GoodRValRefType __attribute__((__nodebug__)) =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;
  template <bool _Dummy>
  using _BadRValRefType __attribute__((__nodebug__)) =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;
  template <bool _Dummy, class _Deleter = typename __dependent_type<
                             __type_identity<deleter_type>, _Dummy>::type>
  using _EnableIfDeleterDefaultConstructible __attribute__((__nodebug__)) =
      typename enable_if<is_default_constructible<_Deleter>::value &&
                         !is_pointer<_Deleter>::value>::type;
  template <class _ArgType>
  using _EnableIfDeleterConstructible __attribute__((__nodebug__)) =
      typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;
  template <class _Pp>
  using _EnableIfPointerConvertible __attribute__((__nodebug__)) = typename enable_if<
      _CheckArrayPointerConversion<_Pp>::value
  >::type;
  template <class _UPtr, class _Up,
        class _ElemT = typename _UPtr::element_type>
  using _EnableIfMoveConvertible __attribute__((__nodebug__)) = typename enable_if<
      is_array<_Up>::value &&
      is_same<pointer, element_type*>::value &&
      is_same<typename _UPtr::pointer, _ElemT*>::value &&
      is_convertible<_ElemT(*)[], element_type(*)[]>::value
    >::type;
  template <class _UDel>
  using _EnableIfDeleterConvertible __attribute__((__nodebug__)) = typename enable_if<
      (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||
      (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)
    >::type;
  template <class _UDel>
  using _EnableIfDeleterAssignable __attribute__((__nodebug__)) = typename enable_if<
      is_assignable<_Dp&, _UDel&&>::value
    >::type;
public:
  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr unique_ptr() noexcept : __ptr_(__value_init_tag(), __value_init_tag()) {}
  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr unique_ptr(nullptr_t) noexcept : __ptr_(__value_init_tag(), __value_init_tag()) {}
  template <class _Pp,
            bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy>,
            class = _EnableIfPointerConvertible<_Pp> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) explicit unique_ptr(_Pp __p) noexcept
      : __ptr_(__p, __value_init_tag()) {}
  template <class _Pp,
            bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> >,
            class = _EnableIfPointerConvertible<_Pp> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) unique_ptr(_Pp __p, _LValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, __d) {}
  template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_LValRefType<_Dummy> > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) unique_ptr(nullptr_t, _LValRefType<_Dummy> __d) noexcept
      : __ptr_(nullptr, __d) {}
  template <class _Pp,
            bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> >,
            class = _EnableIfPointerConvertible<_Pp> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) unique_ptr(_Pp __p, _GoodRValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, std::move(__d)) {
    static_assert(!is_reference<deleter_type>::value,
                  "rvalue deleter bound to reference");
  }
  template <bool _Dummy = true, class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy> > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) unique_ptr(nullptr_t, _GoodRValRefType<_Dummy> __d) noexcept
      : __ptr_(nullptr, std::move(__d)) {
    static_assert(!is_reference<deleter_type>::value,
                  "rvalue deleter bound to reference");
  }
  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy> >,
            class = _EnableIfPointerConvertible<_Pp> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  unique_ptr(_Pp __p, _BadRValRefType<_Dummy> __d) = delete;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) unique_ptr(unique_ptr&& __u) noexcept
      : __ptr_(__u.release(), std::forward<deleter_type>(__u.get_deleter())) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) unique_ptr& operator=(unique_ptr&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::forward<deleter_type>(__u.get_deleter());
    return *this;
  }
  template <class _Up,
            class _Ep,
            class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
            class = _EnableIfDeleterConvertible<_Ep> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
      : __ptr_(__u.release(), std::forward<_Ep>(__u.get_deleter())) {}
  template <class _Up,
            class _Ep,
            class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
            class = _EnableIfDeleterAssignable<_Ep> >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) unique_ptr& operator=(unique_ptr<_Up, _Ep>&& __u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::forward<_Ep>(__u.get_deleter());
    return *this;
  }
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) ~unique_ptr() { reset(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) unique_ptr& operator=(nullptr_t) noexcept {
    reset();
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __add_lvalue_reference_t<_Tp>
  operator[](size_t __i) const {
    return __ptr_.first()[__i];
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) pointer get() const noexcept { return __ptr_.first(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) deleter_type& get_deleter() noexcept {
    return __ptr_.second();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) const deleter_type& get_deleter() const noexcept {
    return __ptr_.second();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) explicit operator bool() const noexcept {
    return __ptr_.first() != nullptr;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) pointer release() noexcept {
    pointer __t = __ptr_.first();
    __ptr_.first() = pointer();
    return __t;
  }
  template <class _Pp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
      typename enable_if< _CheckArrayPointerConversion<_Pp>::value >::type
      reset(_Pp __p) noexcept {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = __p;
    if (__tmp)
      __ptr_.second()(__tmp);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void reset(nullptr_t = nullptr) noexcept {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = nullptr;
    if (__tmp)
      __ptr_.second()(__tmp);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void swap(unique_ptr& __u) noexcept {
    __ptr_.swap(__u.__ptr_);
  }
};
template <class _Tp, class _Dp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    typename enable_if< __is_swappable<_Dp>::value, void >::type
    swap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) noexcept {
  __x.swap(__y);
}
template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool
operator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {
  return __x.get() == __y.get();
}
template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool
operator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)
{
    typedef typename unique_ptr<_T1, _D1>::pointer _P1;
    typedef typename unique_ptr<_T2, _D2>::pointer _P2;
    typedef typename common_type<_P1, _P2>::type _Vp;
    return less<_Vp>()(__x.get(), __y.get());
}
template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool
operator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}
template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool
operator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}
template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool
operator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}
template <class _T1, class _D1, class _T2, class _D2>
requires three_way_comparable_with<typename unique_ptr<_T1, _D1>::pointer,
                                   typename unique_ptr<_T2, _D2>::pointer>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
compare_three_way_result_t<typename unique_ptr<_T1, _D1>::pointer,
                           typename unique_ptr<_T2, _D2>::pointer>
operator<=>(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {
   return compare_three_way()(__x.get(), __y.get());
}
template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool
operator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) noexcept {
  return !__x;
}
template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool
operator<(const unique_ptr<_T1, _D1>& __x, nullptr_t) {
  typedef typename unique_ptr<_T1, _D1>::pointer _P1;
  return less<_P1>()(__x.get(), nullptr);
}
template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool
operator<(nullptr_t, const unique_ptr<_T1, _D1>& __x) {
  typedef typename unique_ptr<_T1, _D1>::pointer _P1;
  return less<_P1>()(nullptr, __x.get());
}
template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool
operator>(const unique_ptr<_T1, _D1>& __x, nullptr_t) {
  return nullptr < __x;
}
template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool
operator>(nullptr_t, const unique_ptr<_T1, _D1>& __x) {
  return __x < nullptr;
}
template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool
operator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t) {
  return !(nullptr < __x);
}
template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool
operator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x) {
  return !(__x < nullptr);
}
template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool
operator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t) {
  return !(__x < nullptr);
}
template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool
operator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x) {
  return !(nullptr < __x);
}
template <class _T1, class _D1>
  requires three_way_comparable<
      typename unique_ptr<_T1, _D1>::pointer> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
      compare_three_way_result_t<typename unique_ptr<_T1, _D1>::pointer>
operator<=>(const unique_ptr<_T1, _D1>& __x, nullptr_t) {
   return compare_three_way()(__x.get(), static_cast<typename unique_ptr<_T1, _D1>::pointer>(nullptr));
}
template<class _Tp>
struct __unique_if
{
    typedef unique_ptr<_Tp> __unique_single;
};
template<class _Tp>
struct __unique_if<_Tp[]>
{
    typedef unique_ptr<_Tp[]> __unique_array_unknown_bound;
};
template<class _Tp, size_t _Np>
struct __unique_if<_Tp[_Np]>
{
    typedef void __unique_array_known_bound;
};
template <class _Tp, class... _Args>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) typename __unique_if<_Tp>::__unique_single
make_unique(_Args&&... __args) {
  return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...));
}
template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) typename __unique_if<_Tp>::__unique_array_unknown_bound
make_unique(size_t __n) {
  typedef __remove_extent_t<_Tp> _Up;
  return unique_ptr<_Tp>(new _Up[__n]());
}
template<class _Tp, class... _Args>
    typename __unique_if<_Tp>::__unique_array_known_bound
    make_unique(_Args&&...) = delete;
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) typename __unique_if<_Tp>::__unique_single
make_unique_for_overwrite() {
  return unique_ptr<_Tp>(new _Tp);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) typename __unique_if<_Tp>::__unique_array_unknown_bound
make_unique_for_overwrite(size_t __n) {
  return unique_ptr<_Tp>(new __remove_extent_t<_Tp>[__n]);
}
template<class _Tp, class... _Args>
typename __unique_if<_Tp>::__unique_array_known_bound make_unique_for_overwrite(_Args&&...) = delete;
template <class _Tp> struct __attribute__((__type_visibility__("default"))) hash;
template <class _Tp, class _Dp>
struct __attribute__((__type_visibility__("default"))) hash<__enable_hash_helper<
    unique_ptr<_Tp, _Dp>, typename unique_ptr<_Tp, _Dp>::pointer> >
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    size_t operator()(const unique_ptr<_Tp, _Dp>& __ptr) const
    {
        typedef typename unique_ptr<_Tp, _Dp>::pointer pointer;
        return hash<pointer>()(__ptr.get());
    }
};
}}

namespace std { inline namespace __1 {
template <class _Predicate>
class __invert
{
private:
    _Predicate __p_;
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __invert() {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    explicit __invert(_Predicate __p) : __p_(__p) {}
    template <class _T1>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool operator()(const _T1& __x) {return !__p_(__x);}
    template <class _T1, class _T2>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool operator()(const _T1& __x, const _T2& __y) {return __p_(__y, __x);}
};
template <class _AlgPolicy, class _Compare, class _InputIterator1, class _Sent1,
          class _InputIterator2, class _Sent2, class _OutputIterator>
// added by concept-synth, original LN: 12004
requires
(
 requires (_InputIterator1 x0) { ++x0; } &&
 requires (_InputIterator1 x0) { *x0; }
) &&
requires (_Compare f, _InputIterator2 x0, _InputIterator1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
(
 requires (_InputIterator2 x0) { ++x0; } &&
 requires (_InputIterator2 x0) { *x0; }
) &&
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void __half_inplace_merge(_InputIterator1 __first1, _Sent1 __last1,
                          _InputIterator2 __first2, _Sent2 __last2,
                          _OutputIterator __result, _Compare&& __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
        {
            std::__move<_AlgPolicy>(__first1, __last1, __result);
            return;
        }
        if (__comp(*__first2, *__first1))
        {
            *__result = _IterOps<_AlgPolicy>::__iter_move(__first2);
            ++__first2;
        }
        else
        {
            *__result = _IterOps<_AlgPolicy>::__iter_move(__first1);
            ++__first1;
        }
    }
}
template <class _AlgPolicy, class _Compare, class _BidirectionalIterator>
// added by concept-synth, original LN: 12030
requires
(
 requires (_BidirectionalIterator x0) { *x0; } &&
 requires (_BidirectionalIterator x0) { ++x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void __buffered_inplace_merge(
    _BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare&& __comp,
    typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
    typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
    typename iterator_traits<_BidirectionalIterator>::value_type* __buff) {
  typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);
    if (__len1 <= __len2)
    {
        value_type* __p = __buff;
        for (_BidirectionalIterator __i = __first; __i != __middle; __d.template __incr<value_type>(), (void) ++__i, (void) ++__p)
            ::new ((void*)__p) value_type(_IterOps<_AlgPolicy>::__iter_move(__i));
        std::__half_inplace_merge<_AlgPolicy>(__buff, __p, __middle, __last, __first, __comp);
    }
    else
    {
        value_type* __p = __buff;
        for (_BidirectionalIterator __i = __middle; __i != __last; __d.template __incr<value_type>(), (void) ++__i, (void) ++__p)
            ::new ((void*)__p) value_type(_IterOps<_AlgPolicy>::__iter_move(__i));
        typedef __unconstrained_reverse_iterator<_BidirectionalIterator> _RBi;
        typedef __unconstrained_reverse_iterator<value_type*> _Rv;
        typedef __invert<_Compare> _Inverted;
        std::__half_inplace_merge<_AlgPolicy>(_Rv(__p), _Rv(__buff),
                                    _RBi(__middle), _RBi(__first),
                                    _RBi(__last), _Inverted(__comp));
    }
}
template <class _AlgPolicy, class _Compare, class _BidirectionalIterator>
// added by concept-synth, original LN: 12063
requires
(
 (
  (
   requires (_BidirectionalIterator x0) { ++x0; } &&
   requires (_BidirectionalIterator x0) { *x0; }
  ) ||
  (
   requires (_BidirectionalIterator x0) { *x0; } &&
   requires (_BidirectionalIterator x0) { ++x0; }
  ) ||
  (
   requires (_BidirectionalIterator x0) { *x0; } &&
   requires (_BidirectionalIterator x0) { ++x0; } &&
   requires (_BidirectionalIterator x0) { --x0; }
  )
 ) &&
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { *x0; }
) &&
requires (_Compare f, _BidirectionalIterator x0, _BidirectionalIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
void __inplace_merge(
    _BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare&& __comp,
    typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
    typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
    typename iterator_traits<_BidirectionalIterator>::value_type* __buff,
    ptrdiff_t __buff_size) {
    using _Ops = _IterOps<_AlgPolicy>;
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    while (true)
    {
        if (__len2 == 0)
            return;
        if (__len1 <= __buff_size || __len2 <= __buff_size)
            return std::__buffered_inplace_merge<_AlgPolicy>
                   (__first, __middle, __last, __comp, __len1, __len2, __buff);
        for (; true; ++__first, (void) --__len1)
        {
            if (__len1 == 0)
                return;
            if (__comp(*__middle, *__first))
                break;
        }
        _BidirectionalIterator __m1;
        _BidirectionalIterator __m2;
        difference_type __len11;
        difference_type __len21;
        if (__len1 < __len2)
        {
            __len21 = __len2 / 2;
            __m2 = __middle;
            _Ops::advance(__m2, __len21);
            __m1 = std::__upper_bound<_AlgPolicy>(__first, __middle, *__m2, __comp, std::__identity());
            __len11 = _Ops::distance(__first, __m1);
        }
        else
        {
            if (__len1 == 1)
            {
              _Ops::iter_swap(__first, __middle);
                return;
            }
            __len11 = __len1 / 2;
            __m1 = __first;
            _Ops::advance(__m1, __len11);
            __m2 = std::lower_bound(__middle, __last, *__m1, __comp);
            __len21 = _Ops::distance(__middle, __m2);
        }
        difference_type __len12 = __len1 - __len11;
        difference_type __len22 = __len2 - __len21;
        __middle = std::__rotate<_AlgPolicy>(__m1, __middle, __m2).first;
        if (__len11 + __len21 < __len12 + __len22)
        {
            std::__inplace_merge<_AlgPolicy>(
                __first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);
            __first = __middle;
            __middle = __m2;
            __len1 = __len12;
            __len2 = __len22;
        }
        else
        {
            std::__inplace_merge<_AlgPolicy>(
                __middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);
            __last = __middle;
            __middle = __m1;
            __len1 = __len11;
            __len2 = __len21;
        }
    }
}
template <class _AlgPolicy, class _BidirectionalIterator, class _Compare>
// added by concept-synth, original LN: 12137
requires
requires (_Compare f, _BidirectionalIterator x0, _BidirectionalIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
(
 (
  (
   requires (_BidirectionalIterator x0) { ++x0; } &&
   requires (_BidirectionalIterator x0) { *x0; }
  ) ||
  (
   requires (_BidirectionalIterator x0) { *x0; } &&
   requires (_BidirectionalIterator x0) { ++x0; }
  ) ||
  (
   requires (_BidirectionalIterator x0) { *x0; } &&
   requires (_BidirectionalIterator x0) { ++x0; } &&
   requires (_BidirectionalIterator x0) { --x0; }
  )
 ) &&
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { *x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void
__inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,
              _Compare&& __comp)
{
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    difference_type __len1 = _IterOps<_AlgPolicy>::distance(__first, __middle);
    difference_type __len2 = _IterOps<_AlgPolicy>::distance(__middle, __last);
    difference_type __buf_size = std::min(__len1, __len2);
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    pair<value_type*, ptrdiff_t> __buf = std::get_temporary_buffer<value_type>(__buf_size);
#pragma GCC diagnostic pop
    unique_ptr<value_type, __return_temporary_buffer> __h(__buf.first);
    return std::__inplace_merge<_AlgPolicy>(
        std::move(__first), std::move(__middle), std::move(__last), __comp, __len1, __len2, __buf.first, __buf.second);
}
template <class _BidirectionalIterator, class _Compare>
// added by concept-synth, original LN: 12157
requires
(
 (
  (
   requires (_BidirectionalIterator x0) { ++x0; } &&
   requires (_BidirectionalIterator x0) { *x0; }
  ) ||
  (
   requires (_BidirectionalIterator x0) { *x0; } &&
   requires (_BidirectionalIterator x0) { ++x0; }
  ) ||
  (
   requires (_BidirectionalIterator x0) { *x0; } &&
   requires (_BidirectionalIterator x0) { ++x0; } &&
   requires (_BidirectionalIterator x0) { --x0; }
  )
 ) &&
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void inplace_merge(
    _BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Compare __comp) {
  std::__inplace_merge<_ClassicAlgPolicy>(
      std::move(__first), std::move(__middle), std::move(__last), static_cast<__comp_ref_type<_Compare> >(__comp));
}
template <class _BidirectionalIterator>
// added by concept-synth, original LN: 12163
requires
(
 (
  (
   requires (_BidirectionalIterator x0) { ++x0; } &&
   requires (_BidirectionalIterator x0) { *x0; }
  ) ||
  (
   requires (_BidirectionalIterator x0) { *x0; } &&
   requires (_BidirectionalIterator x0) { ++x0; }
  ) ||
  (
   requires (_BidirectionalIterator x0) { *x0; } &&
   requires (_BidirectionalIterator x0) { ++x0; } &&
   requires (_BidirectionalIterator x0) { --x0; }
  )
 ) &&
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void
inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)
{
    std::inplace_merge(std::move(__first), std::move(__middle), std::move(__last),
                        __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}
}}
namespace std { inline namespace __1 {
template <class _Compare, class _RandomAccessIterator>
// added by concept-synth, original LN: 12173
requires
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
) &&
requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _RandomAccessIterator
__is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare&& __comp)
{
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    difference_type __len = __last - __first;
    difference_type __p = 0;
    difference_type __c = 1;
    _RandomAccessIterator __pp = __first;
    while (__c < __len)
    {
        _RandomAccessIterator __cp = __first + __c;
        if (__comp(*__pp, *__cp))
            return __cp;
        ++__c;
        ++__cp;
        if (__c == __len)
            return __last;
        if (__comp(*__pp, *__cp))
            return __cp;
        ++__p;
        ++__pp;
        __c = 2 * __p + 1;
    }
    return __last;
}
template <class _RandomAccessIterator, class _Compare>
// added by concept-synth, original LN: 12199
requires
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _RandomAccessIterator
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    return std::__is_heap_until(__first, __last, static_cast<__comp_ref_type<_Compare> >(__comp));
}
template<class _RandomAccessIterator>
// added by concept-synth, original LN: 12205
requires
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _RandomAccessIterator
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    return std::__is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}
}}
namespace std { inline namespace __1 {
template <class _RandomAccessIterator, class _Compare>
// added by concept-synth, original LN: 12213
requires
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
[[nodiscard]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool
is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
{
    return std::__is_heap_until(__first, __last, static_cast<__comp_ref_type<_Compare> >(__comp)) == __last;
}
template<class _RandomAccessIterator>
// added by concept-synth, original LN: 12221
requires
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
[[nodiscard]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool
is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
    return std::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}
}}

namespace std { inline namespace __1 {
template <class _InputIterator, class _Predicate>
// added by concept-synth, original LN: 12232
requires
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
) &&
(
 requires (_Predicate f, _InputIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
 requires (_Predicate f, _InputIterator x0) { f(*x0); }
)
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool
is_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            break;
    if ( __first == __last )
        return true;
    ++__first;
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return false;
    return true;
}
}}
namespace std { inline namespace __1 {
template <class _Iter1, class _Sent1, class _Iter2, class _Sent2, class = void>
struct _ConstTimeDistance : false_type {};
template <class _Iter1, class _Sent1, class _Iter2, class _Sent2>
struct _ConstTimeDistance<_Iter1, _Sent1, _Iter2, _Sent2, __enable_if_t<
  sized_sentinel_for<_Sent1, _Iter1> &&
  sized_sentinel_for<_Sent2, _Iter2>
>> : true_type {};
template <class _AlgPolicy,
          class _Iter1, class _Sent1, class _Iter2, class _Sent2,
          class _Proj1, class _Proj2, class _Pred>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool
__is_permutation_impl(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,
                      _Pred&& __pred, _Proj1&& __proj1, _Proj2&& __proj2) {
  using _D1 = __iter_diff_t<_Iter1>;
  for (auto __i = __first1; __i != __last1; ++__i) {
    auto __match = __first1;
    for (; __match != __i; ++__match) {
      if (std::__invoke(__pred, std::__invoke(__proj1, *__match), std::__invoke(__proj1, *__i)))
        break;
    }
    if (__match == __i) {
      _D1 __c2 = 0;
      for (auto __j = __first2; __j != __last2; ++__j) {
        if (std::__invoke(__pred, std::__invoke(__proj1, *__i), std::__invoke(__proj2, *__j)))
          ++__c2;
      }
      if (__c2 == 0)
        return false;
      _D1 __c1 = 1;
      for (auto __j = _IterOps<_AlgPolicy>::next(__i); __j != __last1; ++__j) {
        if (std::__invoke(__pred, std::__invoke(__proj1, *__i), std::__invoke(__proj1, *__j)))
          ++__c1;
      }
      if (__c1 != __c2)
        return false;
    }
  }
  return true;
}
template <class _AlgPolicy, class _ForwardIterator1, class _Sentinel1, class _ForwardIterator2, class _BinaryPredicate>
// added by concept-synth, original LN: 12288
requires
requires (_BinaryPredicate f, _ForwardIterator1 x0, _ForwardIterator2 x1) { f(*x0, *x1); } &&
(
 requires (_ForwardIterator1 x0) { *x0; } &&
 requires (_ForwardIterator1 x0) { ++x0; }
) &&
(
 requires (_ForwardIterator2 x0) { *x0; } &&
 requires (_ForwardIterator2 x0) { ++x0; }
)
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool
__is_permutation(_ForwardIterator1 __first1, _Sentinel1 __last1, _ForwardIterator2 __first2,
                 _BinaryPredicate&& __pred) {
  for (; __first1 != __last1; ++__first1, (void)++__first2) {
    if (!__pred(*__first1, *__first2))
      break;
  }
  if (__first1 == __last1)
    return true;
  using _D1 = __iter_diff_t<_ForwardIterator1>;
  _D1 __l1 = _IterOps<_AlgPolicy>::distance(__first1, __last1);
  if (__l1 == _D1(1))
    return false;
  auto __last2 = _IterOps<_AlgPolicy>::next(__first2, __l1);
  return std::__is_permutation_impl<_AlgPolicy>(
      std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2),
      __pred, __identity(), __identity());
}
template <class _AlgPolicy,
          class _Iter1, class _Sent1, class _Iter2, class _Sent2,
          class _Proj1, class _Proj2, class _Pred>
// added by concept-synth, original LN: 12307
requires
(
 requires (_Iter2 x0) { ++x0; } &&
 requires (_Iter2 x0) { *x0; }
) &&
(
 requires (_Iter1 x0) { ++x0; } &&
 requires (_Iter1 x0) { *x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool
__is_permutation(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,
                 _Pred&& __pred, _Proj1&& __proj1, _Proj2&& __proj2,
                                        false_type) {
  while (__first1 != __last1 && __first2 != __last2) {
    if (!std::__invoke(__pred, std::__invoke(__proj1, *__first1), std::__invoke(__proj2, *__first2)))
      break;
    ++__first1;
    ++__first2;
  }
  if (__first1 == __last1)
    return __first2 == __last2;
  if (__first2 == __last2)
    return false;
  using _D1 = __iter_diff_t<_Iter1>;
  _D1 __l1 = _IterOps<_AlgPolicy>::distance(__first1, __last1);
  using _D2 = __iter_diff_t<_Iter2>;
  _D2 __l2 = _IterOps<_AlgPolicy>::distance(__first2, __last2);
  if (__l1 != __l2)
    return false;
  return std::__is_permutation_impl<_AlgPolicy>(
      std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2),
      __pred, __proj1, __proj2);
}
template <class _AlgPolicy,
          class _Iter1, class _Sent1, class _Iter2, class _Sent2,
          class _Proj1, class _Proj2, class _Pred>
// added by concept-synth, original LN: 12334
requires
(
 (
  requires (_Sent2 x0) { ++x0; } &&
  requires (_Sent2 x0, _Sent2 x1) { x0 != x1; }
 ) ||
 requires (_Sent2 x0, _Sent2 x1) { x0 - x1; }
) &&
(
 (
  requires (_Sent1 x0) { ++x0; } &&
  requires (_Sent1 x0, _Sent1 x1) { x0 != x1; }
 ) ||
 requires (_Sent1 x0, _Sent1 x1) { x0 - x1; }
) &&
(
 (
  requires (_Sent2 x0) { ++x0; } &&
  requires (_Sent2 x0, _Sent2 x1) { x0 != x1; }
 ) ||
 requires (_Sent2 x0, _Sent2 x1) { x0 - x1; }
) &&
(
 (
  requires (_Sent1 x0) { ++x0; } &&
  requires (_Sent1 x0, _Sent1 x1) { x0 != x1; }
 ) ||
 requires (_Sent1 x0, _Sent1 x1) { x0 - x1; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool
__is_permutation(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,
                 _Pred&& __pred, _Proj1&& __proj1, _Proj2&& __proj2,
                                        true_type) {
  if (std::distance(__first1, __last1) != std::distance(__first2, __last2))
    return false;
  return std::__is_permutation<_AlgPolicy>(
      std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2),
      __pred, __proj1, __proj2,
                             false_type());
}
template <class _AlgPolicy,
          class _Iter1, class _Sent1, class _Iter2, class _Sent2,
          class _Proj1, class _Proj2, class _Pred>
// added by concept-synth, original LN: 12348
requires
(
 (
  requires (_Iter2 x0) { ++x0; } &&
  requires (_Iter2 x0) { *x0; }
 ) ||
 (
  requires (_Sent2 x0) { ++x0; } &&
  requires (_Sent2 x0, _Sent2 x1) { x0 != x1; }
 ) ||
 requires (_Sent2 x0, _Sent2 x1) { x0 - x1; }
) &&
(
 (
  requires (_Iter1 x0) { ++x0; } &&
  requires (_Iter1 x0) { *x0; }
 ) ||
 (
  requires (_Sent1 x0) { ++x0; } &&
  requires (_Sent1 x0, _Sent1 x1) { x0 != x1; }
 ) ||
 requires (_Sent1 x0, _Sent1 x1) { x0 - x1; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool
__is_permutation(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,
                 _Pred&& __pred, _Proj1&& __proj1, _Proj2&& __proj2) {
  return std::__is_permutation<_AlgPolicy>(
      std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2),
      __pred, __proj1, __proj2,
      _ConstTimeDistance<_Iter1, _Sent1, _Iter2, _Sent2>());
}
template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
// added by concept-synth, original LN: 12359
requires
(
 requires (_ForwardIterator2 x0) { *x0; } &&
 requires (_ForwardIterator2 x0) { ++x0; }
) &&
requires (_BinaryPredicate f, _ForwardIterator1 x0, _ForwardIterator2 x1) { f(*x0, *x1); } &&
(
 requires (_ForwardIterator1 x0) { *x0; } &&
 requires (_ForwardIterator1 x0) { ++x0; }
)
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
               _BinaryPredicate __pred) {
  static_assert(__is_callable<_BinaryPredicate, decltype(*__first1), decltype(*__first2)>::value,
      "The predicate has to be callable");
  return std::__is_permutation<_ClassicAlgPolicy>(
      std::move(__first1), std::move(__last1), std::move(__first2), __pred);
}
template <class _ForwardIterator1, class _ForwardIterator2>
// added by concept-synth, original LN: 12368
requires
(
 requires (_ForwardIterator2 x0) { *x0; } &&
 requires (_ForwardIterator2 x0) { ++x0; }
) &&
(
 requires (_ForwardIterator1 x0) { *x0; } &&
 requires (_ForwardIterator1 x0) { ++x0; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2) {
  return std::is_permutation(__first1, __last1, __first2, __equal_to());
}
template <class _ForwardIterator1, class _ForwardIterator2>
// added by concept-synth, original LN: 12373
requires
(
 (
  requires (_ForwardIterator2 x0) { ++x0; } &&
  requires (_ForwardIterator2 x0) { *x0; }
 ) ||
 (
  requires (_ForwardIterator2 x0) { ++x0; } &&
  requires (_ForwardIterator2 x0, _ForwardIterator2 x1) { x0 != x1; }
 ) ||
 requires (_ForwardIterator2 x0, _ForwardIterator2 x1) { x0 - x1; }
) &&
(
 (
  requires (_ForwardIterator1 x0) { ++x0; } &&
  requires (_ForwardIterator1 x0) { *x0; }
 ) ||
 (
  requires (_ForwardIterator1 x0) { ++x0; } &&
  requires (_ForwardIterator1 x0, _ForwardIterator1 x1) { x0 != x1; }
 ) ||
 requires (_ForwardIterator1 x0, _ForwardIterator1 x1) { x0 - x1; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool is_permutation(
    _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2) {
  return std::__is_permutation<_ClassicAlgPolicy>(
      std::move(__first1),
      std::move(__last1),
      std::move(__first2),
      std::move(__last2),
      __equal_to(),
      __identity(),
      __identity());
}
template <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
// added by concept-synth, original LN: 12385
requires
(
 (
  (
   requires (_ForwardIterator1 x0) { ++x0; } &&
   requires (_ForwardIterator1 x0) { *x0; }
  ) ||
  (
   requires (_ForwardIterator1 x0) { ++x0; } &&
   requires (_ForwardIterator1 x0, _ForwardIterator1 x1) { x0 != x1; }
  ) ||
  requires (_ForwardIterator1 x0, _ForwardIterator1 x1) { x0 - x1; }
 ) &&
 requires (_ForwardIterator1 x0) { *x0; }
) &&
(
 (
  (
   requires (_ForwardIterator2 x0) { ++x0; } &&
   requires (_ForwardIterator2 x0) { *x0; }
  ) ||
  (
   requires (_ForwardIterator2 x0) { ++x0; } &&
   requires (_ForwardIterator2 x0, _ForwardIterator2 x1) { x0 != x1; }
  ) ||
  requires (_ForwardIterator2 x0, _ForwardIterator2 x1) { x0 - x1; }
 ) &&
 requires (_ForwardIterator2 x0) { *x0; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
               _ForwardIterator2 __last2, _BinaryPredicate __pred) {
  static_assert(__is_callable<_BinaryPredicate, decltype(*__first1), decltype(*__first2)>::value,
      "The predicate has to be callable");
  return std::__is_permutation<_ClassicAlgPolicy>(
      std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2),
      __pred, __identity(), __identity());
}
}}
namespace std { inline namespace __1 {
template <class _Compare, class _ForwardIterator>
// added by concept-synth, original LN: 12397
requires
requires (_Compare f, _ForwardIterator x0, _ForwardIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _ForwardIterator
__is_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (__comp(*__i, *__first))
                return __i;
            __first = __i;
        }
    }
    return __last;
}
template <class _ForwardIterator, class _Compare>
// added by concept-synth, original LN: 12413
requires
requires (_Compare f, _ForwardIterator x0, _ForwardIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _ForwardIterator
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    return std::__is_sorted_until<__comp_ref_type<_Compare> >(__first, __last, __comp);
}
template<class _ForwardIterator>
// added by concept-synth, original LN: 12419
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _ForwardIterator
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
}
}}
namespace std { inline namespace __1 {
template <class _ForwardIterator, class _Compare>
// added by concept-synth, original LN: 12427
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
) &&
requires (_Compare f, _ForwardIterator x0, _ForwardIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
[[nodiscard]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool
is_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    return std::__is_sorted_until<__comp_ref_type<_Compare> >(__first, __last, __comp) == __last;
}
template<class _ForwardIterator>
// added by concept-synth, original LN: 12435
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
[[nodiscard]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool
is_sorted(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
}
}}
namespace std { inline namespace __1 {
template <class _Compare, class _InputIterator1, class _InputIterator2>
// added by concept-synth, original LN: 12445
requires
(
 requires (_InputIterator2 x0) { *x0; } &&
 requires (_InputIterator2 x0) { ++x0; }
) &&
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
) &&
(
 requires (_Compare f, _InputIterator2 x0, _InputIterator1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 requires (_Compare f, _InputIterator1 x0, _InputIterator2 x1) { f(*x0, *x1); }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool
__lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                          _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
{
    for (; __first2 != __last2; ++__first1, (void) ++__first2)
    {
        if (__first1 == __last1 || __comp(*__first1, *__first2))
            return true;
        if (__comp(*__first2, *__first1))
            return false;
    }
    return false;
}
template <class _InputIterator1, class _InputIterator2, class _Compare>
// added by concept-synth, original LN: 12459
requires
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
) &&
(
 requires (_InputIterator2 x0) { *x0; } &&
 requires (_InputIterator2 x0) { ++x0; }
) &&
(
 requires (_Compare f, _InputIterator2 x0, _InputIterator1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 requires (_Compare f, _InputIterator1 x0, _InputIterator2 x1) { f(*x0, *x1); }
)
[[nodiscard]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool
lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                        _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
{
    return std::__lexicographical_compare<__comp_ref_type<_Compare> >(__first1, __last1, __first2, __last2, __comp);
}
template <class _InputIterator1, class _InputIterator2>
// added by concept-synth, original LN: 12468
requires
(
 requires (_InputIterator2 x0) { *x0; } &&
 requires (_InputIterator2 x0) { ++x0; }
) &&
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
)
[[nodiscard]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool
lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                        _InputIterator2 __first2, _InputIterator2 __last2)
{
    return std::lexicographical_compare(__first1, __last1, __first2, __last2,
                                         __less<typename iterator_traits<_InputIterator1>::value_type,
                                                typename iterator_traits<_InputIterator2>::value_type>());
}
}}

namespace std { inline namespace __1 {
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
// added by concept-synth, original LN: 12482
requires
requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr void
__sift_down(_RandomAccessIterator __first, _Compare&& __comp,
            typename iterator_traits<_RandomAccessIterator>::difference_type __len,
            _RandomAccessIterator __start)
{
    using _Ops = _IterOps<_AlgPolicy>;
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    difference_type __child = __start - __first;
    if (__len < 2 || (__len - 2) / 2 < __child)
        return;
    __child = 2 * __child + 1;
    _RandomAccessIterator __child_i = __first + __child;
    if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + difference_type(1)))) {
        ++__child_i;
        ++__child;
    }
    if (__comp(*__child_i, *__start))
        return;
    value_type __top(_Ops::__iter_move(__start));
    do
    {
        *__start = _Ops::__iter_move(__child_i);
        __start = __child_i;
        if ((__len - 2) / 2 < __child)
            break;
        __child = 2 * __child + 1;
        __child_i = __first + __child;
        if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + difference_type(1)))) {
            ++__child_i;
            ++__child;
        }
    } while (!__comp(*__child_i, __top));
    *__start = std::move(__top);
}
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
// added by concept-synth, original LN: 12518
requires
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _RandomAccessIterator
__floyd_sift_down(_RandomAccessIterator __first, _Compare&& __comp,
                  typename iterator_traits<_RandomAccessIterator>::difference_type __len)
{
    using difference_type = typename iterator_traits<_RandomAccessIterator>::difference_type;
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(__len >= 2))
#pragma clang diagnostic pop
    );
    _RandomAccessIterator __hole = __first;
    _RandomAccessIterator __child_i = __first;
    difference_type __child = 0;
    while (true) {
        __child_i += difference_type(__child + 1);
        __child = 2 * __child + 1;
        if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + difference_type(1)))) {
            ++__child_i;
            ++__child;
        }
        *__hole = _IterOps<_AlgPolicy>::__iter_move(__child_i);
        __hole = __child_i;
        if (__child > (__len - 2) / 2)
            return __hole;
    }
}
}}
namespace std { inline namespace __1 {
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
// added by concept-synth, original LN: 12548
requires
requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare&& __comp) {
  __comp_ref_type<_Compare> __comp_ref = __comp;
  using difference_type = typename iterator_traits<_RandomAccessIterator>::difference_type;
  difference_type __n = __last - __first;
  if (__n > 1) {
    for (difference_type __start = (__n - 2) / 2; __start >= 0; --__start) {
        std::__sift_down<_AlgPolicy>(__first, __comp_ref, __n, __first + __start);
    }
  }
}
template <class _RandomAccessIterator, class _Compare>
// added by concept-synth, original LN: 12560
requires
requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {
  std::__make_heap<_ClassicAlgPolicy>(std::move(__first), std::move(__last), __comp);
}
template <class _RandomAccessIterator>
// added by concept-synth, original LN: 12565
requires
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) {
  std::make_heap(std::move(__first), std::move(__last),
      __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}
}}
namespace std { inline namespace __1 {
template <class _Compare, class _ForwardIterator>
// added by concept-synth, original LN: 12573
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
) &&
requires (_Compare f, _ForwardIterator x0, _ForwardIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _ForwardIterator
__max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    static_assert(__is_cpp17_forward_iterator<_ForwardIterator>::value,
        "std::max_element requires a ForwardIterator");
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
            if (__comp(*__first, *__i))
                __first = __i;
    }
    return __first;
}
template <class _ForwardIterator, class _Compare>
// added by concept-synth, original LN: 12588
requires
requires (_Compare f, _ForwardIterator x0, _ForwardIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
{
    return std::__max_element<__comp_ref_type<_Compare> >(__first, __last, __comp);
}
template <class _ForwardIterator>
// added by concept-synth, original LN: 12594
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last)
{
    return std::max_element(__first, __last,
              __less<typename iterator_traits<_ForwardIterator>::value_type>());
}
}}

namespace std { inline namespace __1 {
template <class _Tp, class _Compare>
// added by concept-synth, original LN: 12604
requires
requires (_Compare f, _Tp x0, _Tp x1) { f(x0, x1); }
[[nodiscard]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
const _Tp&
max(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__a, __b) ? __b : __a;
}
template <class _Tp>
[[nodiscard]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
const _Tp&
max(const _Tp& __a, const _Tp& __b)
{
    return std::max(__a, __b, __less<_Tp>());
}
template<class _Tp, class _Compare>
[[nodiscard]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_Tp
max(initializer_list<_Tp> __t, _Compare __comp)
{
    return *std::__max_element<__comp_ref_type<_Compare> >(__t.begin(), __t.end(), __comp);
}
template<class _Tp>
[[nodiscard]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_Tp
max(initializer_list<_Tp> __t)
{
    return *std::max_element(__t.begin(), __t.end(), __less<_Tp>());
}
}}

namespace std { inline namespace __1 {
template <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
// added by concept-synth, original LN: 12639
requires
(
 requires (_InputIterator2 x0) { ++x0; } &&
 requires (_InputIterator2 x0) { *x0; }
) &&
requires (_Compare f, _InputIterator2 x0, _InputIterator1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
) &&
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_OutputIterator
__merge(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
            return std::copy(__first1, __last1, __result);
        if (__comp(*__first2, *__first1))
        {
            *__result = *__first2;
            ++__first2;
        }
        else
        {
            *__result = *__first1;
            ++__first1;
        }
    }
    return std::copy(__first2, __last2, __result);
}
template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
// added by concept-synth, original LN: 12662
requires
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
) &&
(
 requires (_InputIterator2 x0) { ++x0; } &&
 requires (_InputIterator2 x0) { *x0; }
) &&
requires (_Compare f, _InputIterator2 x0, _InputIterator1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_OutputIterator
merge(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
{
    return std::__merge<__comp_ref_type<_Compare> >(__first1, __last1, __first2, __last2, __result, __comp);
}
template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
// added by concept-synth, original LN: 12670
requires
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
) &&
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
) &&
(
 requires (_InputIterator2 x0) { ++x0; } &&
 requires (_InputIterator2 x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_OutputIterator
merge(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return std::merge(__first1, __last1, __first2, __last2, __result, __less<__v1, __v2>());
}
}}

namespace std { inline namespace __1 {
namespace ranges {
template <class _T1>
struct min_max_result {
  [[no_unique_address]] _T1 min;
  [[no_unique_address]] _T1 max;
  template <class _T2>
    requires convertible_to<const _T1&, _T2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr operator min_max_result<_T2>() const & {
    return {min, max};
  }
  template <class _T2>
    requires convertible_to<_T1, _T2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr operator min_max_result<_T2>() && {
    return {std::move(min), std::move(max)};
  }
};
}
}}
namespace std { inline namespace __1 {
template <class _Comp, class _Proj>
class _MinmaxElementLessFunc {
  _Comp& __comp_;
  _Proj& __proj_;
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  _MinmaxElementLessFunc(_Comp& __comp, _Proj& __proj) : __comp_(__comp), __proj_(__proj) {}
  template <class _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  bool operator()(_Iter& __it1, _Iter& __it2) {
    return std::__invoke(__comp_, std::__invoke(__proj_, *__it1), std::__invoke(__proj_, *__it2));
  }
};
template <class _Iter, class _Sent, class _Proj, class _Comp>
// added by concept-synth, original LN: 12715
requires
requires (_Iter x0) { ++x0; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
pair<_Iter, _Iter> __minmax_element_impl(_Iter __first, _Sent __last, _Comp& __comp, _Proj& __proj) {
  auto __less = _MinmaxElementLessFunc<_Comp, _Proj>(__comp, __proj);
  pair<_Iter, _Iter> __result(__first, __first);
  if (__first == __last || ++__first == __last)
    return __result;
  if (__less(__first, __result.first))
    __result.first = __first;
  else
    __result.second = __first;
  while (++__first != __last) {
    _Iter __i = __first;
    if (++__first == __last) {
      if (__less(__i, __result.first))
        __result.first = __i;
      else if (!__less(__i, __result.second))
        __result.second = __i;
      return __result;
    }
    if (__less(__first, __i)) {
      if (__less(__first, __result.first))
        __result.first = __first;
    if (!__less(__i, __result.second))
      __result.second = __i;
    } else {
      if (__less(__i, __result.first))
        __result.first = __i;
      if (!__less(__first, __result.second))
        __result.second = __first;
    }
  }
  return __result;
}
template <class _ForwardIterator, class _Compare>
// added by concept-synth, original LN: 12749
requires
(
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0) { *x0; }
)
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
pair<_ForwardIterator, _ForwardIterator>
minmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {
  static_assert(__is_cpp17_forward_iterator<_ForwardIterator>::value,
                "std::minmax_element requires a ForwardIterator");
  static_assert(__is_callable<_Compare, decltype(*__first), decltype(*__first)>::value,
                "The comparator has to be callable");
  auto __proj = __identity();
  return std::__minmax_element_impl(__first, __last, __comp, __proj);
}
template <class _ForwardIterator>
// added by concept-synth, original LN: 12760
requires
(
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0) { *x0; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
pair<_ForwardIterator, _ForwardIterator> minmax_element(_ForwardIterator __first, _ForwardIterator __last) {
    return std::minmax_element(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());
}
}}
namespace std { inline namespace __1 {
template<class _Tp, class _Compare>
// added by concept-synth, original LN: 12767
requires
requires (_Compare f, _Tp x0, _Tp x1) { f(x0, x1); }
[[nodiscard]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
pair<const _Tp&, const _Tp&>
minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
{
    return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a) :
                              pair<const _Tp&, const _Tp&>(__a, __b);
}
template<class _Tp>
[[nodiscard]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
pair<const _Tp&, const _Tp&>
minmax(const _Tp& __a, const _Tp& __b)
{
    return std::minmax(__a, __b, __less<_Tp>());
}
template<class _Tp, class _Compare>
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
pair<_Tp, _Tp> minmax(initializer_list<_Tp> __t, _Compare __comp) {
    static_assert(__is_callable<_Compare, _Tp, _Tp>::value, "The comparator has to be callable");
    __identity __proj;
    auto __ret = std::__minmax_element_impl(__t.begin(), __t.end(), __comp, __proj);
    return pair<_Tp, _Tp>(*__ret.first, *__ret.second);
}
template<class _Tp>
[[nodiscard]] inline
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
pair<_Tp, _Tp>
minmax(initializer_list<_Tp> __t)
{
    return std::minmax(__t, __less<_Tp>());
}
}}

namespace std { inline namespace __1 {
template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
// added by concept-synth, original LN: 12803
requires
(
 requires (_InputIterator2 x0) { *x0; } &&
 requires (_InputIterator2 x0) { ++x0; }
) &&
requires (_BinaryPredicate f, _InputIterator1 x0, _InputIterator2 x1) { f(*x0, *x1); } &&
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred) {
  for (; __first1 != __last1; ++__first1, (void)++__first2)
    if (!__pred(*__first1, *__first2))
      break;
  return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
}
template <class _InputIterator1, class _InputIterator2>
// added by concept-synth, original LN: 12812
requires
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
) &&
(
 requires (_InputIterator2 x0) { *x0; } &&
 requires (_InputIterator2 x0) { ++x0; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2) {
  return std::mismatch(__first1, __last1, __first2, __equal_to());
}
template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
// added by concept-synth, original LN: 12818
requires
(
 requires (_InputIterator2 x0) { *x0; } &&
 requires (_InputIterator2 x0) { ++x0; }
) &&
requires (_BinaryPredicate f, _InputIterator1 x0, _InputIterator2 x1) { f(*x0, *x1); } &&
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,
             _BinaryPredicate __pred) {
  for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void)++__first2)
    if (!__pred(*__first1, *__first2))
      break;
  return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
}
template <class _InputIterator1, class _InputIterator2>
// added by concept-synth, original LN: 12828
requires
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
) &&
(
 requires (_InputIterator2 x0) { *x0; } &&
 requires (_InputIterator2 x0) { ++x0; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2) {
  return std::mismatch(__first1, __last1, __first2, __last2, __equal_to());
}
}}
namespace std { inline namespace __1 {
template <class _AlgPolicy, class _BidirectionalIterator>
// added by concept-synth, original LN: 12836
requires
(
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { --x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void
__reverse_impl(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag)
{
    while (__first != __last)
    {
        if (__first == --__last)
            break;
        _IterOps<_AlgPolicy>::iter_swap(__first, __last);
        ++__first;
    }
}
template <class _AlgPolicy, class _RandomAccessIterator>
// added by concept-synth, original LN: 12849
requires
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void
__reverse_impl(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)
{
    if (__first != __last)
        for (; __first < --__last; ++__first)
            _IterOps<_AlgPolicy>::iter_swap(__first, __last);
}
template <class _AlgPolicy, class _BidirectionalIterator, class _Sentinel>
// added by concept-synth, original LN: 12858
requires
(
 requires (_Sentinel x0) { ++x0; } &&
 requires (_Sentinel x0) { --x0; }
) &&
(
 requires (_Sentinel x0) { ++x0; } &&
 requires (_Sentinel x0) { --x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void __reverse(_BidirectionalIterator __first, _Sentinel __last) {
  using _IterCategory = typename _IterOps<_AlgPolicy>::template __iterator_category<_BidirectionalIterator>;
  std::__reverse_impl<_AlgPolicy>(std::move(__first), std::move(__last), _IterCategory());
}
template <class _BidirectionalIterator>
// added by concept-synth, original LN: 12864
requires
(
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { --x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void
reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
  std::__reverse<_ClassicAlgPolicy>(std::move(__first), std::move(__last));
}
}}
namespace std { inline namespace __1 {
template <class _AlgPolicy, class _Compare, class _BidirectionalIterator, class _Sentinel>
// added by concept-synth, original LN: 12873
requires
(
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { --x0; } &&
 requires (_BidirectionalIterator x0) { *x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_BidirectionalIterator, bool>
__next_permutation(_BidirectionalIterator __first, _Sentinel __last, _Compare&& __comp)
{
    using _Result = pair<_BidirectionalIterator, bool>;
    _BidirectionalIterator __last_iter = _IterOps<_AlgPolicy>::next(__first, __last);
    _BidirectionalIterator __i = __last_iter;
    if (__first == __last || __first == --__i)
        return _Result(std::move(__last_iter), false);
    while (true)
    {
        _BidirectionalIterator __ip1 = __i;
        if (__comp(*--__i, *__ip1))
        {
            _BidirectionalIterator __j = __last_iter;
            while (!__comp(*__i, *--__j))
                ;
            _IterOps<_AlgPolicy>::iter_swap(__i, __j);
            std::__reverse<_AlgPolicy>(__ip1, __last_iter);
            return _Result(std::move(__last_iter), true);
        }
        if (__i == __first)
        {
            std::__reverse<_AlgPolicy>(__first, __last_iter);
            return _Result(std::move(__last_iter), false);
        }
    }
}
template <class _BidirectionalIterator, class _Compare>
// added by concept-synth, original LN: 12901
requires
(
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { --x0; } &&
 requires (_BidirectionalIterator x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
  return std::__next_permutation<_ClassicAlgPolicy>(
      std::move(__first), std::move(__last), static_cast<__comp_ref_type<_Compare> >(__comp)).second;
}
template <class _BidirectionalIterator>
// added by concept-synth, original LN: 12909
requires
(
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { --x0; } &&
 requires (_BidirectionalIterator x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    return std::next_permutation(__first, __last,
                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}
}}
namespace std { inline namespace __1 {
template <class _InputIterator, class _Predicate>
// added by concept-synth, original LN: 12919
requires
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
) &&
requires (_Predicate f, _InputIterator x0) { {f(*x0)} -> std::convertible_to<bool>; }
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool
none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (__pred(*__first))
      return false;
  return true;
}
}}
namespace std { inline namespace __1 {
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
// added by concept-synth, original LN: 12929
requires
(
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void __sift_up(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare&& __comp,
        typename iterator_traits<_RandomAccessIterator>::difference_type __len) {
  using value_type = typename iterator_traits<_RandomAccessIterator>::value_type;
  if (__len > 1) {
    __len = (__len - 2) / 2;
    _RandomAccessIterator __ptr = __first + __len;
    if (__comp(*__ptr, *--__last)) {
      value_type __t(_IterOps<_AlgPolicy>::__iter_move(__last));
      do {
        *__last = _IterOps<_AlgPolicy>::__iter_move(__ptr);
        __last = __ptr;
        if (__len == 0)
          break;
        __len = (__len - 1) / 2;
        __ptr = __first + __len;
      } while (__comp(*__ptr, __t));
      *__last = std::move(__t);
    }
  }
}
template <class _AlgPolicy, class _RandomAccessIterator, class _Compare>
// added by concept-synth, original LN: 12951
requires
(
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void __push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare& __comp) {
  typename iterator_traits<_RandomAccessIterator>::difference_type __len = __last - __first;
  std::__sift_up<_AlgPolicy, __comp_ref_type<_Compare> >(std::move(__first), std::move(__last), __comp, __len);
}
template <class _RandomAccessIterator, class _Compare>
// added by concept-synth, original LN: 12957
requires
(
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {
  static_assert(std::is_copy_constructible<_RandomAccessIterator>::value, "Iterators must be copy constructible.");
  static_assert(std::is_copy_assignable<_RandomAccessIterator>::value, "Iterators must be copy assignable.");
  std::__push_heap<_ClassicAlgPolicy>(std::move(__first), std::move(__last), __comp);
}
template <class _RandomAccessIterator>
// added by concept-synth, original LN: 12964
requires
(
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) {
  std::push_heap(std::move(__first), std::move(__last),
      __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}
}}
namespace std { inline namespace __1 {
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
// added by concept-synth, original LN: 12972
requires
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare& __comp,
    typename iterator_traits<_RandomAccessIterator>::difference_type __len) {
  (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
  __builtin_assume(static_cast<bool>(__len > 0))
#pragma clang diagnostic pop
  );
  __comp_ref_type<_Compare> __comp_ref = __comp;
  using value_type = typename iterator_traits<_RandomAccessIterator>::value_type;
  if (__len > 1) {
    value_type __top = _IterOps<_AlgPolicy>::__iter_move(__first);
    _RandomAccessIterator __hole = std::__floyd_sift_down<_AlgPolicy>(__first, __comp_ref, __len);
    --__last;
    if (__hole == __last) {
      *__hole = std::move(__top);
    } else {
      *__hole = _IterOps<_AlgPolicy>::__iter_move(__last);
      ++__hole;
      *__last = std::move(__top);
      std::__sift_up<_AlgPolicy>(__first, __hole, __comp_ref, __hole - __first);
    }
  }
}
template <class _RandomAccessIterator, class _Compare>
// added by concept-synth, original LN: 12998
requires
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {
  static_assert(std::is_copy_constructible<_RandomAccessIterator>::value, "Iterators must be copy constructible.");
  static_assert(std::is_copy_assignable<_RandomAccessIterator>::value, "Iterators must be copy assignable.");
  typename iterator_traits<_RandomAccessIterator>::difference_type __len = __last - __first;
  std::__pop_heap<_ClassicAlgPolicy>(std::move(__first), std::move(__last), __comp, __len);
}
template <class _RandomAccessIterator>
// added by concept-synth, original LN: 13006
requires
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) {
  std::pop_heap(std::move(__first), std::move(__last),
      __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}
}}
namespace std { inline namespace __1 {
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
// added by concept-synth, original LN: 13014
requires
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void __sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare&& __comp) {
  __comp_ref_type<_Compare> __comp_ref = __comp;
  using difference_type = typename iterator_traits<_RandomAccessIterator>::difference_type;
  for (difference_type __n = __last - __first; __n > 1; --__last, (void) --__n)
    std::__pop_heap<_AlgPolicy>(__first, __last, __comp_ref, __n);
}
template <class _RandomAccessIterator, class _Compare>
// added by concept-synth, original LN: 13022
requires
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {
  static_assert(std::is_copy_constructible<_RandomAccessIterator>::value, "Iterators must be copy constructible.");
  static_assert(std::is_copy_assignable<_RandomAccessIterator>::value, "Iterators must be copy assignable.");
  std::__sort_heap<_ClassicAlgPolicy>(std::move(__first), std::move(__last), __comp);
}
template <class _RandomAccessIterator>
// added by concept-synth, original LN: 13029
requires
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) {
  std::sort_heap(std::move(__first), std::move(__last),
      __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}
}}
namespace std { inline namespace __1 {
template <class _AlgPolicy, class _Iterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void __debug_randomize_range(_Iterator __first, _Sentinel __last) {
  (void)__first;
  (void)__last;
}
}}
namespace std { inline namespace __1 {
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator, class _Sentinel>
// added by concept-synth, original LN: 13045
requires
requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_RandomAccessIterator __partial_sort_impl(
    _RandomAccessIterator __first, _RandomAccessIterator __middle, _Sentinel __last, _Compare&& __comp) {
  if (__first == __middle) {
    return _IterOps<_AlgPolicy>::next(__middle, __last);
  }
  std::__make_heap<_AlgPolicy>(__first, __middle, __comp);
  typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;
  _RandomAccessIterator __i = __middle;
  for (; __i != __last; ++__i)
  {
      if (__comp(*__i, *__first))
      {
          _IterOps<_AlgPolicy>::iter_swap(__i, __first);
          std::__sift_down<_AlgPolicy>(__first, __comp, __len, __first);
      }
  }
  std::__sort_heap<_AlgPolicy>(std::move(__first), std::move(__middle), __comp);
  return __i;
}
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator, class _Sentinel>
// added by concept-synth, original LN: 13066
requires
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_RandomAccessIterator __partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _Sentinel __last,
                                     _Compare& __comp) {
  if (__first == __middle)
      return _IterOps<_AlgPolicy>::next(__middle, __last);
  std::__debug_randomize_range<_AlgPolicy>(__first, __last);
  auto __last_iter =
      std::__partial_sort_impl<_AlgPolicy>(__first, __middle, __last, static_cast<__comp_ref_type<_Compare> >(__comp));
  std::__debug_randomize_range<_AlgPolicy>(__middle, __last);
  return __last_iter;
}
template <class _RandomAccessIterator, class _Compare>
// added by concept-synth, original LN: 13078
requires
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,
             _Compare __comp)
{
  static_assert(std::is_copy_constructible<_RandomAccessIterator>::value, "Iterators must be copy constructible.");
  static_assert(std::is_copy_assignable<_RandomAccessIterator>::value, "Iterators must be copy assignable.");
  (void)std::__partial_sort<_ClassicAlgPolicy>(std::move(__first), std::move(__middle), std::move(__last), __comp);
}
template <class _RandomAccessIterator>
// added by concept-synth, original LN: 13088
requires
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
{
    std::partial_sort(__first, __middle, __last,
                        __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}
}}
namespace std { inline namespace __1 {
namespace ranges {
struct equal_to {
  template <class _Tp, class _Up>
  requires equality_comparable_with<_Tp, _Up>
  [[nodiscard]] constexpr bool operator()(_Tp &&__t, _Up &&__u) const
      noexcept(noexcept(bool(std::forward<_Tp>(__t) == std::forward<_Up>(__u)))) {
    return std::forward<_Tp>(__t) == std::forward<_Up>(__u);
  }
  using is_transparent = void;
};
struct not_equal_to {
  template <class _Tp, class _Up>
  requires equality_comparable_with<_Tp, _Up>
  [[nodiscard]] constexpr bool operator()(_Tp &&__t, _Up &&__u) const
      noexcept(noexcept(bool(!(std::forward<_Tp>(__t) == std::forward<_Up>(__u))))) {
    return !(std::forward<_Tp>(__t) == std::forward<_Up>(__u));
  }
  using is_transparent = void;
};
struct less {
  template <class _Tp, class _Up>
  requires totally_ordered_with<_Tp, _Up>
  [[nodiscard]] constexpr bool operator()(_Tp &&__t, _Up &&__u) const
      noexcept(noexcept(bool(std::forward<_Tp>(__t) < std::forward<_Up>(__u)))) {
    return std::forward<_Tp>(__t) < std::forward<_Up>(__u);
  }
  using is_transparent = void;
};
struct less_equal {
  template <class _Tp, class _Up>
  requires totally_ordered_with<_Tp, _Up>
  [[nodiscard]] constexpr bool operator()(_Tp &&__t, _Up &&__u) const
      noexcept(noexcept(bool(!(std::forward<_Up>(__u) < std::forward<_Tp>(__t))))) {
    return !(std::forward<_Up>(__u) < std::forward<_Tp>(__t));
  }
  using is_transparent = void;
};
struct greater {
  template <class _Tp, class _Up>
  requires totally_ordered_with<_Tp, _Up>
  [[nodiscard]] constexpr bool operator()(_Tp &&__t, _Up &&__u) const
      noexcept(noexcept(bool(std::forward<_Up>(__u) < std::forward<_Tp>(__t)))) {
    return std::forward<_Up>(__u) < std::forward<_Tp>(__t);
  }
  using is_transparent = void;
};
struct greater_equal {
  template <class _Tp, class _Up>
  requires totally_ordered_with<_Tp, _Up>
  [[nodiscard]] constexpr bool operator()(_Tp &&__t, _Up &&__u) const
      noexcept(noexcept(bool(!(std::forward<_Tp>(__t) < std::forward<_Up>(__u))))) {
    return !(std::forward<_Tp>(__t) < std::forward<_Up>(__u));
  }
  using is_transparent = void;
};
}
}}
namespace std { inline namespace __1 {
template <class _ToType, class _FromType>
  requires(sizeof(_ToType) == sizeof(_FromType) &&
           is_trivially_copyable_v<_ToType> &&
           is_trivially_copyable_v<_FromType>)
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _ToType bit_cast(const _FromType& __from) noexcept {
  return __builtin_bit_cast(_ToType, __from);
}
}}
namespace std { inline namespace __1 {
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_Tp __rotr(_Tp __t, unsigned int __cnt) noexcept
{
    static_assert(__libcpp_is_unsigned_integer<_Tp>::value, "__rotr requires an unsigned integer type");
    const unsigned int __dig = numeric_limits<_Tp>::digits;
    if ((__cnt % __dig) == 0)
        return __t;
    return (__t >> (__cnt % __dig)) | (__t << (__dig - (__cnt % __dig)));
}
template <__libcpp_unsigned_integer _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Tp rotl(_Tp __t, unsigned int __cnt) noexcept {
  const unsigned int __dig = numeric_limits<_Tp>::digits;
  if ((__cnt % __dig) == 0)
    return __t;
  return (__t << (__cnt % __dig)) | (__t >> (__dig - (__cnt % __dig)));
}
template <__libcpp_unsigned_integer _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Tp rotr(_Tp __t, unsigned int __cnt) noexcept {
  return std::__rotr(__t, __cnt);
}
}}

namespace std { inline namespace __1 {
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
int __libcpp_clz(unsigned __x) noexcept { return __builtin_clz(__x); }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
int __libcpp_clz(unsigned long __x) noexcept { return __builtin_clzl(__x); }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
int __libcpp_clz(unsigned long long __x) noexcept { return __builtin_clzll(__x); }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
int __libcpp_clz(__uint128_t __x) noexcept {
  return ((__x >> 64) == 0)
           ? (64 + __builtin_clzll(static_cast<unsigned long long>(__x)))
           : __builtin_clzll(static_cast<unsigned long long>(__x >> 64));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
int __countl_zero(_Tp __t) noexcept
{
    static_assert(__libcpp_is_unsigned_integer<_Tp>::value, "__countl_zero requires an unsigned integer type");
    if (__t == 0)
        return numeric_limits<_Tp>::digits;
    if (sizeof(_Tp) <= sizeof(unsigned int))
        return std::__libcpp_clz(static_cast<unsigned int>(__t))
              - (numeric_limits<unsigned int>::digits - numeric_limits<_Tp>::digits);
    else if (sizeof(_Tp) <= sizeof(unsigned long))
        return std::__libcpp_clz(static_cast<unsigned long>(__t))
              - (numeric_limits<unsigned long>::digits - numeric_limits<_Tp>::digits);
    else if (sizeof(_Tp) <= sizeof(unsigned long long))
        return std::__libcpp_clz(static_cast<unsigned long long>(__t))
              - (numeric_limits<unsigned long long>::digits - numeric_limits<_Tp>::digits);
    else
    {
        int __ret = 0;
        int __iter = 0;
        const unsigned int __ulldigits = numeric_limits<unsigned long long>::digits;
        while (true) {
            __t = std::__rotr(__t, __ulldigits);
            if ((__iter = std::__countl_zero(static_cast<unsigned long long>(__t))) != __ulldigits)
                break;
            __ret += __iter;
            }
        return __ret + __iter;
    }
}
template <__libcpp_unsigned_integer _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr int countl_zero(_Tp __t) noexcept {
  return std::__countl_zero(__t);
}
template <__libcpp_unsigned_integer _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr int countl_one(_Tp __t) noexcept {
  return __t != numeric_limits<_Tp>::max() ? std::countl_zero(static_cast<_Tp>(~__t)) : numeric_limits<_Tp>::digits;
}
}}
namespace std { inline namespace __1 {
template <__libcpp_unsigned_integer _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Tp bit_ceil(_Tp __t) noexcept {
  if (__t < 2)
    return 1;
  const unsigned __n = numeric_limits<_Tp>::digits - std::countl_zero((_Tp)(__t - 1u));
  (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
  __builtin_assume(static_cast<bool>(__n != numeric_limits<_Tp>::digits))
#pragma clang diagnostic pop
  );
  if constexpr (sizeof(_Tp) >= sizeof(unsigned))
    return _Tp{1} << __n;
  else {
    const unsigned __extra = numeric_limits<unsigned>::digits - numeric_limits<_Tp>::digits;
    const unsigned __retVal = 1u << (__n + __extra);
    return (_Tp)(__retVal >> __extra);
  }
}
}}
namespace std { inline namespace __1 {
template <__libcpp_unsigned_integer _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Tp __bit_log2(_Tp __t) noexcept {
  return numeric_limits<_Tp>::digits - 1 - std::countl_zero(__t);
}
}}
namespace std { inline namespace __1 {
template <__libcpp_unsigned_integer _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Tp bit_floor(_Tp __t) noexcept {
  return __t == 0 ? 0 : _Tp{1} << std::__bit_log2(__t);
}
}}

namespace std { inline namespace __1 {
template <__libcpp_unsigned_integer _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr int bit_width(_Tp __t) noexcept {
  return __t == 0 ? 0 : std::__bit_log2(__t) + 1;
}
}}
namespace std { inline namespace __1 {
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr unsigned __libcpp_blsr(unsigned __x) noexcept {
  return __x ^ (__x & -__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr unsigned long __libcpp_blsr(unsigned long __x) noexcept {
  return __x ^ (__x & -__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr unsigned long long __libcpp_blsr(unsigned long long __x) noexcept {
  return __x ^ (__x & -__x);
}
}}
namespace std { inline namespace __1 {
}}


namespace std { inline namespace __1 {
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
int __libcpp_ctz(unsigned __x) noexcept { return __builtin_ctz(__x); }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
int __libcpp_ctz(unsigned long __x) noexcept { return __builtin_ctzl(__x); }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
int __libcpp_ctz(unsigned long long __x) noexcept { return __builtin_ctzll(__x); }
template <__libcpp_unsigned_integer _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr int countr_zero(_Tp __t) noexcept {
  if (__t == 0)
    return numeric_limits<_Tp>::digits;
  if (sizeof(_Tp) <= sizeof(unsigned int))
    return std::__libcpp_ctz(static_cast<unsigned int>(__t));
  else if (sizeof(_Tp) <= sizeof(unsigned long))
    return std::__libcpp_ctz(static_cast<unsigned long>(__t));
  else if (sizeof(_Tp) <= sizeof(unsigned long long))
    return std::__libcpp_ctz(static_cast<unsigned long long>(__t));
  else {
    int __ret = 0;
    const unsigned int __ulldigits = numeric_limits<unsigned long long>::digits;
    while (static_cast<unsigned long long>(__t) == 0uLL) {
      __ret += __ulldigits;
      __t >>= __ulldigits;
    }
    return __ret + std::__libcpp_ctz(static_cast<unsigned long long>(__t));
  }
}
template <__libcpp_unsigned_integer _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr int countr_one(_Tp __t) noexcept {
  return __t != numeric_limits<_Tp>::max() ? std::countr_zero(static_cast<_Tp>(~__t)) : numeric_limits<_Tp>::digits;
}
}}
namespace std { inline namespace __1 {
enum class endian {
  little = 0xDEAD,
  big = 0xFACE,
  native = little
};
}}
namespace std { inline namespace __1 {
template <__libcpp_unsigned_integer _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool has_single_bit(_Tp __t) noexcept {
  return __t != 0 && (((__t & (__t - 1)) == 0));
}
}}

namespace std { inline namespace __1 {
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
int __libcpp_popcount(unsigned __x) noexcept { return __builtin_popcount(__x); }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
int __libcpp_popcount(unsigned long __x) noexcept { return __builtin_popcountl(__x); }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
int __libcpp_popcount(unsigned long long __x) noexcept { return __builtin_popcountll(__x); }
template <__libcpp_unsigned_integer _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr int popcount(_Tp __t) noexcept {
  if (sizeof(_Tp) <= sizeof(unsigned int))
    return std::__libcpp_popcount(static_cast<unsigned int>(__t));
  else if (sizeof(_Tp) <= sizeof(unsigned long))
    return std::__libcpp_popcount(static_cast<unsigned long>(__t));
  else if (sizeof(_Tp) <= sizeof(unsigned long long))
    return std::__libcpp_popcount(static_cast<unsigned long long>(__t));
  else {
    int __ret = 0;
    while (__t != 0) {
      __ret += std::__libcpp_popcount(static_cast<unsigned long long>(__t));
      __t >>= numeric_limits<unsigned long long>::digits;
    }
    return __ret;
  }
}
}}
namespace std { inline namespace __1 {
namespace pmr {
template <class _ValueType>
class __attribute__((__type_visibility__("default"))) polymorphic_allocator;
}
}}
namespace std { inline namespace __1 {
template <class _CharT>
struct __attribute__((__type_visibility__("default"))) char_traits;
template <>
struct char_traits<char>;
template <>
struct char_traits<char8_t>;
template <>
struct char_traits<char16_t>;
template <>
struct char_traits<char32_t>;
template <>
struct char_traits<wchar_t>;
template <class _Tp>
class __attribute__((__type_visibility__("default"))) allocator;
template <class _CharT, class _Traits = char_traits<_CharT>, class _Allocator = allocator<_CharT> >
class __attribute__((__type_visibility__("default"))) basic_string;
using string = basic_string<char>;
using wstring = basic_string<wchar_t>;
using u8string = basic_string<char8_t>;
using u16string = basic_string<char16_t>;
using u32string = basic_string<char32_t>;
namespace pmr {
template <class _CharT, class _Traits = char_traits<_CharT>>
using basic_string = std::basic_string<_CharT, _Traits, polymorphic_allocator<_CharT>>;
using string = basic_string<char>;
using wstring = basic_string<wchar_t>;
using u8string = basic_string<char8_t>;
using u16string = basic_string<char16_t>;
using u32string = basic_string<char32_t>;
}
template <class _CharT, class _Traits, class _Allocator>
class __attribute__((__preferred_name__(string)))
      __attribute__((__preferred_name__(wstring)))
      __attribute__((__preferred_name__(u8string)))
      __attribute__((__preferred_name__(u16string)))
      __attribute__((__preferred_name__(u32string)))
      __attribute__((__preferred_name__(pmr::string)))
      __attribute__((__preferred_name__(pmr::wstring)))
      __attribute__((__preferred_name__(pmr::u8string)))
      __attribute__((__preferred_name__(pmr::u16string)))
      __attribute__((__preferred_name__(pmr::u32string)))
      basic_string;
}}
typedef __darwin_mbstate_t mbstate_t;
typedef __builtin_va_list va_list;
typedef __builtin_va_list __gnuc_va_list;
typedef __darwin_va_list va_list;

extern "C" {
int renameat(int, const char *, int, const char *) __attribute__((availability(macosx,introduced=10.10)));
int renamex_np(const char *, const char *, unsigned int) __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0)));
int renameatx_np(int, const char *, int, const char *, unsigned int) __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0)));
}

typedef __darwin_off_t fpos_t;
struct __sbuf {
 unsigned char *_base;
 int _size;
};
struct __sFILEX;
typedef struct __sFILE {
 unsigned char *_p;
 int _r;
 int _w;
 short _flags;
 short _file;
 struct __sbuf _bf;
 int _lbfsize;
 void *_cookie;
 int (* _Nullable _close)(void *);
 int (* _Nullable _read) (void *, char *, int);
 fpos_t (* _Nullable _seek) (void *, fpos_t, int);
 int (* _Nullable _write)(void *, const char *, int);
 struct __sbuf _ub;
 struct __sFILEX *_extra;
 int _ur;
 unsigned char _ubuf[3];
 unsigned char _nbuf[1];
 struct __sbuf _lb;
 int _blksize;
 fpos_t _offset;
} FILE;


extern "C" {
extern FILE *__stdinp;
extern FILE *__stdoutp;
extern FILE *__stderrp;
}
extern "C" {
void clearerr(FILE *);
int fclose(FILE *);
int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
int fgetc(FILE *);
int fgetpos(FILE * , fpos_t *);
char *fgets(char * , int, FILE *);
FILE *fopen(const char * __filename, const char * __mode) __asm("_" "fopen" );
int fprintf(FILE * , const char * , ...) __attribute__((__format__ (__printf__, 2, 3)));
int fputc(int, FILE *);
int fputs(const char * , FILE * ) __asm("_" "fputs" );
size_t fread(void * __ptr, size_t __size, size_t __nitems, FILE * __stream);
FILE *freopen(const char * , const char * ,
                 FILE * ) __asm("_" "freopen" );
int fscanf(FILE * , const char * , ...) __attribute__((__format__ (__scanf__, 2, 3)));
int fseek(FILE *, long, int);
int fsetpos(FILE *, const fpos_t *);
long ftell(FILE *);
size_t fwrite(const void * __ptr, size_t __size, size_t __nitems, FILE * __stream) __asm("_" "fwrite" );
int getc(FILE *);
int getchar(void);
__attribute__((__deprecated__("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of gets(3), it is highly recommended that you use fgets(3) instead.")))
char *gets(char *);
void perror(const char *) __attribute__((__cold__));
int printf(const char * , ...) __attribute__((__format__ (__printf__, 1, 2)));
int putc(int, FILE *);
int putchar(int);
int puts(const char *);
int remove(const char *);
int rename (const char *__old, const char *__new);
void rewind(FILE *);
int scanf(const char * , ...) __attribute__((__format__ (__scanf__, 1, 2)));
void setbuf(FILE * , char * );
int setvbuf(FILE * , char * , int, size_t);
__attribute__((__availability__(swift, unavailable, message="Use snprintf instead.")))
__attribute__((__deprecated__("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of sprintf(3), it is highly recommended that you use snprintf(3) instead.")))
int sprintf(char * , const char * , ...) __attribute__((__format__ (__printf__, 2, 3)));
int sscanf(const char * , const char * , ...) __attribute__((__format__ (__scanf__, 2, 3)));
FILE *tmpfile(void);
__attribute__((__availability__(swift, unavailable, message="Use mkstemp(3) instead.")))
__attribute__((__deprecated__("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of tmpnam(3), it is highly recommended that you use mkstemp(3) instead.")))
char *tmpnam(char *);
int ungetc(int, FILE *);
int vfprintf(FILE * , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0)));
int vprintf(const char * , va_list) __attribute__((__format__ (__printf__, 1, 0)));
__attribute__((__availability__(swift, unavailable, message="Use vsnprintf instead.")))
__attribute__((__deprecated__("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of sprintf(3), it is highly recommended that you use vsnprintf(3) instead.")))
int vsprintf(char * , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0)));
}
extern "C" {
char *ctermid(char *);
}

extern "C" {
FILE *fdopen(int, const char *) __asm("_" "fdopen" );
int fileno(FILE *);
}
extern "C" {
int pclose(FILE *) __attribute__((__availability__(swift, unavailable, message="Use posix_spawn APIs or NSTask instead. (On iOS, process spawning is unavailable.)")));
FILE *popen(const char *, const char *) __asm("_" "popen" ) __attribute__((__availability__(swift, unavailable, message="Use posix_spawn APIs or NSTask instead. (On iOS, process spawning is unavailable.)")));
}
extern "C" {
int __srget(FILE *);
int __svfscanf(FILE *, const char *, va_list) __attribute__((__format__ (__scanf__, 2, 0)));
int __swbuf(int, FILE *);
}
inline __attribute__ ((__always_inline__)) int __sputc(int _c, FILE *_p) {
 if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
  return (*_p->_p++ = _c);
 else
  return (__swbuf(_c, _p));
}
extern "C" {
void flockfile(FILE *);
int ftrylockfile(FILE *);
void funlockfile(FILE *);
int getc_unlocked(FILE *);
int getchar_unlocked(void);
int putc_unlocked(int, FILE *);
int putchar_unlocked(int);
int getw(FILE *);
int putw(int, FILE *);
__attribute__((__availability__(swift, unavailable, message="Use mkstemp(3) instead.")))
__attribute__((__deprecated__("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of tempnam(3), it is highly recommended that you use mkstemp(3) instead.")))
char *tempnam(const char *__dir, const char *__prefix) __asm("_" "tempnam" );
}
typedef __darwin_off_t off_t;

extern "C" {
int fseeko(FILE * __stream, off_t __offset, int __whence);
off_t ftello(FILE * __stream);
}
extern "C" {
int snprintf(char * __str, size_t __size, const char * __format, ...) __attribute__((__format__ (__printf__, 3, 4)));
int vfscanf(FILE * __stream, const char * __format, va_list) __attribute__((__format__ (__scanf__, 2, 0)));
int vscanf(const char * __format, va_list) __attribute__((__format__ (__scanf__, 1, 0)));
int vsnprintf(char * __str, size_t __size, const char * __format, va_list) __attribute__((__format__ (__printf__, 3, 0)));
int vsscanf(const char * __str, const char * __format, va_list) __attribute__((__format__ (__scanf__, 2, 0)));
}
extern "C" {
int dprintf(int, const char * , ...) __attribute__((__format__ (__printf__, 2, 3))) __attribute__((availability(macosx,introduced=10.7)));
int vdprintf(int, const char * , va_list) __attribute__((__format__ (__printf__, 2, 0))) __attribute__((availability(macosx,introduced=10.7)));
ssize_t getdelim(char ** __linep, size_t * __linecapp, int __delimiter, FILE * __stream) __attribute__((availability(macosx,introduced=10.7)));
ssize_t getline(char ** __linep, size_t * __linecapp, FILE * __stream) __attribute__((availability(macosx,introduced=10.7)));
FILE *fmemopen(void * __buf, size_t __size, const char * __mode) __attribute__((availability(macos,introduced=10.13))) __attribute__((availability(ios,introduced=11.0))) __attribute__((availability(tvos,introduced=11.0))) __attribute__((availability(watchos,introduced=4.0)));
FILE *open_memstream(char **__bufp, size_t *__sizep) __attribute__((availability(macos,introduced=10.13))) __attribute__((availability(ios,introduced=11.0))) __attribute__((availability(tvos,introduced=11.0))) __attribute__((availability(watchos,introduced=4.0)));
}
extern "C" {
extern const int sys_nerr;
extern const char *const sys_errlist[];
int asprintf(char ** , const char * , ...) __attribute__((__format__ (__printf__, 2, 3)));
char *ctermid_r(char *);
char *fgetln(FILE *, size_t *);
const char *fmtcheck(const char *, const char *) __attribute__((format_arg(2)));
int fpurge(FILE *);
void setbuffer(FILE *, char *, int);
int setlinebuf(FILE *);
int vasprintf(char ** , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0)));
FILE *funopen(const void *,
                 int (* _Nullable)(void *, char *, int),
                 int (* _Nullable)(void *, const char *, int),
                 fpos_t (* _Nullable)(void *, fpos_t, int),
                 int (* _Nullable)(void *));
}
typedef __darwin_clock_t clock_t;
typedef __darwin_time_t time_t;
struct timespec
{
 __darwin_time_t tv_sec;
 long tv_nsec;
};

struct tm {
 int tm_sec;
 int tm_min;
 int tm_hour;
 int tm_mday;
 int tm_mon;
 int tm_year;
 int tm_wday;
 int tm_yday;
 int tm_isdst;
 long tm_gmtoff;
 char *tm_zone;
};
extern char *tzname[];
extern int getdate_err;
extern long timezone __asm("_" "timezone" );
extern int daylight;
extern "C" {
char *asctime(const struct tm *);
clock_t clock(void) __asm("_" "clock" );
char *ctime(const time_t *);
double difftime(time_t, time_t);
struct tm *getdate(const char *);
struct tm *gmtime(const time_t *);
struct tm *localtime(const time_t *);
time_t mktime(struct tm *) __asm("_" "mktime" );
size_t strftime(char * , size_t, const char * , const struct tm * ) __asm("_" "strftime" );
char *strptime(const char * , const char * , struct tm * ) __asm("_" "strptime" );
time_t time(time_t *);
void tzset(void);
char *asctime_r(const struct tm * , char * );
char *ctime_r(const time_t *, char *);
struct tm *gmtime_r(const time_t * , struct tm * );
struct tm *localtime_r(const time_t * , struct tm * );
time_t posix2time(time_t);
void tzsetwall(void);
time_t time2posix(time_t);
time_t timelocal(struct tm * const);
time_t timegm(struct tm * const);
int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp) __asm("_" "nanosleep" );
typedef enum {
_CLOCK_REALTIME __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 0,
_CLOCK_MONOTONIC __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 6,
_CLOCK_MONOTONIC_RAW __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 4,
_CLOCK_MONOTONIC_RAW_APPROX __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 5,
_CLOCK_UPTIME_RAW __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 8,
_CLOCK_UPTIME_RAW_APPROX __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 9,
_CLOCK_PROCESS_CPUTIME_ID __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 12,
_CLOCK_THREAD_CPUTIME_ID __attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0))) = 16
} clockid_t;
__attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0)))
int clock_getres(clockid_t __clock_id, struct timespec *__res);
__attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0)))
int clock_gettime(clockid_t __clock_id, struct timespec *__tp);
__attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,introduced=10.0))) __attribute__((availability(tvos,introduced=10.0))) __attribute__((availability(watchos,introduced=3.0)))
__uint64_t clock_gettime_nsec_np(clockid_t __clock_id);
__attribute__((availability(macosx,introduced=10.12))) __attribute__((availability(ios,unavailable)))
__attribute__((availability(tvos,unavailable))) __attribute__((availability(watchos,unavailable)))
int clock_settime(clockid_t __clock_id, const struct timespec *__tp);
__attribute__((availability(macos,introduced=10.15))) __attribute__((availability(ios,introduced=13.0))) __attribute__((availability(tvos,introduced=13.0))) __attribute__((availability(watchos,introduced=6.0)))
int timespec_get(struct timespec *ts, int base);
}
typedef __darwin_wint_t wint_t;

typedef __darwin_wctype_t wctype_t;
typedef struct {
 __darwin_rune_t __min;
 __darwin_rune_t __max;
 __darwin_rune_t __map;
 __uint32_t *__types;
} _RuneEntry;
typedef struct {
 int __nranges;
 _RuneEntry *__ranges;
} _RuneRange;
typedef struct {
 char __name[14];
 __uint32_t __mask;
} _RuneCharClass;
typedef struct {
 char __magic[8];
 char __encoding[32];
 __darwin_rune_t (*__sgetrune)(const char *, __darwin_size_t, char const **);
 int (*__sputrune)(__darwin_rune_t, char *, __darwin_size_t, char **);
 __darwin_rune_t __invalid_rune;
 __uint32_t __runetype[(1 <<8 )];
 __darwin_rune_t __maplower[(1 <<8 )];
 __darwin_rune_t __mapupper[(1 <<8 )];
 _RuneRange __runetype_ext;
 _RuneRange __maplower_ext;
 _RuneRange __mapupper_ext;
 void *__variable;
 int __variable_len;
 int __ncharclasses;
 _RuneCharClass *__charclasses;
} _RuneLocale;
extern "C" {
extern _RuneLocale _DefaultRuneLocale;
extern _RuneLocale *_CurrentRuneLocale;
}
extern "C" {
unsigned long ___runetype(__darwin_ct_rune_t);
__darwin_ct_rune_t ___tolower(__darwin_ct_rune_t);
__darwin_ct_rune_t ___toupper(__darwin_ct_rune_t);
}
inline int
isascii(int _c)
{
 return ((_c & ~0x7F) == 0);
}
extern "C" {
int __maskrune(__darwin_ct_rune_t, unsigned long);
}
inline int
__istype(__darwin_ct_rune_t _c, unsigned long _f)
{
 return (isascii(_c) ? !!(_DefaultRuneLocale.__runetype[_c] & _f)
  : !!__maskrune(_c, _f));
}
inline __darwin_ct_rune_t
__isctype(__darwin_ct_rune_t _c, unsigned long _f)
{
 return (_c < 0 || _c >= (1 <<8 )) ? 0 :
  !!(_DefaultRuneLocale.__runetype[_c] & _f);
}
extern "C" {
__darwin_ct_rune_t __toupper(__darwin_ct_rune_t);
__darwin_ct_rune_t __tolower(__darwin_ct_rune_t);
}
inline int
__wcwidth(__darwin_ct_rune_t _c)
{
 unsigned int _x;
 if (_c == 0)
  return (0);
 _x = (unsigned int)__maskrune(_c, 0xe0000000L|0x00040000L);
 if ((_x & 0xe0000000L) != 0)
  return ((_x & 0xe0000000L) >> 30);
 return ((_x & 0x00040000L) != 0 ? 1 : -1);
}
inline int
isalnum(int _c)
{
 return (__istype(_c, 0x00000100L|0x00000400L));
}
inline int
isalpha(int _c)
{
 return (__istype(_c, 0x00000100L));
}
inline int
isblank(int _c)
{
 return (__istype(_c, 0x00020000L));
}
inline int
iscntrl(int _c)
{
 return (__istype(_c, 0x00000200L));
}
inline int
isdigit(int _c)
{
 return (__isctype(_c, 0x00000400L));
}
inline int
isgraph(int _c)
{
 return (__istype(_c, 0x00000800L));
}
inline int
islower(int _c)
{
 return (__istype(_c, 0x00001000L));
}
inline int
isprint(int _c)
{
 return (__istype(_c, 0x00040000L));
}
inline int
ispunct(int _c)
{
 return (__istype(_c, 0x00002000L));
}
inline int
isspace(int _c)
{
 return (__istype(_c, 0x00004000L));
}
inline int
isupper(int _c)
{
 return (__istype(_c, 0x00008000L));
}
inline int
isxdigit(int _c)
{
 return (__isctype(_c, 0x00010000L));
}
inline int
toascii(int _c)
{
 return (_c & 0x7F);
}
inline int
tolower(int _c)
{
        return (__tolower(_c));
}
inline int
toupper(int _c)
{
        return (__toupper(_c));
}
inline int
digittoint(int _c)
{
 return (__maskrune(_c, 0x0F));
}
inline int
ishexnumber(int _c)
{
 return (__istype(_c, 0x00010000L));
}
inline int
isideogram(int _c)
{
 return (__istype(_c, 0x00080000L));
}
inline int
isnumber(int _c)
{
 return (__istype(_c, 0x00000400L));
}
inline int
isphonogram(int _c)
{
 return (__istype(_c, 0x00200000L));
}
inline int
isrune(int _c)
{
 return (__istype(_c, 0xFFFFFFF0L));
}
inline int
isspecial(int _c)
{
 return (__istype(_c, 0x00100000L));
}
inline int
iswalnum(wint_t _wc)
{
 return (__istype(_wc, 0x00000100L|0x00000400L));
}
inline int
iswalpha(wint_t _wc)
{
 return (__istype(_wc, 0x00000100L));
}
inline int
iswcntrl(wint_t _wc)
{
 return (__istype(_wc, 0x00000200L));
}
inline int
iswctype(wint_t _wc, wctype_t _charclass)
{
 return (__istype(_wc, _charclass));
}
inline int
iswdigit(wint_t _wc)
{
 return (__isctype(_wc, 0x00000400L));
}
inline int
iswgraph(wint_t _wc)
{
 return (__istype(_wc, 0x00000800L));
}
inline int
iswlower(wint_t _wc)
{
 return (__istype(_wc, 0x00001000L));
}
inline int
iswprint(wint_t _wc)
{
 return (__istype(_wc, 0x00040000L));
}
inline int
iswpunct(wint_t _wc)
{
 return (__istype(_wc, 0x00002000L));
}
inline int
iswspace(wint_t _wc)
{
 return (__istype(_wc, 0x00004000L));
}
inline int
iswupper(wint_t _wc)
{
 return (__istype(_wc, 0x00008000L));
}
inline int
iswxdigit(wint_t _wc)
{
 return (__isctype(_wc, 0x00010000L));
}
inline wint_t
towlower(wint_t _wc)
{
        return (__tolower(_wc));
}
inline wint_t
towupper(wint_t _wc)
{
        return (__toupper(_wc));
}
extern "C" {
wctype_t
 wctype(const char *);
}
extern "C" {
wint_t btowc(int);
wint_t fgetwc(FILE *);
wchar_t *fgetws(wchar_t * , int, FILE * );
wint_t fputwc(wchar_t, FILE *);
int fputws(const wchar_t * , FILE * );
int fwide(FILE *, int);
int fwprintf(FILE * , const wchar_t * , ...);
int fwscanf(FILE * , const wchar_t * , ...);
wint_t getwc(FILE *);
wint_t getwchar(void);
size_t mbrlen(const char * , size_t, mbstate_t * );
size_t mbrtowc(wchar_t * , const char * , size_t,
     mbstate_t * );
int mbsinit(const mbstate_t *);
size_t mbsrtowcs(wchar_t * , const char ** , size_t,
     mbstate_t * );
wint_t putwc(wchar_t, FILE *);
wint_t putwchar(wchar_t);
int swprintf(wchar_t * , size_t, const wchar_t * , ...);
int swscanf(const wchar_t * , const wchar_t * , ...);
wint_t ungetwc(wint_t, FILE *);
int vfwprintf(FILE * , const wchar_t * ,
     __darwin_va_list);
int vswprintf(wchar_t * , size_t, const wchar_t * ,
     __darwin_va_list);
int vwprintf(const wchar_t * , __darwin_va_list);
size_t wcrtomb(char * , wchar_t, mbstate_t * );
wchar_t *wcscat(wchar_t * , const wchar_t * );
wchar_t *wcschr(const wchar_t *, wchar_t);
int wcscmp(const wchar_t *, const wchar_t *);
int wcscoll(const wchar_t *, const wchar_t *);
wchar_t *wcscpy(wchar_t * , const wchar_t * );
size_t wcscspn(const wchar_t *, const wchar_t *);
size_t wcsftime(wchar_t * , size_t, const wchar_t * ,
     const struct tm * ) __asm("_" "wcsftime" );
size_t wcslen(const wchar_t *);
wchar_t *wcsncat(wchar_t * , const wchar_t * , size_t);
int wcsncmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wcsncpy(wchar_t * , const wchar_t * , size_t);
wchar_t *wcspbrk(const wchar_t *, const wchar_t *);
wchar_t *wcsrchr(const wchar_t *, wchar_t);
size_t wcsrtombs(char * , const wchar_t ** , size_t,
     mbstate_t * );
size_t wcsspn(const wchar_t *, const wchar_t *);
wchar_t *wcsstr(const wchar_t * , const wchar_t * );
size_t wcsxfrm(wchar_t * , const wchar_t * , size_t);
int wctob(wint_t);
double wcstod(const wchar_t * , wchar_t ** );
wchar_t *wcstok(wchar_t * , const wchar_t * ,
     wchar_t ** );
long wcstol(const wchar_t * , wchar_t ** , int);
unsigned long
  wcstoul(const wchar_t * , wchar_t ** , int);
wchar_t *wmemchr(const wchar_t *, wchar_t, size_t);
int wmemcmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wmemcpy(wchar_t * , const wchar_t * , size_t);
wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t);
wchar_t *wmemset(wchar_t *, wchar_t, size_t);
int wprintf(const wchar_t * , ...);
int wscanf(const wchar_t * , ...);
int wcswidth(const wchar_t *, size_t);
int wcwidth(wchar_t);
}
extern "C" {
int vfwscanf(FILE * , const wchar_t * ,
     __darwin_va_list);
int vswscanf(const wchar_t * , const wchar_t * ,
     __darwin_va_list);
int vwscanf(const wchar_t * , __darwin_va_list);
float wcstof(const wchar_t * , wchar_t ** );
long double
 wcstold(const wchar_t * , wchar_t ** );
long long
 wcstoll(const wchar_t * , wchar_t ** , int);
unsigned long long
 wcstoull(const wchar_t * , wchar_t ** , int);
}
extern "C" {
size_t mbsnrtowcs(wchar_t * , const char ** , size_t,
            size_t, mbstate_t * );
wchar_t *wcpcpy(wchar_t * , const wchar_t * ) __attribute__((availability(macosx,introduced=10.7)));
wchar_t *wcpncpy(wchar_t * , const wchar_t * , size_t) __attribute__((availability(macosx,introduced=10.7)));
wchar_t *wcsdup(const wchar_t *) __attribute__((availability(macosx,introduced=10.7)));
int wcscasecmp(const wchar_t *, const wchar_t *) __attribute__((availability(macosx,introduced=10.7)));
int wcsncasecmp(const wchar_t *, const wchar_t *, size_t n) __attribute__((availability(macosx,introduced=10.7)));
size_t wcsnlen(const wchar_t *, size_t) __attribute__((availability(macosx,introduced=10.7)));
size_t wcsnrtombs(char * , const wchar_t ** , size_t,
            size_t, mbstate_t * );
FILE *open_wmemstream(wchar_t ** __bufp, size_t * __sizep) __attribute__((availability(macos,introduced=10.13))) __attribute__((availability(ios,introduced=11.0))) __attribute__((availability(tvos,introduced=11.0))) __attribute__((availability(watchos,introduced=4.0)));
}
extern "C" {
wchar_t *fgetwln(FILE * , size_t *) __attribute__((availability(macosx,introduced=10.7)));
size_t wcslcat(wchar_t *, const wchar_t *, size_t);
size_t wcslcpy(wchar_t *, const wchar_t *, size_t);
}
extern "C++" {
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
wchar_t* __libcpp_wcschr(const wchar_t* __s, wchar_t __c) {return (wchar_t*)wcschr(__s, __c);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__enable_if__(true, "")))
const wchar_t* wcschr(const wchar_t* __s, wchar_t __c) {return __libcpp_wcschr(__s, __c);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__enable_if__(true, "")))
      wchar_t* wcschr( wchar_t* __s, wchar_t __c) {return __libcpp_wcschr(__s, __c);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
wchar_t* __libcpp_wcspbrk(const wchar_t* __s1, const wchar_t* __s2) {return (wchar_t*)wcspbrk(__s1, __s2);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__enable_if__(true, "")))
const wchar_t* wcspbrk(const wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcspbrk(__s1, __s2);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__enable_if__(true, "")))
      wchar_t* wcspbrk( wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcspbrk(__s1, __s2);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
wchar_t* __libcpp_wcsrchr(const wchar_t* __s, wchar_t __c) {return (wchar_t*)wcsrchr(__s, __c);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__enable_if__(true, "")))
const wchar_t* wcsrchr(const wchar_t* __s, wchar_t __c) {return __libcpp_wcsrchr(__s, __c);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__enable_if__(true, "")))
      wchar_t* wcsrchr( wchar_t* __s, wchar_t __c) {return __libcpp_wcsrchr(__s, __c);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
wchar_t* __libcpp_wcsstr(const wchar_t* __s1, const wchar_t* __s2) {return (wchar_t*)wcsstr(__s1, __s2);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__enable_if__(true, "")))
const wchar_t* wcsstr(const wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcsstr(__s1, __s2);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__enable_if__(true, "")))
      wchar_t* wcsstr( wchar_t* __s1, const wchar_t* __s2) {return __libcpp_wcsstr(__s1, __s2);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
wchar_t* __libcpp_wmemchr(const wchar_t* __s, wchar_t __c, size_t __n) {return (wchar_t*)wmemchr(__s, __c, __n);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__enable_if__(true, "")))
const wchar_t* wmemchr(const wchar_t* __s, wchar_t __c, size_t __n) {return __libcpp_wmemchr(__s, __c, __n);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__enable_if__(true, "")))
      wchar_t* wmemchr( wchar_t* __s, wchar_t __c, size_t __n) {return __libcpp_wmemchr(__s, __c, __n);}
}
namespace std { inline namespace __1 {
using ::mbstate_t __attribute__((__using_if_exists__));
}}
namespace std { inline namespace __1 {
class __attribute__((__visibility__("default"))) ios_base;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__((__type_visibility__("default"))) basic_ios;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__((__type_visibility__("default"))) basic_streambuf;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__((__type_visibility__("default"))) basic_istream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__((__type_visibility__("default"))) basic_ostream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__((__type_visibility__("default"))) basic_iostream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__((__type_visibility__("default"))) basic_stringbuf;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__((__type_visibility__("default"))) basic_istringstream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__((__type_visibility__("default"))) basic_ostringstream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
    class __attribute__((__type_visibility__("default"))) basic_stringstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__((__type_visibility__("default"))) basic_filebuf;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__((__type_visibility__("default"))) basic_ifstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__((__type_visibility__("default"))) basic_ofstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__((__type_visibility__("default"))) basic_fstream;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__((__type_visibility__("default"))) istreambuf_iterator;
template <class _CharT, class _Traits = char_traits<_CharT> >
    class __attribute__((__type_visibility__("default"))) ostreambuf_iterator;
typedef basic_ios<char> ios;
typedef basic_ios<wchar_t> wios;
typedef basic_streambuf<char> streambuf;
typedef basic_istream<char> istream;
typedef basic_ostream<char> ostream;
typedef basic_iostream<char> iostream;
typedef basic_stringbuf<char> stringbuf;
typedef basic_istringstream<char> istringstream;
typedef basic_ostringstream<char> ostringstream;
typedef basic_stringstream<char> stringstream;
typedef basic_filebuf<char> filebuf;
typedef basic_ifstream<char> ifstream;
typedef basic_ofstream<char> ofstream;
typedef basic_fstream<char> fstream;
typedef basic_streambuf<wchar_t> wstreambuf;
typedef basic_istream<wchar_t> wistream;
typedef basic_ostream<wchar_t> wostream;
typedef basic_iostream<wchar_t> wiostream;
typedef basic_stringbuf<wchar_t> wstringbuf;
typedef basic_istringstream<wchar_t> wistringstream;
typedef basic_ostringstream<wchar_t> wostringstream;
typedef basic_stringstream<wchar_t> wstringstream;
typedef basic_filebuf<wchar_t> wfilebuf;
typedef basic_ifstream<wchar_t> wifstream;
typedef basic_ofstream<wchar_t> wofstream;
typedef basic_fstream<wchar_t> wfstream;
template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(ios))) __attribute__((__preferred_name__(wios))) basic_ios;
template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(streambuf))) __attribute__((__preferred_name__(wstreambuf))) basic_streambuf;
template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(istream))) __attribute__((__preferred_name__(wistream))) basic_istream;
template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(ostream))) __attribute__((__preferred_name__(wostream))) basic_ostream;
template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(iostream))) __attribute__((__preferred_name__(wiostream))) basic_iostream;
template <class _CharT, class _Traits, class _Allocator>
    class __attribute__((__preferred_name__(stringbuf))) __attribute__((__preferred_name__(wstringbuf))) basic_stringbuf;
template <class _CharT, class _Traits, class _Allocator>
    class __attribute__((__preferred_name__(istringstream))) __attribute__((__preferred_name__(wistringstream))) basic_istringstream;
template <class _CharT, class _Traits, class _Allocator>
    class __attribute__((__preferred_name__(ostringstream))) __attribute__((__preferred_name__(wostringstream))) basic_ostringstream;
template <class _CharT, class _Traits, class _Allocator>
    class __attribute__((__preferred_name__(stringstream))) __attribute__((__preferred_name__(wstringstream))) basic_stringstream;
template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(filebuf))) __attribute__((__preferred_name__(wfilebuf))) basic_filebuf;
template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(ifstream))) __attribute__((__preferred_name__(wifstream))) basic_ifstream;
template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(ofstream))) __attribute__((__preferred_name__(wofstream))) basic_ofstream;
template <class _CharT, class _Traits>
    class __attribute__((__preferred_name__(fstream))) __attribute__((__preferred_name__(wfstream))) basic_fstream;
template <class _State> class __attribute__((__type_visibility__("default"))) fpos;
typedef fpos<mbstate_t> streampos;
typedef fpos<mbstate_t> wstreampos;
typedef fpos<mbstate_t> u8streampos;
typedef fpos<mbstate_t> u16streampos;
typedef fpos<mbstate_t> u32streampos;
typedef long long streamoff;
template <class _Tp, class _Alloc = allocator<_Tp> >
class __attribute__((__type_visibility__("default"))) vector;
template <class _CharT, class _Traits>
class __save_flags
{
    typedef basic_ios<_CharT, _Traits> __stream_type;
    typedef typename __stream_type::fmtflags fmtflags;
    __stream_type& __stream_;
    fmtflags __fmtflags_;
    _CharT __fill_;
    __save_flags(const __save_flags&);
    __save_flags& operator=(const __save_flags&);
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    explicit __save_flags(__stream_type& __stream)
        : __stream_(__stream),
          __fmtflags_(__stream.flags()),
          __fill_(__stream.fill())
        {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    ~__save_flags()
    {
        __stream_.flags(__fmtflags_);
        __stream_.fill(__fill_);
    }
};
}}
namespace std { inline namespace __1 {
template <class _PolicyT, class _CompT, class = void>
struct _WrapAlgPolicy {
  using type = _WrapAlgPolicy;
  using _AlgPolicy = _PolicyT;
  using _Comp = _CompT;
  _Comp& __comp;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  _WrapAlgPolicy(_Comp& __c) : __comp(__c) {}
};
template <class _PolicyT, class _CompT>
struct _WrapAlgPolicy<_PolicyT, _CompT, __enable_if_t<std::is_same<_PolicyT, _ClassicAlgPolicy>::value> > {
  using type = _CompT;
};
template <class _CompT>
struct _UnwrapAlgPolicy {
  using _AlgPolicy = _ClassicAlgPolicy;
  using _Comp = _CompT;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr static
  _Comp __get_comp(_Comp __comp) { return __comp; }
};
template <class... _Ts>
struct _UnwrapAlgPolicy<_WrapAlgPolicy<_Ts...> > {
  using _Wrapped = _WrapAlgPolicy<_Ts...>;
  using _AlgPolicy = typename _Wrapped::_AlgPolicy;
  using _Comp = typename _Wrapped::_Comp;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr static
  _Comp __get_comp(_Wrapped& __w) { return __w.__comp; }
};
template <class _AlgPolicy, class _Compare, class _ForwardIterator>
// added by concept-synth, original LN: 14202
requires
requires (_ForwardIterator x0) { *x0; } &&
(
 requires (_Compare f, _ForwardIterator x0, _ForwardIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 requires (_Compare f, _ForwardIterator x0, _ForwardIterator x1) { f(*x0, *x1); }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr unsigned __sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z,
                                               _Compare __c) {
  using _Ops = _IterOps<_AlgPolicy>;
  unsigned __r = 0;
  if (!__c(*__y, *__x))
  {
    if (!__c(*__z, *__y))
      return __r;
    _Ops::iter_swap(__y, __z);
    __r = 1;
    if (__c(*__y, *__x))
    {
      _Ops::iter_swap(__x, __y);
      __r = 2;
    }
    return __r;
  }
  if (__c(*__z, *__y))
  {
    _Ops::iter_swap(__x, __z);
    __r = 1;
    return __r;
  }
  _Ops::iter_swap(__x, __y);
  __r = 1;
  if (__c(*__z, *__y))
  {
    _Ops::iter_swap(__y, __z);
    __r = 2;
  }
  return __r;
}
template <class _AlgPolicy, class _Compare, class _ForwardIterator>
// added by concept-synth, original LN: 14236
requires
(
 requires (_Compare f, _ForwardIterator x0, _ForwardIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 requires (_Compare f, _ForwardIterator x0, _ForwardIterator x1) { f(*x0, *x1); }
) &&
requires (_ForwardIterator x0) { *x0; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
unsigned __sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3, _ForwardIterator __x4,
                 _Compare __c) {
  using _Ops = _IterOps<_AlgPolicy>;
  unsigned __r = std::__sort3<_AlgPolicy, _Compare>(__x1, __x2, __x3, __c);
  if (__c(*__x4, *__x3)) {
    _Ops::iter_swap(__x3, __x4);
    ++__r;
    if (__c(*__x3, *__x2)) {
      _Ops::iter_swap(__x2, __x3);
      ++__r;
      if (__c(*__x2, *__x1)) {
        _Ops::iter_swap(__x1, __x2);
        ++__r;
      }
    }
  }
  return __r;
}
template <class _WrappedComp, class _ForwardIterator>
// added by concept-synth, original LN: 14256
requires
requires (_ForwardIterator x0) { *x0; }
__attribute__((__visibility__("hidden"))) unsigned __sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,
                                _ForwardIterator __x4, _ForwardIterator __x5, _WrappedComp __wrapped_comp) {
  using _Unwrap = _UnwrapAlgPolicy<_WrappedComp>;
  using _AlgPolicy = typename _Unwrap::_AlgPolicy;
  using _Ops = _IterOps<_AlgPolicy>;
  using _Compare = typename _Unwrap::_Comp;
  _Compare __c = _Unwrap::__get_comp(__wrapped_comp);
  unsigned __r = std::__sort4<_AlgPolicy, _Compare>(__x1, __x2, __x3, __x4, __c);
  if (__c(*__x5, *__x4)) {
    _Ops::iter_swap(__x4, __x5);
    ++__r;
    if (__c(*__x4, *__x3)) {
      _Ops::iter_swap(__x3, __x4);
      ++__r;
      if (__c(*__x3, *__x2)) {
        _Ops::iter_swap(__x2, __x3);
        ++__r;
        if (__c(*__x2, *__x1)) {
          _Ops::iter_swap(__x1, __x2);
          ++__r;
        }
      }
    }
  }
  return __r;
}
template <class _AlgPolicy, class _Compare, class _ForwardIterator>
// added by concept-synth, original LN: 14283
requires
requires (_ForwardIterator x0) { *x0; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) unsigned __sort5_wrap_policy(
    _ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3, _ForwardIterator __x4, _ForwardIterator __x5,
    _Compare __c) {
  using _WrappedComp = typename _WrapAlgPolicy<_AlgPolicy, _Compare>::type;
  _WrappedComp __wrapped_comp(__c);
  return std::__sort5<_WrappedComp>(
      std::move(__x1), std::move(__x2), std::move(__x3), std::move(__x4), std::move(__x5), __wrapped_comp);
}
template <class _Tp>
struct __is_simple_comparator : false_type {};
template <class _Tp>
struct __is_simple_comparator<__less<_Tp>&> : true_type {};
template <class _Tp>
struct __is_simple_comparator<less<_Tp>&> : true_type {};
template <class _Tp>
struct __is_simple_comparator<greater<_Tp>&> : true_type {};
template <>
struct __is_simple_comparator<ranges::less&> : true_type {};
template <>
struct __is_simple_comparator<ranges::greater&> : true_type {};
template <class _Compare, class _Iter, class _Tp = typename iterator_traits<_Iter>::value_type>
using __use_branchless_sort =
    integral_constant<bool, __is_cpp17_contiguous_iterator<_Iter>::value && sizeof(_Tp) <= sizeof(void*) &&
                                is_arithmetic<_Tp>::value && __is_simple_comparator<_Compare>::value>;
template <class _Compare, class _RandomAccessIterator>
// added by concept-synth, original LN: 14308
requires
requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); } &&
requires (_RandomAccessIterator x0) { *x0; }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void __cond_swap(_RandomAccessIterator __x, _RandomAccessIterator __y, _Compare __c) {
  using value_type = typename iterator_traits<_RandomAccessIterator>::value_type;
  bool __r = __c(*__x, *__y);
  value_type __tmp = __r ? *__x : *__y;
  *__y = __r ? *__y : *__x;
  *__x = __tmp;
}
template <class _Compare, class _RandomAccessIterator>
// added by concept-synth, original LN: 14316
requires
requires (_RandomAccessIterator x0) { *x0; } &&
requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void __partially_sorted_swap(_RandomAccessIterator __x, _RandomAccessIterator __y,
                                                          _RandomAccessIterator __z, _Compare __c) {
  using value_type = typename iterator_traits<_RandomAccessIterator>::value_type;
  bool __r = __c(*__z, *__x);
  value_type __tmp = __r ? *__z : *__x;
  *__z = __r ? *__x : *__z;
  __r = __c(__tmp, *__y);
  *__x = __r ? *__x : *__y;
  *__y = __r ? *__y : __tmp;
}
template <class, class _Compare, class _RandomAccessIterator>
// added by concept-synth, original LN: 14327
requires
requires (_RandomAccessIterator x0) { *x0; } &&
requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __enable_if_t<__use_branchless_sort<_Compare, _RandomAccessIterator>::value, void>
__sort3_maybe_branchless(_RandomAccessIterator __x1, _RandomAccessIterator __x2, _RandomAccessIterator __x3,
                         _Compare __c) {
  std::__cond_swap<_Compare>(__x2, __x3, __c);
  std::__partially_sorted_swap<_Compare>(__x1, __x2, __x3, __c);
}
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
// added by concept-synth, original LN: 14334
requires
requires (_RandomAccessIterator x0) { *x0; } &&
(
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __enable_if_t<!__use_branchless_sort<_Compare, _RandomAccessIterator>::value, void>
__sort3_maybe_branchless(_RandomAccessIterator __x1, _RandomAccessIterator __x2, _RandomAccessIterator __x3,
                         _Compare __c) {
  std::__sort3<_AlgPolicy, _Compare>(__x1, __x2, __x3, __c);
}
template <class, class _Compare, class _RandomAccessIterator>
// added by concept-synth, original LN: 14340
requires
requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); } &&
requires (_RandomAccessIterator x0) { *x0; }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __enable_if_t<__use_branchless_sort<_Compare, _RandomAccessIterator>::value, void>
__sort4_maybe_branchless(_RandomAccessIterator __x1, _RandomAccessIterator __x2, _RandomAccessIterator __x3,
                         _RandomAccessIterator __x4, _Compare __c) {
  std::__cond_swap<_Compare>(__x1, __x3, __c);
  std::__cond_swap<_Compare>(__x2, __x4, __c);
  std::__cond_swap<_Compare>(__x1, __x2, __c);
  std::__cond_swap<_Compare>(__x3, __x4, __c);
  std::__cond_swap<_Compare>(__x2, __x3, __c);
}
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
// added by concept-synth, original LN: 14350
requires
requires (_RandomAccessIterator x0) { *x0; } &&
(
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __enable_if_t<!__use_branchless_sort<_Compare, _RandomAccessIterator>::value, void>
__sort4_maybe_branchless(_RandomAccessIterator __x1, _RandomAccessIterator __x2, _RandomAccessIterator __x3,
                         _RandomAccessIterator __x4, _Compare __c) {
  std::__sort4<_AlgPolicy, _Compare>(__x1, __x2, __x3, __x4, __c);
}
template <class, class _Compare, class _RandomAccessIterator>
// added by concept-synth, original LN: 14356
requires
requires (_RandomAccessIterator x0) { *x0; } &&
requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __enable_if_t<__use_branchless_sort<_Compare, _RandomAccessIterator>::value, void>
__sort5_maybe_branchless(_RandomAccessIterator __x1, _RandomAccessIterator __x2, _RandomAccessIterator __x3,
                         _RandomAccessIterator __x4, _RandomAccessIterator __x5, _Compare __c) {
  std::__cond_swap<_Compare>(__x1, __x2, __c);
  std::__cond_swap<_Compare>(__x4, __x5, __c);
  std::__partially_sorted_swap<_Compare>(__x3, __x4, __x5, __c);
  std::__cond_swap<_Compare>(__x2, __x5, __c);
  std::__partially_sorted_swap<_Compare>(__x1, __x3, __x4, __c);
  std::__partially_sorted_swap<_Compare>(__x2, __x3, __x4, __c);
}
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
// added by concept-synth, original LN: 14367
requires
requires (_RandomAccessIterator x0) { *x0; }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __enable_if_t<!__use_branchless_sort<_Compare, _RandomAccessIterator>::value, void>
__sort5_maybe_branchless(_RandomAccessIterator __x1, _RandomAccessIterator __x2, _RandomAccessIterator __x3,
                         _RandomAccessIterator __x4, _RandomAccessIterator __x5, _Compare __c) {
  std::__sort5_wrap_policy<_AlgPolicy, _Compare>(__x1, __x2, __x3, __x4, __x5, __c);
}
template <class _AlgPolicy, class _Compare, class _BidirectionalIterator>
// added by concept-synth, original LN: 14373
requires
(
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { *x0; } &&
 requires (_BidirectionalIterator x0) { --x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr void __selection_sort(_BidirectionalIterator __first, _BidirectionalIterator __last,
                                                    _Compare __comp) {
  _BidirectionalIterator __lm1 = __last;
  for (--__lm1; __first != __lm1; ++__first) {
    _BidirectionalIterator __i = std::__min_element<_Compare>(__first, __last, __comp);
    if (__i != __first)
      _IterOps<_AlgPolicy>::iter_swap(__first, __i);
  }
}
template <class _AlgPolicy, class _Compare, class _BidirectionalIterator>
// added by concept-synth, original LN: 14384
requires
(
 requires (_BidirectionalIterator x0) { --x0; } &&
 requires (_BidirectionalIterator x0) { *x0; } &&
 requires (_BidirectionalIterator x0) { ++x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void __insertion_sort(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp) {
  using _Ops = _IterOps<_AlgPolicy>;
  typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
  if (__first != __last) {
    _BidirectionalIterator __i = __first;
    for (++__i; __i != __last; ++__i) {
      _BidirectionalIterator __j = __i;
      value_type __t(_Ops::__iter_move(__j));
      for (_BidirectionalIterator __k = __i; __k != __first && __comp(__t, *--__k); --__j)
        *__j = _Ops::__iter_move(__k);
      *__j = std::move(__t);
    }
  }
}
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
// added by concept-synth, original LN: 14400
requires
(
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
) &&
(
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 (
  requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); } ||
  (
   requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
   requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
  )
 )
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void __insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {
  using _Ops = _IterOps<_AlgPolicy>;
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
  typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
  _RandomAccessIterator __j = __first + difference_type(2);
  std::__sort3_maybe_branchless<_AlgPolicy, _Compare>(__first, __first + difference_type(1), __j, __comp);
  for (_RandomAccessIterator __i = __j + difference_type(1); __i != __last; ++__i) {
    if (__comp(*__i, *__j)) {
      value_type __t(_Ops::__iter_move(__i));
      _RandomAccessIterator __k = __j;
      __j = __i;
      do {
        *__j = _Ops::__iter_move(__k);
        __j = __k;
      } while (__j != __first && __comp(__t, *--__k));
      *__j = std::move(__t);
    }
    __j = __i;
  }
}
template <class _WrappedComp, class _RandomAccessIterator>
// added by concept-synth, original LN: 14422
requires
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { --x0; }
)
__attribute__((__visibility__("hidden"))) bool __insertion_sort_incomplete(
    _RandomAccessIterator __first, _RandomAccessIterator __last, _WrappedComp __wrapped_comp) {
  using _Unwrap = _UnwrapAlgPolicy<_WrappedComp>;
  using _AlgPolicy = typename _Unwrap::_AlgPolicy;
  using _Ops = _IterOps<_AlgPolicy>;
  using _Compare = typename _Unwrap::_Comp;
  _Compare __comp = _Unwrap::__get_comp(__wrapped_comp);
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
  switch (__last - __first) {
  case 0:
  case 1:
    return true;
  case 2:
    if (__comp(*--__last, *__first))
      _IterOps<_AlgPolicy>::iter_swap(__first, __last);
    return true;
  case 3:
    std::__sort3_maybe_branchless<_AlgPolicy, _Compare>(__first, __first + difference_type(1), --__last, __comp);
    return true;
  case 4:
    std::__sort4_maybe_branchless<_AlgPolicy, _Compare>(
        __first, __first + difference_type(1), __first + difference_type(2), --__last, __comp);
    return true;
  case 5:
    std::__sort5_maybe_branchless<_AlgPolicy, _Compare>(
        __first, __first + difference_type(1), __first + difference_type(2), __first + difference_type(3),
        --__last, __comp);
    return true;
  }
  typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
  _RandomAccessIterator __j = __first + difference_type(2);
  std::__sort3_maybe_branchless<_AlgPolicy, _Compare>(__first, __first + difference_type(1), __j, __comp);
  const unsigned __limit = 8;
  unsigned __count = 0;
  for (_RandomAccessIterator __i = __j + difference_type(1); __i != __last; ++__i) {
    if (__comp(*__i, *__j)) {
      value_type __t(_Ops::__iter_move(__i));
      _RandomAccessIterator __k = __j;
      __j = __i;
      do {
        *__j = _Ops::__iter_move(__k);
        __j = __k;
      } while (__j != __first && __comp(__t, *--__k));
      *__j = std::move(__t);
      if (++__count == __limit)
        return ++__i == __last;
    }
    __j = __i;
  }
  return true;
}
template <class _AlgPolicy, class _Compare, class _BidirectionalIterator>
// added by concept-synth, original LN: 14474
requires
(
 requires (_BidirectionalIterator x0) { *x0; } &&
 requires (_BidirectionalIterator x0) { ++x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void __insertion_sort_move(_BidirectionalIterator __first1, _BidirectionalIterator __last1,
                           typename iterator_traits<_BidirectionalIterator>::value_type* __first2, _Compare __comp) {
  using _Ops = _IterOps<_AlgPolicy>;
  typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
  if (__first1 != __last1) {
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n&> __h(__first2, __d);
    value_type* __last2 = __first2;
    ::new ((void*)__last2) value_type(_Ops::__iter_move(__first1));
    __d.template __incr<value_type>();
    for (++__last2; ++__first1 != __last1; ++__last2) {
      value_type* __j2 = __last2;
      value_type* __i2 = __j2;
      if (__comp(*__first1, *--__i2)) {
        ::new ((void*)__j2) value_type(std::move(*__i2));
        __d.template __incr<value_type>();
        for (--__j2; __i2 != __first2 && __comp(*__first1, *--__i2); --__j2)
          *__j2 = std::move(*__i2);
        *__j2 = _Ops::__iter_move(__first1);
      } else {
        ::new ((void*)__j2) value_type(_Ops::__iter_move(__first1));
        __d.template __incr<value_type>();
      }
    }
    __h.release();
  }
}
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
// added by concept-synth, original LN: 14503
requires
(
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 (
  requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); } ||
  (
   requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
   requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
  )
 ) &&
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
) &&
(
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; }
)
void __introsort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
                 typename iterator_traits<_RandomAccessIterator>::difference_type __depth) {
  using _Ops = _IterOps<_AlgPolicy>;
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
  typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
  const difference_type __limit =
      is_trivially_copy_constructible<value_type>::value && is_trivially_copy_assignable<value_type>::value ? 30 : 6;
  while (true) {
  __restart:
    difference_type __len = __last - __first;
    switch (__len) {
    case 0:
    case 1:
      return;
    case 2:
      if (__comp(*--__last, *__first))
        _IterOps<_AlgPolicy>::iter_swap(__first, __last);
      return;
    case 3:
      std::__sort3_maybe_branchless<_AlgPolicy, _Compare>(__first, __first + difference_type(1), --__last, __comp);
      return;
    case 4:
      std::__sort4_maybe_branchless<_AlgPolicy, _Compare>(
          __first, __first + difference_type(1), __first + difference_type(2), --__last, __comp);
      return;
    case 5:
      std::__sort5_maybe_branchless<_AlgPolicy, _Compare>(
          __first, __first + difference_type(1), __first + difference_type(2), __first + difference_type(3),
          --__last, __comp);
      return;
    }
    if (__len <= __limit) {
      std::__insertion_sort_3<_AlgPolicy, _Compare>(__first, __last, __comp);
      return;
    }
    if (__depth == 0) {
      std::__partial_sort<_AlgPolicy, _Compare>(__first, __last, __last, __comp);
      return;
    }
    --__depth;
    _RandomAccessIterator __m = __first;
    _RandomAccessIterator __lm1 = __last;
    --__lm1;
    unsigned __n_swaps;
    {
      difference_type __delta;
      if (__len >= 1000) {
        __delta = __len / 2;
        __m += __delta;
        __delta /= 2;
        __n_swaps = std::__sort5_wrap_policy<_AlgPolicy, _Compare>(
            __first, __first + __delta, __m, __m + __delta, __lm1, __comp);
      } else {
        __delta = __len / 2;
        __m += __delta;
        __n_swaps = std::__sort3<_AlgPolicy, _Compare>(__first, __m, __lm1, __comp);
      }
    }
    _RandomAccessIterator __i = __first;
    _RandomAccessIterator __j = __lm1;
    if (!__comp(*__i, *__m))
    {
      while (true) {
        if (__i == --__j) {
          ++__i;
          __j = __last;
          if (!__comp(*__first, *--__j))
          {
            while (true) {
              if (__i == __j)
                return;
              if (__comp(*__first, *__i)) {
                _Ops::iter_swap(__i, __j);
                ++__n_swaps;
                ++__i;
                break;
              }
              ++__i;
            }
          }
          if (__i == __j)
            return;
          while (true) {
            while (!__comp(*__first, *__i))
              ++__i;
            while (__comp(*__first, *--__j))
              ;
            if (__i >= __j)
              break;
            _Ops::iter_swap(__i, __j);
            ++__n_swaps;
            ++__i;
          }
          __first = __i;
          goto __restart;
        }
        if (__comp(*__j, *__m)) {
          _Ops::iter_swap(__i, __j);
          ++__n_swaps;
          break;
        }
      }
    }
    ++__i;
    if (__i < __j) {
      while (true) {
        while (__comp(*__i, *__m))
          ++__i;
        while (!__comp(*--__j, *__m))
          ;
        if (__i > __j)
          break;
        _Ops::iter_swap(__i, __j);
        ++__n_swaps;
        if (__m == __i)
          __m = __j;
        ++__i;
      }
    }
    if (__i != __m && __comp(*__m, *__i)) {
      _Ops::iter_swap(__i, __m);
      ++__n_swaps;
    }
    if (__n_swaps == 0) {
      using _WrappedComp = typename _WrapAlgPolicy<_AlgPolicy, _Compare>::type;
      _WrappedComp __wrapped_comp(__comp);
      bool __fs = std::__insertion_sort_incomplete<_WrappedComp>(__first, __i, __wrapped_comp);
      if (std::__insertion_sort_incomplete<_WrappedComp>(__i + difference_type(1), __last, __wrapped_comp)) {
        if (__fs)
          return;
        __last = __i;
        continue;
      } else {
        if (__fs) {
          __first = ++__i;
          continue;
        }
      }
    }
    if (__i - __first < __last - __i) {
      std::__introsort<_AlgPolicy, _Compare>(__first, __i, __comp, __depth);
      __first = ++__i;
    } else {
      std::__introsort<_AlgPolicy, _Compare>(__i + difference_type(1), __last, __comp, __depth);
      __last = __i;
    }
  }
}
template <typename _Number>
// added by concept-synth, original LN: 14652
requires
requires (_Number x0) { x0++; }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) _Number __log2i(_Number __n) {
  if (__n == 0)
    return 0;
  if (sizeof(__n) <= sizeof(unsigned))
    return sizeof(unsigned) * 8 - 1 - __libcpp_clz(static_cast<unsigned>(__n));
  if (sizeof(__n) <= sizeof(unsigned long))
    return sizeof(unsigned long) * 8 - 1 - __libcpp_clz(static_cast<unsigned long>(__n));
  if (sizeof(__n) <= sizeof(unsigned long long))
    return sizeof(unsigned long long) * 8 - 1 - __libcpp_clz(static_cast<unsigned long long>(__n));
  _Number __log2 = 0;
  while (__n > 1) {
    __log2++;
    __n >>= 1;
  }
  return __log2;
}
template <class _WrappedComp, class _RandomAccessIterator>
// added by concept-synth, original LN: 14669
requires
(
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; }
)
__attribute__((__visibility__("hidden"))) void __sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _WrappedComp __wrapped_comp) {
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
  difference_type __depth_limit = 2 * __log2i(__last - __first);
  using _Unwrap = _UnwrapAlgPolicy<_WrappedComp>;
  using _AlgPolicy = typename _Unwrap::_AlgPolicy;
  using _Compare = typename _Unwrap::_Comp;
  _Compare __comp = _Unwrap::__get_comp(__wrapped_comp);
  std::__introsort<_AlgPolicy, _Compare>(__first, __last, __comp, __depth_limit);
}
template <class _Compare, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void __sort(_Tp** __first, _Tp** __last, __less<_Tp*>&) {
  __less<uintptr_t> __comp;
  std::__sort<__less<uintptr_t>&, uintptr_t*>((uintptr_t*)__first, (uintptr_t*)__last, __comp);
}
extern template __attribute__((__visibility__("default"))) void __sort<__less<char>&, char*>(char*, char*, __less<char>&);
extern template __attribute__((__visibility__("default"))) void __sort<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&);
extern template __attribute__((__visibility__("default"))) void __sort<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&);
extern template __attribute__((__visibility__("default"))) void __sort<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&);
extern template __attribute__((__visibility__("default"))) void __sort<__less<short>&, short*>(short*, short*, __less<short>&);
extern template __attribute__((__visibility__("default"))) void __sort<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&);
extern template __attribute__((__visibility__("default"))) void __sort<__less<int>&, int*>(int*, int*, __less<int>&);
extern template __attribute__((__visibility__("default"))) void __sort<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&);
extern template __attribute__((__visibility__("default"))) void __sort<__less<long>&, long*>(long*, long*, __less<long>&);
extern template __attribute__((__visibility__("default"))) void __sort<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&);
extern template __attribute__((__visibility__("default"))) void __sort<__less<long long>&, long long*>(long long*, long long*, __less<long long>&);
extern template __attribute__((__visibility__("default"))) void __sort<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&);
extern template __attribute__((__visibility__("default"))) void __sort<__less<float>&, float*>(float*, float*, __less<float>&);
extern template __attribute__((__visibility__("default"))) void __sort<__less<double>&, double*>(double*, double*, __less<double>&);
extern template __attribute__((__visibility__("default"))) void __sort<__less<long double>&, long double*>(long double*, long double*, __less<long double>&);
extern template __attribute__((__visibility__("default"))) bool __insertion_sort_incomplete<__less<char>&, char*>(char*, char*, __less<char>&);
extern template __attribute__((__visibility__("default"))) bool __insertion_sort_incomplete<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&);
extern template __attribute__((__visibility__("default"))) bool __insertion_sort_incomplete<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&);
extern template __attribute__((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&);
extern template __attribute__((__visibility__("default"))) bool __insertion_sort_incomplete<__less<short>&, short*>(short*, short*, __less<short>&);
extern template __attribute__((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&);
extern template __attribute__((__visibility__("default"))) bool __insertion_sort_incomplete<__less<int>&, int*>(int*, int*, __less<int>&);
extern template __attribute__((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&);
extern template __attribute__((__visibility__("default"))) bool __insertion_sort_incomplete<__less<long>&, long*>(long*, long*, __less<long>&);
extern template __attribute__((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&);
extern template __attribute__((__visibility__("default"))) bool __insertion_sort_incomplete<__less<long long>&, long long*>(long long*, long long*, __less<long long>&);
extern template __attribute__((__visibility__("default"))) bool __insertion_sort_incomplete<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&);
extern template __attribute__((__visibility__("default"))) bool __insertion_sort_incomplete<__less<float>&, float*>(float*, float*, __less<float>&);
extern template __attribute__((__visibility__("default"))) bool __insertion_sort_incomplete<__less<double>&, double*>(double*, double*, __less<double>&);
extern template __attribute__((__visibility__("default"))) bool __insertion_sort_incomplete<__less<long double>&, long double*>(long double*, long double*, __less<long double>&);
extern template __attribute__((__visibility__("default"))) unsigned __sort5<__less<long double>&, long double*>(long double*, long double*, long double*, long double*, long double*, __less<long double>&);
template <class _AlgPolicy, class _RandomAccessIterator, class _Comp>
// added by concept-synth, original LN: 14715
requires
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void __sort_impl(_RandomAccessIterator __first, _RandomAccessIterator __last, _Comp& __comp) {
  std::__debug_randomize_range<_AlgPolicy>(__first, __last);
  using _Comp_ref = __comp_ref_type<_Comp>;
  if (__libcpp_is_constant_evaluated()) {
    std::__partial_sort<_AlgPolicy>(__first, __last, __last, __comp);
  } else {
    using _WrappedComp = typename _WrapAlgPolicy<_AlgPolicy, _Comp_ref>::type;
    _Comp_ref __comp_ref(__comp);
    _WrappedComp __wrapped_comp(__comp_ref);
    std::__sort<_WrappedComp>(std::__unwrap_iter(__first), std::__unwrap_iter(__last), __wrapped_comp);
  }
}
template <class _RandomAccessIterator, class _Comp>
// added by concept-synth, original LN: 14729
requires
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Comp __comp) {
  std::__sort_impl<_ClassicAlgPolicy>(std::move(__first), std::move(__last), __comp);
}
template <class _RandomAccessIterator>
// added by concept-synth, original LN: 14734
requires
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void sort(_RandomAccessIterator __first, _RandomAccessIterator __last) {
  std::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}
}}
namespace std { inline namespace __1 {
template<class _Compare, class _RandomAccessIterator>
// added by concept-synth, original LN: 14741
requires
requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
(
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { --x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool
__nth_element_find_guard(_RandomAccessIterator& __i, _RandomAccessIterator& __j,
                         _RandomAccessIterator __m, _Compare __comp)
{
    while (true) {
        if (__i == --__j) {
            return false;
        }
        if (__comp(*__j, *__m)) {
            return true;
        }
    }
}
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
// added by concept-synth, original LN: 14755
requires
(
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
) &&
(
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { ++x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr void
__nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)
{
    using _Ops = _IterOps<_AlgPolicy>;
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    const difference_type __limit = 7;
    while (true)
    {
        if (__nth == __last)
            return;
        difference_type __len = __last - __first;
        switch (__len)
        {
        case 0:
        case 1:
            return;
        case 2:
            if (__comp(*--__last, *__first))
                _Ops::iter_swap(__first, __last);
            return;
        case 3:
            {
            _RandomAccessIterator __m = __first;
            std::__sort3<_AlgPolicy, _Compare>(__first, ++__m, --__last, __comp);
            return;
            }
        }
        if (__len <= __limit)
        {
            std::__selection_sort<_AlgPolicy, _Compare>(__first, __last, __comp);
            return;
        }
        _RandomAccessIterator __m = __first + __len/2;
        _RandomAccessIterator __lm1 = __last;
        unsigned __n_swaps = std::__sort3<_AlgPolicy, _Compare>(__first, __m, --__lm1, __comp);
        _RandomAccessIterator __i = __first;
        _RandomAccessIterator __j = __lm1;
        if (!__comp(*__i, *__m))
        {
            if (std::__nth_element_find_guard<_Compare>(__i, __j, __m, __comp)) {
                _Ops::iter_swap(__i, __j);
                ++__n_swaps;
            } else {
                ++__i;
                __j = __last;
                if (!__comp(*__first, *--__j)) {
                    while (true) {
                        if (__i == __j) {
                            return;
                        } else if (__comp(*__first, *__i)) {
                            _Ops::iter_swap(__i, __j);
                            ++__n_swaps;
                            ++__i;
                            break;
                        }
                        ++__i;
                    }
                }
                if (__i == __j) {
                    return;
                }
                while (true) {
                    while (!__comp(*__first, *__i))
                        ++__i;
                    while (__comp(*__first, *--__j))
                        ;
                    if (__i >= __j)
                        break;
                    _Ops::iter_swap(__i, __j);
                    ++__n_swaps;
                    ++__i;
                }
                if (__nth < __i) {
                    return;
                }
                __first = __i;
                continue;
            }
        }
        ++__i;
        if (__i < __j)
        {
            while (true)
            {
                while (__comp(*__i, *__m))
                    ++__i;
                while (!__comp(*--__j, *__m))
                    ;
                if (__i >= __j)
                    break;
                _Ops::iter_swap(__i, __j);
                ++__n_swaps;
                if (__m == __i)
                    __m = __j;
                ++__i;
            }
        }
        if (__i != __m && __comp(*__m, *__i))
        {
            _Ops::iter_swap(__i, __m);
            ++__n_swaps;
        }
        if (__nth == __i)
            return;
        if (__n_swaps == 0)
        {
            if (__nth < __i)
            {
                __j = __m = __first;
                while (true) {
                    if (++__j == __i) {
                        return;
                    }
                    if (__comp(*__j, *__m)) {
                        break;
                    }
                    __m = __j;
                }
            }
            else
            {
                __j = __m = __i;
                while (true) {
                    if (++__j == __last) {
                        return;
                    }
                    if (__comp(*__j, *__m)) {
                        break;
                    }
                    __m = __j;
                }
            }
        }
        if (__nth < __i)
        {
            __last = __i;
        }
        else
        {
            __first = ++__i;
        }
    }
}
template <class _AlgPolicy, class _RandomAccessIterator, class _Compare>
// added by concept-synth, original LN: 14899
requires
(
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
) &&
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { --x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void __nth_element_impl(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last,
                        _Compare& __comp) {
  if (__nth == __last)
    return;
  std::__debug_randomize_range<_AlgPolicy>(__first, __last);
  std::__nth_element<_AlgPolicy, __comp_ref_type<_Compare> >(__first, __nth, __last, __comp);
  std::__debug_randomize_range<_AlgPolicy>(__first, __nth);
  if (__nth != __last) {
    std::__debug_randomize_range<_AlgPolicy>(++__nth, __last);
  }
}
template <class _RandomAccessIterator, class _Compare>
// added by concept-synth, original LN: 14912
requires
(
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { f(*x0, *x1); }
) &&
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { --x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last,
                 _Compare __comp) {
  std::__nth_element_impl<_ClassicAlgPolicy>(std::move(__first), std::move(__nth), std::move(__last), __comp);
}
template <class _RandomAccessIterator>
// added by concept-synth, original LN: 14918
requires
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { --x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last) {
  std::nth_element(std::move(__first), std::move(__nth), std::move(__last), __less<typename
      iterator_traits<_RandomAccessIterator>::value_type>());
}
}}

namespace std { inline namespace __1 {
template <class _Pred, class _Proj>
struct _ProjectedPred {
  _Pred& __pred;
  _Proj& __proj;
  constexpr _ProjectedPred(_Pred& __pred_arg, _Proj& __proj_arg) : __pred(__pred_arg), __proj(__proj_arg) {}
  template <class _Tp>
  typename __invoke_of<_Pred&,
                       decltype(std::__invoke(std::declval<_Proj&>(), std::declval<_Tp>()))
  >::type
  constexpr operator()(_Tp&& __v) const {
    return std::__invoke(__pred, std::__invoke(__proj, std::forward<_Tp>(__v)));
  }
  template <class _T1, class _T2>
  typename __invoke_of<_Pred&,
                       decltype(std::__invoke(std::declval<_Proj&>(), std::declval<_T1>())),
                       decltype(std::__invoke(std::declval<_Proj&>(), std::declval<_T2>()))
  >::type
  constexpr operator()(_T1&& __lhs, _T2&& __rhs) const {
    return std::__invoke(__pred,
                      std::__invoke(__proj, std::forward<_T1>(__lhs)),
                      std::__invoke(__proj, std::forward<_T2>(__rhs)));
  }
};
template <class _Pred, class _Proj, class = void>
struct __can_use_pristine_comp : false_type {};
template <class _Pred, class _Proj>
struct __can_use_pristine_comp<_Pred, _Proj, __enable_if_t<
    !is_member_pointer<typename decay<_Pred>::type>::value && (
      is_same<typename decay<_Proj>::type, identity>::value ||
      is_same<typename decay<_Proj>::type, __identity>::value
    )
> > : true_type {};
template <class _Pred, class _Proj>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr static
__enable_if_t<
    !__can_use_pristine_comp<_Pred, _Proj>::value,
    _ProjectedPred<_Pred, _Proj>
>
__make_projected(_Pred& __pred, _Proj& __proj) {
  return _ProjectedPred<_Pred, _Proj>(__pred, __proj);
}
template <class _Pred, class _Proj>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr static
__enable_if_t<
    __can_use_pristine_comp<_Pred, _Proj>::value,
    _Pred&
>
__make_projected(_Pred& __pred, _Proj&) {
  return __pred;
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _Comp, class _Proj1, class _Proj2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr static
decltype(auto) __make_projected_comp(_Comp& __comp, _Proj1& __proj1, _Proj2& __proj2) {
  if constexpr (same_as<decay_t<_Proj1>, identity> && same_as<decay_t<_Proj2>, identity> &&
                !is_member_pointer_v<decay_t<_Comp>>) {
    return __comp;
  } else {
    return [&](auto&& __lhs, auto&& __rhs) {
      return std::invoke(__comp,
                        std::invoke(__proj1, std::forward<decltype(__lhs)>(__lhs)),
                        std::invoke(__proj2, std::forward<decltype(__rhs)>(__rhs)));
    };
  }
}
}
}}
namespace std { inline namespace __1 {
template <class _AlgPolicy, class _Compare,
          class _InputIterator, class _Sentinel1, class _RandomAccessIterator, class _Sentinel2,
          class _Proj1, class _Proj2>
// added by concept-synth, original LN: 14997
requires
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
) &&
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_InputIterator, _RandomAccessIterator>
__partial_sort_copy(_InputIterator __first, _Sentinel1 __last,
                    _RandomAccessIterator __result_first, _Sentinel2 __result_last,
                    _Compare&& __comp, _Proj1&& __proj1, _Proj2&& __proj2)
{
    _RandomAccessIterator __r = __result_first;
    auto&& __projected_comp = std::__make_projected(__comp, __proj2);
    if (__r != __result_last)
    {
        for (; __first != __last && __r != __result_last; ++__first, (void) ++__r)
            *__r = *__first;
        std::__make_heap<_AlgPolicy>(__result_first, __r, __projected_comp);
        typename iterator_traits<_RandomAccessIterator>::difference_type __len = __r - __result_first;
        for (; __first != __last; ++__first)
            if (std::__invoke(__comp, std::__invoke(__proj1, *__first), std::__invoke(__proj2, *__result_first))) {
                *__result_first = *__first;
                std::__sift_down<_AlgPolicy>(__result_first, __projected_comp, __len, __result_first);
            }
        std::__sort_heap<_AlgPolicy>(__result_first, __r, __projected_comp);
    }
    return pair<_InputIterator, _RandomAccessIterator>(
        _IterOps<_AlgPolicy>::next(std::move(__first), std::move(__last)), std::move(__r));
}
template <class _InputIterator, class _RandomAccessIterator, class _Compare>
// added by concept-synth, original LN: 15023
requires
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
) &&
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_RandomAccessIterator
partial_sort_copy(_InputIterator __first, _InputIterator __last,
                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)
{
  static_assert(__is_callable<_Compare, decltype(*__first), decltype(*__result_first)>::value,
                "Comparator has to be callable");
  auto __result = std::__partial_sort_copy<_ClassicAlgPolicy>(__first, __last, __result_first, __result_last,
      static_cast<__comp_ref_type<_Compare> >(__comp), __identity(), __identity());
  return __result.second;
}
template <class _InputIterator, class _RandomAccessIterator>
// added by concept-synth, original LN: 15035
requires
(
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 requires (_RandomAccessIterator x0) { *x0; }
) &&
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_RandomAccessIterator
partial_sort_copy(_InputIterator __first, _InputIterator __last,
                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)
{
    return std::partial_sort_copy(__first, __last, __result_first, __result_last,
                                   __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}
}}
namespace std { inline namespace __1 {
template <class _Predicate, class _AlgPolicy, class _ForwardIterator, class _Sentinel>
// added by concept-synth, original LN: 15046
requires
(
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0) { *x0; }
) &&
(
 requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
 requires (_Predicate f, _ForwardIterator x0) { f(*x0); }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_ForwardIterator, _ForwardIterator>
__partition_impl(_ForwardIterator __first, _Sentinel __last, _Predicate __pred, forward_iterator_tag)
{
    while (true)
    {
        if (__first == __last)
            return std::make_pair(std::move(__first), std::move(__first));
        if (!__pred(*__first))
            break;
        ++__first;
    }
    _ForwardIterator __p = __first;
    while (++__p != __last)
    {
        if (__pred(*__p))
        {
            _IterOps<_AlgPolicy>::iter_swap(__first, __p);
            ++__first;
        }
    }
    return std::make_pair(std::move(__first), std::move(__p));
}
template <class _Predicate, class _AlgPolicy, class _BidirectionalIterator, class _Sentinel>
// added by concept-synth, original LN: 15069
requires
(
 requires (_BidirectionalIterator x0) { --x0; } &&
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { *x0; }
) &&
requires (_Predicate f, _BidirectionalIterator x0) { f(*x0); }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_BidirectionalIterator, _BidirectionalIterator>
__partition_impl(_BidirectionalIterator __first, _Sentinel __sentinel, _Predicate __pred,
            bidirectional_iterator_tag)
{
    _BidirectionalIterator __original_last = _IterOps<_AlgPolicy>::next(__first, __sentinel);
    _BidirectionalIterator __last = __original_last;
    while (true)
    {
        while (true)
        {
            if (__first == __last)
                return std::make_pair(std::move(__first), std::move(__original_last));
            if (!__pred(*__first))
                break;
            ++__first;
        }
        do
        {
            if (__first == --__last)
                return std::make_pair(std::move(__first), std::move(__original_last));
        } while (!__pred(*__last));
        _IterOps<_AlgPolicy>::iter_swap(__first, __last);
        ++__first;
    }
}
template <class _AlgPolicy, class _ForwardIterator, class _Sentinel, class _Predicate, class _IterCategory>
// added by concept-synth, original LN: 15095
requires
(
 (
  requires (_ForwardIterator x0) { ++x0; } &&
  requires (_ForwardIterator x0) { *x0; }
 ) ||
 (
  requires (_ForwardIterator x0) { --x0; } &&
  requires (_ForwardIterator x0) { ++x0; } &&
  requires (_ForwardIterator x0) { *x0; }
 )
) &&
(
 (
  requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
  requires (_Predicate f, _ForwardIterator x0) { f(*x0); }
 ) ||
 requires (_Predicate f, _ForwardIterator x0) { f(*x0); }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
pair<_ForwardIterator, _ForwardIterator> __partition(
    _ForwardIterator __first, _Sentinel __last, _Predicate&& __pred, _IterCategory __iter_category) {
  return std::__partition_impl<__remove_cvref_t<_Predicate>&, _AlgPolicy>(
      std::move(__first), std::move(__last), __pred, __iter_category);
}
template <class _ForwardIterator, class _Predicate>
// added by concept-synth, original LN: 15102
requires
(
 (
  requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
  requires (_Predicate f, _ForwardIterator x0) { f(*x0); }
 ) ||
 requires (_Predicate f, _ForwardIterator x0) { f(*x0); }
) &&
(
 (
  requires (_ForwardIterator x0) { ++x0; } &&
  requires (_ForwardIterator x0) { *x0; }
 ) ||
 (
  requires (_ForwardIterator x0) { --x0; } &&
  requires (_ForwardIterator x0) { ++x0; } &&
  requires (_ForwardIterator x0) { *x0; }
 )
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_ForwardIterator
partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
  using _IterCategory = typename iterator_traits<_ForwardIterator>::iterator_category;
  auto __result = std::__partition<_ClassicAlgPolicy>(std::move(__first), std::move(__last), __pred, _IterCategory());
  return __result.first;
}
}}
namespace std { inline namespace __1 {
template <class _InputIterator, class _OutputIterator1,
          class _OutputIterator2, class _Predicate>
// added by concept-synth, original LN: 15113
requires
(
 requires (_OutputIterator2 x0) { ++x0; } &&
 requires (_OutputIterator2 x0) { *x0; }
) &&
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
) &&
requires (_Predicate f, _InputIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
(
 requires (_OutputIterator1 x0) { ++x0; } &&
 requires (_OutputIterator1 x0) { *x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<_OutputIterator1, _OutputIterator2>
partition_copy(_InputIterator __first, _InputIterator __last,
               _OutputIterator1 __out_true, _OutputIterator2 __out_false,
               _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (__pred(*__first))
        {
            *__out_true = *__first;
            ++__out_true;
        }
        else
        {
            *__out_false = *__first;
            ++__out_false;
        }
    }
    return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
}
}}
namespace std { inline namespace __1 {
template<class _ForwardIterator, class _Predicate>
// added by concept-synth, original LN: 15137
requires
requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
(
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0) { *x0; } &&
 (
  (
   requires (_ForwardIterator x0) { ++x0; } &&
   requires (_ForwardIterator x0, _ForwardIterator x1) { x0 != x1; }
  ) ||
  requires (_ForwardIterator x0, _ForwardIterator x1) { x0 - x1; }
 )
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _ForwardIterator
partition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    difference_type __len = std::distance(__first, __last);
    while (__len != 0)
    {
        difference_type __l2 = std::__half_positive(__len);
        _ForwardIterator __m = __first;
        std::advance(__m, __l2);
        if (__pred(*__m))
        {
            __first = ++__m;
            __len -= __l2 + 1;
        }
        else
            __len = __l2;
    }
    return __first;
}
}}

namespace std { inline namespace __1 {
template <class _AlgPolicy, class _Compare, class _BidirectionalIterator, class _Sentinel>
// added by concept-synth, original LN: 15161
requires
(
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { --x0; } &&
 requires (_BidirectionalIterator x0) { *x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
pair<_BidirectionalIterator, bool>
__prev_permutation(_BidirectionalIterator __first, _Sentinel __last, _Compare&& __comp)
{
    using _Result = pair<_BidirectionalIterator, bool>;
    _BidirectionalIterator __last_iter = _IterOps<_AlgPolicy>::next(__first, __last);
    _BidirectionalIterator __i = __last_iter;
    if (__first == __last || __first == --__i)
        return _Result(std::move(__last_iter), false);
    while (true)
    {
        _BidirectionalIterator __ip1 = __i;
        if (__comp(*__ip1, *--__i))
        {
            _BidirectionalIterator __j = __last_iter;
            while (!__comp(*--__j, *__i))
                ;
            _IterOps<_AlgPolicy>::iter_swap(__i, __j);
            std::__reverse<_AlgPolicy>(__ip1, __last_iter);
            return _Result(std::move(__last_iter), true);
        }
        if (__i == __first)
        {
            std::__reverse<_AlgPolicy>(__first, __last_iter);
            return _Result(std::move(__last_iter), false);
        }
    }
}
template <class _BidirectionalIterator, class _Compare>
// added by concept-synth, original LN: 15190
requires
(
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { --x0; } &&
 requires (_BidirectionalIterator x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
{
  return std::__prev_permutation<_ClassicAlgPolicy>(
      std::move(__first), std::move(__last), static_cast<__comp_ref_type<_Compare> >(__comp)).second;
}
template <class _BidirectionalIterator>
// added by concept-synth, original LN: 15198
requires
(
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { --x0; } &&
 requires (_BidirectionalIterator x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)
{
    return std::prev_permutation(__first, __last,
                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}
}}

namespace std { inline namespace __1 {
template<indirectly_readable _It, indirectly_regular_unary_invocable<_It> _Proj>
struct projected {
  using value_type = remove_cvref_t<indirect_result_t<_Proj&, _It>>;
  indirect_result_t<_Proj&, _It> operator*() const;
};
template<weakly_incrementable _It, class _Proj>
struct incrementable_traits<projected<_It, _Proj>> {
  using difference_type = iter_difference_t<_It>;
};
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __adjacent_find {
struct __fn {
  template <class _Iter, class _Sent, class _Proj, class _Pred>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr static
  _Iter __adjacent_find_impl(_Iter __first, _Sent __last, _Pred& __pred, _Proj& __proj) {
    if (__first == __last)
      return __first;
    auto __i = __first;
    while (++__i != __last) {
      if (std::invoke(__pred, std::invoke(__proj, *__first), std::invoke(__proj, *__i)))
        return __first;
      __first = __i;
    }
    return __i;
  }
  template <forward_iterator _Iter, sentinel_for<_Iter> _Sent,
            class _Proj = identity,
            indirect_binary_predicate<projected<_Iter, _Proj>, projected<_Iter, _Proj>> _Pred = ranges::equal_to>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  _Iter operator()(_Iter __first, _Sent __last, _Pred __pred = {}, _Proj __proj = {}) const {
    return __adjacent_find_impl(std::move(__first), std::move(__last), __pred, __proj);
  }
  template <forward_range _Range,
            class _Proj = identity,
            indirect_binary_predicate<projected<iterator_t<_Range>, _Proj>,
                                      projected<iterator_t<_Range>, _Proj>> _Pred = ranges::equal_to>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  borrowed_iterator_t<_Range> operator()(_Range&& __range, _Pred __pred = {}, _Proj __proj = {}) const {
    return __adjacent_find_impl(ranges::begin(__range), ranges::end(__range), __pred, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto adjacent_find = __adjacent_find::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __all_of {
struct __fn {
  template <class _Iter, class _Sent, class _Proj, class _Pred>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr static
  bool __all_of_impl(_Iter __first, _Sent __last, _Pred& __pred, _Proj& __proj) {
    for (; __first != __last; ++__first) {
      if (!std::invoke(__pred, std::invoke(__proj, *__first)))
        return false;
    }
    return true;
  }
  template <input_iterator _Iter, sentinel_for<_Iter> _Sent, class _Proj = identity,
            indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  bool operator()(_Iter __first, _Sent __last, _Pred __pred, _Proj __proj = {}) const {
    return __all_of_impl(std::move(__first), std::move(__last), __pred, __proj);
  }
  template <input_range _Range, class _Proj = identity,
            indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  bool operator()(_Range&& __range, _Pred __pred, _Proj __proj = {}) const {
    return __all_of_impl(ranges::begin(__range), ranges::end(__range), __pred, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto all_of = __all_of::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __any_of {
struct __fn {
  template <class _Iter, class _Sent, class _Proj, class _Pred>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr static
  bool __any_of_impl(_Iter __first, _Sent __last, _Pred& __pred, _Proj& __proj) {
    for (; __first != __last; ++__first) {
      if (std::invoke(__pred, std::invoke(__proj, *__first)))
        return true;
    }
    return false;
  }
  template <input_iterator _Iter, sentinel_for<_Iter> _Sent, class _Proj = identity,
            indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  bool operator()(_Iter __first, _Sent __last, _Pred __pred = {}, _Proj __proj = {}) const {
    return __any_of_impl(std::move(__first), std::move(__last), __pred, __proj);
  }
  template <input_range _Range, class _Proj = identity,
            indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  bool operator()(_Range&& __range, _Pred __pred, _Proj __proj = {}) const {
    return __any_of_impl(ranges::begin(__range), ranges::end(__range), __pred, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto any_of = __any_of::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __binary_search {
struct __fn {
  template <forward_iterator _Iter, sentinel_for<_Iter> _Sent, class _Type, class _Proj = identity,
            indirect_strict_weak_order<const _Type*, projected<_Iter, _Proj>> _Comp = ranges::less>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  bool operator()(_Iter __first, _Sent __last, const _Type& __value, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __ret = std::__lower_bound_impl<_RangeAlgPolicy>(__first, __last, __value, __comp, __proj);
    return __ret != __last && !std::invoke(__comp, __value, std::invoke(__proj, *__ret));
  }
  template <forward_range _Range, class _Type, class _Proj = identity,
            indirect_strict_weak_order<const _Type*, projected<iterator_t<_Range>, _Proj>> _Comp = ranges::less>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  bool operator()(_Range&& __r, const _Type& __value, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __first = ranges::begin(__r);
    auto __last = ranges::end(__r);
    auto __ret = std::__lower_bound_impl<_RangeAlgPolicy>(__first, __last, __value, __comp, __proj);
    return __ret != __last && !std::invoke(__comp, __value, std::invoke(__proj, *__ret));
  }
};
}
inline namespace __cpo {
  inline constexpr auto binary_search = __binary_search::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __clamp {
struct __fn {
  template <class _Type,
            class _Proj = identity,
            indirect_strict_weak_order<projected<const _Type*, _Proj>> _Comp = ranges::less>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  const _Type& operator()(const _Type& __value,
                          const _Type& __low,
                          const _Type& __high,
                          _Comp __comp = {},
                          _Proj __proj = {}) const {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(!bool(std::invoke(__comp, std::invoke(__proj, __high), std::invoke(__proj, __low)))))
#pragma clang diagnostic pop
    );
    if (std::invoke(__comp, std::invoke(__proj, __value), std::invoke(__proj, __low)))
      return __low;
    else if (std::invoke(__comp, std::invoke(__proj, __high), std::invoke(__proj, __value)))
      return __high;
    else
      return __value;
  }
};
}
inline namespace __cpo {
  inline constexpr auto clamp = __clamp::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _InIter, class _OutIter>
using copy_result = in_out_result<_InIter, _OutIter>;
namespace __copy {
struct __fn {
  template <input_iterator _InIter, sentinel_for<_InIter> _Sent, weakly_incrementable _OutIter>
    requires indirectly_copyable<_InIter, _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  copy_result<_InIter, _OutIter> operator()(_InIter __first, _Sent __last, _OutIter __result) const {
    auto __ret = std::__copy<_RangeAlgPolicy>(std::move(__first), std::move(__last), std::move(__result));
    return {std::move(__ret.first), std::move(__ret.second)};
  }
  template <input_range _Range, weakly_incrementable _OutIter>
    requires indirectly_copyable<iterator_t<_Range>, _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  copy_result<borrowed_iterator_t<_Range>, _OutIter> operator()(_Range&& __r, _OutIter __result) const {
    auto __ret = std::__copy<_RangeAlgPolicy>(ranges::begin(__r), ranges::end(__r), std::move(__result));
    return {std::move(__ret.first), std::move(__ret.second)};
  }
};
}
inline namespace __cpo {
  inline constexpr auto copy = __copy::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template<class _Ip, class _Op>
using copy_backward_result = in_out_result<_Ip, _Op>;
namespace __copy_backward {
struct __fn {
  template <bidirectional_iterator _InIter1, sentinel_for<_InIter1> _Sent1, bidirectional_iterator _InIter2>
    requires indirectly_copyable<_InIter1, _InIter2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  copy_backward_result<_InIter1, _InIter2> operator()(_InIter1 __first, _Sent1 __last, _InIter2 __result) const {
    auto __ret = std::__copy_backward<_RangeAlgPolicy>(std::move(__first), std::move(__last), std::move(__result));
    return {std::move(__ret.first), std::move(__ret.second)};
  }
  template <bidirectional_range _Range, bidirectional_iterator _Iter>
    requires indirectly_copyable<iterator_t<_Range>, _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  copy_backward_result<borrowed_iterator_t<_Range>, _Iter> operator()(_Range&& __r, _Iter __result) const {
    auto __ret = std::__copy_backward<_RangeAlgPolicy>(ranges::begin(__r), ranges::end(__r), std::move(__result));
    return {std::move(__ret.first), std::move(__ret.second)};
  }
};
}
inline namespace __cpo {
  inline constexpr auto copy_backward = __copy_backward::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template<class _Ip, class _Op>
using copy_if_result = in_out_result<_Ip, _Op>;
namespace __copy_if {
struct __fn {
  template <class _InIter, class _Sent, class _OutIter, class _Proj, class _Pred>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr
  copy_if_result <_InIter, _OutIter>
  __copy_if_impl(_InIter __first, _Sent __last, _OutIter __result, _Pred& __pred, _Proj& __proj) {
    for (; __first != __last; ++__first) {
      if (std::invoke(__pred, std::invoke(__proj, *__first))) {
        *__result = *__first;
        ++__result;
      }
    }
    return {std::move(__first), std::move(__result)};
  }
  template <input_iterator _Iter, sentinel_for<_Iter> _Sent, weakly_incrementable _OutIter, class _Proj = identity,
            indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
    requires indirectly_copyable<_Iter, _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  copy_if_result<_Iter, _OutIter>
  operator()(_Iter __first, _Sent __last, _OutIter __result, _Pred __pred, _Proj __proj = {}) const {
    return __copy_if_impl(std::move(__first), std::move(__last), std::move(__result), __pred, __proj);
  }
  template <input_range _Range, weakly_incrementable _OutIter, class _Proj = identity,
            indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
    requires indirectly_copyable<iterator_t<_Range>, _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  copy_if_result<borrowed_iterator_t<_Range>, _OutIter>
  operator()(_Range&& __r, _OutIter __result, _Pred __pred, _Proj __proj = {}) const {
    return __copy_if_impl(ranges::begin(__r), ranges::end(__r), std::move(__result), __pred, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto copy_if = __copy_if::__fn{};
}
}
}}
namespace std { inline namespace __1 {
struct unreachable_sentinel_t {
  template<weakly_incrementable _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator==(unreachable_sentinel_t, const _Iter&) noexcept {
    return false;
  }
};
inline constexpr unreachable_sentinel_t unreachable_sentinel{};
}}
namespace std { inline namespace __1 {
template <class _Iter>
class __wrap_iter
{
public:
    typedef _Iter iterator_type;
    typedef typename iterator_traits<iterator_type>::value_type value_type;
    typedef typename iterator_traits<iterator_type>::difference_type difference_type;
    typedef typename iterator_traits<iterator_type>::pointer pointer;
    typedef typename iterator_traits<iterator_type>::reference reference;
    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;
    typedef contiguous_iterator_tag iterator_concept;
private:
    iterator_type __i_;
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __wrap_iter() noexcept
                : __i_()
    {
        std::__debug_db_insert_i(this);
    }
    template <class _Up> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
        __wrap_iter(const __wrap_iter<_Up>& __u,
            typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = nullptr) noexcept
            : __i_(__u.base())
    {
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr reference operator*() const noexcept
    {
        ((void)0);
        return *__i_;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pointer operator->() const noexcept
    {
        ((void)0);
        return std::__to_address(__i_);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __wrap_iter& operator++() noexcept
    {
        ((void)0);
        ++__i_;
        return *this;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __wrap_iter operator++(int) noexcept
        {__wrap_iter __tmp(*this); ++(*this); return __tmp;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __wrap_iter& operator--() noexcept
    {
        ((void)0);
        --__i_;
        return *this;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __wrap_iter operator--(int) noexcept
        {__wrap_iter __tmp(*this); --(*this); return __tmp;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __wrap_iter operator+ (difference_type __n) const noexcept
        {__wrap_iter __w(*this); __w += __n; return __w;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __wrap_iter& operator+=(difference_type __n) noexcept
    {
        ((void)0);
        __i_ += __n;
        return *this;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __wrap_iter operator- (difference_type __n) const noexcept
        {return *this + (-__n);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __wrap_iter& operator-=(difference_type __n) noexcept
        {*this += -__n; return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr reference operator[](difference_type __n) const noexcept
    {
        ((void)0);
        return __i_[__n];
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr iterator_type base() const noexcept {return __i_;}
private:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    explicit __wrap_iter(const void* __p, iterator_type __x) noexcept : __i_(__x)
    {
        (void)__p;
    }
    template <class _Up> friend class __wrap_iter;
    template <class _CharT, class _Traits, class _Alloc> friend class basic_string;
    template <class _Tp, class _Alloc> friend class __attribute__((__type_visibility__("default"))) vector;
    template <class _Tp, size_t> friend class __attribute__((__type_visibility__("default"))) span;
};
template <class _Iter1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool operator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return __x.base() == __y.base();
}
template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool operator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return __x.base() == __y.base();
}
template <class _Iter1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool operator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    ((void)0);
    return __x.base() < __y.base();
}
template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool operator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    ((void)0);
    return __x.base() < __y.base();
}
template <class _Iter1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return !(__x == __y);
}
template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool operator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return !(__x == __y);
}
template <class _Iter1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return __y < __x;
}
template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool operator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return __y < __x;
}
template <class _Iter1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return !(__x < __y);
}
template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return !(__x < __y);
}
template <class _Iter1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) noexcept
{
    return !(__y < __x);
}
template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool operator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
{
    return !(__y < __x);
}
template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
auto operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) noexcept
    -> decltype(__x.base() - __y.base())
{
    ((void)0);
    return __x.base() - __y.base();
}
template <class _Iter1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
__wrap_iter<_Iter1> operator+(typename __wrap_iter<_Iter1>::difference_type __n, __wrap_iter<_Iter1> __x) noexcept
{
    __x += __n;
    return __x;
}
template <class _It>
struct __attribute__((__type_visibility__("default"))) pointer_traits<__wrap_iter<_It> >
{
    typedef __wrap_iter<_It> pointer;
    typedef typename pointer_traits<_It>::element_type element_type;
    typedef typename pointer_traits<_It>::difference_type difference_type;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    static element_type *to_address(pointer __w) noexcept {
        return std::__to_address(__w.base());
    }
};
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _Ip, class _Op>
using copy_n_result = in_out_result<_Ip, _Op>;
namespace __copy_n {
struct __fn {
  template <class _InIter, class _DiffType, class _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr static
  copy_n_result<_InIter, _OutIter> __go(_InIter __first, _DiffType __n, _OutIter __result) {
    while (__n != 0) {
      *__result = *__first;
      ++__first;
      ++__result;
      --__n;
    }
    return {std::move(__first), std::move(__result)};
  }
  template <random_access_iterator _InIter, class _DiffType, random_access_iterator _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr static
  copy_n_result<_InIter, _OutIter> __go(_InIter __first, _DiffType __n, _OutIter __result) {
    auto __ret = std::__copy<_RangeAlgPolicy>(__first, __first + __n, __result);
    return {__ret.first, __ret.second};
  }
  template <input_iterator _Ip, weakly_incrementable _Op>
    requires indirectly_copyable<_Ip, _Op>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  copy_n_result<_Ip, _Op> operator()(_Ip __first, iter_difference_t<_Ip> __n, _Op __result) const {
    return __go(std::move(__first), __n, std::move(__result));
  }
};
}
inline namespace __cpo {
  inline constexpr auto copy_n = __copy_n::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _Iter, class _Sent, class _Proj, class _Pred>
// added by concept-synth, original LN: 15707
requires
(
 requires (_Iter x0) { *x0; } &&
 requires (_Iter x0) { ++x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
iter_difference_t<_Iter> __count_if_impl(_Iter __first, _Sent __last,
                                             _Pred& __pred, _Proj& __proj) {
  iter_difference_t<_Iter> __counter(0);
  for (; __first != __last; ++__first) {
    if (std::invoke(__pred, std::invoke(__proj, *__first)))
      ++__counter;
  }
  return __counter;
}
namespace __count_if {
struct __fn {
  template <input_iterator _Iter, sentinel_for<_Iter> _Sent, class _Proj = identity,
            indirect_unary_predicate<projected<_Iter, _Proj>> _Predicate>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  iter_difference_t<_Iter> operator()(_Iter __first, _Sent __last, _Predicate __pred, _Proj __proj = {}) const {
    return ranges::__count_if_impl(std::move(__first), std::move(__last), __pred, __proj);
  }
  template <input_range _Range, class _Proj = identity,
            indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Predicate>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  range_difference_t<_Range> operator()(_Range&& __r, _Predicate __pred, _Proj __proj = {}) const {
    return ranges::__count_if_impl(ranges::begin(__r), ranges::end(__r), __pred, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto count_if = __count_if::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __count {
struct __fn {
  template <input_iterator _Iter, sentinel_for<_Iter> _Sent, class _Type, class _Proj = identity>
    requires indirect_binary_predicate<ranges::equal_to, projected<_Iter, _Proj>, const _Type*>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  iter_difference_t<_Iter> operator()(_Iter __first, _Sent __last, const _Type& __value, _Proj __proj = {}) const {
    auto __pred = [&](auto&& __e) { return __e == __value; };
    return ranges::__count_if_impl(std::move(__first), std::move(__last), __pred, __proj);
  }
  template <input_range _Range, class _Type, class _Proj = identity>
    requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<_Range>, _Proj>, const _Type*>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  range_difference_t<_Range> operator()(_Range&& __r, const _Type& __value, _Proj __proj = {}) const {
    auto __pred = [&](auto&& __e) { return __e == __value; };
    return ranges::__count_if_impl(ranges::begin(__r), ranges::end(__r), __pred, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto count = __count::__fn{};
}
}
}}

namespace std { inline namespace __1 {
template <class _I1, class _I2, class _Rp, class _P1 = identity, class _P2 = identity>
concept indirectly_comparable =
  indirect_binary_predicate<_Rp, projected<_I1, _P1>, projected<_I2, _P2>>;
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __equal {
struct __fn {
private:
  template <class _Iter1, class _Sent1,
            class _Iter2, class _Sent2,
            class _Pred,
            class _Proj1,
            class _Proj2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr static
  bool __equal_impl(_Iter1 __first1, _Sent1 __last1,
                    _Iter2 __first2, _Sent2 __last2,
                    _Pred& __pred,
                    _Proj1& __proj1,
                    _Proj2& __proj2) {
    while (__first1 != __last1 && __first2 != __last2) {
      if (!std::invoke(__pred, std::invoke(__proj1, *__first1), std::invoke(__proj2, *__first2)))
        return false;
      ++__first1;
      ++__first2;
    }
    return __first1 == __last1 && __first2 == __last2;
  }
public:
  template <input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
            input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
            class _Pred = ranges::equal_to,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  bool operator()(_Iter1 __first1, _Sent1 __last1,
                  _Iter2 __first2, _Sent2 __last2,
                  _Pred __pred = {},
                  _Proj1 __proj1 = {},
                  _Proj2 __proj2 = {}) const {
    if constexpr (sized_sentinel_for<_Sent1, _Iter1> && sized_sentinel_for<_Sent2, _Iter2>) {
      if (__last1 - __first1 != __last2 - __first2)
        return false;
    }
    return __equal_impl(std::move(__first1), std::move(__last1),
                        std::move(__first2), std::move(__last2),
                        __pred,
                        __proj1,
                        __proj2);
  }
  template <input_range _Range1,
            input_range _Range2,
            class _Pred = ranges::equal_to,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>, _Pred, _Proj1, _Proj2>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  bool operator()(_Range1&& __range1,
                  _Range2&& __range2,
                  _Pred __pred = {},
                  _Proj1 __proj1 = {},
                  _Proj2 __proj2 = {}) const {
    if constexpr (sized_range<_Range1> && sized_range<_Range2>) {
      if (ranges::distance(__range1) != ranges::distance(__range2))
        return false;
    }
    return __equal_impl(ranges::begin(__range1), ranges::end(__range1),
                        ranges::begin(__range2), ranges::end(__range2),
                        __pred,
                        __proj1,
                        __proj2);
    return false;
  }
};
}
inline namespace __cpo {
  inline constexpr auto equal = __equal::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __equal_range {
struct __fn {
  template <
      forward_iterator _Iter,
      sentinel_for<_Iter> _Sent,
      class _Tp,
      class _Proj = identity,
      indirect_strict_weak_order<const _Tp*, projected<_Iter, _Proj>> _Comp = ranges::less>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr subrange<_Iter>
  operator()(_Iter __first, _Sent __last, const _Tp& __value, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __ret = std::__equal_range<_RangeAlgPolicy>(
        std::move(__first), std::move(__last), __value, __comp, __proj);
    return {std::move(__ret.first), std::move(__ret.second)};
  }
  template <
      forward_range _Range,
      class _Tp,
      class _Proj = identity,
      indirect_strict_weak_order<const _Tp*, projected<iterator_t<_Range>, _Proj>> _Comp = ranges::less>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr borrowed_subrange_t<_Range>
  operator()(_Range&& __range, const _Tp& __value, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __ret = std::__equal_range<_RangeAlgPolicy>(
        ranges::begin(__range), ranges::end(__range), __value, __comp, __proj);
    return {std::move(__ret.first), std::move(__ret.second)};
  }
};
}
inline namespace __cpo {
  inline constexpr auto equal_range = __equal_range::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __fill_n {
struct __fn {
  template <class _Type, output_iterator<const _Type&> _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  _Iter operator()(_Iter __first, iter_difference_t<_Iter> __n, const _Type& __value) const {
    for (; __n != 0; --__n) {
      *__first = __value;
      ++__first;
    }
    return __first;
  }
};
}
inline namespace __cpo {
  inline constexpr auto fill_n = __fill_n::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __fill {
struct __fn {
  template <class _Type, output_iterator<const _Type&> _Iter, sentinel_for<_Iter> _Sent>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  _Iter operator()(_Iter __first, _Sent __last, const _Type& __value) const {
    if constexpr(random_access_iterator<_Iter> && sized_sentinel_for<_Sent, _Iter>) {
      return ranges::fill_n(__first, __last - __first, __value);
    } else {
      for (; __first != __last; ++__first)
        *__first = __value;
      return __first;
    }
  }
  template <class _Type, output_range<const _Type&> _Range>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  borrowed_iterator_t<_Range> operator()(_Range&& __range, const _Type& __value) const {
    return (*this)(ranges::begin(__range), ranges::end(__range), __value);
  }
};
}
inline namespace __cpo {
  inline constexpr auto fill = __fill::__fn{};
}
}
}}

namespace std { inline namespace __1 {
namespace ranges {
template <class _Ip, class _Sp, class _Pred, class _Proj>
// added by concept-synth, original LN: 15931
requires
(
 requires (_Ip x0) { *x0; } &&
 requires (_Ip x0) { ++x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr
_Ip __find_if_impl(_Ip __first, _Sp __last, _Pred& __pred, _Proj& __proj) {
  for (; __first != __last; ++__first) {
    if (std::invoke(__pred, std::invoke(__proj, *__first)))
      break;
  }
  return __first;
}
namespace __find_if {
struct __fn {
  template <input_iterator _Ip, sentinel_for<_Ip> _Sp, class _Proj = identity,
            indirect_unary_predicate<projected<_Ip, _Proj>> _Pred>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  _Ip operator()(_Ip __first, _Sp __last, _Pred __pred, _Proj __proj = {}) const {
    return ranges::__find_if_impl(std::move(__first), std::move(__last), __pred, __proj);
  }
  template <input_range _Rp, class _Proj = identity,
            indirect_unary_predicate<projected<iterator_t<_Rp>, _Proj>> _Pred>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  borrowed_iterator_t<_Rp> operator()(_Rp&& __r, _Pred __pred, _Proj __proj = {}) const {
    return ranges::__find_if_impl(ranges::begin(__r), ranges::end(__r), __pred, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto find_if = __find_if::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __find {
struct __fn {
  template <input_iterator _Ip, sentinel_for<_Ip> _Sp, class _Tp, class _Proj = identity>
    requires indirect_binary_predicate<ranges::equal_to, projected<_Ip, _Proj>, const _Tp*>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  _Ip operator()(_Ip __first, _Sp __last, const _Tp& __value, _Proj __proj = {}) const {
    auto __pred = [&](auto&& __e) { return std::forward<decltype(__e)>(__e) == __value; };
    return ranges::__find_if_impl(std::move(__first), std::move(__last), __pred, __proj);
  }
  template <input_range _Rp, class _Tp, class _Proj = identity>
    requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<_Rp>, _Proj>, const _Tp*>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  borrowed_iterator_t<_Rp> operator()(_Rp&& __r, const _Tp& __value, _Proj __proj = {}) const {
    auto __pred = [&](auto&& __e) { return std::forward<decltype(__e)>(__e) == __value; };
    return ranges::__find_if_impl(ranges::begin(__r), ranges::end(__r), __pred, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto find = __find::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __find_end {
struct __fn {
  template <forward_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
            forward_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
            class _Pred = ranges::equal_to,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  subrange<_Iter1> operator()(_Iter1 __first1, _Sent1 __last1,
                              _Iter2 __first2, _Sent2 __last2,
                              _Pred __pred = {},
                              _Proj1 __proj1 = {},
                              _Proj2 __proj2 = {}) const {
    auto __ret = std::__find_end_impl<_RangeAlgPolicy>(
        __first1,
        __last1,
        __first2,
        __last2,
        __pred,
        __proj1,
        __proj2,
        __iterator_concept<_Iter1>(),
        __iterator_concept<_Iter2>());
    return {__ret.first, __ret.second};
  }
  template <forward_range _Range1,
            forward_range _Range2,
            class _Pred = ranges::equal_to,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>, _Pred, _Proj1, _Proj2>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  borrowed_subrange_t<_Range1> operator()(_Range1&& __range1,
                                          _Range2&& __range2,
                                          _Pred __pred = {},
                                          _Proj1 __proj1 = {},
                                          _Proj2 __proj2 = {}) const {
    auto __ret = std::__find_end_impl<_RangeAlgPolicy>(
        ranges::begin(__range1),
        ranges::end(__range1),
        ranges::begin(__range2),
        ranges::end(__range2),
        __pred,
        __proj1,
        __proj2,
        __iterator_concept<iterator_t<_Range1>>(),
        __iterator_concept<iterator_t<_Range2>>());
    return {__ret.first, __ret.second};
  }
};
}
inline namespace __cpo {
  inline constexpr auto find_end = __find_end::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __find_first_of {
struct __fn {
  template <class _Iter1, class _Sent1, class _Iter2, class _Sent2, class _Pred, class _Proj1, class _Proj2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr static
  _Iter1 __find_first_of_impl(_Iter1 __first1, _Sent1 __last1,
                              _Iter2 __first2, _Sent2 __last2,
                              _Pred& __pred,
                              _Proj1& __proj1,
                              _Proj2& __proj2) {
    for (; __first1 != __last1; ++__first1) {
      for (auto __j = __first2; __j != __last2; ++__j) {
        if (std::invoke(__pred, std::invoke(__proj1, *__first1), std::invoke(__proj2, *__j)))
          return __first1;
      }
    }
    return __first1;
  }
  template <input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
            forward_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
            class _Pred = ranges::equal_to,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  _Iter1 operator()(_Iter1 __first1, _Sent1 __last1,
                    _Iter2 __first2, _Sent2 __last2,
                    _Pred __pred = {},
                    _Proj1 __proj1 = {},
                    _Proj2 __proj2 = {}) const {
    return __find_first_of_impl(std::move(__first1), std::move(__last1),
                                std::move(__first2), std::move(__last2),
                                __pred,
                                __proj1,
                                __proj2);
  }
  template <input_range _Range1,
            forward_range _Range2,
            class _Pred = ranges::equal_to,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>, _Pred, _Proj1, _Proj2>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  borrowed_iterator_t<_Range1> operator()(_Range1&& __range1,
                                          _Range2&& __range2,
                                          _Pred __pred = {},
                                          _Proj1 __proj1 = {},
                                          _Proj2 __proj2 = {}) const {
    return __find_first_of_impl(ranges::begin(__range1), ranges::end(__range1),
                                ranges::begin(__range2), ranges::end(__range2),
                                __pred,
                                __proj1,
                                __proj2);
  }
};
}
inline namespace __cpo {
  inline constexpr auto find_first_of = __find_first_of::__fn{};
}
}
}}

namespace std { inline namespace __1 {
namespace ranges {
namespace __find_if_not {
struct __fn {
  template <input_iterator _Ip, sentinel_for<_Ip> _Sp, class _Proj = identity,
            indirect_unary_predicate<projected<_Ip, _Proj>> _Pred>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  _Ip operator()(_Ip __first, _Sp __last, _Pred __pred, _Proj __proj = {}) const {
    auto __pred2 = [&](auto&& __e) { return !std::invoke(__pred, std::forward<decltype(__e)>(__e)); };
    return ranges::__find_if_impl(std::move(__first), std::move(__last), __pred2, __proj);
  }
  template <input_range _Rp, class _Proj = identity,
            indirect_unary_predicate<projected<iterator_t<_Rp>, _Proj>> _Pred>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  borrowed_iterator_t<_Rp> operator()(_Rp&& __r, _Pred __pred, _Proj __proj = {}) const {
    auto __pred2 = [&](auto&& __e) { return !std::invoke(__pred, std::forward<decltype(__e)>(__e)); };
    return ranges::__find_if_impl(ranges::begin(__r), ranges::end(__r), __pred2, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto find_if_not = __find_if_not::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _Iter, class _Func>
using for_each_result = in_fun_result<_Iter, _Func>;
namespace __for_each {
struct __fn {
private:
  template <class _Iter, class _Sent, class _Proj, class _Func>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr static
  for_each_result<_Iter, _Func> __for_each_impl(_Iter __first, _Sent __last, _Func& __func, _Proj& __proj) {
    for (; __first != __last; ++__first)
      std::invoke(__func, std::invoke(__proj, *__first));
    return {std::move(__first), std::move(__func)};
  }
public:
  template <input_iterator _Iter, sentinel_for<_Iter> _Sent,
            class _Proj = identity,
            indirectly_unary_invocable<projected<_Iter, _Proj>> _Func>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  for_each_result<_Iter, _Func> operator()(_Iter __first, _Sent __last, _Func __func, _Proj __proj = {}) const {
    return __for_each_impl(std::move(__first), std::move(__last), __func, __proj);
  }
  template <input_range _Range,
            class _Proj = identity,
            indirectly_unary_invocable<projected<iterator_t<_Range>, _Proj>> _Func>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  for_each_result<borrowed_iterator_t<_Range>, _Func> operator()(_Range&& __range,
                                                                 _Func __func,
                                                                 _Proj __proj = {}) const {
    return __for_each_impl(ranges::begin(__range), ranges::end(__range), __func, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto for_each = __for_each::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _Iter, class _Func>
using for_each_n_result = in_fun_result<_Iter, _Func>;
namespace __for_each_n {
struct __fn {
  template <input_iterator _Iter,
            class _Proj = identity,
            indirectly_unary_invocable<projected<_Iter, _Proj>> _Func>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  for_each_n_result<_Iter, _Func> operator()(_Iter __first,
                                             iter_difference_t<_Iter> __count,
                                             _Func __func,
                                             _Proj __proj = {}) const {
    while (__count-- > 0) {
      std::invoke(__func, std::invoke(__proj, *__first));
      ++__first;
    }
    return {std::move(__first), std::move(__func)};
  }
};
}
inline namespace __cpo {
  inline constexpr auto for_each_n = __for_each_n::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __generate {
struct __fn {
  template <class _OutIter, class _Sent, class _Func>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  static _OutIter __generate_fn_impl(_OutIter __first, _Sent __last, _Func& __gen) {
    for (; __first != __last; ++__first) {
      *__first = __gen();
    }
    return __first;
  }
  template <input_or_output_iterator _OutIter, sentinel_for<_OutIter> _Sent, copy_constructible _Func>
  requires invocable<_Func&> && indirectly_writable<_OutIter, invoke_result_t<_Func&>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  _OutIter operator()(_OutIter __first, _Sent __last, _Func __gen) const {
    return __generate_fn_impl(std::move(__first), std::move(__last), __gen);
  }
  template <class _Range, copy_constructible _Func>
  requires invocable<_Func&> && output_range<_Range, invoke_result_t<_Func&>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  borrowed_iterator_t<_Range> operator()(_Range&& __range, _Func __gen) const {
    return __generate_fn_impl(ranges::begin(__range), ranges::end(__range), __gen);
  }
};
}
inline namespace __cpo {
  inline constexpr auto generate = __generate::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __generate_n {
struct __fn {
  template <input_or_output_iterator _OutIter, copy_constructible _Func>
  requires invocable<_Func&> && indirectly_writable<_OutIter, invoke_result_t<_Func&>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  _OutIter operator()(_OutIter __first, iter_difference_t<_OutIter> __n, _Func __gen) const {
    for (; __n > 0; --__n) {
      *__first = __gen();
      ++__first;
    }
    return __first;
  }
};
}
inline namespace __cpo {
  inline constexpr auto generate_n = __generate_n::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __includes {
struct __fn {
  template <
      input_iterator _Iter1,
      sentinel_for<_Iter1> _Sent1,
      input_iterator _Iter2,
      sentinel_for<_Iter2> _Sent2,
      class _Proj1 = identity,
      class _Proj2 = identity,
      indirect_strict_weak_order<projected<_Iter1, _Proj1>, projected<_Iter2, _Proj2>> _Comp = ranges::less>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool operator()(
      _Iter1 __first1,
      _Sent1 __last1,
      _Iter2 __first2,
      _Sent2 __last2,
      _Comp __comp = {},
      _Proj1 __proj1 = {},
      _Proj2 __proj2 = {}) const {
    return std::__includes(
        std::move(__first1),
        std::move(__last1),
        std::move(__first2),
        std::move(__last2),
        std::move(__comp),
        std::move(__proj1),
        std::move(__proj2));
  }
  template <
      input_range _Range1,
      input_range _Range2,
      class _Proj1 = identity,
      class _Proj2 = identity,
      indirect_strict_weak_order<projected<iterator_t<_Range1>, _Proj1>, projected<iterator_t<_Range2>, _Proj2>>
          _Comp = ranges::less>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool operator()(
      _Range1&& __range1, _Range2&& __range2, _Comp __comp = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
    return std::__includes(
        ranges::begin(__range1),
        ranges::end(__range1),
        ranges::begin(__range2),
        ranges::end(__range2),
        std::move(__comp),
        std::move(__proj1),
        std::move(__proj2));
  }
};
}
inline namespace __cpo {
  inline constexpr auto includes = __includes::__fn{};
}
}
}}
namespace std { inline namespace __1 {
template <class _Iterator>
concept permutable =
    forward_iterator<_Iterator> &&
    indirectly_movable_storable<_Iterator, _Iterator> &&
    indirectly_swappable<_Iterator, _Iterator>;
}}
namespace std { inline namespace __1 {
template <class _Iter, class _Comp = ranges::less, class _Proj = identity>
concept sortable =
  permutable<_Iter> &&
  indirect_strict_weak_order<_Comp, projected<_Iter, _Proj>>;
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __inplace_merge {
  struct __fn {
    template <class _Iter, class _Sent, class _Comp, class _Proj>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr auto
    __inplace_merge_impl(_Iter __first, _Iter __middle, _Sent __last, _Comp&& __comp, _Proj&& __proj) {
      auto __last_iter = ranges::next(__middle, __last);
      std::__inplace_merge<_RangeAlgPolicy>(
          std::move(__first), std::move(__middle), __last_iter, std::__make_projected(__comp, __proj));
      return __last_iter;
    }
    template <
        bidirectional_iterator _Iter,
        sentinel_for<_Iter> _Sent,
        class _Comp = ranges::less,
        class _Proj = identity>
      requires sortable<_Iter, _Comp, _Proj>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) _Iter
    operator()(_Iter __first, _Iter __middle, _Sent __last, _Comp __comp = {}, _Proj __proj = {}) const {
      return __inplace_merge_impl(
          std::move(__first), std::move(__middle), std::move(__last), std::move(__comp), std::move(__proj));
    }
    template <bidirectional_range _Range, class _Comp = ranges::less, class _Proj = identity>
      requires sortable<
          iterator_t<_Range>,
          _Comp,
          _Proj> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) borrowed_iterator_t<_Range>
      operator()(_Range&& __range, iterator_t<_Range> __middle, _Comp __comp = {}, _Proj __proj = {}) const {
      return __inplace_merge_impl(
          ranges::begin(__range), std::move(__middle), ranges::end(__range), std::move(__comp), std::move(__proj));
    }
  };
}
inline namespace __cpo {
  inline constexpr auto inplace_merge = __inplace_merge::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __is_heap {
struct __fn {
  template <class _Iter, class _Sent, class _Proj, class _Comp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  static bool __is_heap_fn_impl(_Iter __first, _Sent __last, _Comp& __comp, _Proj& __proj) {
    auto __last_iter = ranges::next(__first, __last);
    auto&& __projected_comp = std::__make_projected(__comp, __proj);
    auto __result = std::__is_heap_until(std::move(__first), std::move(__last_iter), __projected_comp);
    return __result == __last;
  }
  template <random_access_iterator _Iter, sentinel_for<_Iter> _Sent, class _Proj = identity,
            indirect_strict_weak_order<projected<_Iter, _Proj>> _Comp = ranges::less>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  bool operator()(_Iter __first, _Sent __last, _Comp __comp = {}, _Proj __proj = {}) const {
    return __is_heap_fn_impl(std::move(__first), std::move(__last), __comp, __proj);
  }
  template <random_access_range _Range, class _Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>> _Comp = ranges::less>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  bool operator()(_Range&& __range, _Comp __comp = {}, _Proj __proj = {}) const {
    return __is_heap_fn_impl(ranges::begin(__range), ranges::end(__range), __comp, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto is_heap = __is_heap::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __is_heap_until {
struct __fn {
  template <class _Iter, class _Sent, class _Proj, class _Comp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  static _Iter __is_heap_until_fn_impl(_Iter __first, _Sent __last, _Comp& __comp, _Proj& __proj) {
    auto __last_iter = ranges::next(__first, __last);
    auto&& __projected_comp = std::__make_projected(__comp, __proj);
    return std::__is_heap_until(std::move(__first), std::move(__last_iter), __projected_comp);
  }
  template <random_access_iterator _Iter, sentinel_for<_Iter> _Sent, class _Proj = identity,
            indirect_strict_weak_order<projected<_Iter, _Proj>> _Comp = ranges::less>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  _Iter operator()(_Iter __first, _Sent __last, _Comp __comp = {}, _Proj __proj = {}) const {
    return __is_heap_until_fn_impl(std::move(__first), std::move(__last), __comp, __proj);
  }
  template <random_access_range _Range, class _Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>> _Comp = ranges::less>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  borrowed_iterator_t<_Range> operator()(_Range&& __range, _Comp __comp = {}, _Proj __proj = {}) const {
    return __is_heap_until_fn_impl(ranges::begin(__range), ranges::end(__range), __comp, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto is_heap_until = __is_heap_until::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __is_partitioned {
struct __fn {
  template <class _Iter, class _Sent, class _Proj, class _Pred>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr static
  bool __is_parititioned_impl(_Iter __first, _Sent __last, _Pred& __pred, _Proj& __proj) {
    for (; __first != __last; ++__first) {
      if (!std::invoke(__pred, std::invoke(__proj, *__first)))
        break;
    }
    if (__first == __last)
      return true;
    ++__first;
    for (; __first != __last; ++__first) {
      if (std::invoke(__pred, std::invoke(__proj, *__first)))
        return false;
    }
    return true;
  }
  template <input_iterator _Iter, sentinel_for<_Iter> _Sent,
            class _Proj = identity,
            indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  bool operator()(_Iter __first, _Sent __last, _Pred __pred, _Proj __proj = {}) const {
    return __is_parititioned_impl(std::move(__first), std::move(__last), __pred, __proj);
  }
  template <input_range _Range,
            class _Proj = identity,
            indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  bool operator()(_Range&& __range, _Pred __pred, _Proj __proj = {}) const {
    return __is_parititioned_impl(ranges::begin(__range), ranges::end(__range), __pred, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto is_partitioned = __is_partitioned::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __is_permutation {
struct __fn {
  template <class _Iter1, class _Sent1, class _Iter2, class _Sent2,
            class _Proj1, class _Proj2, class _Pred>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr static
  bool __is_permutation_func_impl(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,
                                  _Pred& __pred, _Proj1& __proj1, _Proj2& __proj2) {
    return std::__is_permutation<_RangeAlgPolicy>(
        std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2),
        __pred, __proj1, __proj2);
  }
  template <forward_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
            forward_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
            class _Proj1 = identity,
            class _Proj2 = identity,
            indirect_equivalence_relation<projected<_Iter1, _Proj1>,
                                          projected<_Iter2, _Proj2>> _Pred = ranges::equal_to>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  bool operator()(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,
                  _Pred __pred = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
    return __is_permutation_func_impl(
        std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2),
        __pred, __proj1, __proj2);
  }
  template <forward_range _Range1,
            forward_range _Range2,
            class _Proj1 = identity,
            class _Proj2 = identity,
            indirect_equivalence_relation<projected<iterator_t<_Range1>, _Proj1>, projected<iterator_t<_Range2>, _Proj2>> _Pred = ranges::equal_to>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  bool operator()(_Range1&& __range1, _Range2&& __range2,
                  _Pred __pred = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
    if constexpr (sized_range<_Range1> && sized_range<_Range2>) {
      if (ranges::distance(__range1) != ranges::distance(__range2))
        return false;
    }
    return __is_permutation_func_impl(
        ranges::begin(__range1), ranges::end(__range1), ranges::begin(__range2), ranges::end(__range2),
        __pred, __proj1, __proj2);
  }
};
}
inline namespace __cpo {
  inline constexpr auto is_permutation = __is_permutation::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _Iter, class _Sent, class _Proj, class _Comp>
// added by concept-synth, original LN: 16509
requires
requires (_Iter x0) { *x0; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_Iter __is_sorted_until_impl(_Iter __first, _Sent __last, _Comp& __comp, _Proj& __proj) {
  if (__first == __last)
    return __first;
  auto __i = __first;
  while (++__i != __last) {
    if (std::invoke(__comp, std::invoke(__proj, *__i), std::invoke(__proj, *__first)))
      return __i;
    __first = __i;
  }
  return __i;
}
namespace __is_sorted_until {
struct __fn {
  template <forward_iterator _Iter, sentinel_for<_Iter> _Sent,
            class _Proj = identity,
            indirect_strict_weak_order<projected<_Iter, _Proj>> _Comp = ranges::less>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  _Iter operator()(_Iter __first, _Sent __last, _Comp __comp = {}, _Proj __proj = {}) const {
    return ranges::__is_sorted_until_impl(std::move(__first), std::move(__last), __comp, __proj);
  }
  template <forward_range _Range,
            class _Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>> _Comp = ranges::less>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  borrowed_iterator_t<_Range> operator()(_Range&& __range, _Comp __comp = {}, _Proj __proj = {}) const {
    return ranges::__is_sorted_until_impl(ranges::begin(__range), ranges::end(__range), __comp, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto is_sorted_until = __is_sorted_until::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __is_sorted {
struct __fn {
  template <forward_iterator _Iter, sentinel_for<_Iter> _Sent,
            class _Proj = identity,
            indirect_strict_weak_order<projected<_Iter, _Proj>> _Comp = ranges::less>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  bool operator()(_Iter __first, _Sent __last, _Comp __comp = {}, _Proj __proj = {}) const {
    return ranges::__is_sorted_until_impl(std::move(__first), __last, __comp, __proj) == __last;
  }
  template <forward_range _Range,
            class _Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>> _Comp = ranges::less>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  bool operator()(_Range&& __range, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __last = ranges::end(__range);
    return ranges::__is_sorted_until_impl(ranges::begin(__range), __last, __comp, __proj) == __last;
  }
};
}
inline namespace __cpo {
  inline constexpr auto is_sorted = __is_sorted::__fn{};
}
}
}}

namespace std { inline namespace __1 {
namespace ranges {
namespace __lexicographical_compare {
struct __fn {
  template <class _Iter1, class _Sent1, class _Iter2, class _Sent2, class _Proj1, class _Proj2, class _Comp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr static
  bool __lexicographical_compare_impl(_Iter1 __first1, _Sent1 __last1,
                                      _Iter2 __first2, _Sent2 __last2,
                                      _Comp& __comp,
                                      _Proj1& __proj1,
                                      _Proj2& __proj2) {
    while (__first2 != __last2) {
      if (__first1 == __last1
       || std::invoke(__comp, std::invoke(__proj1, *__first1), std::invoke(__proj2, *__first2)))
        return true;
      if (std::invoke(__comp, std::invoke(__proj2, *__first2), std::invoke(__proj1, *__first1)))
        return false;
      ++__first1;
      ++__first2;
    }
    return false;
  }
  template <input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
            input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
            class _Proj1 = identity,
            class _Proj2 = identity,
            indirect_strict_weak_order<projected<_Iter1, _Proj1>, projected<_Iter2, _Proj2>> _Comp = ranges::less>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  bool operator()(_Iter1 __first1, _Sent1 __last1,
                  _Iter2 __first2, _Sent2 __last2,
                  _Comp __comp = {},
                  _Proj1 __proj1 = {},
                  _Proj2 __proj2 = {}) const {
    return __lexicographical_compare_impl(std::move(__first1), std::move(__last1),
                                          std::move(__first2), std::move(__last2),
                                          __comp,
                                          __proj1,
                                          __proj2);
  }
  template <input_range _Range1,
            input_range _Range2,
            class _Proj1 = identity,
            class _Proj2 = identity,
            indirect_strict_weak_order<projected<iterator_t<_Range1>, _Proj1>,
                                       projected<iterator_t<_Range2>, _Proj2>> _Comp = ranges::less>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  bool operator()(_Range1&& __range1, _Range2&& __range2, _Comp __comp = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
    return __lexicographical_compare_impl(ranges::begin(__range1), ranges::end(__range1),
                                          ranges::begin(__range2), ranges::end(__range2),
                                          __comp,
                                          __proj1,
                                          __proj2);
  }
};
}
inline namespace __cpo {
  inline constexpr auto lexicographical_compare = __lexicographical_compare::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __lower_bound {
struct __fn {
  template <forward_iterator _Iter, sentinel_for<_Iter> _Sent, class _Type, class _Proj = identity,
            indirect_strict_weak_order<const _Type*, projected<_Iter, _Proj>> _Comp = ranges::less>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  _Iter operator()(_Iter __first, _Sent __last, const _Type& __value, _Comp __comp = {}, _Proj __proj = {}) const {
    return std::__lower_bound_impl<_RangeAlgPolicy>(__first, __last, __value, __comp, __proj);
  }
  template <forward_range _Range, class _Type, class _Proj = identity,
            indirect_strict_weak_order<const _Type*, projected<iterator_t<_Range>, _Proj>> _Comp = ranges::less>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  borrowed_iterator_t<_Range> operator()(_Range&& __r,
                                         const _Type& __value,
                                         _Comp __comp = {},
                                         _Proj __proj = {}) const {
    return std::__lower_bound_impl<_RangeAlgPolicy>(ranges::begin(__r), ranges::end(__r), __value, __comp, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto lower_bound = __lower_bound::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __make_heap {
struct __fn {
  template <class _Iter, class _Sent, class _Comp, class _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr static
  _Iter __make_heap_fn_impl(_Iter __first, _Sent __last, _Comp& __comp, _Proj& __proj) {
    auto __last_iter = ranges::next(__first, __last);
    auto&& __projected_comp = std::__make_projected(__comp, __proj);
    std::__make_heap<_RangeAlgPolicy>(std::move(__first), __last_iter, __projected_comp);
    return __last_iter;
  }
  template <random_access_iterator _Iter, sentinel_for<_Iter> _Sent, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<_Iter, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  _Iter operator()(_Iter __first, _Sent __last, _Comp __comp = {}, _Proj __proj = {}) const {
    return __make_heap_fn_impl(std::move(__first), std::move(__last), __comp, __proj);
  }
  template <random_access_range _Range, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<iterator_t<_Range>, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  borrowed_iterator_t<_Range> operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const {
    return __make_heap_fn_impl(ranges::begin(__r), ranges::end(__r), __comp, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto make_heap = __make_heap::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _Ip, class _Sp, class _Proj, class _Comp>
// added by concept-synth, original LN: 16691
requires
(
 requires (_Ip x0) { *x0; } &&
 requires (_Ip x0) { ++x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr
_Ip __min_element_impl(_Ip __first, _Sp __last, _Comp& __comp, _Proj& __proj) {
  if (__first == __last)
    return __first;
  _Ip __i = __first;
  while (++__i != __last)
    if (std::invoke(__comp, std::invoke(__proj, *__i), std::invoke(__proj, *__first)))
      __first = __i;
  return __first;
}
namespace __min_element {
struct __fn {
  template <forward_iterator _Ip, sentinel_for<_Ip> _Sp, class _Proj = identity,
            indirect_strict_weak_order<projected<_Ip, _Proj>> _Comp = ranges::less>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  _Ip operator()(_Ip __first, _Sp __last, _Comp __comp = {}, _Proj __proj = {}) const {
    return ranges::__min_element_impl(__first, __last, __comp, __proj);
  }
  template <forward_range _Rp, class _Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rp>, _Proj>> _Comp = ranges::less>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  borrowed_iterator_t<_Rp> operator()(_Rp&& __r, _Comp __comp = {}, _Proj __proj = {}) const {
    return ranges::__min_element_impl(ranges::begin(__r), ranges::end(__r), __comp, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto min_element = __min_element::__fn{};
}
}
}}

namespace std { inline namespace __1 {
namespace ranges {
namespace __max {
struct __fn {
  template <class _Tp, class _Proj = identity,
            indirect_strict_weak_order<projected<const _Tp*, _Proj>> _Comp = ranges::less>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  const _Tp& operator()(const _Tp& __a, const _Tp& __b, _Comp __comp = {}, _Proj __proj = {}) const {
    return std::invoke(__comp, std::invoke(__proj, __a), std::invoke(__proj, __b)) ? __b : __a;
  }
  template <copyable _Tp, class _Proj = identity,
            indirect_strict_weak_order<projected<const _Tp*, _Proj>> _Comp = ranges::less>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  _Tp operator()(initializer_list<_Tp> __il, _Comp __comp = {}, _Proj __proj = {}) const {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(__il.begin() != __il.end()))
#pragma clang diagnostic pop
    );
    auto __comp_lhs_rhs_swapped = [&](auto&& __lhs, auto&& __rhs) { return std::invoke(__comp, __rhs, __lhs); };
    return *ranges::__min_element_impl(__il.begin(), __il.end(), __comp_lhs_rhs_swapped, __proj);
  }
  template <input_range _Rp, class _Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rp>, _Proj>> _Comp = ranges::less>
    requires indirectly_copyable_storable<iterator_t<_Rp>, range_value_t<_Rp>*>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  range_value_t<_Rp> operator()(_Rp&& __r, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __first = ranges::begin(__r);
    auto __last = ranges::end(__r);
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(__first != __last))
#pragma clang diagnostic pop
    );
    if constexpr (forward_range<_Rp>) {
      auto __comp_lhs_rhs_swapped = [&](auto&& __lhs, auto&& __rhs) { return std::invoke(__comp, __rhs, __lhs); };
      return *ranges::__min_element_impl(std::move(__first), std::move(__last), __comp_lhs_rhs_swapped, __proj);
    } else {
      range_value_t<_Rp> __result = *__first;
      while (++__first != __last) {
        if (std::invoke(__comp, std::invoke(__proj, __result), std::invoke(__proj, *__first)))
          __result = *__first;
      }
      return __result;
    }
  }
};
}
inline namespace __cpo {
  inline constexpr auto max = __max::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __max_element {
struct __fn {
  template <forward_iterator _Ip, sentinel_for<_Ip> _Sp, class _Proj = identity,
            indirect_strict_weak_order<projected<_Ip, _Proj>> _Comp = ranges::less>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  _Ip operator()(_Ip __first, _Sp __last, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __comp_lhs_rhs_swapped = [&](auto&& __lhs, auto&& __rhs) { return std::invoke(__comp, __rhs, __lhs); };
    return ranges::__min_element_impl(__first, __last, __comp_lhs_rhs_swapped, __proj);
  }
  template <forward_range _Rp, class _Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rp>, _Proj>> _Comp = ranges::less>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  borrowed_iterator_t<_Rp> operator()(_Rp&& __r, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __comp_lhs_rhs_swapped = [&](auto&& __lhs, auto&& __rhs) { return std::invoke(__comp, __rhs, __lhs); };
    return ranges::__min_element_impl(ranges::begin(__r), ranges::end(__r), __comp_lhs_rhs_swapped, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto max_element = __max_element::__fn{};
}
}
}}
namespace std { inline namespace __1 {
template <class _Input1, class _Input2, class _Output,
          class _Comp = ranges::less, class _Proj1 = identity, class _Proj2 = identity>
concept mergeable =
    input_iterator<_Input1> &&
    input_iterator<_Input2> &&
    weakly_incrementable<_Output> &&
    indirectly_copyable<_Input1, _Output> &&
    indirectly_copyable<_Input2, _Output> &&
    indirect_strict_weak_order<_Comp, projected<_Input1, _Proj1>, projected<_Input2, _Proj2>>;
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _InIter1, class _InIter2, class _OutIter>
using merge_result = in_in_out_result<_InIter1, _InIter2, _OutIter>;
namespace __merge {
template <
    class _InIter1,
    class _Sent1,
    class _InIter2,
    class _Sent2,
    class _OutIter,
    class _Comp,
    class _Proj1,
    class _Proj2>
// added by concept-synth, original LN: 16820
requires
(
 requires (_InIter1 x0) { ++x0; } &&
 requires (_InIter1 x0) { *x0; }
) &&
(
 requires (_OutIter x0) { *x0; } &&
 requires (_OutIter x0) { ++x0; }
) &&
(
 requires (_InIter2 x0) { ++x0; } &&
 requires (_InIter2 x0) { *x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr merge_result<__remove_cvref_t<_InIter1>, __remove_cvref_t<_InIter2>, __remove_cvref_t<_OutIter>>
__merge_impl(
    _InIter1&& __first1,
    _Sent1&& __last1,
    _InIter2&& __first2,
    _Sent2&& __last2,
    _OutIter&& __result,
    _Comp&& __comp,
    _Proj1&& __proj1,
    _Proj2&& __proj2) {
  for (; __first1 != __last1 && __first2 != __last2; ++__result) {
    if (std::invoke(__comp, std::invoke(__proj2, *__first2), std::invoke(__proj1, *__first1))) {
      *__result = *__first2;
      ++__first2;
    } else {
      *__result = *__first1;
      ++__first1;
    }
  }
  auto __ret1 = ranges::copy(std::move(__first1), std::move(__last1), std::move(__result));
  auto __ret2 = ranges::copy(std::move(__first2), std::move(__last2), std::move(__ret1.out));
  return {std::move(__ret1.in), std::move(__ret2.in), std::move(__ret2.out)};
}
struct __fn {
  template <
      input_iterator _InIter1,
      sentinel_for<_InIter1> _Sent1,
      input_iterator _InIter2,
      sentinel_for<_InIter2> _Sent2,
      weakly_incrementable _OutIter,
      class _Comp = less,
      class _Proj1 = identity,
      class _Proj2 = identity>
    requires mergeable<_InIter1, _InIter2, _OutIter, _Comp, _Proj1, _Proj2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr merge_result<_InIter1, _InIter2, _OutIter> operator()(
      _InIter1 __first1,
      _Sent1 __last1,
      _InIter2 __first2,
      _Sent2 __last2,
      _OutIter __result,
      _Comp __comp = {},
      _Proj1 __proj1 = {},
      _Proj2 __proj2 = {}) const {
    return __merge::__merge_impl(__first1, __last1, __first2, __last2, __result, __comp, __proj1, __proj2);
  }
  template <
      input_range _Range1,
      input_range _Range2,
      weakly_incrementable _OutIter,
      class _Comp = less,
      class _Proj1 = identity,
      class _Proj2 = identity>
    requires mergeable<
        iterator_t<_Range1>,
        iterator_t<_Range2>,
        _OutIter,
        _Comp,
        _Proj1,
        _Proj2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr merge_result<borrowed_iterator_t<_Range1>, borrowed_iterator_t<_Range2>, _OutIter>
        operator()(
            _Range1&& __range1,
            _Range2&& __range2,
            _OutIter __result,
            _Comp __comp = {},
            _Proj1 __proj1 = {},
            _Proj2 __proj2 = {}) const {
    return __merge::__merge_impl(
        ranges::begin(__range1),
        ranges::end(__range1),
        ranges::begin(__range2),
        ranges::end(__range2),
        __result,
        __comp,
        __proj1,
        __proj2);
  }
};
}
inline namespace __cpo {
  inline constexpr auto merge = __merge::__fn{};
}
}
}}

namespace std { inline namespace __1 {
namespace ranges {
namespace __min {
struct __fn {
  template <class _Tp, class _Proj = identity,
            indirect_strict_weak_order<projected<const _Tp*, _Proj>> _Comp = ranges::less>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  const _Tp& operator()(const _Tp& __a, const _Tp& __b, _Comp __comp = {}, _Proj __proj = {}) const {
    return std::invoke(__comp, std::invoke(__proj, __b), std::invoke(__proj, __a)) ? __b : __a;
  }
  template <copyable _Tp, class _Proj = identity,
            indirect_strict_weak_order<projected<const _Tp*, _Proj>> _Comp = ranges::less>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  _Tp operator()(initializer_list<_Tp> __il, _Comp __comp = {}, _Proj __proj = {}) const {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(__il.begin() != __il.end()))
#pragma clang diagnostic pop
    );
    return *ranges::__min_element_impl(__il.begin(), __il.end(), __comp, __proj);
  }
  template <input_range _Rp, class _Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rp>, _Proj>> _Comp = ranges::less>
    requires indirectly_copyable_storable<iterator_t<_Rp>, range_value_t<_Rp>*>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  range_value_t<_Rp> operator()(_Rp&& __r, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __first = ranges::begin(__r);
    auto __last = ranges::end(__r);
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(__first != __last))
#pragma clang diagnostic pop
    );
    if constexpr (forward_range<_Rp>) {
      return *ranges::__min_element_impl(__first, __last, __comp, __proj);
    } else {
      range_value_t<_Rp> __result = *__first;
      while (++__first != __last) {
        if (std::invoke(__comp, std::invoke(__proj, *__first), std::invoke(__proj, __result)))
          __result = *__first;
      }
      return __result;
    }
  }
};
}
inline namespace __cpo {
  inline constexpr auto min = __min::__fn{};
}
}
}}


namespace std { inline namespace __1 {
namespace ranges {
template <class _T1>
using minmax_result = min_max_result<_T1>;
namespace __minmax {
struct __fn {
  template <class _Type, class _Proj = identity,
            indirect_strict_weak_order<projected<const _Type*, _Proj>> _Comp = ranges::less>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr ranges::minmax_result<const _Type&>
  operator()(const _Type& __a, const _Type& __b, _Comp __comp = {}, _Proj __proj = {}) const {
    if (std::invoke(__comp, std::invoke(__proj, __b), std::invoke(__proj, __a)))
      return {__b, __a};
    return {__a, __b};
  }
  template <copyable _Type, class _Proj = identity,
            indirect_strict_weak_order<projected<const _Type*, _Proj>> _Comp = ranges::less>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  ranges::minmax_result<_Type> operator()(initializer_list<_Type> __il, _Comp __comp = {}, _Proj __proj = {}) const {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(__il.begin() != __il.end()))
#pragma clang diagnostic pop
    );
    auto __iters = std::__minmax_element_impl(__il.begin(), __il.end(), __comp, __proj);
    return ranges::minmax_result<_Type> { *__iters.first, *__iters.second };
  }
  template <input_range _Range, class _Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>> _Comp = ranges::less>
    requires indirectly_copyable_storable<iterator_t<_Range>, range_value_t<_Range>*>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  ranges::minmax_result<range_value_t<_Range>> operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __first = ranges::begin(__r);
    auto __last = ranges::end(__r);
    using _ValueT = range_value_t<_Range>;
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(__first != __last))
#pragma clang diagnostic pop
    );
    if constexpr (forward_range<_Range>) {
      auto __result = std::__minmax_element_impl(__first, __last, __comp, __proj);
      return {*__result.first, *__result.second};
    } else {
      auto __less = [&](auto&& __a, auto&& __b) -> bool {
        return std::invoke(__comp, std::invoke(__proj, std::forward<decltype(__a)>(__a)),
                                   std::invoke(__proj, std::forward<decltype(__b)>(__b)));
      };
      ranges::minmax_result<_ValueT> __result = {*__first, __result.min};
      if (__first == __last || ++__first == __last)
        return __result;
      if (__less(*__first, __result.min))
        __result.min = *__first;
      else
        __result.max = *__first;
      while (++__first != __last) {
        _ValueT __i = *__first;
        if (++__first == __last) {
          if (__less(__i, __result.min))
            __result.min = __i;
          else if (!__less(__i, __result.max))
            __result.max = __i;
          return __result;
        }
        if (__less(*__first, __i)) {
          if (__less(*__first, __result.min))
            __result.min = *__first;
          if (!__less(__i, __result.max))
            __result.max = std::move(__i);
        } else {
          if (__less(__i, __result.min))
            __result.min = std::move(__i);
          if (!__less(*__first, __result.max))
            __result.max = *__first;
        }
      }
      return __result;
    }
  }
};
}
inline namespace __cpo {
  inline constexpr auto minmax = __minmax::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _T1>
using minmax_element_result = min_max_result<_T1>;
namespace __minmax_element {
struct __fn {
  template <forward_iterator _Ip, sentinel_for<_Ip> _Sp, class _Proj = identity,
            indirect_strict_weak_order<projected<_Ip, _Proj>> _Comp = ranges::less>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  ranges::minmax_element_result<_Ip> operator()(_Ip __first, _Sp __last, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __ret = std::__minmax_element_impl(std::move(__first), std::move(__last), __comp, __proj);
    return {__ret.first, __ret.second};
  }
  template <forward_range _Rp, class _Proj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rp>, _Proj>> _Comp = ranges::less>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  ranges::minmax_element_result<borrowed_iterator_t<_Rp>>
  operator()(_Rp&& __r, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __ret = std::__minmax_element_impl(ranges::begin(__r), ranges::end(__r), __comp, __proj);
    return {__ret.first, __ret.second};
  }
};
}
inline namespace __cpo {
  inline constexpr auto minmax_element = __minmax_element::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _I1, class _I2>
using mismatch_result = in_in_result<_I1, _I2>;
namespace __mismatch {
struct __fn {
  template <class _I1, class _S1, class _I2, class _S2,
            class _Pred, class _Proj1, class _Proj2>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  mismatch_result<_I1, _I2>
  __go(_I1 __first1, _S1 __last1, _I2 __first2, _S2 __last2,
       _Pred& __pred, _Proj1& __proj1, _Proj2& __proj2) {
    while (__first1 != __last1 && __first2 != __last2) {
      if (!std::invoke(__pred, std::invoke(__proj1, *__first1), std::invoke(__proj2, *__first2)))
        break;
      ++__first1;
      ++__first2;
    }
    return {std::move(__first1), std::move(__first2)};
  }
  template <input_iterator _I1, sentinel_for<_I1> _S1,
            input_iterator _I2, sentinel_for<_I2> _S2,
            class _Pred = ranges::equal_to, class _Proj1 = identity, class _Proj2 = identity>
    requires indirectly_comparable<_I1, _I2, _Pred, _Proj1, _Proj2>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  mismatch_result<_I1, _I2> operator()(_I1 __first1, _S1 __last1, _I2 __first2, _S2 __last2,
                                       _Pred __pred = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
    return __go(std::move(__first1), __last1, std::move(__first2), __last2, __pred, __proj1, __proj2);
  }
  template <input_range _R1, input_range _R2,
            class _Pred = ranges::equal_to, class _Proj1 = identity, class _Proj2 = identity>
    requires indirectly_comparable<iterator_t<_R1>, iterator_t<_R2>, _Pred, _Proj1, _Proj2>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  mismatch_result<borrowed_iterator_t<_R1>, borrowed_iterator_t<_R2>>
  operator()(_R1&& __r1, _R2&& __r2, _Pred __pred = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
    return __go(ranges::begin(__r1), ranges::end(__r1), ranges::begin(__r2), ranges::end(__r2),
                __pred, __proj1, __proj2);
  }
};
}
inline namespace __cpo {
  constexpr inline auto mismatch = __mismatch::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _InIter, class _OutIter>
using move_result = in_out_result<_InIter, _OutIter>;
namespace __move {
struct __fn {
  template <class _InIter, class _Sent, class _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr static
  move_result<_InIter, _OutIter> __move_impl(_InIter __first, _Sent __last, _OutIter __result) {
    auto __ret = std::__move<_RangeAlgPolicy>(std::move(__first), std::move(__last), std::move(__result));
    return {std::move(__ret.first), std::move(__ret.second)};
  }
  template <input_iterator _InIter, sentinel_for<_InIter> _Sent, weakly_incrementable _OutIter>
    requires indirectly_movable<_InIter, _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  move_result<_InIter, _OutIter> operator()(_InIter __first, _Sent __last, _OutIter __result) const {
    return __move_impl(std::move(__first), std::move(__last), std::move(__result));
  }
  template <input_range _Range, weakly_incrementable _OutIter>
    requires indirectly_movable<iterator_t<_Range>, _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  move_result<borrowed_iterator_t<_Range>, _OutIter> operator()(_Range&& __range, _OutIter __result) const {
    return __move_impl(ranges::begin(__range), ranges::end(__range), std::move(__result));
  }
};
}
inline namespace __cpo {
  inline constexpr auto move = __move::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _InIter, class _OutIter>
using move_backward_result = in_out_result<_InIter, _OutIter>;
namespace __move_backward {
struct __fn {
  template <class _InIter, class _Sent, class _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr static
  move_backward_result<_InIter, _OutIter> __move_backward_impl(_InIter __first, _Sent __last, _OutIter __result) {
    auto __ret = std::__move_backward<_RangeAlgPolicy>(std::move(__first), std::move(__last), std::move(__result));
    return {std::move(__ret.first), std::move(__ret.second)};
  }
  template <bidirectional_iterator _InIter, sentinel_for<_InIter> _Sent, bidirectional_iterator _OutIter>
    requires indirectly_movable<_InIter, _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  move_backward_result<_InIter, _OutIter> operator()(_InIter __first, _Sent __last, _OutIter __result) const {
    return __move_backward_impl(std::move(__first), std::move(__last), std::move(__result));
  }
  template <bidirectional_range _Range, bidirectional_iterator _Iter>
    requires indirectly_movable<iterator_t<_Range>, _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  move_backward_result<borrowed_iterator_t<_Range>, _Iter> operator()(_Range&& __range, _Iter __result) const {
    return __move_backward_impl(ranges::begin(__range), ranges::end(__range), std::move(__result));
  }
};
}
inline namespace __cpo {
  inline constexpr auto move_backward = __move_backward::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _InIter>
using next_permutation_result = in_found_result<_InIter>;
namespace __next_permutation {
struct __fn {
  template <bidirectional_iterator _Iter, sentinel_for<_Iter> _Sent, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<_Iter, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr next_permutation_result<_Iter>
  operator()(_Iter __first, _Sent __last, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __result = std::__next_permutation<_RangeAlgPolicy>(
        std::move(__first), std::move(__last), std::__make_projected(__comp, __proj));
    return {std::move(__result.first), std::move(__result.second)};
  }
  template <bidirectional_range _Range, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<iterator_t<_Range>, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr next_permutation_result<borrowed_iterator_t<_Range>>
  operator()(_Range&& __range, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __result = std::__next_permutation<_RangeAlgPolicy>(
        ranges::begin(__range), ranges::end(__range), std::__make_projected(__comp, __proj));
    return {std::move(__result.first), std::move(__result.second)};
  }
};
}
inline namespace __cpo {
constexpr inline auto next_permutation = __next_permutation::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __none_of {
struct __fn {
  template <class _Iter, class _Sent, class _Proj, class _Pred>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr static
  bool __none_of_impl(_Iter __first, _Sent __last, _Pred& __pred, _Proj& __proj) {
    for (; __first != __last; ++__first) {
      if (std::invoke(__pred, std::invoke(__proj, *__first)))
        return false;
    }
    return true;
  }
  template <input_iterator _Iter, sentinel_for<_Iter> _Sent, class _Proj = identity,
            indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  bool operator()(_Iter __first, _Sent __last, _Pred __pred = {}, _Proj __proj = {}) const {
    return __none_of_impl(std::move(__first), std::move(__last), __pred, __proj);
  }
  template <input_range _Range, class _Proj = identity,
            indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  bool operator()(_Range&& __range, _Pred __pred, _Proj __proj = {}) const {
    return __none_of_impl(ranges::begin(__range), ranges::end(__range), __pred, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto none_of = __none_of::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __nth_element {
struct __fn {
  template <class _Iter, class _Sent, class _Comp, class _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr static
  _Iter __nth_element_fn_impl(_Iter __first, _Iter __nth, _Sent __last, _Comp& __comp, _Proj& __proj) {
    auto __last_iter = ranges::next(__first, __last);
    auto&& __projected_comp = std::__make_projected(__comp, __proj);
    std::__nth_element_impl<_RangeAlgPolicy>(std::move(__first), std::move(__nth), __last_iter, __projected_comp);
    return __last_iter;
  }
  template <random_access_iterator _Iter, sentinel_for<_Iter> _Sent, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<_Iter, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  _Iter operator()(_Iter __first, _Iter __nth, _Sent __last, _Comp __comp = {}, _Proj __proj = {}) const {
    return __nth_element_fn_impl(std::move(__first), std::move(__nth), std::move(__last), __comp, __proj);
  }
  template <random_access_range _Range, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<iterator_t<_Range>, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  borrowed_iterator_t<_Range> operator()(_Range&& __r, iterator_t<_Range> __nth, _Comp __comp = {},
                                         _Proj __proj = {}) const {
    return __nth_element_fn_impl(ranges::begin(__r), std::move(__nth), ranges::end(__r), __comp, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto nth_element = __nth_element::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __partial_sort {
struct __fn {
  template <class _Iter, class _Sent, class _Comp, class _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr static
  _Iter __partial_sort_fn_impl(_Iter __first, _Iter __middle, _Sent __last, _Comp& __comp, _Proj& __proj) {
    auto&& __projected_comp = std::__make_projected(__comp, __proj);
    return std::__partial_sort<_RangeAlgPolicy>(std::move(__first), std::move(__middle), __last, __projected_comp);
  }
  template <random_access_iterator _Iter, sentinel_for<_Iter> _Sent, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<_Iter, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  _Iter operator()(_Iter __first, _Iter __middle, _Sent __last, _Comp __comp = {}, _Proj __proj = {}) const {
    return __partial_sort_fn_impl(std::move(__first), std::move(__middle), std::move(__last), __comp, __proj);
  }
  template <random_access_range _Range, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<iterator_t<_Range>, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  borrowed_iterator_t<_Range> operator()(_Range&& __r, iterator_t<_Range> __middle, _Comp __comp = {},
                                         _Proj __proj = {}) const {
    return __partial_sort_fn_impl(ranges::begin(__r), std::move(__middle), ranges::end(__r), __comp, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto partial_sort = __partial_sort::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _InIter, class _OutIter>
using partial_sort_copy_result = in_out_result<_InIter, _OutIter>;
namespace __partial_sort_copy {
struct __fn {
  template <input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
            random_access_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
            class _Comp = ranges::less, class _Proj1 = identity, class _Proj2 = identity>
  requires indirectly_copyable<_Iter1, _Iter2> && sortable<_Iter2, _Comp, _Proj2> &&
           indirect_strict_weak_order<_Comp, projected<_Iter1, _Proj1>, projected<_Iter2, _Proj2>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  partial_sort_copy_result<_Iter1, _Iter2>
  operator()(_Iter1 __first, _Sent1 __last, _Iter2 __result_first, _Sent2 __result_last,
             _Comp __comp = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
    auto __result = std::__partial_sort_copy<_RangeAlgPolicy>(
        std::move(__first), std::move(__last), std::move(__result_first), std::move(__result_last),
        __comp, __proj1, __proj2
    );
    return {std::move(__result.first), std::move(__result.second)};
  }
  template <input_range _Range1, random_access_range _Range2, class _Comp = ranges::less,
            class _Proj1 = identity, class _Proj2 = identity>
  requires indirectly_copyable<iterator_t<_Range1>, iterator_t<_Range2>> &&
           sortable<iterator_t<_Range2>, _Comp, _Proj2> &&
           indirect_strict_weak_order<_Comp, projected<iterator_t<_Range1>, _Proj1>,
                                      projected<iterator_t<_Range2>, _Proj2>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  partial_sort_copy_result<borrowed_iterator_t<_Range1>, borrowed_iterator_t<_Range2>>
  operator()(_Range1&& __range, _Range2&& __result_range, _Comp __comp = {},
             _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const {
    auto __result = std::__partial_sort_copy<_RangeAlgPolicy>(
        ranges::begin(__range), ranges::end(__range), ranges::begin(__result_range), ranges::end(__result_range),
        __comp, __proj1, __proj2
    );
    return {std::move(__result.first), std::move(__result.second)};
  }
};
}
inline namespace __cpo {
  inline constexpr auto partial_sort_copy = __partial_sort_copy::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __partition {
struct __fn {
  template <class _Iter, class _Sent, class _Proj, class _Pred>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr
  subrange<__remove_cvref_t<_Iter>> __partition_fn_impl(_Iter&& __first, _Sent&& __last, _Pred&& __pred, _Proj&& __proj) {
    auto&& __projected_pred = std::__make_projected(__pred, __proj);
    auto __result = std::__partition<_RangeAlgPolicy>(
        std::move(__first), std::move(__last), __projected_pred, __iterator_concept<_Iter>());
    return {std::move(__result.first), std::move(__result.second)};
  }
  template <permutable _Iter, sentinel_for<_Iter> _Sent, class _Proj = identity,
            indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  subrange<_Iter> operator()(_Iter __first, _Sent __last, _Pred __pred, _Proj __proj = {}) const {
    return __partition_fn_impl(__first, __last, __pred, __proj);
  }
  template <forward_range _Range, class _Proj = identity,
            indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
  requires permutable<iterator_t<_Range>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  borrowed_subrange_t<_Range> operator()(_Range&& __range, _Pred __pred, _Proj __proj = {}) const {
    return __partition_fn_impl(ranges::begin(__range), ranges::end(__range), __pred, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto partition = __partition::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _InIter, class _OutIter1, class _OutIter2>
using partition_copy_result = in_out_out_result<_InIter, _OutIter1, _OutIter2>;
namespace __partition_copy {
struct __fn {
  template <class _InIter, class _Sent, class _OutIter1, class _OutIter2, class _Proj, class _Pred>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  static partition_copy_result<
      __remove_cvref_t<_InIter>, __remove_cvref_t<_OutIter1>, __remove_cvref_t<_OutIter2>
  > __partition_copy_fn_impl( _InIter&& __first, _Sent&& __last, _OutIter1&& __out_true, _OutIter2&& __out_false,
      _Pred& __pred, _Proj& __proj) {
    for (; __first != __last; ++__first) {
      if (std::invoke(__pred, std::invoke(__proj, *__first))) {
        *__out_true = *__first;
        ++__out_true;
      } else {
        *__out_false = *__first;
        ++__out_false;
      }
    }
    return {std::move(__first), std::move(__out_true), std::move(__out_false)};
  }
  template <input_iterator _InIter, sentinel_for<_InIter> _Sent,
            weakly_incrementable _OutIter1, weakly_incrementable _OutIter2,
            class _Proj = identity, indirect_unary_predicate<projected<_InIter, _Proj>> _Pred>
  requires indirectly_copyable<_InIter, _OutIter1> && indirectly_copyable<_InIter, _OutIter2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  partition_copy_result<_InIter, _OutIter1, _OutIter2>
  operator()(_InIter __first, _Sent __last, _OutIter1 __out_true, _OutIter2 __out_false,
             _Pred __pred, _Proj __proj = {}) const {
    return __partition_copy_fn_impl(
        std::move(__first), std::move(__last), std::move(__out_true), std::move(__out_false), __pred, __proj);
  }
  template <input_range _Range, weakly_incrementable _OutIter1, weakly_incrementable _OutIter2,
            class _Proj = identity, indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
  requires indirectly_copyable<iterator_t<_Range>, _OutIter1> && indirectly_copyable<iterator_t<_Range>, _OutIter2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  partition_copy_result<borrowed_iterator_t<_Range>, _OutIter1, _OutIter2>
  operator()(_Range&& __range, _OutIter1 __out_true, _OutIter2 __out_false, _Pred __pred, _Proj __proj = {}) const {
    return __partition_copy_fn_impl(
        ranges::begin(__range), ranges::end(__range), std::move(__out_true), std::move(__out_false), __pred, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto partition_copy = __partition_copy::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __partition_point {
struct __fn {
  template <class _Iter, class _Sent, class _Proj, class _Pred>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  static _Iter __partition_point_fn_impl(_Iter&& __first, _Sent&& __last, _Pred& __pred, _Proj& __proj) {
    auto __len = ranges::distance(__first, __last);
    while (__len != 0) {
      auto __half_len = std::__half_positive(__len);
      auto __mid = ranges::next(__first, __half_len);
      if (std::invoke(__pred, std::invoke(__proj, *__mid))) {
        __first = ++__mid;
        __len -= __half_len + 1;
      } else {
        __len = __half_len;
      }
    }
    return __first;
  }
  template <forward_iterator _Iter, sentinel_for<_Iter> _Sent, class _Proj = identity,
            indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  _Iter operator()(_Iter __first, _Sent __last, _Pred __pred, _Proj __proj = {}) const {
    return __partition_point_fn_impl(std::move(__first), std::move(__last), __pred, __proj);
  }
  template <forward_range _Range, class _Proj = identity,
            indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  borrowed_iterator_t<_Range> operator()(_Range&& __range, _Pred __pred, _Proj __proj = {}) const {
    return __partition_point_fn_impl(ranges::begin(__range), ranges::end(__range), __pred, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto partition_point = __partition_point::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __pop_heap {
struct __fn {
  template <class _Iter, class _Sent, class _Comp, class _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr static
  _Iter __pop_heap_fn_impl(_Iter __first, _Sent __last, _Comp& __comp, _Proj& __proj) {
    auto __last_iter = ranges::next(__first, __last);
    auto __len = __last_iter - __first;
    auto&& __projected_comp = std::__make_projected(__comp, __proj);
    std::__pop_heap<_RangeAlgPolicy>(std::move(__first), __last_iter, __projected_comp, __len);
    return __last_iter;
  }
  template <random_access_iterator _Iter, sentinel_for<_Iter> _Sent, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<_Iter, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  _Iter operator()(_Iter __first, _Sent __last, _Comp __comp = {}, _Proj __proj = {}) const {
    return __pop_heap_fn_impl(std::move(__first), std::move(__last), __comp, __proj);
  }
  template <random_access_range _Range, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<iterator_t<_Range>, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  borrowed_iterator_t<_Range> operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const {
    return __pop_heap_fn_impl(ranges::begin(__r), ranges::end(__r), __comp, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto pop_heap = __pop_heap::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _InIter>
using prev_permutation_result = in_found_result<_InIter>;
namespace __prev_permutation {
struct __fn {
  template <bidirectional_iterator _Iter, sentinel_for<_Iter> _Sent,
            class _Comp = ranges::less, class _Proj = identity>
    requires sortable<_Iter, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr prev_permutation_result<_Iter>
  operator()(_Iter __first, _Sent __last, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __result = std::__prev_permutation<_RangeAlgPolicy>(
        std::move(__first), std::move(__last), std::__make_projected(__comp, __proj));
    return {std::move(__result.first), std::move(__result.second)};
  }
  template <bidirectional_range _Range,
            class _Comp = ranges::less, class _Proj = identity>
    requires sortable<iterator_t<_Range>, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr prev_permutation_result<borrowed_iterator_t<_Range>>
  operator()(_Range&& __range, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __result = std::__prev_permutation<_RangeAlgPolicy>(
        ranges::begin(__range), ranges::end(__range), std::__make_projected(__comp, __proj));
    return {std::move(__result.first), std::move(__result.second)};
  }
};
}
inline namespace __cpo {
constexpr inline auto prev_permutation = __prev_permutation::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __push_heap {
struct __fn {
  template <class _Iter, class _Sent, class _Comp, class _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr static
  _Iter __push_heap_fn_impl(_Iter __first, _Sent __last, _Comp& __comp, _Proj& __proj) {
    auto __last_iter = ranges::next(__first, __last);
    auto&& __projected_comp = std::__make_projected(__comp, __proj);
    std::__push_heap<_RangeAlgPolicy>(std::move(__first), __last_iter, __projected_comp);
    return __last_iter;
  }
  template <random_access_iterator _Iter, sentinel_for<_Iter> _Sent, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<_Iter, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  _Iter operator()(_Iter __first, _Sent __last, _Comp __comp = {}, _Proj __proj = {}) const {
    return __push_heap_fn_impl(std::move(__first), std::move(__last), __comp, __proj);
  }
  template <random_access_range _Range, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<iterator_t<_Range>, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  borrowed_iterator_t<_Range> operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const {
    return __push_heap_fn_impl(ranges::begin(__r), ranges::end(__r), __comp, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto push_heap = __push_heap::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _Iter, class _Sent, class _Proj, class _Pred>
// added by concept-synth, original LN: 17575
requires
(
 requires (_Iter x0) { *x0; } &&
 requires (_Iter x0) { ++x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
subrange<_Iter> __remove_if_impl(_Iter __first, _Sent __last, _Pred& __pred, _Proj& __proj) {
  auto __new_end = ranges::__find_if_impl(__first, __last, __pred, __proj);
  if (__new_end == __last)
    return {__new_end, __new_end};
  _Iter __i = __new_end;
  while (++__i != __last) {
    if (!std::invoke(__pred, std::invoke(__proj, *__i))) {
      *__new_end = ranges::iter_move(__i);
      ++__new_end;
    }
  }
  return {__new_end, __i};
}
namespace __remove_if {
struct __fn {
  template <permutable _Iter, sentinel_for<_Iter> _Sent,
            class _Proj = identity,
            indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  subrange<_Iter> operator()(_Iter __first, _Sent __last, _Pred __pred, _Proj __proj = {}) const {
    return ranges::__remove_if_impl(std::move(__first), std::move(__last), __pred, __proj);
  }
  template <forward_range _Range,
            class _Proj = identity,
            indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
    requires permutable<iterator_t<_Range>>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  borrowed_subrange_t<_Range> operator()(_Range&& __range, _Pred __pred, _Proj __proj = {}) const {
    return ranges::__remove_if_impl(ranges::begin(__range), ranges::end(__range), __pred, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto remove_if = __remove_if::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __remove {
struct __fn {
  template <permutable _Iter, sentinel_for<_Iter> _Sent, class _Type, class _Proj = identity>
    requires indirect_binary_predicate<ranges::equal_to, projected<_Iter, _Proj>, const _Type*>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  subrange<_Iter> operator()(_Iter __first, _Sent __last, const _Type& __value, _Proj __proj = {}) const {
    auto __pred = [&](auto&& __other) { return __value == __other; };
    return ranges::__remove_if_impl(std::move(__first), std::move(__last), __pred, __proj);
  }
  template <forward_range _Range, class _Type, class _Proj = identity>
    requires permutable<iterator_t<_Range>>
          && indirect_binary_predicate<ranges::equal_to, projected<iterator_t<_Range>, _Proj>, const _Type*>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  borrowed_subrange_t<_Range> operator()(_Range&& __range, const _Type& __value, _Proj __proj = {}) const {
    auto __pred = [&](auto&& __other) { return __value == __other; };
    return ranges::__remove_if_impl(ranges::begin(__range), ranges::end(__range), __pred, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto remove = __remove::__fn{};
}
}
}}
namespace std { inline namespace __1 {
template <class _InputIterator, class _OutputIterator, class _Predicate>
// added by concept-synth, original LN: 17641
requires
requires (_Predicate f, _InputIterator x0) { f(*x0); } &&
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
) &&
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_OutputIterator
remove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)
{
    for (; __first != __last; ++__first)
    {
        if (!__pred(*__first))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _InIter, class _OutIter>
using remove_copy_if_result = in_out_result<_InIter, _OutIter>;
template <class _InIter, class _Sent, class _OutIter, class _Proj, class _Pred>
// added by concept-synth, original LN: 17661
requires
(
 requires (_InIter x0) { *x0; } &&
 requires (_InIter x0) { ++x0; }
) &&
(
 requires (_OutIter x0) { ++x0; } &&
 requires (_OutIter x0) { *x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr in_out_result<_InIter, _OutIter>
__remove_copy_if_impl(_InIter __first, _Sent __last, _OutIter __result, _Pred& __pred, _Proj& __proj) {
  for (; __first != __last; ++__first) {
    if (!std::invoke(__pred, std::invoke(__proj, *__first))) {
      *__result = *__first;
      ++__result;
    }
  }
  return {std::move(__first), std::move(__result)};
}
namespace __remove_copy_if {
  struct __fn {
    template <input_iterator _InIter,
              sentinel_for<_InIter> _Sent,
              weakly_incrementable _OutIter,
              class _Proj = identity,
              indirect_unary_predicate<projected<_InIter, _Proj>> _Pred>
      requires indirectly_copyable<_InIter, _OutIter>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr remove_copy_if_result<_InIter, _OutIter>
    operator()(_InIter __first, _Sent __last, _OutIter __result, _Pred __pred, _Proj __proj = {}) const {
      return ranges::__remove_copy_if_impl(std::move(__first), std::move(__last), std::move(__result), __pred, __proj);
    }
    template <input_range _Range,
              weakly_incrementable _OutIter,
              class _Proj = identity,
              indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
      requires indirectly_copyable<iterator_t<_Range>, _OutIter>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr remove_copy_if_result<borrowed_iterator_t<_Range>, _OutIter>
    operator()(_Range&& __range, _OutIter __result, _Pred __pred, _Proj __proj = {}) const {
      return ranges::__remove_copy_if_impl(
          ranges::begin(__range), ranges::end(__range), std::move(__result), __pred, __proj);
    }
  };
}
inline namespace __cpo {
  inline constexpr auto remove_copy_if = __remove_copy_if::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _InIter, class _OutIter>
using remove_copy_result = in_out_result<_InIter, _OutIter>;
namespace __remove_copy {
  struct __fn {
    template <input_iterator _InIter,
              sentinel_for<_InIter> _Sent,
              weakly_incrementable _OutIter,
              class _Type,
              class _Proj = identity>
      requires indirectly_copyable<_InIter, _OutIter> &&
               indirect_binary_predicate<ranges::equal_to, projected<_InIter, _Proj>, const _Type*>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr remove_copy_result<_InIter, _OutIter>
    operator()(_InIter __first, _Sent __last, _OutIter __result, const _Type& __value, _Proj __proj = {}) const {
      auto __pred = [&](auto&& __val) { return __value == __val; };
      return ranges::__remove_copy_if_impl(std::move(__first), std::move(__last), std::move(__result), __pred, __proj);
    }
    template <input_range _Range, weakly_incrementable _OutIter, class _Type, class _Proj = identity>
      requires indirectly_copyable<iterator_t<_Range>, _OutIter> &&
               indirect_binary_predicate<ranges::equal_to, projected<iterator_t<_Range>, _Proj>, const _Type*>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr remove_copy_result<borrowed_iterator_t<_Range>, _OutIter>
    operator()(_Range&& __range, _OutIter __result, const _Type& __value, _Proj __proj = {}) const {
      auto __pred = [&](auto&& __val) { return __value == __val; };
      return ranges::__remove_copy_if_impl(
          ranges::begin(__range), ranges::end(__range), std::move(__result), __pred, __proj);
    }
  };
}
inline namespace __cpo {
  inline constexpr auto remove_copy = __remove_copy::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _Iter, class _Sent, class _Type, class _Proj, class _Pred>
// added by concept-synth, original LN: 17737
requires
(
 requires (_Iter x0) { *x0; } &&
 requires (_Iter x0) { ++x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_Iter __replace_if_impl(_Iter __first, _Sent __last, _Pred& __pred, const _Type& __new_value, _Proj& __proj) {
  for (; __first != __last; ++__first) {
    if (std::invoke(__pred, std::invoke(__proj, *__first)))
      *__first = __new_value;
  }
  return __first;
}
namespace __replace_if {
struct __fn {
  template <input_iterator _Iter, sentinel_for<_Iter> _Sent,
            class _Type,
            class _Proj = identity,
            indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
    requires indirectly_writable<_Iter, const _Type&>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  _Iter operator()(_Iter __first, _Sent __last, _Pred __pred, const _Type& __new_value, _Proj __proj = {}) const {
    return ranges::__replace_if_impl(std::move(__first), std::move(__last), __pred, __new_value, __proj);
  }
  template <input_range _Range,
            class _Type,
            class _Proj = identity,
            indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
    requires indirectly_writable<iterator_t<_Range>, const _Type&>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr borrowed_iterator_t<_Range>
  operator()(_Range&& __range, _Pred __pred, const _Type& __new_value, _Proj __proj = {}) const {
    return ranges::__replace_if_impl(ranges::begin(__range), ranges::end(__range), __pred, __new_value, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto replace_if = __replace_if::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __replace {
struct __fn {
  template <input_iterator _Iter, sentinel_for<_Iter> _Sent,
            class _Type1,
            class _Type2,
            class _Proj = identity>
    requires indirectly_writable<_Iter, const _Type2&>
          && indirect_binary_predicate<ranges::equal_to, projected<_Iter, _Proj>, const _Type1*>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  _Iter operator()(_Iter __first, _Sent __last,
                   const _Type1& __old_value,
                   const _Type2& __new_value,
                   _Proj __proj = {}) const {
    auto __pred = [&](const auto& __val) { return __val == __old_value; };
    return ranges::__replace_if_impl(std::move(__first), std::move(__last), __pred, __new_value, __proj);
  }
  template <input_range _Range,
            class _Type1,
            class _Type2,
            class _Proj = identity>
    requires indirectly_writable<iterator_t<_Range>, const _Type2&>
          && indirect_binary_predicate<ranges::equal_to, projected<iterator_t<_Range>, _Proj>, const _Type1*>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr borrowed_iterator_t<_Range>
  operator()(_Range&& __range, const _Type1& __old_value, const _Type2& __new_value, _Proj __proj = {}) const {
    auto __pred = [&](auto&& __val) { return __val == __old_value; };
    return ranges::__replace_if_impl(ranges::begin(__range), ranges::end(__range), __pred, __new_value, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto replace = __replace::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _InIter, class _OutIter>
using replace_copy_if_result = in_out_result<_InIter, _OutIter>;
template <class _InIter, class _Sent, class _OutIter, class _Pred, class _Type, class _Proj>
// added by concept-synth, original LN: 17813
requires
(
 requires (_InIter x0) { ++x0; } &&
 requires (_InIter x0) { *x0; }
) &&
(
 requires (_OutIter x0) { ++x0; } &&
 requires (_OutIter x0) { *x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr replace_copy_if_result<_InIter, _OutIter> __replace_copy_if_impl(
    _InIter __first, _Sent __last, _OutIter __result, _Pred& __pred, const _Type& __new_value, _Proj& __proj) {
  while (__first != __last) {
    if (std::invoke(__pred, std::invoke(__proj, *__first)))
      *__result = __new_value;
    else
      *__result = *__first;
    ++__first;
    ++__result;
  }
  return {std::move(__first), std::move(__result)};
}
namespace __replace_copy_if {
  struct __fn {
    template <input_iterator _InIter,
              sentinel_for<_InIter> _Sent,
              class _Type,
              output_iterator<const _Type&> _OutIter,
              class _Proj = identity,
              indirect_unary_predicate<projected<_InIter, _Proj>> _Pred>
      requires indirectly_copyable<_InIter, _OutIter>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr replace_copy_if_result<_InIter, _OutIter> operator()(
        _InIter __first, _Sent __last, _OutIter __result, _Pred __pred, const _Type& __new_value, _Proj __proj = {})
        const {
      return ranges::__replace_copy_if_impl(
          std::move(__first), std::move(__last), std::move(__result), __pred, __new_value, __proj);
    }
    template <input_range _Range,
              class _Type,
              output_iterator<const _Type&> _OutIter,
              class _Proj = identity,
              indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
      requires indirectly_copyable<iterator_t<_Range>, _OutIter>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr replace_copy_if_result<borrowed_iterator_t<_Range>, _OutIter>
    operator()(_Range&& __range, _OutIter __result, _Pred __pred, const _Type& __new_value, _Proj __proj = {}) const {
      return ranges::__replace_copy_if_impl(
          ranges::begin(__range), ranges::end(__range), std::move(__result), __pred, __new_value, __proj);
    }
  };
}
inline namespace __cpo {
  inline constexpr auto replace_copy_if = __replace_copy_if::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _InIter, class _OutIter>
using replace_copy_result = in_out_result<_InIter, _OutIter>;
namespace __replace_copy {
  struct __fn {
    template <input_iterator _InIter,
              sentinel_for<_InIter> _Sent,
              class _OldType,
              class _NewType,
              output_iterator<const _NewType&> _OutIter,
              class _Proj = identity>
      requires indirectly_copyable<_InIter, _OutIter> &&
               indirect_binary_predicate<ranges::equal_to, projected<_InIter, _Proj>, const _OldType*>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr replace_copy_result<_InIter, _OutIter>
    operator()(_InIter __first,
               _Sent __last,
               _OutIter __result,
               const _OldType& __old_value,
               const _NewType& __new_value,
               _Proj __proj = {}) const {
      auto __pred = [&](const auto& __value) { return __value == __old_value; };
      return ranges::__replace_copy_if_impl(
          std::move(__first), std::move(__last), std::move(__result), __pred, __new_value, __proj);
    }
    template <input_range _Range,
              class _OldType,
              class _NewType,
              output_iterator<const _NewType&> _OutIter,
              class _Proj = identity>
      requires indirectly_copyable<iterator_t<_Range>, _OutIter> &&
               indirect_binary_predicate<ranges::equal_to, projected<iterator_t<_Range>, _Proj>, const _OldType*>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr replace_copy_result<borrowed_iterator_t<_Range>, _OutIter>
    operator()(_Range&& __range,
               _OutIter __result,
               const _OldType& __old_value,
               const _NewType& __new_value,
               _Proj __proj = {}) const {
      auto __pred = [&](const auto& __value) { return __value == __old_value; };
      return ranges::__replace_copy_if_impl(
          ranges::begin(__range), ranges::end(__range), std::move(__result), __pred, __new_value, __proj);
    }
  };
}
inline namespace __cpo {
  inline constexpr auto replace_copy = __replace_copy::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __reverse {
struct __fn {
  template <bidirectional_iterator _Iter, sentinel_for<_Iter> _Sent>
    requires permutable<_Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  _Iter operator()(_Iter __first, _Sent __last) const {
    if constexpr (random_access_iterator<_Iter>) {
      if (__first == __last)
        return __first;
      auto __end = ranges::next(__first, __last);
      auto __ret = __end;
      while (__first < --__end) {
        ranges::iter_swap(__first, __end);
        ++__first;
      }
      return __ret;
    } else {
      auto __end = ranges::next(__first, __last);
      auto __ret = __end;
      while (__first != __end) {
        if (__first == --__end)
          break;
        ranges::iter_swap(__first, __end);
        ++__first;
      }
      return __ret;
    }
  }
  template <bidirectional_range _Range>
    requires permutable<iterator_t<_Range>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  borrowed_iterator_t<_Range> operator()(_Range&& __range) const {
    return (*this)(ranges::begin(__range), ranges::end(__range));
  }
};
}
inline namespace __cpo {
  inline constexpr auto reverse = __reverse::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _InIter, class _OutIter>
using reverse_copy_result = in_out_result<_InIter, _OutIter>;
namespace __reverse_copy {
struct __fn {
  template <bidirectional_iterator _InIter, sentinel_for<_InIter> _Sent, weakly_incrementable _OutIter>
    requires indirectly_copyable<_InIter, _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  reverse_copy_result<_InIter, _OutIter> operator()(_InIter __first, _Sent __last, _OutIter __result) const {
    return (*this)(subrange(std::move(__first), std::move(__last)), std::move(__result));
  }
  template <bidirectional_range _Range, weakly_incrementable _OutIter>
    requires indirectly_copyable<iterator_t<_Range>, _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  reverse_copy_result<borrowed_iterator_t<_Range>, _OutIter> operator()(_Range&& __range, _OutIter __result) const {
    auto __ret = ranges::copy(std::__reverse_range(__range), std::move(__result));
    return {ranges::next(ranges::begin(__range), ranges::end(__range)), std::move(__ret.out)};
  }
};
}
inline namespace __cpo {
  inline constexpr auto reverse_copy = __reverse_copy::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __rotate {
struct __fn {
  template <class _Iter, class _Sent>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  static subrange<_Iter> __rotate_fn_impl(_Iter __first, _Iter __middle, _Sent __last) {
    auto __ret = std::__rotate<_RangeAlgPolicy>(
      std::move(__first), std::move(__middle), std::move(__last));
    return {std::move(__ret.first), std::move(__ret.second)};
  }
  template <permutable _Iter, sentinel_for<_Iter> _Sent>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  subrange<_Iter> operator()(_Iter __first, _Iter __middle, _Sent __last) const {
    return __rotate_fn_impl(std::move(__first), std::move(__middle), std::move(__last));
  }
  template <forward_range _Range>
  requires permutable<iterator_t<_Range>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  borrowed_subrange_t<_Range> operator()(_Range&& __range, iterator_t<_Range> __middle) const {
    return __rotate_fn_impl(ranges::begin(__range), std::move(__middle), ranges::end(__range));
  }
};
}
inline namespace __cpo {
  inline constexpr auto rotate = __rotate::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _InIter, class _OutIter>
using rotate_copy_result = in_out_result<_InIter, _OutIter>;
namespace __rotate_copy {
struct __fn {
  template <bidirectional_iterator _InIter, sentinel_for<_InIter> _Sent, weakly_incrementable _OutIter>
    requires indirectly_copyable<_InIter, _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  rotate_copy_result<_InIter, _OutIter>
  operator()(_InIter __first, _InIter __middle, _Sent __last, _OutIter __result) const {
    auto __res1 = ranges::copy(__middle, __last, std::move(__result));
    auto __res2 = ranges::copy(__first, __middle, std::move(__res1.out));
    return {std::move(__res1.in), std::move(__res2.out)};
  }
  template <bidirectional_range _Range, weakly_incrementable _OutIter>
    requires indirectly_copyable<iterator_t<_Range>, _OutIter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  rotate_copy_result<borrowed_iterator_t<_Range>, _OutIter>
  operator()(_Range&& __range, iterator_t<_Range> __middle, _OutIter __result) const {
    return (*this)(ranges::begin(__range), std::move(__middle), ranges::end(__range), std::move(__result));
  }
};
}
inline namespace __cpo {
  inline constexpr auto rotate_copy = __rotate_copy::__fn{};
}
}
}}
namespace std { inline namespace __1 {
template<class> struct __libcpp_random_is_valid_inttype : false_type {};
template<> struct __libcpp_random_is_valid_inttype<int8_t> : true_type {};
template<> struct __libcpp_random_is_valid_inttype<short> : true_type {};
template<> struct __libcpp_random_is_valid_inttype<int> : true_type {};
template<> struct __libcpp_random_is_valid_inttype<long> : true_type {};
template<> struct __libcpp_random_is_valid_inttype<long long> : true_type {};
template<> struct __libcpp_random_is_valid_inttype<uint8_t> : true_type {};
template<> struct __libcpp_random_is_valid_inttype<unsigned short> : true_type {};
template<> struct __libcpp_random_is_valid_inttype<unsigned int> : true_type {};
template<> struct __libcpp_random_is_valid_inttype<unsigned long> : true_type {};
template<> struct __libcpp_random_is_valid_inttype<unsigned long long> : true_type {};
template<> struct __libcpp_random_is_valid_inttype<__int128_t> : true_type {};
template<> struct __libcpp_random_is_valid_inttype<__uint128_t> : true_type {};
template<class, class = void> struct __libcpp_random_is_valid_urng : false_type {};
template<class _Gp> struct __libcpp_random_is_valid_urng<_Gp, __enable_if_t<
    is_unsigned<typename _Gp::result_type>::value &&
    _IsSame<decltype(std::declval<_Gp&>()()), typename _Gp::result_type>::value
> > : true_type {};
}}
namespace std { inline namespace __1 {
template <class _UIntType, _UIntType _Xp, size_t _Rp>
struct __log2_imp;
template <unsigned long long _Xp, size_t _Rp>
struct __log2_imp<unsigned long long, _Xp, _Rp>
{
    static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp
                                           : __log2_imp<unsigned long long, _Xp, _Rp - 1>::value;
};
template <unsigned long long _Xp>
struct __log2_imp<unsigned long long, _Xp, 0>
{
    static const size_t value = 0;
};
template <size_t _Rp>
struct __log2_imp<unsigned long long, 0, _Rp>
{
    static const size_t value = _Rp + 1;
};
template <__uint128_t _Xp, size_t _Rp>
struct __log2_imp<__uint128_t, _Xp, _Rp>
{
    static const size_t value = (_Xp >> 64)
        ? (64 + __log2_imp<unsigned long long, (_Xp >> 64), 63>::value)
        : __log2_imp<unsigned long long, _Xp, 63>::value;
};
template <class _UIntType, _UIntType _Xp>
struct __log2
{
    static const size_t value = __log2_imp<
        __conditional_t<sizeof(_UIntType) <= sizeof(unsigned long long), unsigned long long, __uint128_t>,
        _Xp,
        sizeof(_UIntType) * 8 - 1>::value;
};
}}

namespace std { inline namespace __1 {
template<class _Engine, class _UIntType>
class __independent_bits_engine
{
public:
    typedef _UIntType result_type;
private:
    typedef typename _Engine::result_type _Engine_result_type;
    typedef __conditional_t<sizeof(_Engine_result_type) <= sizeof(result_type), result_type, _Engine_result_type>
        _Working_result_type;
    _Engine& __e_;
    size_t __w_;
    size_t __w0_;
    size_t __n_;
    size_t __n0_;
    _Working_result_type __y0_;
    _Working_result_type __y1_;
    _Engine_result_type __mask0_;
    _Engine_result_type __mask1_;
    static constexpr const _Working_result_type _Rp = _Engine::max() - _Engine::min()
                                                      + _Working_result_type(1);
    static constexpr const size_t __m = __log2<_Working_result_type, _Rp>::value;
    static constexpr const size_t _WDt = numeric_limits<_Working_result_type>::digits;
    static constexpr const size_t _EDt = numeric_limits<_Engine_result_type>::digits;
public:
    __independent_bits_engine(_Engine& __e, size_t __w);
    result_type operator()() {return __eval(integral_constant<bool, _Rp != 0>());}
private:
    result_type __eval(false_type);
    result_type __eval(true_type);
};
template<class _Engine, class _UIntType>
__independent_bits_engine<_Engine, _UIntType>
    ::__independent_bits_engine(_Engine& __e, size_t __w)
        : __e_(__e),
          __w_(__w)
{
    __n_ = __w_ / __m + (__w_ % __m != 0);
    __w0_ = __w_ / __n_;
    if (_Rp == 0)
        __y0_ = _Rp;
    else if (__w0_ < _WDt)
        __y0_ = (_Rp >> __w0_) << __w0_;
    else
        __y0_ = 0;
    if (_Rp - __y0_ > __y0_ / __n_)
    {
        ++__n_;
        __w0_ = __w_ / __n_;
        if (__w0_ < _WDt)
            __y0_ = (_Rp >> __w0_) << __w0_;
        else
            __y0_ = 0;
    }
    __n0_ = __n_ - __w_ % __n_;
    if (__w0_ < _WDt - 1)
        __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);
    else
        __y1_ = 0;
    __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_) :
                          _Engine_result_type(0);
    __mask1_ = __w0_ < _EDt - 1 ?
                               _Engine_result_type(~0) >> (_EDt - (__w0_ + 1)) :
                               _Engine_result_type(~0);
}
template<class _Engine, class _UIntType>
inline
_UIntType
__independent_bits_engine<_Engine, _UIntType>::__eval(false_type)
{
    return static_cast<result_type>(__e_() & __mask0_);
}
template<class _Engine, class _UIntType>
_UIntType
__independent_bits_engine<_Engine, _UIntType>::__eval(true_type)
{
    const size_t _WRt = numeric_limits<result_type>::digits;
    result_type _Sp = 0;
    for (size_t __k = 0; __k < __n0_; ++__k)
    {
        _Engine_result_type __u;
        do
        {
            __u = __e_() - _Engine::min();
        } while (__u >= __y0_);
        if (__w0_ < _WRt)
            _Sp <<= __w0_;
        else
            _Sp = 0;
        _Sp += __u & __mask0_;
    }
    for (size_t __k = __n0_; __k < __n_; ++__k)
    {
        _Engine_result_type __u;
        do
        {
            __u = __e_() - _Engine::min();
        } while (__u >= __y1_);
        if (__w0_ < _WRt - 1)
            _Sp <<= __w0_ + 1;
        else
            _Sp = 0;
        _Sp += __u & __mask1_;
    }
    return _Sp;
}
template<class _IntType = int>
class uniform_int_distribution
{
    static_assert(__libcpp_random_is_valid_inttype<_IntType>::value, "IntType must be a supported integer type");
public:
    typedef _IntType result_type;
    class param_type
    {
        result_type __a_;
        result_type __b_;
    public:
        typedef uniform_int_distribution distribution_type;
        explicit param_type(result_type __a = 0,
                            result_type __b = numeric_limits<result_type>::max())
            : __a_(__a), __b_(__b) {}
        result_type a() const {return __a_;}
        result_type b() const {return __b_;}
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
        friend bool operator==(const param_type& __x, const param_type& __y)
            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
        friend bool operator!=(const param_type& __x, const param_type& __y)
            {return !(__x == __y);}
    };
private:
    param_type __p_;
public:
    uniform_int_distribution() : uniform_int_distribution(0) {}
    explicit uniform_int_distribution(
        result_type __a, result_type __b = numeric_limits<result_type>::max())
        : __p_(param_type(__a, __b)) {}
    explicit uniform_int_distribution(const param_type& __p) : __p_(__p) {}
    void reset() {}
    template<class _URNG> result_type operator()(_URNG& __g)
        {return (*this)(__g, __p_);}
    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);
    result_type a() const {return __p_.a();}
    result_type b() const {return __p_.b();}
    param_type param() const {return __p_;}
    void param(const param_type& __p) {__p_ = __p;}
    result_type min() const {return a();}
    result_type max() const {return b();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    friend bool operator==(const uniform_int_distribution& __x,
                           const uniform_int_distribution& __y)
        {return __x.__p_ == __y.__p_;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    friend bool operator!=(const uniform_int_distribution& __x,
                           const uniform_int_distribution& __y)
            {return !(__x == __y);}
};
template<class _IntType>
template<class _URNG>
typename uniform_int_distribution<_IntType>::result_type
uniform_int_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p)
__attribute__((__no_sanitize__("unsigned-integer-overflow")))
{
    static_assert(__libcpp_random_is_valid_urng<_URNG>::value, "");
    typedef __conditional_t<sizeof(result_type) <= sizeof(uint32_t), uint32_t, __make_unsigned_t<result_type> >
        _UIntType;
    const _UIntType _Rp = _UIntType(__p.b()) - _UIntType(__p.a()) + _UIntType(1);
    if (_Rp == 1)
        return __p.a();
    const size_t _Dt = numeric_limits<_UIntType>::digits;
    typedef __independent_bits_engine<_URNG, _UIntType> _Eng;
    if (_Rp == 0)
        return static_cast<result_type>(_Eng(__g, _Dt)());
    size_t __w = _Dt - std::__countl_zero(_Rp) - 1;
    if ((_Rp & (numeric_limits<_UIntType>::max() >> (_Dt - __w))) != 0)
        ++__w;
    _Eng __e(__g, __w);
    _UIntType __u;
    do
    {
        __u = __e();
    } while (__u >= _Rp);
    return static_cast<result_type>(__u + __p.a());
}
template <class _CharT, class _Traits, class _IT>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const uniform_int_distribution<_IT>& __x)
{
    __save_flags<_CharT, _Traits> __lx(__os);
    typedef basic_ostream<_CharT, _Traits> _Ostream;
    __os.flags(_Ostream::dec | _Ostream::left);
    _CharT __sp = __os.widen(' ');
    __os.fill(__sp);
    return __os << __x.a() << __sp << __x.b();
}
template <class _CharT, class _Traits, class _IT>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           uniform_int_distribution<_IT>& __x)
{
    typedef uniform_int_distribution<_IT> _Eng;
    typedef typename _Eng::result_type result_type;
    typedef typename _Eng::param_type param_type;
    __save_flags<_CharT, _Traits> __lx(__is);
    typedef basic_istream<_CharT, _Traits> _Istream;
    __is.flags(_Istream::dec | _Istream::skipws);
    result_type __a;
    result_type __b;
    __is >> __a >> __b;
    if (!__is.fail())
        __x.param(param_type(__a, __b));
    return __is;
}
}}

namespace std { inline namespace __1 {
template <class _AlgPolicy,
          class _PopulationIterator, class _PopulationSentinel, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>
// added by concept-synth, original LN: 18308
requires
requires (_Distance x0) { ++x0; } &&
(
 requires (_PopulationIterator x0) { *x0; } &&
 requires (_PopulationIterator x0) { ++x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_SampleIterator __sample(_PopulationIterator __first,
                         _PopulationSentinel __last, _SampleIterator __output_iter,
                         _Distance __n,
                         _UniformRandomNumberGenerator& __g,
                         input_iterator_tag) {
  _Distance __k = 0;
  for (; __first != __last && __k < __n; ++__first, (void) ++__k)
    __output_iter[__k] = *__first;
  _Distance __sz = __k;
  for (; __first != __last; ++__first, (void) ++__k) {
    _Distance __r = uniform_int_distribution<_Distance>(0, __k)(__g);
    if (__r < __sz)
      __output_iter[__r] = *__first;
  }
  return __output_iter + std::min(__n, __k);
}
template <class _AlgPolicy,
          class _PopulationIterator, class _PopulationSentinel, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>
// added by concept-synth, original LN: 18328
requires
requires (_Distance x0) { --x0; } &&
(
 requires (_PopulationIterator x0) { *x0; } &&
 requires (_PopulationIterator x0) { ++x0; }
) &&
requires (_SampleIterator x0) { x0++; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_SampleIterator __sample(_PopulationIterator __first,
                         _PopulationSentinel __last, _SampleIterator __output_iter,
                         _Distance __n,
                         _UniformRandomNumberGenerator& __g,
                         forward_iterator_tag) {
  _Distance __unsampled_sz = _IterOps<_AlgPolicy>::distance(__first, __last);
  for (__n = std::min(__n, __unsampled_sz); __n != 0; ++__first) {
    _Distance __r = uniform_int_distribution<_Distance>(0, --__unsampled_sz)(__g);
    if (__r < __n) {
      *__output_iter++ = *__first;
      --__n;
    }
  }
  return __output_iter;
}
template <class _AlgPolicy,
          class _PopulationIterator, class _PopulationSentinel, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>
// added by concept-synth, original LN: 18347
requires
(
 requires (_PopulationIterator x0) { *x0; } &&
 requires (_PopulationIterator x0) { ++x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_SampleIterator __sample(_PopulationIterator __first,
                         _PopulationSentinel __last, _SampleIterator __output_iter,
                         _Distance __n, _UniformRandomNumberGenerator& __g) {
  (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
  __builtin_assume(static_cast<bool>(__n >= 0))
#pragma clang diagnostic pop
  );
  using _PopIterCategory = typename _IterOps<_AlgPolicy>::template __iterator_category<_PopulationIterator>;
  using _Difference = typename _IterOps<_AlgPolicy>::template __difference_type<_PopulationIterator>;
  using _CommonType = typename common_type<_Distance, _Difference>::type;
  return std::__sample<_AlgPolicy>(
      std::move(__first), std::move(__last), std::move(__output_iter), _CommonType(__n),
      __g, _PopIterCategory());
}
template <class _PopulationIterator, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>
// added by concept-synth, original LN: 18367
requires
(
 requires (_PopulationIterator x0) { *x0; } &&
 requires (_PopulationIterator x0) { ++x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_SampleIterator sample(_PopulationIterator __first,
                       _PopulationIterator __last, _SampleIterator __output_iter,
                       _Distance __n, _UniformRandomNumberGenerator&& __g) {
  static_assert(__is_cpp17_forward_iterator<_PopulationIterator>::value ||
                __is_cpp17_random_access_iterator<_SampleIterator>::value,
                "SampleIterator must meet the requirements of RandomAccessIterator");
  return std::__sample<_ClassicAlgPolicy>(
      std::move(__first), std::move(__last), std::move(__output_iter), __n, __g);
}
}}

namespace std { inline namespace __1 {
template <class _Gen>
class _ClassicGenAdaptor {
private:
  _Gen& __gen_;
public:
  using result_type = invoke_result_t<_Gen&>;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  static constexpr auto min() { return __remove_cvref_t<_Gen>::min(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  static constexpr auto max() { return __remove_cvref_t<_Gen>::max(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr explicit _ClassicGenAdaptor(_Gen& __g) : __gen_(__g) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr auto operator()() const { return __gen_(); }
};
}}

namespace std { inline namespace __1 {
template<class _Gen>
concept uniform_random_bit_generator =
  invocable<_Gen&> && unsigned_integral<invoke_result_t<_Gen&>> &&
  requires {
    { _Gen::min() } -> same_as<invoke_result_t<_Gen&>>;
    { _Gen::max() } -> same_as<invoke_result_t<_Gen&>>;
    requires bool_constant<(_Gen::min() < _Gen::max())>::value;
  };
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __sample {
struct __fn {
  template <input_iterator _Iter, sentinel_for<_Iter> _Sent, weakly_incrementable _OutIter, class _Gen>
  requires (forward_iterator<_Iter> || random_access_iterator<_OutIter>) &&
           indirectly_copyable<_Iter, _OutIter> &&
           uniform_random_bit_generator<remove_reference_t<_Gen>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  _OutIter operator()(_Iter __first, _Sent __last,
                      _OutIter __out_first, iter_difference_t<_Iter> __n, _Gen&& __gen) const {
    _ClassicGenAdaptor<_Gen> __adapted_gen(__gen);
    return std::__sample<_RangeAlgPolicy>(
        std::move(__first), std::move(__last), std::move(__out_first), __n, __adapted_gen);
  }
  template <input_range _Range, weakly_incrementable _OutIter, class _Gen>
  requires (forward_range<_Range> || random_access_iterator<_OutIter>) &&
           indirectly_copyable<iterator_t<_Range>, _OutIter> &&
           uniform_random_bit_generator<remove_reference_t<_Gen>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  _OutIter operator()(_Range&& __range, _OutIter __out_first, range_difference_t<_Range> __n, _Gen&& __gen) const {
    return (*this)(ranges::begin(__range), ranges::end(__range),
                   std::move(__out_first), __n, std::forward<_Gen>(__gen));
  }
};
}
inline namespace __cpo {
  inline constexpr auto sample = __sample::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __search {
struct __fn {
  template <class _Iter1, class _Sent1, class _Iter2, class _Sent2, class _Pred, class _Proj1, class _Proj2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr subrange<_Iter1> __ranges_search_impl(
      _Iter1 __first1,
      _Sent1 __last1,
      _Iter2 __first2,
      _Sent2 __last2,
      _Pred& __pred,
      _Proj1& __proj1,
      _Proj2& __proj2) {
    if constexpr (sized_sentinel_for<_Sent2, _Iter2>) {
      auto __size2 = ranges::distance(__first2, __last2);
      if (__size2 == 0)
        return {__first1, __first1};
      if constexpr (sized_sentinel_for<_Sent1, _Iter1>) {
        auto __size1 = ranges::distance(__first1, __last1);
        if (__size1 < __size2) {
          ranges::advance(__first1, __last1);
          return {__first1, __first1};
        }
        if constexpr (random_access_iterator<_Iter1> && random_access_iterator<_Iter2>) {
          auto __ret = std::__search_random_access_impl<_RangeAlgPolicy>(
              __first1, __last1, __first2, __last2, __pred, __proj1, __proj2, __size1, __size2);
          return {__ret.first, __ret.second};
        }
      }
    }
    auto __ret =
        std::__search_forward_impl<_RangeAlgPolicy>(__first1, __last1, __first2, __last2, __pred, __proj1, __proj2);
    return {__ret.first, __ret.second};
  }
  template <forward_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
            forward_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
            class _Pred = ranges::equal_to,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  subrange<_Iter1> operator()(_Iter1 __first1, _Sent1 __last1,
                              _Iter2 __first2, _Sent2 __last2,
                              _Pred __pred = {},
                              _Proj1 __proj1 = {},
                              _Proj2 __proj2 = {}) const {
    return __ranges_search_impl(__first1, __last1, __first2, __last2, __pred, __proj1, __proj2);
  }
  template <forward_range _Range1,
            forward_range _Range2,
            class _Pred = ranges::equal_to,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>, _Pred, _Proj1, _Proj2>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  borrowed_subrange_t<_Range1> operator()(_Range1&& __range1,
                                          _Range2&& __range2,
                                          _Pred __pred = {},
                                          _Proj1 __proj1 = {},
                                          _Proj2 __proj2 = {}) const {
    auto __first1 = ranges::begin(__range1);
    if constexpr (sized_range<_Range2>) {
      auto __size2 = ranges::size(__range2);
      if (__size2 == 0)
        return {__first1, __first1};
      if constexpr (sized_range<_Range1>) {
        auto __size1 = ranges::size(__range1);
        if (__size1 < __size2) {
          ranges::advance(__first1, ranges::end(__range1));
          return {__first1, __first1};
        }
      }
    }
    return __ranges_search_impl(
        ranges::begin(__range1),
        ranges::end(__range1),
        ranges::begin(__range2),
        ranges::end(__range2),
        __pred,
        __proj1,
        __proj2);
  }
};
}
inline namespace __cpo {
  inline constexpr auto search = __search::__fn{};
}
}
}}
namespace std { inline namespace __1 {
template <class _AlgPolicy, class _Pred, class _Iter, class _Sent, class _SizeT, class _Type, class _Proj>
// added by concept-synth, original LN: 18530
requires
requires (_SizeT x0) { ++x0; } &&
(
 requires (_Iter x0) { *x0; } &&
 requires (_Iter x0) { ++x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
pair<_Iter, _Iter> __search_n_forward_impl(_Iter __first, _Sent __last,
                                           _SizeT __count,
                                           const _Type& __value,
                                           _Pred& __pred,
                                           _Proj& __proj) {
  if (__count <= 0)
    return std::make_pair(__first, __first);
  while (true) {
    while (true) {
      if (__first == __last) {
        _IterOps<_AlgPolicy>::__advance_to(__first, __last);
        return std::make_pair(__first, __first);
      }
      if (std::__invoke(__pred, std::__invoke(__proj, *__first), __value))
        break;
      ++__first;
    }
    _Iter __m = __first;
    _SizeT __c(0);
    while (true) {
      if (++__c == __count)
        return std::make_pair(__first, ++__m);
      if (++__m == __last) {
        _IterOps<_AlgPolicy>::__advance_to(__first, __last);
        return std::make_pair(__first, __first);
      }
      if (!std::__invoke(__pred, std::__invoke(__proj, *__m), __value))
      {
        __first = __m;
        ++__first;
        break;
      }
    }
  }
}
template <class _AlgPolicy, class _Pred, class _Iter, class _Sent, class _SizeT, class _Type, class _Proj, class _DiffT>
// added by concept-synth, original LN: 18567
requires
requires (_SizeT x0) { ++x0; } &&
(
 requires (_Iter x0) { *x0; } &&
 requires (_Iter x0) { ++x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
std::pair<_Iter, _Iter> __search_n_random_access_impl(_Iter __first, _Sent __last,
                                                      _SizeT __count,
                                                      const _Type& __value,
                                                      _Pred& __pred,
                                                      _Proj& __proj,
                                                      _DiffT __size1) {
  using difference_type = typename iterator_traits<_Iter>::difference_type;
  if (__count == 0)
    return std::make_pair(__first, __first);
  if (__size1 < static_cast<_DiffT>(__count)) {
    _IterOps<_AlgPolicy>::__advance_to(__first, __last);
    return std::make_pair(__first, __first);
  }
  const auto __s = __first + __size1 - difference_type(__count - 1);
  while (true) {
    while (true) {
      if (__first >= __s) {
        _IterOps<_AlgPolicy>::__advance_to(__first, __last);
        return std::make_pair(__first, __first);
      }
      if (std::__invoke(__pred, std::__invoke(__proj, *__first), __value))
        break;
      ++__first;
    }
    auto __m = __first;
    _SizeT __c(0);
    while (true) {
      if (++__c == __count)
        return std::make_pair(__first, __first + _DiffT(__count));
      ++__m;
      if (!std::__invoke(__pred, std::__invoke(__proj, *__m), __value))
      {
        __first = __m;
        ++__first;
        break;
      }
    }
  }
}
template <class _Iter, class _Sent,
          class _DiffT,
          class _Type,
          class _Pred,
          class _Proj>
// added by concept-synth, original LN: 18608
requires
requires (_DiffT x0) { ++x0; } &&
(
 requires (_Iter x0) { *x0; } &&
 requires (_Iter x0) { ++x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
pair<_Iter, _Iter> __search_n_impl(_Iter __first, _Sent __last,
                                   _DiffT __count,
                                   const _Type& __value,
                                   _Pred& __pred,
                                   _Proj& __proj,
                                   __enable_if_t<__is_cpp17_random_access_iterator<_Iter>::value>* = nullptr) {
  return std::__search_n_random_access_impl<_ClassicAlgPolicy>(__first, __last,
                                                               __count,
                                                               __value,
                                                               __pred,
                                                               __proj,
                                                               __last - __first);
}
template <class _Iter1, class _Sent1,
          class _DiffT,
          class _Type,
          class _Pred,
          class _Proj>
// added by concept-synth, original LN: 18627
requires
requires (_DiffT x0) { ++x0; } &&
(
 requires (_Iter1 x0) { *x0; } &&
 requires (_Iter1 x0) { ++x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
pair<_Iter1, _Iter1> __search_n_impl(_Iter1 __first, _Sent1 __last,
                                     _DiffT __count,
                                     const _Type& __value,
                                     _Pred& __pred,
                                     _Proj& __proj,
                                     __enable_if_t<__is_cpp17_forward_iterator<_Iter1>::value
                                               && !__is_cpp17_random_access_iterator<_Iter1>::value>* = nullptr) {
  return std::__search_n_forward_impl<_ClassicAlgPolicy>(__first, __last,
                                                         __count,
                                                         __value,
                                                         __pred,
                                                         __proj);
}
template <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>
// added by concept-synth, original LN: 18646
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_ForwardIterator search_n(_ForwardIterator __first, _ForwardIterator __last,
                          _Size __count,
                          const _Tp& __value,
                          _BinaryPredicate __pred) {
  static_assert(__is_callable<_BinaryPredicate, decltype(*__first), const _Tp&>::value,
                "BinaryPredicate has to be callable");
  auto __proj = __identity();
  return std::__search_n_impl(__first, __last, std::__convert_to_integral(__count), __value, __pred, __proj).first;
}
template <class _ForwardIterator, class _Size, class _Tp>
// added by concept-synth, original LN: 18657
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_ForwardIterator search_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value) {
  return std::search_n(__first, __last, std::__convert_to_integral(__count), __value, __equal_to());
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __search_n {
struct __fn {
  template <class _Iter1, class _Sent1, class _SizeT, class _Type, class _Pred, class _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr subrange<_Iter1> __ranges_search_n_impl(
      _Iter1 __first, _Sent1 __last, _SizeT __count, const _Type& __value, _Pred& __pred, _Proj& __proj) {
    if (__count == 0)
      return {__first, __first};
    if constexpr (sized_sentinel_for<_Sent1, _Iter1>) {
      auto __size = ranges::distance(__first, __last);
      if (__size < __count) {
        ranges::advance(__first, __last);
        return {__first, __first};
      }
      if constexpr (random_access_iterator<_Iter1>) {
        auto __ret = std::__search_n_random_access_impl<_RangeAlgPolicy>(
            __first, __last, __count, __value, __pred, __proj, __size);
        return {std::move(__ret.first), std::move(__ret.second)};
      }
    }
    auto __ret = std::__search_n_forward_impl<_RangeAlgPolicy>(__first, __last,
                                                               __count,
                                                               __value,
                                                               __pred,
                                                               __proj);
    return {std::move(__ret.first), std::move(__ret.second)};
  }
  template <forward_iterator _Iter, sentinel_for<_Iter> _Sent,
            class _Type,
            class _Pred = ranges::equal_to,
            class _Proj = identity>
    requires indirectly_comparable<_Iter, const _Type*, _Pred, _Proj>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  subrange<_Iter> operator()(_Iter __first, _Sent __last,
                             iter_difference_t<_Iter> __count,
                             const _Type& __value,
                             _Pred __pred = {},
                             _Proj __proj = _Proj{}) const {
    return __ranges_search_n_impl(__first, __last, __count, __value, __pred, __proj);
  }
  template <forward_range _Range, class _Type, class _Pred = ranges::equal_to, class _Proj = identity>
    requires indirectly_comparable<iterator_t<_Range>, const _Type*, _Pred, _Proj>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  borrowed_subrange_t<_Range> operator()(_Range&& __range,
                                         range_difference_t<_Range> __count,
                                         const _Type& __value,
                                         _Pred __pred = {},
                                         _Proj __proj = {}) const {
    auto __first = ranges::begin(__range);
    if (__count <= 0)
      return {__first, __first};
    if constexpr (sized_range<_Range>) {
      auto __size1 = ranges::size(__range);
      if (__size1 < static_cast<range_size_t<_Range>>(__count)) {
        ranges::advance(__first, ranges::end(__range));
        return {__first, __first};
      }
    }
    return __ranges_search_n_impl(ranges::begin(__range), ranges::end(__range), __count, __value, __pred, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto search_n = __search_n::__fn{};
}
}
}}
namespace std { inline namespace __1 {
template <class _AlgPolicy, class _Comp, class _InIter1, class _Sent1, class _InIter2, class _Sent2, class _OutIter>
// added by concept-synth, original LN: 18732
requires
(
 requires (_InIter2 x0) { ++x0; } &&
 requires (_InIter2 x0) { *x0; }
) &&
(
 requires (_OutIter x0) { ++x0; } &&
 requires (_OutIter x0) { *x0; }
) &&
(
 requires (_Comp f, _InIter2 x0, _InIter1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 requires (_Comp f, _InIter1 x0, _InIter2 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
) &&
(
 requires (_InIter1 x0) { ++x0; } &&
 requires (_InIter1 x0) { *x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pair<__remove_cvref_t<_InIter1>, __remove_cvref_t<_OutIter> >
__set_difference(
    _InIter1&& __first1, _Sent1&& __last1, _InIter2&& __first2, _Sent2&& __last2, _OutIter&& __result, _Comp&& __comp) {
  while (__first1 != __last1 && __first2 != __last2) {
    if (__comp(*__first1, *__first2)) {
      *__result = *__first1;
      ++__first1;
      ++__result;
    } else if (__comp(*__first2, *__first1)) {
      ++__first2;
    } else {
      ++__first1;
      ++__first2;
    }
  }
  return std::__copy<_AlgPolicy>(std::move(__first1), std::move(__last1), std::move(__result));
}
template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
// added by concept-synth, original LN: 18750
requires
(
 requires (_InputIterator1 x0) { ++x0; } &&
 requires (_InputIterator1 x0) { *x0; }
) &&
(
 requires (_Compare f, _InputIterator2 x0, _InputIterator1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 requires (_Compare f, _InputIterator1 x0, _InputIterator2 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
) &&
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
) &&
(
 requires (_InputIterator2 x0) { ++x0; } &&
 requires (_InputIterator2 x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _OutputIterator set_difference(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result,
    _Compare __comp) {
  return std::__set_difference<_ClassicAlgPolicy, __comp_ref_type<_Compare> >(
      __first1, __last1, __first2, __last2, __result, __comp)
      .second;
}
template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
// added by concept-synth, original LN: 18762
requires
(
 requires (_InputIterator1 x0) { ++x0; } &&
 requires (_InputIterator1 x0) { *x0; }
) &&
(
 requires (_InputIterator2 x0) { ++x0; } &&
 requires (_InputIterator2 x0) { *x0; }
) &&
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _OutputIterator set_difference(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result) {
  return std::__set_difference<_ClassicAlgPolicy>(
      __first1,
      __last1,
      __first2,
      __last2,
      __result,
      __less<typename iterator_traits<_InputIterator1>::value_type,
             typename iterator_traits<_InputIterator2>::value_type>()).second;
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _InIter, class _OutIter>
using set_difference_result = in_out_result<_InIter, _OutIter>;
namespace __set_difference {
struct __fn {
  template <
      input_iterator _InIter1,
      sentinel_for<_InIter1> _Sent1,
      input_iterator _InIter2,
      sentinel_for<_InIter2> _Sent2,
      weakly_incrementable _OutIter,
      class _Comp = less,
      class _Proj1 = identity,
      class _Proj2 = identity>
    requires mergeable<_InIter1, _InIter2, _OutIter, _Comp, _Proj1, _Proj2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr set_difference_result<_InIter1, _OutIter> operator()(
      _InIter1 __first1,
      _Sent1 __last1,
      _InIter2 __first2,
      _Sent2 __last2,
      _OutIter __result,
      _Comp __comp = {},
      _Proj1 __proj1 = {},
      _Proj2 __proj2 = {}) const {
    auto __ret = std::__set_difference<_RangeAlgPolicy>(
        __first1, __last1, __first2, __last2, __result, ranges::__make_projected_comp(__comp, __proj1, __proj2));
    return {std::move(__ret.first), std::move(__ret.second)};
  }
  template <
      input_range _Range1,
      input_range _Range2,
      weakly_incrementable _OutIter,
      class _Comp = less,
      class _Proj1 = identity,
      class _Proj2 = identity>
    requires mergeable<iterator_t<_Range1>, iterator_t<_Range2>, _OutIter, _Comp, _Proj1, _Proj2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr set_difference_result<borrowed_iterator_t<_Range1>, _OutIter>
    operator()(
        _Range1&& __range1,
        _Range2&& __range2,
        _OutIter __result,
        _Comp __comp = {},
        _Proj1 __proj1 = {},
        _Proj2 __proj2 = {}) const {
    auto __ret = std::__set_difference<_RangeAlgPolicy>(
        ranges::begin(__range1),
        ranges::end(__range1),
        ranges::begin(__range2),
        ranges::end(__range2),
        __result,
        ranges::__make_projected_comp(__comp, __proj1, __proj2));
    return {std::move(__ret.first), std::move(__ret.second)};
  }
};
}
inline namespace __cpo {
  inline constexpr auto set_difference = __set_difference::__fn{};
}
}
}}
namespace std { inline namespace __1 {
template <class _InIter1, class _InIter2, class _OutIter>
struct __set_intersection_result {
  _InIter1 __in1_;
  _InIter2 __in2_;
  _OutIter __out_;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  __set_intersection_result(_InIter1&& __in_iter1, _InIter2&& __in_iter2, _OutIter&& __out_iter)
      : __in1_(std::move(__in_iter1)), __in2_(std::move(__in_iter2)), __out_(std::move(__out_iter)) {}
};
template <class _AlgPolicy, class _Compare, class _InIter1, class _Sent1, class _InIter2, class _Sent2, class _OutIter>
// added by concept-synth, original LN: 18850
requires
(
 requires (_InIter2 x0) { ++x0; } &&
 requires (_InIter2 x0) { *x0; }
) &&
(
 requires (_OutIter x0) { ++x0; } &&
 requires (_OutIter x0) { *x0; }
) &&
(
 requires (_Compare f, _InIter2 x0, _InIter1 x1) { f(*x0, *x1); } &&
 requires (_Compare f, _InIter1 x0, _InIter2 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
) &&
(
 requires (_InIter1 x0) { ++x0; } &&
 requires (_InIter1 x0) { *x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __set_intersection_result<_InIter1, _InIter2, _OutIter>
__set_intersection(
    _InIter1 __first1, _Sent1 __last1, _InIter2 __first2, _Sent2 __last2, _OutIter __result, _Compare&& __comp) {
  while (__first1 != __last1 && __first2 != __last2) {
    if (__comp(*__first1, *__first2))
      ++__first1;
    else {
      if (!__comp(*__first2, *__first1)) {
        *__result = *__first1;
        ++__result;
        ++__first1;
      }
      ++__first2;
    }
  }
  return __set_intersection_result<_InIter1, _InIter2, _OutIter>(
      _IterOps<_AlgPolicy>::next(std::move(__first1), std::move(__last1)),
      _IterOps<_AlgPolicy>::next(std::move(__first2), std::move(__last2)),
      std::move(__result));
}
template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
// added by concept-synth, original LN: 18871
requires
(
 requires (_InputIterator1 x0) { ++x0; } &&
 requires (_InputIterator1 x0) { *x0; }
) &&
(
 requires (_InputIterator2 x0) { ++x0; } &&
 requires (_InputIterator2 x0) { *x0; }
) &&
(
 requires (_Compare f, _InputIterator2 x0, _InputIterator1 x1) { f(*x0, *x1); } &&
 requires (_Compare f, _InputIterator1 x0, _InputIterator2 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
) &&
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _OutputIterator set_intersection(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result,
    _Compare __comp) {
  return std::__set_intersection<_ClassicAlgPolicy, __comp_ref_type<_Compare> >(
             std::move(__first1),
             std::move(__last1),
             std::move(__first2),
             std::move(__last2),
             std::move(__result),
             __comp)
      .__out_;
}
template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
// added by concept-synth, original LN: 18888
requires
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
) &&
(
 requires (_InputIterator2 x0) { ++x0; } &&
 requires (_InputIterator2 x0) { *x0; }
) &&
(
 requires (_InputIterator1 x0) { ++x0; } &&
 requires (_InputIterator1 x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _OutputIterator set_intersection(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result) {
  return std::__set_intersection<_ClassicAlgPolicy>(
             std::move(__first1),
             std::move(__last1),
             std::move(__first2),
             std::move(__last2),
             std::move(__result),
             __less<typename iterator_traits<_InputIterator1>::value_type,
                    typename iterator_traits<_InputIterator2>::value_type>())
      .__out_;
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _InIter1, class _InIter2, class _OutIter>
using set_intersection_result = in_in_out_result<_InIter1, _InIter2, _OutIter>;
namespace __set_intersection {
struct __fn {
  template <
      input_iterator _InIter1,
      sentinel_for<_InIter1> _Sent1,
      input_iterator _InIter2,
      sentinel_for<_InIter2> _Sent2,
      weakly_incrementable _OutIter,
      class _Comp = less,
      class _Proj1 = identity,
      class _Proj2 = identity>
    requires mergeable<_InIter1, _InIter2, _OutIter, _Comp, _Proj1, _Proj2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr set_intersection_result<_InIter1, _InIter2, _OutIter> operator()(
      _InIter1 __first1,
      _Sent1 __last1,
      _InIter2 __first2,
      _Sent2 __last2,
      _OutIter __result,
      _Comp __comp = {},
      _Proj1 __proj1 = {},
      _Proj2 __proj2 = {}) const {
    auto __ret = std::__set_intersection<_RangeAlgPolicy>(
        std::move(__first1),
        std::move(__last1),
        std::move(__first2),
        std::move(__last2),
        std::move(__result),
        ranges::__make_projected_comp(__comp, __proj1, __proj2));
    return {std::move(__ret.__in1_), std::move(__ret.__in2_), std::move(__ret.__out_)};
  }
  template <
      input_range _Range1,
      input_range _Range2,
      weakly_incrementable _OutIter,
      class _Comp = less,
      class _Proj1 = identity,
      class _Proj2 = identity>
    requires mergeable<
        iterator_t<_Range1>,
        iterator_t<_Range2>,
        _OutIter,
        _Comp,
        _Proj1,
        _Proj2>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr set_intersection_result<borrowed_iterator_t<_Range1>,
                                                            borrowed_iterator_t<_Range2>,
                                                            _OutIter>
    operator()(
        _Range1&& __range1,
        _Range2&& __range2,
        _OutIter __result,
        _Comp __comp = {},
        _Proj1 __proj1 = {},
        _Proj2 __proj2 = {}) const {
    auto __ret = std::__set_intersection<_RangeAlgPolicy>(
        ranges::begin(__range1),
        ranges::end(__range1),
        ranges::begin(__range2),
        ranges::end(__range2),
        std::move(__result),
        ranges::__make_projected_comp(__comp, __proj1, __proj2));
    return {std::move(__ret.__in1_), std::move(__ret.__in2_), std::move(__ret.__out_)};
  }
};
}
inline namespace __cpo {
  inline constexpr auto set_intersection = __set_intersection::__fn{};
}
}
}}
namespace std { inline namespace __1 {
template <class _InIter1, class _InIter2, class _OutIter>
struct __set_symmetric_difference_result {
  _InIter1 __in1_;
  _InIter2 __in2_;
  _OutIter __out_;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  __set_symmetric_difference_result(_InIter1&& __in_iter1, _InIter2&& __in_iter2, _OutIter&& __out_iter)
      : __in1_(std::move(__in_iter1)), __in2_(std::move(__in_iter2)), __out_(std::move(__out_iter)) {}
};
template <class _AlgPolicy, class _Compare, class _InIter1, class _Sent1, class _InIter2, class _Sent2, class _OutIter>
// added by concept-synth, original LN: 18990
requires
(
 requires (_InIter2 x0) { ++x0; } &&
 requires (_InIter2 x0) { *x0; }
) &&
(
 requires (_OutIter x0) { ++x0; } &&
 requires (_OutIter x0) { *x0; }
) &&
(
 requires (_InIter1 x0) { ++x0; } &&
 requires (_InIter1 x0) { *x0; }
) &&
(
 requires (_Compare f, _InIter2 x0, _InIter1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 requires (_Compare f, _InIter1 x0, _InIter2 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __set_symmetric_difference_result<_InIter1, _InIter2, _OutIter>
__set_symmetric_difference(
    _InIter1 __first1, _Sent1 __last1, _InIter2 __first2, _Sent2 __last2, _OutIter __result, _Compare&& __comp) {
  while (__first1 != __last1) {
    if (__first2 == __last2) {
      auto __ret1 = std::__copy<_AlgPolicy>(std::move(__first1), std::move(__last1), std::move(__result));
      return __set_symmetric_difference_result<_InIter1, _InIter2, _OutIter>(
          std::move(__ret1.first), std::move(__first2), std::move((__ret1.second)));
    }
    if (__comp(*__first1, *__first2)) {
      *__result = *__first1;
      ++__result;
      ++__first1;
    } else {
      if (__comp(*__first2, *__first1)) {
        *__result = *__first2;
        ++__result;
      } else {
        ++__first1;
      }
      ++__first2;
    }
  }
  auto __ret2 = std::__copy<_AlgPolicy>(std::move(__first2), std::move(__last2), std::move(__result));
  return __set_symmetric_difference_result<_InIter1, _InIter2, _OutIter>(
      std::move(__first1), std::move(__ret2.first), std::move((__ret2.second)));
}
template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
// added by concept-synth, original LN: 19018
requires
(
 requires (_Compare f, _InputIterator2 x0, _InputIterator1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
 requires (_Compare f, _InputIterator1 x0, _InputIterator2 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
) &&
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
) &&
(
 requires (_InputIterator2 x0) { ++x0; } &&
 requires (_InputIterator2 x0) { *x0; }
) &&
(
 requires (_InputIterator1 x0) { ++x0; } &&
 requires (_InputIterator1 x0) { *x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _OutputIterator set_symmetric_difference(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result,
    _Compare __comp) {
  return std::__set_symmetric_difference<_ClassicAlgPolicy, __comp_ref_type<_Compare> >(
             std::move(__first1),
             std::move(__last1),
             std::move(__first2),
             std::move(__last2),
             std::move(__result),
             __comp)
      .__out_;
}
template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
// added by concept-synth, original LN: 19035
requires
(
 requires (_InputIterator1 x0) { ++x0; } &&
 requires (_InputIterator1 x0) { *x0; }
) &&
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
) &&
(
 requires (_InputIterator2 x0) { ++x0; } &&
 requires (_InputIterator2 x0) { *x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _OutputIterator set_symmetric_difference(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result) {
  return std::set_symmetric_difference(
      std::move(__first1),
      std::move(__last1),
      std::move(__first2),
      std::move(__last2),
      std::move(__result),
      __less<typename iterator_traits<_InputIterator1>::value_type,
             typename iterator_traits<_InputIterator2>::value_type>());
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _InIter1, class _InIter2, class _OutIter>
using set_symmetric_difference_result = in_in_out_result<_InIter1, _InIter2, _OutIter>;
namespace __set_symmetric_difference {
struct __fn {
  template <
      input_iterator _InIter1,
      sentinel_for<_InIter1> _Sent1,
      input_iterator _InIter2,
      sentinel_for<_InIter2> _Sent2,
      weakly_incrementable _OutIter,
      class _Comp = ranges::less,
      class _Proj1 = identity,
      class _Proj2 = identity>
    requires mergeable<_InIter1, _InIter2, _OutIter, _Comp, _Proj1, _Proj2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr set_symmetric_difference_result<_InIter1, _InIter2, _OutIter> operator()(
      _InIter1 __first1,
      _Sent1 __last1,
      _InIter2 __first2,
      _Sent2 __last2,
      _OutIter __result,
      _Comp __comp = {},
      _Proj1 __proj1 = {},
      _Proj2 __proj2 = {}) const {
    auto __ret = std::__set_symmetric_difference<_RangeAlgPolicy>(
        std::move(__first1),
        std::move(__last1),
        std::move(__first2),
        std::move(__last2),
        std::move(__result),
        ranges::__make_projected_comp(__comp, __proj1, __proj2));
    return {std::move(__ret.__in1_), std::move(__ret.__in2_), std::move(__ret.__out_)};
  }
  template <
      input_range _Range1,
      input_range _Range2,
      weakly_incrementable _OutIter,
      class _Comp = ranges::less,
      class _Proj1 = identity,
      class _Proj2 = identity>
    requires mergeable<
        iterator_t<_Range1>,
        iterator_t<_Range2>,
        _OutIter,
        _Comp,
        _Proj1,
        _Proj2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr set_symmetric_difference_result<borrowed_iterator_t<_Range1>,
                                                                  borrowed_iterator_t<_Range2>,
                                                                  _OutIter>
    operator()(
        _Range1&& __range1,
        _Range2&& __range2,
        _OutIter __result,
        _Comp __comp = {},
        _Proj1 __proj1 = {},
        _Proj2 __proj2 = {}) const {
    auto __ret = std::__set_symmetric_difference<_RangeAlgPolicy>(
        ranges::begin(__range1),
        ranges::end(__range1),
        ranges::begin(__range2),
        ranges::end(__range2),
        std::move(__result),
        ranges::__make_projected_comp(__comp, __proj1, __proj2));
    return {std::move(__ret.__in1_), std::move(__ret.__in2_), std::move(__ret.__out_)};
  }
};
}
inline namespace __cpo {
  inline constexpr auto set_symmetric_difference = __set_symmetric_difference::__fn{};
}
}
}}
namespace std { inline namespace __1 {
template <class _InIter1, class _InIter2, class _OutIter>
struct __set_union_result {
  _InIter1 __in1_;
  _InIter2 __in2_;
  _OutIter __out_;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  __set_union_result(_InIter1&& __in_iter1, _InIter2&& __in_iter2, _OutIter&& __out_iter)
      : __in1_(std::move(__in_iter1)), __in2_(std::move(__in_iter2)), __out_(std::move(__out_iter)) {}
};
template <class _AlgPolicy, class _Compare, class _InIter1, class _Sent1, class _InIter2, class _Sent2, class _OutIter>
// added by concept-synth, original LN: 19136
requires
(
 requires (_OutIter x0) { *x0; } &&
 requires (_OutIter x0) { ++x0; }
) &&
(
 requires (_Compare f, _InIter1 x0, _InIter2 x1) { f(*x0, *x1); } &&
 requires (_Compare f, _InIter2 x0, _InIter1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
) &&
(
 requires (_InIter1 x0) { ++x0; } &&
 requires (_InIter1 x0) { *x0; }
) &&
(
 requires (_InIter2 x0) { ++x0; } &&
 requires (_InIter2 x0) { *x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __set_union_result<_InIter1, _InIter2, _OutIter> __set_union(
    _InIter1 __first1, _Sent1 __last1, _InIter2 __first2, _Sent2 __last2, _OutIter __result, _Compare&& __comp) {
  for (; __first1 != __last1; ++__result) {
    if (__first2 == __last2) {
      auto __ret1 = std::__copy<_AlgPolicy>(std::move(__first1), std::move(__last1), std::move(__result));
      return __set_union_result<_InIter1, _InIter2, _OutIter>(
          std::move(__ret1.first), std::move(__first2), std::move((__ret1.second)));
    }
    if (__comp(*__first2, *__first1)) {
      *__result = *__first2;
      ++__first2;
    } else {
      if (!__comp(*__first1, *__first2)) {
        ++__first2;
      }
      *__result = *__first1;
      ++__first1;
    }
  }
  auto __ret2 = std::__copy<_AlgPolicy>(std::move(__first2), std::move(__last2), std::move(__result));
  return __set_union_result<_InIter1, _InIter2, _OutIter>(
      std::move(__first1), std::move(__ret2.first), std::move((__ret2.second)));
}
template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>
// added by concept-synth, original LN: 19160
requires
(
 requires (_InputIterator2 x0) { ++x0; } &&
 requires (_InputIterator2 x0) { *x0; }
) &&
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
) &&
(
 requires (_InputIterator1 x0) { ++x0; } &&
 requires (_InputIterator1 x0) { *x0; }
) &&
(
 requires (_Compare f, _InputIterator1 x0, _InputIterator2 x1) { f(*x0, *x1); } &&
 requires (_Compare f, _InputIterator2 x0, _InputIterator1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _OutputIterator set_union(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result,
    _Compare __comp) {
  return std::__set_union<_ClassicAlgPolicy, __comp_ref_type<_Compare> >(
             std::move(__first1),
             std::move(__last1),
             std::move(__first2),
             std::move(__last2),
             std::move(__result),
             __comp)
      .__out_;
}
template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
// added by concept-synth, original LN: 19177
requires
(
 requires (_InputIterator2 x0) { ++x0; } &&
 requires (_InputIterator2 x0) { *x0; }
) &&
(
 requires (_InputIterator1 x0) { ++x0; } &&
 requires (_InputIterator1 x0) { *x0; }
) &&
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _OutputIterator set_union(
    _InputIterator1 __first1,
    _InputIterator1 __last1,
    _InputIterator2 __first2,
    _InputIterator2 __last2,
    _OutputIterator __result) {
  return std::set_union(
      std::move(__first1),
      std::move(__last1),
      std::move(__first2),
      std::move(__last2),
      std::move(__result),
      __less<typename iterator_traits<_InputIterator1>::value_type,
             typename iterator_traits<_InputIterator2>::value_type>());
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _InIter1, class _InIter2, class _OutIter>
using set_union_result = in_in_out_result<_InIter1, _InIter2, _OutIter>;
namespace __set_union {
struct __fn {
  template <
      input_iterator _InIter1,
      sentinel_for<_InIter1> _Sent1,
      input_iterator _InIter2,
      sentinel_for<_InIter2> _Sent2,
      weakly_incrementable _OutIter,
      class _Comp = ranges::less,
      class _Proj1 = identity,
      class _Proj2 = identity>
    requires mergeable<_InIter1, _InIter2, _OutIter, _Comp, _Proj1, _Proj2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr set_union_result<_InIter1, _InIter2, _OutIter> operator()(
      _InIter1 __first1,
      _Sent1 __last1,
      _InIter2 __first2,
      _Sent2 __last2,
      _OutIter __result,
      _Comp __comp = {},
      _Proj1 __proj1 = {},
      _Proj2 __proj2 = {}) const {
    auto __ret = std::__set_union<_RangeAlgPolicy>(
        std::move(__first1),
        std::move(__last1),
        std::move(__first2),
        std::move(__last2),
        std::move(__result),
        ranges::__make_projected_comp(__comp, __proj1, __proj2));
    return {std::move(__ret.__in1_), std::move(__ret.__in2_), std::move(__ret.__out_)};
  }
  template <
      input_range _Range1,
      input_range _Range2,
      weakly_incrementable _OutIter,
      class _Comp = ranges::less,
      class _Proj1 = identity,
      class _Proj2 = identity>
    requires mergeable<
        iterator_t<_Range1>,
        iterator_t<_Range2>,
        _OutIter,
        _Comp,
        _Proj1,
        _Proj2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr set_union_result<borrowed_iterator_t<_Range1>,
                                                   borrowed_iterator_t<_Range2>,
                                                   _OutIter>
    operator()(
        _Range1&& __range1,
        _Range2&& __range2,
        _OutIter __result,
        _Comp __comp = {},
        _Proj1 __proj1 = {},
        _Proj2 __proj2 = {}) const {
    auto __ret = std::__set_union<_RangeAlgPolicy>(
        ranges::begin(__range1),
        ranges::end(__range1),
        ranges::begin(__range2),
        ranges::end(__range2),
        std::move(__result),
        ranges::__make_projected_comp(__comp, __proj1, __proj2));
    return {std::move(__ret.__in1_), std::move(__ret.__in2_), std::move(__ret.__out_)};
  }
};
}
inline namespace __cpo {
  inline constexpr auto set_union = __set_union::__fn{};
}
}
}}

namespace std { inline namespace __1 {
class __attribute__((__visibility__("default"))) __libcpp_debug_randomizer {
public:
  __libcpp_debug_randomizer() {
    __state_ = __seed();
    __inc_ = __state_ + 0xda3e39cb94b95bdbULL;
    __inc_ = (__inc_ << 1) | 1;
  }
  typedef uint_fast32_t result_type;
  static const result_type _Min = 0;
  static const result_type _Max = 0xFFFFFFFF;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) result_type operator()() {
    uint_fast64_t __oldstate = __state_;
    __state_ = __oldstate * 6364136223846793005ULL + __inc_;
    return __oldstate >> 32;
  }
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr result_type min() { return _Min; }
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr result_type max() { return _Max; }
private:
  uint_fast64_t __state_;
  uint_fast64_t __inc_;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static uint_fast64_t __seed() {
    static char __x;
    return reinterpret_cast<uintptr_t>(&__x);
  }
};
template <class _AlgPolicy, class _RandomAccessIterator, class _Sentinel, class _UniformRandomNumberGenerator>
// added by concept-synth, original LN: 19295
requires
requires (_RandomAccessIterator x0) { ++x0; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) _RandomAccessIterator __shuffle(
    _RandomAccessIterator __first, _Sentinel __last_sentinel, _UniformRandomNumberGenerator&& __g) {
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    typedef uniform_int_distribution<ptrdiff_t> _Dp;
    typedef typename _Dp::param_type _Pp;
    auto __original_last = _IterOps<_AlgPolicy>::next(__first, __last_sentinel);
    auto __last = __original_last;
    difference_type __d = __last - __first;
    if (__d > 1)
    {
        _Dp __uid;
        for (--__last, (void) --__d; __first < __last; ++__first, (void) --__d)
        {
            difference_type __i = __uid(__g, _Pp(0, __d));
            if (__i != difference_type(0))
                _IterOps<_AlgPolicy>::iter_swap(__first, __first + __i);
        }
    }
    return __original_last;
}
template <class _RandomAccessIterator, class _UniformRandomNumberGenerator>
// added by concept-synth, original LN: 19316
requires
requires (_RandomAccessIterator x0) { ++x0; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void
shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last, _UniformRandomNumberGenerator&& __g) {
  (void)std::__shuffle<_ClassicAlgPolicy>(
      std::move(__first), std::move(__last), std::forward<_UniformRandomNumberGenerator>(__g));
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __shuffle {
struct __fn {
  template <random_access_iterator _Iter, sentinel_for<_Iter> _Sent, class _Gen>
  requires permutable<_Iter> && uniform_random_bit_generator<remove_reference_t<_Gen>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  _Iter operator()(_Iter __first, _Sent __last, _Gen&& __gen) const {
    _ClassicGenAdaptor<_Gen> __adapted_gen(__gen);
    return std::__shuffle<_RangeAlgPolicy>(std::move(__first), std::move(__last), __adapted_gen);
  }
  template<random_access_range _Range, class _Gen>
  requires permutable<iterator_t<_Range>> && uniform_random_bit_generator<remove_reference_t<_Gen>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  borrowed_iterator_t<_Range> operator()(_Range&& __range, _Gen&& __gen) const {
    return (*this)(ranges::begin(__range), ranges::end(__range), std::forward<_Gen>(__gen));
  }
};
}
inline namespace __cpo {
  inline constexpr auto shuffle = __shuffle::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __sort {
struct __fn {
  template <class _Iter, class _Sent, class _Comp, class _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr static
  _Iter __sort_fn_impl(_Iter __first, _Sent __last, _Comp& __comp, _Proj& __proj) {
    auto __last_iter = ranges::next(__first, __last);
    auto&& __projected_comp = std::__make_projected(__comp, __proj);
    std::__sort_impl<_RangeAlgPolicy>(std::move(__first), __last_iter, __projected_comp);
    return __last_iter;
  }
  template <random_access_iterator _Iter, sentinel_for<_Iter> _Sent, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<_Iter, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  _Iter operator()(_Iter __first, _Sent __last, _Comp __comp = {}, _Proj __proj = {}) const {
    return __sort_fn_impl(std::move(__first), std::move(__last), __comp, __proj);
  }
  template <random_access_range _Range, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<iterator_t<_Range>, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  borrowed_iterator_t<_Range> operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const {
    return __sort_fn_impl(ranges::begin(__r), ranges::end(__r), __comp, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto sort = __sort::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __sort_heap {
struct __fn {
  template <class _Iter, class _Sent, class _Comp, class _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr static
  _Iter __sort_heap_fn_impl(_Iter __first, _Sent __last, _Comp& __comp, _Proj& __proj) {
    auto __last_iter = ranges::next(__first, __last);
    auto&& __projected_comp = std::__make_projected(__comp, __proj);
    std::__sort_heap<_RangeAlgPolicy>(std::move(__first), __last_iter, __projected_comp);
    return __last_iter;
  }
  template <random_access_iterator _Iter, sentinel_for<_Iter> _Sent, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<_Iter, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  _Iter operator()(_Iter __first, _Sent __last, _Comp __comp = {}, _Proj __proj = {}) const {
    return __sort_heap_fn_impl(std::move(__first), std::move(__last), __comp, __proj);
  }
  template <random_access_range _Range, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<iterator_t<_Range>, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  borrowed_iterator_t<_Range> operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const {
    return __sort_heap_fn_impl(ranges::begin(__r), ranges::end(__r), __comp, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto sort_heap = __sort_heap::__fn{};
}
}
}}
namespace std { inline namespace __1 {
template <class _AlgPolicy, class _Predicate, class _ForwardIterator, class _Distance, class _Pair>
// added by concept-synth, original LN: 19410
requires
(
 requires (_Distance x0) { --x0; } &&
 requires (_Distance x0, int x1) { x0 / x1; }
) &&
(
 (
  (
   requires (_ForwardIterator x0) { ++x0; } &&
   requires (_ForwardIterator x0) { *x0; }
  ) ||
  (
   requires (_ForwardIterator x0) { *x0; } &&
   requires (_ForwardIterator x0) { ++x0; }
  ) ||
  (
   requires (_ForwardIterator x0) { *x0; } &&
   requires (_ForwardIterator x0) { ++x0; } &&
   requires (_ForwardIterator x0) { --x0; }
  )
 ) &&
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
) &&
requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
(
 requires (_Pair o) { o.first; } &&
 requires (_Pair o) { o.second; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) _ForwardIterator
__stable_partition_impl(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,
                   _Distance __len, _Pair __p, forward_iterator_tag __fit)
{
    using _Ops = _IterOps<_AlgPolicy>;
    if (__len == 1)
        return __first;
    if (__len == 2)
    {
        _ForwardIterator __m = __first;
        if (__pred(*++__m))
        {
            _Ops::iter_swap(__first, __m);
            return __m;
        }
        return __first;
    }
    if (__len <= __p.second)
    {
        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);
        value_type* __t = __p.first;
        ::new ((void*)__t) value_type(_Ops::__iter_move(__first));
        __d.template __incr<value_type>();
        ++__t;
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__i))
            {
                *__first = _Ops::__iter_move(__i);
                ++__first;
            }
            else
            {
                ::new ((void*)__t) value_type(_Ops::__iter_move(__i));
                __d.template __incr<value_type>();
                ++__t;
            }
        }
        __i = __first;
        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, (void) ++__i)
            *__i = _Ops::__iter_move(__t2);
        return __first;
    }
    _ForwardIterator __m = __first;
    _Distance __len2 = __len / 2;
    _Ops::advance(__m, __len2);
    _ForwardIterator __first_false = std::__stable_partition_impl<_AlgPolicy, _Predicate&>(
        __first, __m, __pred, __len2, __p, __fit);
    _ForwardIterator __m1 = __m;
    _ForwardIterator __second_false = __last;
    _Distance __len_half = __len - __len2;
    while (__pred(*__m1))
    {
        if (++__m1 == __last)
            goto __second_half_done;
        --__len_half;
    }
    __second_false = std::__stable_partition_impl<_AlgPolicy, _Predicate&>(
        __m1, __last, __pred, __len_half, __p, __fit);
__second_half_done:
    return std::__rotate<_AlgPolicy>(__first_false, __m, __second_false).first;
}
template <class _AlgPolicy, class _Predicate, class _ForwardIterator>
// added by concept-synth, original LN: 19476
requires
(
 (
  (
   requires (_ForwardIterator x0) { ++x0; } &&
   requires (_ForwardIterator x0) { *x0; }
  ) ||
  (
   requires (_ForwardIterator x0) { *x0; } &&
   requires (_ForwardIterator x0) { ++x0; }
  ) ||
  (
   requires (_ForwardIterator x0) { *x0; } &&
   requires (_ForwardIterator x0) { ++x0; } &&
   requires (_ForwardIterator x0) { --x0; }
  )
 ) &&
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
) &&
(
 requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
 requires (_Predicate f, _ForwardIterator x0) { f(*x0); }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) _ForwardIterator
__stable_partition_impl(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,
                   forward_iterator_tag)
{
    const unsigned __alloc_limit = 3;
    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }
    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
    difference_type __len = _IterOps<_AlgPolicy>::distance(__first, __last);
    pair<value_type*, ptrdiff_t> __p(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len >= __alloc_limit)
    {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
        __p = std::get_temporary_buffer<value_type>(__len);
#pragma GCC diagnostic pop
        __h.reset(__p.first);
    }
    return std::__stable_partition_impl<_AlgPolicy, _Predicate&>(
        std::move(__first), std::move(__last), __pred, __len, __p, forward_iterator_tag());
}
template <class _AlgPolicy, class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>
// added by concept-synth, original LN: 19507
requires
(
 requires (_Distance x0) { --x0; } &&
 requires (_Distance x0, int x1) { x0 / x1; }
) &&
requires (_Predicate f, _BidirectionalIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
(
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { --x0; } &&
 (
  (
   requires (_BidirectionalIterator x0) { ++x0; } &&
   requires (_BidirectionalIterator x0) { *x0; }
  ) ||
  (
   requires (_BidirectionalIterator x0) { *x0; } &&
   requires (_BidirectionalIterator x0) { ++x0; }
  ) ||
  (
   requires (_BidirectionalIterator x0) { *x0; } &&
   requires (_BidirectionalIterator x0) { ++x0; } &&
   requires (_BidirectionalIterator x0) { --x0; }
  )
 ) &&
 requires (_BidirectionalIterator x0) { *x0; }
) &&
(
 requires (_Pair o) { o.first; } &&
 requires (_Pair o) { o.second; }
)
_BidirectionalIterator
__stable_partition_impl(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
                   _Distance __len, _Pair __p, bidirectional_iterator_tag __bit)
{
    using _Ops = _IterOps<_AlgPolicy>;
    if (__len == 2)
    {
        _Ops::iter_swap(__first, __last);
        return __last;
    }
    if (__len == 3)
    {
        _BidirectionalIterator __m = __first;
        if (__pred(*++__m))
        {
            _Ops::iter_swap(__first, __m);
            _Ops::iter_swap(__m, __last);
            return __last;
        }
        _Ops::iter_swap(__m, __last);
        _Ops::iter_swap(__first, __m);
        return __m;
    }
    if (__len <= __p.second)
    {
        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);
        value_type* __t = __p.first;
        ::new ((void*)__t) value_type(_Ops::__iter_move(__first));
        __d.template __incr<value_type>();
        ++__t;
        _BidirectionalIterator __i = __first;
        while (++__i != __last)
        {
            if (__pred(*__i))
            {
                *__first = _Ops::__iter_move(__i);
                ++__first;
            }
            else
            {
                ::new ((void*)__t) value_type(_Ops::__iter_move(__i));
                __d.template __incr<value_type>();
                ++__t;
            }
        }
        *__first = _Ops::__iter_move(__i);
        __i = ++__first;
        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, (void) ++__i)
            *__i = _Ops::__iter_move(__t2);
        return __first;
    }
    _BidirectionalIterator __m = __first;
    _Distance __len2 = __len / 2;
    _Ops::advance(__m, __len2);
    _BidirectionalIterator __m1 = __m;
    _BidirectionalIterator __first_false = __first;
    _Distance __len_half = __len2;
    while (!__pred(*--__m1))
    {
        if (__m1 == __first)
            goto __first_half_done;
        --__len_half;
    }
    __first_false = std::__stable_partition_impl<_AlgPolicy, _Predicate&>(
        __first, __m1, __pred, __len_half, __p, __bit);
__first_half_done:
    __m1 = __m;
    _BidirectionalIterator __second_false = __last;
    ++__second_false;
    __len_half = __len - __len2;
    while (__pred(*__m1))
    {
        if (++__m1 == __last)
            goto __second_half_done;
        --__len_half;
    }
    __second_false = std::__stable_partition_impl<_AlgPolicy, _Predicate&>(
        __m1, __last, __pred, __len_half, __p, __bit);
__second_half_done:
    return std::__rotate<_AlgPolicy>(__first_false, __m, __second_false).first;
}
template <class _AlgPolicy, class _Predicate, class _BidirectionalIterator>
// added by concept-synth, original LN: 19591
requires
(
 requires (_Predicate f, _BidirectionalIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
 requires (_Predicate f, _BidirectionalIterator x0) { f(*x0); }
) &&
(
 (
  (
   (
    (
     requires (_BidirectionalIterator x0) { ++x0; } &&
     requires (_BidirectionalIterator x0) { *x0; }
    ) ||
    (
     requires (_BidirectionalIterator x0) { *x0; } &&
     requires (_BidirectionalIterator x0) { ++x0; }
    ) ||
    (
     requires (_BidirectionalIterator x0) { *x0; } &&
     requires (_BidirectionalIterator x0) { ++x0; } &&
     requires (_BidirectionalIterator x0) { --x0; }
    )
   ) &&
   requires (_BidirectionalIterator x0) { *x0; } &&
   requires (_BidirectionalIterator x0) { ++x0; }
  ) ||
  (
   requires (_BidirectionalIterator x0) { ++x0; } &&
   requires (_BidirectionalIterator x0) { --x0; } &&
   (
    (
     requires (_BidirectionalIterator x0) { ++x0; } &&
     requires (_BidirectionalIterator x0) { *x0; }
    ) ||
    (
     requires (_BidirectionalIterator x0) { *x0; } &&
     requires (_BidirectionalIterator x0) { ++x0; }
    ) ||
    (
     requires (_BidirectionalIterator x0) { *x0; } &&
     requires (_BidirectionalIterator x0) { ++x0; } &&
     requires (_BidirectionalIterator x0) { --x0; }
    )
   ) &&
   requires (_BidirectionalIterator x0) { *x0; }
  )
 ) &&
 requires (_BidirectionalIterator x0) { --x0; } &&
 requires (_BidirectionalIterator x0) { ++x0; } &&
 requires (_BidirectionalIterator x0) { *x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) _BidirectionalIterator
__stable_partition_impl(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,
                   bidirectional_iterator_tag)
{
    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;
    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    const difference_type __alloc_limit = 4;
    while (true)
    {
        if (__first == __last)
            return __first;
        if (!__pred(*__first))
            break;
        ++__first;
    }
    do
    {
        if (__first == --__last)
            return __first;
    } while (!__pred(*__last));
    difference_type __len = _IterOps<_AlgPolicy>::distance(__first, __last) + 1;
    pair<value_type*, ptrdiff_t> __p(0, 0);
    unique_ptr<value_type, __return_temporary_buffer> __h;
    if (__len >= __alloc_limit)
    {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
        __p = std::get_temporary_buffer<value_type>(__len);
#pragma GCC diagnostic pop
        __h.reset(__p.first);
    }
    return std::__stable_partition_impl<_AlgPolicy, _Predicate&>(
        std::move(__first), std::move(__last), __pred, __len, __p, bidirectional_iterator_tag());
}
template <class _AlgPolicy, class _Predicate, class _ForwardIterator, class _IterCategory>
// added by concept-synth, original LN: 19627
requires
(
 requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
 requires (_Predicate f, _ForwardIterator x0) { f(*x0); }
) &&
(
 (
  (
   (
    requires (_ForwardIterator x0) { ++x0; } &&
    requires (_ForwardIterator x0) { *x0; }
   ) ||
   (
    requires (_ForwardIterator x0) { *x0; } &&
    requires (_ForwardIterator x0) { ++x0; }
   ) ||
   (
    requires (_ForwardIterator x0) { *x0; } &&
    requires (_ForwardIterator x0) { ++x0; } &&
    requires (_ForwardIterator x0) { --x0; }
   )
  ) &&
  requires (_ForwardIterator x0) { *x0; } &&
  requires (_ForwardIterator x0) { ++x0; }
 ) ||
 (
  (
   (
    (
     (
      requires (_ForwardIterator x0) { ++x0; } &&
      requires (_ForwardIterator x0) { *x0; }
     ) ||
     (
      requires (_ForwardIterator x0) { *x0; } &&
      requires (_ForwardIterator x0) { ++x0; }
     ) ||
     (
      requires (_ForwardIterator x0) { *x0; } &&
      requires (_ForwardIterator x0) { ++x0; } &&
      requires (_ForwardIterator x0) { --x0; }
     )
    ) &&
    requires (_ForwardIterator x0) { *x0; } &&
    requires (_ForwardIterator x0) { ++x0; }
   ) ||
   (
    requires (_ForwardIterator x0) { ++x0; } &&
    requires (_ForwardIterator x0) { --x0; } &&
    (
     (
      requires (_ForwardIterator x0) { ++x0; } &&
      requires (_ForwardIterator x0) { *x0; }
     ) ||
     (
      requires (_ForwardIterator x0) { *x0; } &&
      requires (_ForwardIterator x0) { ++x0; }
     ) ||
     (
      requires (_ForwardIterator x0) { *x0; } &&
      requires (_ForwardIterator x0) { ++x0; } &&
      requires (_ForwardIterator x0) { --x0; }
     )
    ) &&
    requires (_ForwardIterator x0) { *x0; }
   )
  ) &&
  requires (_ForwardIterator x0) { --x0; } &&
  requires (_ForwardIterator x0) { ++x0; } &&
  requires (_ForwardIterator x0) { *x0; }
 )
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_ForwardIterator __stable_partition(
    _ForwardIterator __first, _ForwardIterator __last, _Predicate&& __pred, _IterCategory __iter_category) {
  return std::__stable_partition_impl<_AlgPolicy, __remove_cvref_t<_Predicate>&>(
      std::move(__first), std::move(__last), __pred, __iter_category);
}
template <class _ForwardIterator, class _Predicate>
// added by concept-synth, original LN: 19634
requires
(
 requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
 requires (_Predicate f, _ForwardIterator x0) { f(*x0); }
) &&
(
 (
  (
   (
    requires (_ForwardIterator x0) { ++x0; } &&
    requires (_ForwardIterator x0) { *x0; }
   ) ||
   (
    requires (_ForwardIterator x0) { *x0; } &&
    requires (_ForwardIterator x0) { ++x0; }
   ) ||
   (
    requires (_ForwardIterator x0) { *x0; } &&
    requires (_ForwardIterator x0) { ++x0; } &&
    requires (_ForwardIterator x0) { --x0; }
   )
  ) &&
  requires (_ForwardIterator x0) { *x0; } &&
  requires (_ForwardIterator x0) { ++x0; }
 ) ||
 (
  (
   (
    (
     (
      requires (_ForwardIterator x0) { ++x0; } &&
      requires (_ForwardIterator x0) { *x0; }
     ) ||
     (
      requires (_ForwardIterator x0) { *x0; } &&
      requires (_ForwardIterator x0) { ++x0; }
     ) ||
     (
      requires (_ForwardIterator x0) { *x0; } &&
      requires (_ForwardIterator x0) { ++x0; } &&
      requires (_ForwardIterator x0) { --x0; }
     )
    ) &&
    requires (_ForwardIterator x0) { *x0; } &&
    requires (_ForwardIterator x0) { ++x0; }
   ) ||
   (
    requires (_ForwardIterator x0) { ++x0; } &&
    requires (_ForwardIterator x0) { --x0; } &&
    (
     (
      requires (_ForwardIterator x0) { ++x0; } &&
      requires (_ForwardIterator x0) { *x0; }
     ) ||
     (
      requires (_ForwardIterator x0) { *x0; } &&
      requires (_ForwardIterator x0) { ++x0; }
     ) ||
     (
      requires (_ForwardIterator x0) { *x0; } &&
      requires (_ForwardIterator x0) { ++x0; } &&
      requires (_ForwardIterator x0) { --x0; }
     )
    ) &&
    requires (_ForwardIterator x0) { *x0; }
   )
  ) &&
  requires (_ForwardIterator x0) { --x0; } &&
  requires (_ForwardIterator x0) { ++x0; } &&
  requires (_ForwardIterator x0) { *x0; }
 )
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_ForwardIterator
stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
  using _IterCategory = typename iterator_traits<_ForwardIterator>::iterator_category;
  return std::__stable_partition<_ClassicAlgPolicy, _Predicate&>(
      std::move(__first), std::move(__last), __pred, _IterCategory());
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __stable_partition {
struct __fn {
  template <class _Iter, class _Sent, class _Proj, class _Pred>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static
  subrange<__remove_cvref_t<_Iter>> __stable_partition_fn_impl(
      _Iter&& __first, _Sent&& __last, _Pred&& __pred, _Proj&& __proj) {
    auto __last_iter = ranges::next(__first, __last);
    auto&& __projected_pred = std::__make_projected(__pred, __proj);
    auto __result = std::__stable_partition<_RangeAlgPolicy>(
        std::move(__first), __last_iter, __projected_pred, __iterator_concept<_Iter>());
    return {std::move(__result), std::move(__last_iter)};
  }
  template <bidirectional_iterator _Iter, sentinel_for<_Iter> _Sent, class _Proj = identity,
            indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
  requires permutable<_Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  subrange<_Iter> operator()(_Iter __first, _Sent __last, _Pred __pred, _Proj __proj = {}) const {
    return __stable_partition_fn_impl(__first, __last, __pred, __proj);
  }
  template <bidirectional_range _Range, class _Proj = identity,
            indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>> _Pred>
  requires permutable<iterator_t<_Range>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  borrowed_subrange_t<_Range> operator()(_Range&& __range, _Pred __pred, _Proj __proj = {}) const {
    return __stable_partition_fn_impl(ranges::begin(__range), ranges::end(__range), __pred, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto stable_partition = __stable_partition::__fn{};
}
}
}}
namespace std { inline namespace __1 {
template <class _AlgPolicy, class _Compare, class _InputIterator1, class _InputIterator2>
// added by concept-synth, original LN: 19680
requires
requires (_Compare f, _InputIterator2 x0, _InputIterator1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
(
 requires (_InputIterator2 x0) { *x0; } &&
 requires (_InputIterator2 x0) { ++x0; }
) &&
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void
__merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        typename iterator_traits<_InputIterator1>::value_type* __result, _Compare __comp)
{
    using _Ops = _IterOps<_AlgPolicy>;
    typedef typename iterator_traits<_InputIterator1>::value_type value_type;
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n&> __h(__result, __d);
    for (; true; ++__result)
    {
        if (__first1 == __last1)
        {
            for (; __first2 != __last2; ++__first2, (void) ++__result, __d.template __incr<value_type>())
                ::new ((void*)__result) value_type(_Ops::__iter_move(__first2));
            __h.release();
            return;
        }
        if (__first2 == __last2)
        {
            for (; __first1 != __last1; ++__first1, (void) ++__result, __d.template __incr<value_type>())
                ::new ((void*)__result) value_type(_Ops::__iter_move(__first1));
            __h.release();
            return;
        }
        if (__comp(*__first2, *__first1))
        {
            ::new ((void*)__result) value_type(_Ops::__iter_move(__first2));
            __d.template __incr<value_type>();
            ++__first2;
        }
        else
        {
            ::new ((void*)__result) value_type(_Ops::__iter_move(__first1));
            __d.template __incr<value_type>();
            ++__first1;
        }
    }
}
template <class _AlgPolicy, class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>
// added by concept-synth, original LN: 19720
requires
requires (_Compare f, _InputIterator2 x0, _InputIterator1 x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
(
 requires (_InputIterator2 x0) { ++x0; } &&
 requires (_InputIterator2 x0) { *x0; }
) &&
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
) &&
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void
__merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result, _Compare __comp)
{
    using _Ops = _IterOps<_AlgPolicy>;
    for (; __first1 != __last1; ++__result)
    {
        if (__first2 == __last2)
        {
            for (; __first1 != __last1; ++__first1, (void) ++__result)
                *__result = _Ops::__iter_move(__first1);
            return;
        }
        if (__comp(*__first2, *__first1))
        {
            *__result = _Ops::__iter_move(__first2);
            ++__first2;
        }
        else
        {
            *__result = _Ops::__iter_move(__first1);
            ++__first1;
        }
    }
    for (; __first2 != __last2; ++__first2, (void) ++__result)
        *__result = _Ops::__iter_move(__first2);
}
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
// added by concept-synth, original LN: 19805
requires
(
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 (
  (
   requires (_RandomAccessIterator x0) { ++x0; } &&
   requires (_RandomAccessIterator x0) { *x0; }
  ) ||
  (
   requires (_RandomAccessIterator x0) { *x0; } &&
   requires (_RandomAccessIterator x0) { ++x0; }
  ) ||
  (
   requires (_RandomAccessIterator x0) { *x0; } &&
   requires (_RandomAccessIterator x0) { ++x0; } &&
   requires (_RandomAccessIterator x0) { --x0; }
  )
 )
) &&
requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
void
__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
              typename iterator_traits<_RandomAccessIterator>::difference_type __len,
              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size);
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
// added by concept-synth, original LN: 19754
requires
requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
(
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; }
)
void
__stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp,
                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,
                   typename iterator_traits<_RandomAccessIterator>::value_type* __first2)
{
    using _Ops = _IterOps<_AlgPolicy>;
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    switch (__len)
    {
    case 0:
        return;
    case 1:
        ::new ((void*)__first2) value_type(_Ops::__iter_move(__first1));
        return;
    case 2:
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h2(__first2, __d);
        if (__comp(*--__last1, *__first1))
        {
            ::new ((void*)__first2) value_type(_Ops::__iter_move(__last1));
            __d.template __incr<value_type>();
            ++__first2;
            ::new ((void*)__first2) value_type(_Ops::__iter_move(__first1));
        }
        else
        {
            ::new ((void*)__first2) value_type(_Ops::__iter_move(__first1));
            __d.template __incr<value_type>();
            ++__first2;
            ::new ((void*)__first2) value_type(_Ops::__iter_move(__last1));
        }
        __h2.release();
        return;
    }
    if (__len <= 8)
    {
        std::__insertion_sort_move<_AlgPolicy, _Compare>(__first1, __last1, __first2, __comp);
        return;
    }
    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
    _RandomAccessIterator __m = __first1 + __l2;
    std::__stable_sort<_AlgPolicy, _Compare>(__first1, __m, __comp, __l2, __first2, __l2);
    std::__stable_sort<_AlgPolicy, _Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);
    std::__merge_move_construct<_AlgPolicy, _Compare>(__first1, __m, __m, __last1, __first2, __comp);
}
template <class _Tp>
struct __stable_sort_switch
{
    static const unsigned value = 128*is_trivially_copy_assignable<_Tp>::value;
};
template <class _AlgPolicy, class _Compare, class _RandomAccessIterator>
// added by concept-synth, original LN: 19805
requires
(
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 (
  (
   requires (_RandomAccessIterator x0) { ++x0; } &&
   requires (_RandomAccessIterator x0) { *x0; }
  ) ||
  (
   requires (_RandomAccessIterator x0) { *x0; } &&
   requires (_RandomAccessIterator x0) { ++x0; }
  ) ||
  (
   requires (_RandomAccessIterator x0) { *x0; } &&
   requires (_RandomAccessIterator x0) { ++x0; } &&
   requires (_RandomAccessIterator x0) { --x0; }
  )
 )
) &&
requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
void
__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,
              typename iterator_traits<_RandomAccessIterator>::difference_type __len,
              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size)
{
    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;
    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;
    switch (__len)
    {
    case 0:
    case 1:
        return;
    case 2:
        if (__comp(*--__last, *__first))
            _IterOps<_AlgPolicy>::iter_swap(__first, __last);
        return;
    }
    if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value))
    {
        std::__insertion_sort<_AlgPolicy, _Compare>(__first, __last, __comp);
        return;
    }
    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;
    _RandomAccessIterator __m = __first + __l2;
    if (__len <= __buff_size)
    {
        __destruct_n __d(0);
        unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);
        std::__stable_sort_move<_AlgPolicy, _Compare>(__first, __m, __comp, __l2, __buff);
        __d.__set(__l2, (value_type*)nullptr);
        std::__stable_sort_move<_AlgPolicy, _Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);
        __d.__set(__len, (value_type*)nullptr);
        std::__merge_move_assign<_AlgPolicy, _Compare>(
            __buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);
        return;
    }
    std::__stable_sort<_AlgPolicy, _Compare>(__first, __m, __comp, __l2, __buff, __buff_size);
    std::__stable_sort<_AlgPolicy, _Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);
    std::__inplace_merge<_AlgPolicy>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);
}
template <class _AlgPolicy, class _RandomAccessIterator, class _Compare>
// added by concept-synth, original LN: 19846
requires
requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; } &&
(
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 (
  (
   requires (_RandomAccessIterator x0) { ++x0; } &&
   requires (_RandomAccessIterator x0) { *x0; }
  ) ||
  (
   requires (_RandomAccessIterator x0) { *x0; } &&
   requires (_RandomAccessIterator x0) { ++x0; }
  ) ||
  (
   requires (_RandomAccessIterator x0) { *x0; } &&
   requires (_RandomAccessIterator x0) { ++x0; } &&
   requires (_RandomAccessIterator x0) { --x0; }
  )
 )
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void __stable_sort_impl(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare& __comp) {
  using value_type = typename iterator_traits<_RandomAccessIterator>::value_type;
  using difference_type = typename iterator_traits<_RandomAccessIterator>::difference_type;
  difference_type __len = __last - __first;
  pair<value_type*, ptrdiff_t> __buf(0, 0);
  unique_ptr<value_type, __return_temporary_buffer> __h;
  if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value)) {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
      __buf = std::get_temporary_buffer<value_type>(__len);
#pragma GCC diagnostic pop
      __h.reset(__buf.first);
  }
  std::__stable_sort<_AlgPolicy, __comp_ref_type<_Compare> >(__first, __last, __comp, __len, __buf.first, __buf.second);
}
template <class _RandomAccessIterator, class _Compare>
// added by concept-synth, original LN: 19864
requires
(
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 (
  (
   requires (_RandomAccessIterator x0) { ++x0; } &&
   requires (_RandomAccessIterator x0) { *x0; }
  ) ||
  (
   requires (_RandomAccessIterator x0) { *x0; } &&
   requires (_RandomAccessIterator x0) { ++x0; }
  ) ||
  (
   requires (_RandomAccessIterator x0) { *x0; } &&
   requires (_RandomAccessIterator x0) { ++x0; } &&
   requires (_RandomAccessIterator x0) { --x0; }
  )
 )
) &&
requires (_Compare f, _RandomAccessIterator x0, _RandomAccessIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) {
  std::__stable_sort_impl<_ClassicAlgPolicy>(std::move(__first), std::move(__last), __comp);
}
template <class _RandomAccessIterator>
// added by concept-synth, original LN: 19869
requires
(
 requires (_RandomAccessIterator x0) { *x0; } &&
 requires (_RandomAccessIterator x0) { ++x0; } &&
 requires (_RandomAccessIterator x0) { --x0; } &&
 (
  (
   requires (_RandomAccessIterator x0) { ++x0; } &&
   requires (_RandomAccessIterator x0) { *x0; }
  ) ||
  (
   requires (_RandomAccessIterator x0) { *x0; } &&
   requires (_RandomAccessIterator x0) { ++x0; }
  ) ||
  (
   requires (_RandomAccessIterator x0) { *x0; } &&
   requires (_RandomAccessIterator x0) { ++x0; } &&
   requires (_RandomAccessIterator x0) { --x0; }
  )
 )
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last) {
  std::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __stable_sort {
struct __fn {
  template <class _Iter, class _Sent, class _Comp, class _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  static _Iter __stable_sort_fn_impl(_Iter __first, _Sent __last, _Comp& __comp, _Proj& __proj) {
    auto __last_iter = ranges::next(__first, __last);
    auto&& __projected_comp = std::__make_projected(__comp, __proj);
    std::__stable_sort_impl<_RangeAlgPolicy>(std::move(__first), __last_iter, __projected_comp);
    return __last_iter;
  }
  template <random_access_iterator _Iter, sentinel_for<_Iter> _Sent, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<_Iter, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  _Iter operator()(_Iter __first, _Sent __last, _Comp __comp = {}, _Proj __proj = {}) const {
    return __stable_sort_fn_impl(std::move(__first), std::move(__last), __comp, __proj);
  }
  template <random_access_range _Range, class _Comp = ranges::less, class _Proj = identity>
    requires sortable<iterator_t<_Range>, _Comp, _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  borrowed_iterator_t<_Range> operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const {
    return __stable_sort_fn_impl(ranges::begin(__r), ranges::end(__r), __comp, __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto stable_sort = __stable_sort::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _I1, class _I2>
using swap_ranges_result = in_in_result<_I1, _I2>;
namespace __swap_ranges {
struct __fn {
  template <input_iterator _I1, sentinel_for<_I1> _S1,
            input_iterator _I2, sentinel_for<_I2> _S2>
    requires indirectly_swappable<_I1, _I2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr swap_ranges_result<_I1, _I2>
  operator()(_I1 __first1, _S1 __last1, _I2 __first2, _S2 __last2) const {
    auto __ret = std::__swap_ranges<_RangeAlgPolicy>(
        std::move(__first1), std::move(__last1), std::move(__first2), std::move(__last2));
    return {std::move(__ret.first), std::move(__ret.second)};
  }
  template <input_range _R1, input_range _R2>
    requires indirectly_swappable<iterator_t<_R1>, iterator_t<_R2>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  swap_ranges_result<borrowed_iterator_t<_R1>, borrowed_iterator_t<_R2>>
  operator()(_R1&& __r1, _R2&& __r2) const {
    return operator()(ranges::begin(__r1), ranges::end(__r1),
                      ranges::begin(__r2), ranges::end(__r2));
  }
};
}
inline namespace __cpo {
  inline constexpr auto swap_ranges = __swap_ranges::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _Ip, class _Op>
using unary_transform_result = in_out_result<_Ip, _Op>;
template <class _I1, class _I2, class _O1>
using binary_transform_result = in_in_out_result<_I1, _I2, _O1>;
namespace __transform {
struct __fn {
private:
  template <class _InIter, class _Sent,
            class _OutIter,
            class _Func,
            class _Proj>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr
  unary_transform_result<_InIter, _OutIter> __unary(_InIter __first, _Sent __last,
                                                    _OutIter __result,
                                                    _Func& __operation,
                                                    _Proj& __projection) {
    while (__first != __last) {
      *__result = std::invoke(__operation, std::invoke(__projection, *__first));
      ++__first;
      ++__result;
    }
    return {std::move(__first), std::move(__result)};
  }
  template <class _InIter1, class _Sent1,
            class _InIter2, class _Sent2,
            class _OutIter,
            class _Func,
            class _Proj1,
            class _Proj2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr binary_transform_result<_InIter1, _InIter2, _OutIter>
  __binary(_InIter1 __first1, _Sent1 __last1,
           _InIter2 __first2, _Sent2 __last2,
           _OutIter __result,
           _Func& __binary_operation,
           _Proj1& __projection1,
           _Proj2& __projection2) {
    while (__first1 != __last1 && __first2 != __last2) {
      *__result = std::invoke(__binary_operation, std::invoke(__projection1, *__first1),
                                                  std::invoke(__projection2, *__first2));
      ++__first1;
      ++__first2;
      ++__result;
    }
    return {std::move(__first1), std::move(__first2), std::move(__result)};
  }
public:
  template <input_iterator _InIter, sentinel_for<_InIter> _Sent,
            weakly_incrementable _OutIter,
            copy_constructible _Func,
            class _Proj = identity>
    requires indirectly_writable<_OutIter, indirect_result_t<_Func&, projected<_InIter, _Proj>>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  unary_transform_result<_InIter, _OutIter> operator()(_InIter __first, _Sent __last,
                                                       _OutIter __result,
                                                       _Func __operation,
                                                       _Proj __proj = {}) const {
    return __unary(std::move(__first), std::move(__last), std::move(__result), __operation, __proj);
  }
  template <input_range _Range,
            weakly_incrementable _OutIter,
            copy_constructible _Func,
            class _Proj = identity>
    requires indirectly_writable<_OutIter, indirect_result_t<_Func, projected<iterator_t<_Range>, _Proj>>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  unary_transform_result<borrowed_iterator_t<_Range>, _OutIter> operator()(_Range&& __range,
                                                                           _OutIter __result,
                                                                           _Func __operation,
                                                                           _Proj __projection = {}) const {
    return __unary(ranges::begin(__range), ranges::end(__range), std::move(__result), __operation, __projection);
  }
  template <input_iterator _InIter1, sentinel_for<_InIter1> _Sent1,
            input_iterator _InIter2, sentinel_for<_InIter2> _Sent2,
            weakly_incrementable _OutIter,
            copy_constructible _Func,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires indirectly_writable<_OutIter, indirect_result_t<_Func&, projected<_InIter1, _Proj1>,
                                                                     projected<_InIter2, _Proj2>>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  binary_transform_result<_InIter1, _InIter2, _OutIter> operator()(_InIter1 __first1, _Sent1 __last1,
                                                                   _InIter2 __first2, _Sent2 __last2,
                                                                   _OutIter __result,
                                                                   _Func __binary_operation,
                                                                   _Proj1 __projection1 = {},
                                                                   _Proj2 __projection2 = {}) const {
    return __binary(std::move(__first1), std::move(__last1),
                    std::move(__first2), std::move(__last2),
                    std::move(__result),
                    __binary_operation,
                    __projection1,
                    __projection2);
  }
  template <input_range _Range1,
            input_range _Range2,
            weakly_incrementable _OutIter,
            copy_constructible _Func,
            class _Proj1 = identity,
            class _Proj2 = identity>
    requires indirectly_writable<_OutIter, indirect_result_t<_Func&, projected<iterator_t<_Range1>, _Proj1>,
                                                                     projected<iterator_t<_Range2>, _Proj2>>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  binary_transform_result<borrowed_iterator_t<_Range1>, borrowed_iterator_t<_Range2>, _OutIter>
  operator()(_Range1&& __range1,
             _Range2&& __range2,
             _OutIter __result,
             _Func __binary_operation,
             _Proj1 __projection1 = {},
             _Proj2 __projection2 = {}) const {
    return __binary(ranges::begin(__range1), ranges::end(__range1),
                    ranges::begin(__range2), ranges::end(__range2),
                    std::move(__result),
                    __binary_operation,
                    __projection1,
                    __projection2);
  }
};
}
inline namespace __cpo {
  inline constexpr auto transform = __transform::__fn{};
}
}
}}
namespace std { inline namespace __1 {
template <class _AlgPolicy, class _Iter, class _Sent, class _BinaryPredicate>
// added by concept-synth, original LN: 20061
requires
(
 requires (_Sent x0, _Iter x1) { ++x1 != x0; } &&
 requires (_Sent x0, _Iter x1) { x1 == x0; }
) &&
(
 requires (_BinaryPredicate f, _Iter x0, _Iter x1) { f(*x0, *x1); } &&
 requires (_BinaryPredicate f, _Iter x0, _Iter x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
) &&
(
 requires (_Iter x0) { *x0; } &&
 requires (_Iter x0) { ++x0; } &&
 requires (_Iter x0, _Sent x1) { x0 == x1; }
)
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr std::pair<_Iter, _Iter>
__unique(_Iter __first, _Sent __last, _BinaryPredicate&& __pred) {
  __first = std::__adjacent_find(__first, __last, __pred);
  if (__first != __last) {
    _Iter __i = __first;
    for (++__i; ++__i != __last;)
      if (!__pred(*__first, *__i))
        *++__first = _IterOps<_AlgPolicy>::__iter_move(__i);
    ++__first;
    return std::pair<_Iter, _Iter>(std::move(__first), std::move(__i));
  }
  return std::pair<_Iter, _Iter>(__first, __first);
}
template <class _ForwardIterator, class _BinaryPredicate>
// added by concept-synth, original LN: 20075
requires
(
 requires (_ForwardIterator x0, _ForwardIterator x1) { ++x1 != x0; } &&
 requires (_ForwardIterator x0, _ForwardIterator x1) { x1 == x0; } &&
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0, _ForwardIterator x1) { x0 == x1; }
) &&
(
 requires (_BinaryPredicate f, _ForwardIterator x0, _ForwardIterator x1) { f(*x0, *x1); } &&
 requires (_BinaryPredicate f, _ForwardIterator x0, _ForwardIterator x1) { {f(*x0, *x1)} -> std::convertible_to<bool>; }
)
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _ForwardIterator
unique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred) {
  return std::__unique<_ClassicAlgPolicy>(std::move(__first), std::move(__last), __pred).first;
}
template <class _ForwardIterator>
// added by concept-synth, original LN: 20080
requires
(
 requires (_ForwardIterator x0, _ForwardIterator x1) { ++x1 != x0; } &&
 requires (_ForwardIterator x0, _ForwardIterator x1) { x1 == x0; } &&
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0, _ForwardIterator x1) { x0 == x1; }
)
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _ForwardIterator
unique(_ForwardIterator __first, _ForwardIterator __last) {
  return std::unique(__first, __last, __equal_to());
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __unique {
  struct __fn {
    template <
        permutable _Iter,
        sentinel_for<_Iter> _Sent,
        class _Proj = identity,
        indirect_equivalence_relation<projected<_Iter, _Proj>> _Comp = ranges::equal_to>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr subrange<_Iter>
    operator()(_Iter __first, _Sent __last, _Comp __comp = {}, _Proj __proj = {}) const {
      auto __ret = std::__unique<_RangeAlgPolicy>(
          std::move(__first), std::move(__last), std::__make_projected(__comp, __proj));
      return {std::move(__ret.first), std::move(__ret.second)};
    }
    template <
        forward_range _Range,
        class _Proj = identity,
        indirect_equivalence_relation<projected<iterator_t<_Range>, _Proj>> _Comp = ranges::equal_to>
      requires permutable<iterator_t<_Range>>
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr borrowed_subrange_t<_Range>
    operator()(_Range&& __range, _Comp __comp = {}, _Proj __proj = {}) const {
      auto __ret = std::__unique<_RangeAlgPolicy>(
          ranges::begin(__range), ranges::end(__range), std::__make_projected(__comp, __proj));
      return {std::move(__ret.first), std::move(__ret.second)};
    }
  };
}
inline namespace __cpo {
  inline constexpr auto unique = __unique::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace __unique_copy_tags {
struct __reread_from_input_tag {};
struct __reread_from_output_tag {};
struct __read_from_tmp_value_tag {};
}
template <class _AlgPolicy, class _BinaryPredicate, class _InputIterator, class _Sent, class _OutputIterator>
// added by concept-synth, original LN: 20125
requires
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
) &&
(
 requires (_InputIterator x0) { ++x0; } &&
 requires (_InputIterator x0) { *x0; }
)
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) pair<_InputIterator, _OutputIterator>
__unique_copy(_InputIterator __first,
              _Sent __last,
              _OutputIterator __result,
              _BinaryPredicate&& __pred,
              __unique_copy_tags::__read_from_tmp_value_tag) {
  if (__first != __last) {
    typename _IterOps<_AlgPolicy>::template __value_type<_InputIterator> __t(*__first);
    *__result = __t;
    ++__result;
    while (++__first != __last) {
      if (!__pred(__t, *__first)) {
        __t = *__first;
        *__result = __t;
        ++__result;
      }
    }
  }
  return pair<_InputIterator, _OutputIterator>(std::move(__first), std::move(__result));
}
template <class _AlgPolicy, class _BinaryPredicate, class _ForwardIterator, class _Sent, class _OutputIterator>
// added by concept-synth, original LN: 20146
requires
(
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0) { *x0; }
) &&
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
) &&
requires (_BinaryPredicate f, _ForwardIterator x0, _ForwardIterator x1) { f(*x0, *x1); }
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) pair<_ForwardIterator, _OutputIterator>
__unique_copy(_ForwardIterator __first,
              _Sent __last,
              _OutputIterator __result,
              _BinaryPredicate&& __pred,
              __unique_copy_tags::__reread_from_input_tag) {
  if (__first != __last) {
    _ForwardIterator __i = __first;
    *__result = *__i;
    ++__result;
    while (++__first != __last) {
      if (!__pred(*__i, *__first)) {
        *__result = *__first;
        ++__result;
        __i = __first;
      }
    }
  }
  return pair<_ForwardIterator, _OutputIterator>(std::move(__first), std::move(__result));
}
template <class _AlgPolicy, class _BinaryPredicate, class _InputIterator, class _Sent, class _InputAndOutputIterator>
// added by concept-synth, original LN: 20167
requires
(
 requires (_InputIterator x0) { ++x0; } &&
 requires (_InputIterator x0) { *x0; }
) &&
(
 requires (_InputAndOutputIterator x0) { ++x0; } &&
 requires (_InputAndOutputIterator x0) { *x0; }
) &&
requires (_BinaryPredicate f, _InputAndOutputIterator x0, _InputIterator x1) { f(*x0, *x1); }
constexpr __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) pair<_InputIterator, _InputAndOutputIterator>
__unique_copy(_InputIterator __first,
              _Sent __last,
              _InputAndOutputIterator __result,
              _BinaryPredicate&& __pred,
              __unique_copy_tags::__reread_from_output_tag) {
  if (__first != __last) {
    *__result = *__first;
    while (++__first != __last)
      if (!__pred(*__result, *__first))
        *++__result = *__first;
    ++__result;
  }
  return pair<_InputIterator, _InputAndOutputIterator>(std::move(__first), std::move(__result));
}
template <class _InputIterator, class _OutputIterator, class _BinaryPredicate>
// added by concept-synth, original LN: 20183
requires
(
 requires (_InputIterator x0) { ++x0; } &&
 requires (_InputIterator x0) { *x0; }
) &&
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _OutputIterator
unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred) {
  using __algo_tag = __conditional_t<
      is_base_of<forward_iterator_tag, typename iterator_traits<_InputIterator>::iterator_category>::value,
      __unique_copy_tags::__reread_from_input_tag,
      __conditional_t<
          is_base_of<forward_iterator_tag, typename iterator_traits<_OutputIterator>::iterator_category>::value &&
              is_same< typename iterator_traits<_InputIterator>::value_type,
                       typename iterator_traits<_OutputIterator>::value_type>::value,
          __unique_copy_tags::__reread_from_output_tag,
          __unique_copy_tags::__read_from_tmp_value_tag> >;
  return std::__unique_copy<_ClassicAlgPolicy>(
             std::move(__first), std::move(__last), std::move(__result), __pred, __algo_tag())
      .second;
}
template <class _InputIterator, class _OutputIterator>
// added by concept-synth, original LN: 20199
requires
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
) &&
(
 requires (_InputIterator x0) { ++x0; } &&
 requires (_InputIterator x0) { *x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _OutputIterator
unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result) {
  return std::unique_copy(std::move(__first), std::move(__last), std::move(__result), __equal_to());
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _InIter, class _OutIter>
using unique_copy_result = in_out_result<_InIter, _OutIter>;
namespace __unique_copy {
template <class _InIter, class _OutIter>
concept __can_reread_from_output = (input_iterator<_OutIter> && same_as<iter_value_t<_InIter>, iter_value_t<_OutIter>>);
struct __fn {
  template <class _InIter, class _OutIter>
  static consteval auto __get_algo_tag() {
    if constexpr (forward_iterator<_InIter>) {
      return __unique_copy_tags::__reread_from_input_tag{};
    } else if constexpr (__can_reread_from_output<_InIter, _OutIter>) {
      return __unique_copy_tags::__reread_from_output_tag{};
    } else if constexpr (indirectly_copyable_storable<_InIter, _OutIter>) {
      return __unique_copy_tags::__read_from_tmp_value_tag{};
    }
  }
  template <class _InIter, class _OutIter>
  using __algo_tag_t = decltype(__get_algo_tag<_InIter, _OutIter>());
  template <input_iterator _InIter,
            sentinel_for<_InIter> _Sent,
            weakly_incrementable _OutIter,
            class _Proj = identity,
            indirect_equivalence_relation<projected<_InIter, _Proj>> _Comp = ranges::equal_to>
    requires indirectly_copyable<_InIter, _OutIter> &&
             (forward_iterator<_InIter> ||
              (input_iterator<_OutIter> && same_as<iter_value_t<_InIter>, iter_value_t<_OutIter>>) ||
              indirectly_copyable_storable<_InIter, _OutIter>)
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr unique_copy_result<_InIter, _OutIter>
  operator()(_InIter __first, _Sent __last, _OutIter __result, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __ret = std::__unique_copy<_RangeAlgPolicy>(
        std::move(__first),
        std::move(__last),
        std::move(__result),
        std::__make_projected(__comp, __proj),
        __algo_tag_t<_InIter, _OutIter>());
    return {std::move(__ret.first), std::move(__ret.second)};
  }
  template <input_range _Range,
            weakly_incrementable _OutIter,
            class _Proj = identity,
            indirect_equivalence_relation<projected<iterator_t<_Range>, _Proj>> _Comp = ranges::equal_to>
    requires indirectly_copyable<iterator_t<_Range>, _OutIter> &&
      (forward_iterator<iterator_t<_Range>> ||
       (input_iterator<_OutIter> && same_as<range_value_t<_Range>, iter_value_t<_OutIter>>) ||
       indirectly_copyable_storable<iterator_t<_Range>, _OutIter>)
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr unique_copy_result<borrowed_iterator_t<_Range>, _OutIter>
  operator()(_Range&& __range, _OutIter __result, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __ret = std::__unique_copy<_RangeAlgPolicy>(
        ranges::begin(__range),
        ranges::end(__range),
        std::move(__result),
        std::__make_projected(__comp, __proj),
        __algo_tag_t<iterator_t<_Range>, _OutIter>());
    return {std::move(__ret.first), std::move(__ret.second)};
  }
};
}
inline namespace __cpo {
inline constexpr auto unique_copy = __unique_copy::__fn{};
}
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __upper_bound {
struct __fn {
  template <forward_iterator _Iter, sentinel_for<_Iter> _Sent, class _Type, class _Proj = identity,
            indirect_strict_weak_order<const _Type*, projected<_Iter, _Proj>> _Comp = ranges::less>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  _Iter operator()(_Iter __first, _Sent __last, const _Type& __value, _Comp __comp = {}, _Proj __proj = {}) const {
    auto __comp_lhs_rhs_swapped = [&](const auto& __lhs, const auto& __rhs) {
      return !std::invoke(__comp, __rhs, __lhs);
    };
    return std::__lower_bound_impl<_RangeAlgPolicy>(__first, __last, __value, __comp_lhs_rhs_swapped, __proj);
  }
  template <forward_range _Range, class _Type, class _Proj = identity,
            indirect_strict_weak_order<const _Type*, projected<iterator_t<_Range>, _Proj>> _Comp = ranges::less>
  [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  borrowed_iterator_t<_Range> operator()(_Range&& __r,
                                         const _Type& __value,
                                         _Comp __comp = {},
                                         _Proj __proj = {}) const {
    auto __comp_lhs_rhs_swapped = [&](const auto& __lhs, const auto& __rhs) {
      return !std::invoke(__comp, __rhs, __lhs);
    };
    return std::__lower_bound_impl<_RangeAlgPolicy>(ranges::begin(__r),
                                                   ranges::end(__r),
                                                   __value,
                                                   __comp_lhs_rhs_swapped,
                                                   __proj);
  }
};
}
inline namespace __cpo {
  inline constexpr auto upper_bound = __upper_bound::__fn{};
}
}
}}
namespace std { inline namespace __1 {
template <class _ForwardIterator, class _Tp>
// added by concept-synth, original LN: 20306
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _ForwardIterator
remove(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
{
    __first = std::find(__first, __last, __value);
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (!(*__i == __value))
            {
                *__first = std::move(*__i);
                ++__first;
            }
        }
    }
    return __first;
}
}}
namespace std { inline namespace __1 {
template <class _InputIterator, class _OutputIterator, class _Tp>
// added by concept-synth, original LN: 20327
requires
(
 requires (_OutputIterator x0) { ++x0; } &&
 requires (_OutputIterator x0) { *x0; }
) &&
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_OutputIterator
remove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp& __value)
{
    for (; __first != __last; ++__first)
    {
        if (!(*__first == __value))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}
}}

namespace std { inline namespace __1 {
template <class _ForwardIterator, class _Predicate>
// added by concept-synth, original LN: 20345
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
) &&
(
 requires (_Predicate f, _ForwardIterator x0) { f(*x0); } &&
 requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; }
)
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _ForwardIterator
remove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
{
    __first = std::find_if<_ForwardIterator, _Predicate&>(__first, __last, __pred);
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        while (++__i != __last)
        {
            if (!__pred(*__i))
            {
                *__first = std::move(*__i);
                ++__first;
            }
        }
    }
    return __first;
}
}}
namespace std { inline namespace __1 {
template <class _ForwardIterator, class _Tp>
// added by concept-synth, original LN: 20366
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void
replace(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value, const _Tp& __new_value)
{
    for (; __first != __last; ++__first)
        if (*__first == __old_value)
            *__first = __new_value;
}
}}
namespace std { inline namespace __1 {
template <class _InputIterator, class _OutputIterator, class _Tp>
// added by concept-synth, original LN: 20377
requires
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
) &&
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_OutputIterator
replace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
             const _Tp& __old_value, const _Tp& __new_value)
{
    for (; __first != __last; ++__first, (void) ++__result)
        if (*__first == __old_value)
            *__result = __new_value;
        else
            *__result = *__first;
    return __result;
}
}}
namespace std { inline namespace __1 {
template <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp>
// added by concept-synth, original LN: 20392
requires
requires (_Predicate f, _InputIterator x0) { {f(*x0)} -> std::convertible_to<bool>; } &&
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
) &&
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_OutputIterator
replace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
                _Predicate __pred, const _Tp& __new_value)
{
    for (; __first != __last; ++__first, (void) ++__result)
        if (__pred(*__first))
            *__result = __new_value;
        else
            *__result = *__first;
    return __result;
}
}}
namespace std { inline namespace __1 {
template <class _ForwardIterator, class _Predicate, class _Tp>
// added by concept-synth, original LN: 20407
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
) &&
requires (_Predicate f, _ForwardIterator x0) { {f(*x0)} -> std::convertible_to<bool>; }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void
replace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp& __new_value)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            *__first = __new_value;
}
}}

namespace std { inline namespace __1 {
template <class _BidirectionalIterator, class _OutputIterator>
// added by concept-synth, original LN: 20419
requires
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
) &&
requires (_BidirectionalIterator x0) { --x0; }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_OutputIterator
reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)
{
    for (; __first != __last; ++__result)
        *__result = *--__last;
    return __result;
}
}}

namespace std { inline namespace __1 {
template <class _ForwardIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_OutputIterator
rotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)
{
    return std::copy(__first, __middle, std::copy(__middle, __last, __result));
}
}}
namespace std { inline namespace __1 {
template <class _ForwardIterator>
// added by concept-synth, original LN: 20440
requires
requires (_ForwardIterator x0) { ++x0; }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_ForwardIterator
shift_left(_ForwardIterator __first, _ForwardIterator __last,
           typename iterator_traits<_ForwardIterator>::difference_type __n)
{
    if (__n == 0) {
        return __last;
    }
    _ForwardIterator __m = __first;
    if constexpr (__is_cpp17_random_access_iterator<_ForwardIterator>::value) {
        if (__n >= __last - __first) {
            return __first;
        }
        __m += __n;
    } else {
        for (; __n > 0; --__n) {
            if (__m == __last) {
                return __first;
            }
            ++__m;
        }
    }
    return std::move(__m, __last, __first);
}
}}
namespace std { inline namespace __1 {
template <class _ForwardIterator>
// added by concept-synth, original LN: 20467
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; } &&
 requires (_ForwardIterator x0) { --x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_ForwardIterator
shift_right(_ForwardIterator __first, _ForwardIterator __last,
            typename iterator_traits<_ForwardIterator>::difference_type __n)
{
    if (__n == 0) {
        return __first;
    }
    if constexpr (__is_cpp17_random_access_iterator<_ForwardIterator>::value) {
        decltype(__n) __d = __last - __first;
        if (__n >= __d) {
            return __last;
        }
        _ForwardIterator __m = __first + (__d - __n);
        return std::move_backward(__first, __m, __last);
    } else if constexpr (__is_cpp17_bidirectional_iterator<_ForwardIterator>::value) {
        _ForwardIterator __m = __last;
        for (; __n > 0; --__n) {
            if (__m == __first) {
                return __last;
            }
            --__m;
        }
        return std::move_backward(__first, __m, __last);
    } else {
        _ForwardIterator __ret = __first;
        for (; __n > 0; --__n) {
            if (__ret == __last) {
                return __last;
            }
            ++__ret;
        }
        auto __trail = __first;
        auto __lead = __ret;
        while (__trail != __ret) {
            if (__lead == __last) {
                std::move(__first, __trail, __ret);
                return __ret;
            }
            ++__trail;
            ++__lead;
        }
        _ForwardIterator __mid = __first;
        while (true) {
            if (__lead == __last) {
                __trail = std::move(__mid, __ret, __trail);
                std::move(__first, __mid, __trail);
                return __ret;
            }
            swap(*__mid, *__trail);
            ++__mid;
            ++__trail;
            ++__lead;
            if (__mid == __ret) {
                __mid = __first;
            }
        }
    }
}
}}
namespace std { inline namespace __1 {
template <class _InputIterator, class _OutputIterator, class _UnaryOperation>
// added by concept-synth, original LN: 20529
requires
requires (_UnaryOperation f, _InputIterator x0) { f(*x0); } &&
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
) &&
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_OutputIterator
transform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)
{
    for (; __first != __last; ++__first, (void) ++__result)
        *__result = __op(*__first);
    return __result;
}
template <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation>
// added by concept-synth, original LN: 20538
requires
(
 requires (_InputIterator1 x0) { *x0; } &&
 requires (_InputIterator1 x0) { ++x0; }
) &&
requires (_BinaryOperation f, _InputIterator1 x0, _InputIterator2 x1) { f(*x0, *x1); } &&
(
 requires (_InputIterator2 x0) { *x0; } &&
 requires (_InputIterator2 x0) { ++x0; }
) &&
(
 requires (_OutputIterator x0) { *x0; } &&
 requires (_OutputIterator x0) { ++x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_OutputIterator
transform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,
          _OutputIterator __result, _BinaryOperation __binary_op)
{
    for (; __first1 != __last1; ++__first1, (void) ++__first2, ++__result)
        *__result = __binary_op(*__first1, *__first2);
    return __result;
}
}}
namespace std { inline namespace __1 {
template <intmax_t _Xp, intmax_t _Yp>
struct __static_gcd
{
    static const intmax_t value = __static_gcd<_Yp, _Xp % _Yp>::value;
};
template <intmax_t _Xp>
struct __static_gcd<_Xp, 0>
{
    static const intmax_t value = _Xp;
};
template <>
struct __static_gcd<0, 0>
{
    static const intmax_t value = 1;
};
template <intmax_t _Xp, intmax_t _Yp>
struct __static_lcm
{
    static const intmax_t value = _Xp / __static_gcd<_Xp, _Yp>::value * _Yp;
};
template <intmax_t _Xp>
struct __static_abs
{
    static const intmax_t value = _Xp < 0 ? -_Xp : _Xp;
};
template <intmax_t _Xp>
struct __static_sign
{
    static const intmax_t value = _Xp == 0 ? 0 : (_Xp < 0 ? -1 : 1);
};
template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value>
class __ll_add;
template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, 1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;
    static_assert(_Xp <= max - _Yp, "overflow in __ll_add");
public:
    static const intmax_t value = _Xp + _Yp;
};
template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, 0>
{
public:
    static const intmax_t value = _Xp;
};
template <intmax_t _Xp, intmax_t _Yp>
class __ll_add<_Xp, _Yp, -1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;
    static_assert(min - _Yp <= _Xp, "overflow in __ll_add");
public:
    static const intmax_t value = _Xp + _Yp;
};
template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value>
class __ll_sub;
template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, 1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;
    static_assert(min + _Yp <= _Xp, "overflow in __ll_sub");
public:
    static const intmax_t value = _Xp - _Yp;
};
template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, 0>
{
public:
    static const intmax_t value = _Xp;
};
template <intmax_t _Xp, intmax_t _Yp>
class __ll_sub<_Xp, _Yp, -1>
{
    static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
    static const intmax_t max = -min;
    static_assert(_Xp <= max + _Yp, "overflow in __ll_sub");
public:
    static const intmax_t value = _Xp - _Yp;
};
template <intmax_t _Xp, intmax_t _Yp>
class __ll_mul
{
    static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
    static const intmax_t min = nan + 1;
    static const intmax_t max = -min;
    static const intmax_t __a_x = __static_abs<_Xp>::value;
    static const intmax_t __a_y = __static_abs<_Yp>::value;
    static_assert(_Xp != nan && _Yp != nan && __a_x <= max / __a_y, "overflow in __ll_mul");
public:
    static const intmax_t value = _Xp * _Yp;
};
template <intmax_t _Yp>
class __ll_mul<0, _Yp>
{
public:
    static const intmax_t value = 0;
};
template <intmax_t _Xp>
class __ll_mul<_Xp, 0>
{
public:
    static const intmax_t value = 0;
};
template <>
class __ll_mul<0, 0>
{
public:
    static const intmax_t value = 0;
};
template <intmax_t _Xp, intmax_t _Yp>
class __ll_div
{
    static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
    static const intmax_t min = nan + 1;
    static const intmax_t max = -min;
    static_assert(_Xp != nan && _Yp != nan && _Yp != 0, "overflow in __ll_div");
public:
    static const intmax_t value = _Xp / _Yp;
};
template <intmax_t _Num, intmax_t _Den = 1>
class __attribute__((__type_visibility__("default"))) ratio
{
    static_assert(__static_abs<_Num>::value >= 0, "ratio numerator is out of range");
    static_assert(_Den != 0, "ratio divide by 0");
    static_assert(__static_abs<_Den>::value > 0, "ratio denominator is out of range");
    static constexpr const intmax_t __na = __static_abs<_Num>::value;
    static constexpr const intmax_t __da = __static_abs<_Den>::value;
    static constexpr const intmax_t __s = __static_sign<_Num>::value * __static_sign<_Den>::value;
    static constexpr const intmax_t __gcd = __static_gcd<__na, __da>::value;
public:
    static constexpr const intmax_t num = __s * __na / __gcd;
    static constexpr const intmax_t den = __da / __gcd;
    typedef ratio<num, den> type;
};
template <intmax_t _Num, intmax_t _Den>
constexpr const intmax_t ratio<_Num, _Den>::num;
template <intmax_t _Num, intmax_t _Den>
constexpr const intmax_t ratio<_Num, _Den>::den;
template <class _Tp> struct __is_ratio : false_type {};
template <intmax_t _Num, intmax_t _Den> struct __is_ratio<ratio<_Num, _Den> > : true_type {};
typedef ratio<1LL, 1000000000000000000LL> atto;
typedef ratio<1LL, 1000000000000000LL> femto;
typedef ratio<1LL, 1000000000000LL> pico;
typedef ratio<1LL, 1000000000LL> nano;
typedef ratio<1LL, 1000000LL> micro;
typedef ratio<1LL, 1000LL> milli;
typedef ratio<1LL, 100LL> centi;
typedef ratio<1LL, 10LL> deci;
typedef ratio< 10LL, 1LL> deca;
typedef ratio< 100LL, 1LL> hecto;
typedef ratio< 1000LL, 1LL> kilo;
typedef ratio< 1000000LL, 1LL> mega;
typedef ratio< 1000000000LL, 1LL> giga;
typedef ratio< 1000000000000LL, 1LL> tera;
typedef ratio< 1000000000000000LL, 1LL> peta;
typedef ratio<1000000000000000000LL, 1LL> exa;
template <class _R1, class _R2>
struct __ratio_multiply
{
private:
    static const intmax_t __gcd_n1_d2 = __static_gcd<_R1::num, _R2::den>::value;
    static const intmax_t __gcd_d1_n2 = __static_gcd<_R1::den, _R2::num>::value;
public:
    typedef typename ratio
        <
            __ll_mul<_R1::num / __gcd_n1_d2, _R2::num / __gcd_d1_n2>::value,
            __ll_mul<_R2::den / __gcd_n1_d2, _R1::den / __gcd_d1_n2>::value
        >::type type;
};
template <class _R1, class _R2> using ratio_multiply
                                    = typename __ratio_multiply<_R1, _R2>::type;
template <class _R1, class _R2>
struct __ratio_divide
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
public:
    typedef typename ratio
        <
            __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
            __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
        >::type type;
};
template <class _R1, class _R2> using ratio_divide
                                      = typename __ratio_divide<_R1, _R2>::type;
template <class _R1, class _R2>
struct __ratio_add
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
public:
    typedef typename ratio_multiply
        <
            ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>,
            ratio
            <
                __ll_add
                <
                    __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
                    __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
                >::value,
                _R2::den
            >
        >::type type;
};
template <class _R1, class _R2> using ratio_add
                                         = typename __ratio_add<_R1, _R2>::type;
template <class _R1, class _R2>
struct __ratio_subtract
{
private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
public:
    typedef typename ratio_multiply
        <
            ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>,
            ratio
            <
                __ll_sub
                <
                    __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
                    __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value
                >::value,
                _R2::den
            >
        >::type type;
};
template <class _R1, class _R2> using ratio_subtract
                                    = typename __ratio_subtract<_R1, _R2>::type;
template <class _R1, class _R2>
struct __attribute__((__type_visibility__("default"))) ratio_equal
    : _BoolConstant<(_R1::num == _R2::num && _R1::den == _R2::den)> {};
template <class _R1, class _R2>
struct __attribute__((__type_visibility__("default"))) ratio_not_equal
    : _BoolConstant<!ratio_equal<_R1, _R2>::value> {};
template <class _R1, class _R2, bool _Odd = false,
          intmax_t _Q1 = _R1::num / _R1::den, intmax_t _M1 = _R1::num % _R1::den,
          intmax_t _Q2 = _R2::num / _R2::den, intmax_t _M2 = _R2::num % _R2::den>
struct __ratio_less1
{
    static const bool value = _Odd ? _Q2 < _Q1 : _Q1 < _Q2;
};
template <class _R1, class _R2, bool _Odd, intmax_t _Qp>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, 0>
{
    static const bool value = false;
};
template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M2>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, _M2>
{
    static const bool value = !_Odd;
};
template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, 0>
{
    static const bool value = _Odd;
};
template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1,
                                                        intmax_t _M2>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, _M2>
{
    static const bool value = __ratio_less1<ratio<_R1::den, _M1>,
                                            ratio<_R2::den, _M2>, !_Odd>::value;
};
template <class _R1, class _R2, intmax_t _S1 = __static_sign<_R1::num>::value,
                                intmax_t _S2 = __static_sign<_R2::num>::value>
struct __ratio_less
{
    static const bool value = _S1 < _S2;
};
template <class _R1, class _R2>
struct __ratio_less<_R1, _R2, 1LL, 1LL>
{
    static const bool value = __ratio_less1<_R1, _R2>::value;
};
template <class _R1, class _R2>
struct __ratio_less<_R1, _R2, -1LL, -1LL>
{
    static const bool value = __ratio_less1<ratio<-_R2::num, _R2::den>, ratio<-_R1::num, _R1::den> >::value;
};
template <class _R1, class _R2>
struct __attribute__((__type_visibility__("default"))) ratio_less
    : _BoolConstant<__ratio_less<_R1, _R2>::value> {};
template <class _R1, class _R2>
struct __attribute__((__type_visibility__("default"))) ratio_less_equal
    : _BoolConstant<!ratio_less<_R2, _R1>::value> {};
template <class _R1, class _R2>
struct __attribute__((__type_visibility__("default"))) ratio_greater
    : _BoolConstant<ratio_less<_R2, _R1>::value> {};
template <class _R1, class _R2>
struct __attribute__((__type_visibility__("default"))) ratio_greater_equal
    : _BoolConstant<!ratio_less<_R1, _R2>::value> {};
template <class _R1, class _R2>
struct __ratio_gcd
{
    typedef ratio<__static_gcd<_R1::num, _R2::num>::value,
                  __static_lcm<_R1::den, _R2::den>::value> type;
};
template <class _R1, class _R2>
inline constexpr bool ratio_equal_v = ratio_equal<_R1, _R2>::value;
template <class _R1, class _R2>
inline constexpr bool ratio_not_equal_v = ratio_not_equal<_R1, _R2>::value;
template <class _R1, class _R2>
inline constexpr bool ratio_less_v = ratio_less<_R1, _R2>::value;
template <class _R1, class _R2>
inline constexpr bool ratio_less_equal_v = ratio_less_equal<_R1, _R2>::value;
template <class _R1, class _R2>
inline constexpr bool ratio_greater_v = ratio_greater<_R1, _R2>::value;
template <class _R1, class _R2>
inline constexpr bool ratio_greater_equal_v = ratio_greater_equal<_R1, _R2>::value;
}}

namespace std { inline namespace __1 {
namespace chrono
{
template <class _Rep, class _Period = ratio<1> > class __attribute__((__type_visibility__("default"))) duration;
template <class _Tp>
struct __is_duration : false_type {};
template <class _Rep, class _Period>
struct __is_duration<duration<_Rep, _Period> > : true_type {};
template <class _Rep, class _Period>
struct __is_duration<const duration<_Rep, _Period> > : true_type {};
template <class _Rep, class _Period>
struct __is_duration<volatile duration<_Rep, _Period> > : true_type {};
template <class _Rep, class _Period>
struct __is_duration<const volatile duration<_Rep, _Period> > : true_type {};
}
template <class _Rep1, class _Period1, class _Rep2, class _Period2>
struct __attribute__((__type_visibility__("default"))) common_type<chrono::duration<_Rep1, _Period1>,
                                         chrono::duration<_Rep2, _Period2> >
{
    typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
                             typename __ratio_gcd<_Period1, _Period2>::type> type;
};
namespace chrono {
template <class _FromDuration, class _ToDuration,
          class _Period = typename ratio_divide<typename _FromDuration::period, typename _ToDuration::period>::type,
          bool = _Period::num == 1,
          bool = _Period::den == 1>
struct __duration_cast;
template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, true, true>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        return _ToDuration(static_cast<typename _ToDuration::rep>(__fd.count()));
    }
};
template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, true, false>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
        return _ToDuration(static_cast<typename _ToDuration::rep>(
                           static_cast<_Ct>(__fd.count()) / static_cast<_Ct>(_Period::den)));
    }
};
template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, false, true>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
        return _ToDuration(static_cast<typename _ToDuration::rep>(
                           static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)));
    }
};
template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, false, false>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    _ToDuration operator()(const _FromDuration& __fd) const
    {
        typedef typename common_type<typename _ToDuration::rep, typename _FromDuration::rep, intmax_t>::type _Ct;
        return _ToDuration(static_cast<typename _ToDuration::rep>(
                           static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)
                                                          / static_cast<_Ct>(_Period::den)));
    }
};
template <class _ToDuration, class _Rep, class _Period>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr
typename enable_if
<
    __is_duration<_ToDuration>::value,
    _ToDuration
>::type
duration_cast(const duration<_Rep, _Period>& __fd)
{
    return __duration_cast<duration<_Rep, _Period>, _ToDuration>()(__fd);
}
template <class _Rep>
struct __attribute__((__type_visibility__("default"))) treat_as_floating_point : is_floating_point<_Rep> {};
template <class _Rep>
inline constexpr bool treat_as_floating_point_v = treat_as_floating_point<_Rep>::value;
template <class _Rep>
struct __attribute__((__type_visibility__("default"))) duration_values
{
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr _Rep zero() noexcept {return _Rep(0);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr _Rep max() noexcept {return numeric_limits<_Rep>::max();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr _Rep min() noexcept {return numeric_limits<_Rep>::lowest();}
};
template <class _ToDuration, class _Rep, class _Period>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
typename enable_if
<
    __is_duration<_ToDuration>::value,
    _ToDuration
>::type
floor(const duration<_Rep, _Period>& __d)
{
    _ToDuration __t = chrono::duration_cast<_ToDuration>(__d);
    if (__t > __d)
        __t = __t - _ToDuration{1};
    return __t;
}
template <class _ToDuration, class _Rep, class _Period>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
typename enable_if
<
    __is_duration<_ToDuration>::value,
    _ToDuration
>::type
ceil(const duration<_Rep, _Period>& __d)
{
    _ToDuration __t = chrono::duration_cast<_ToDuration>(__d);
    if (__t < __d)
        __t = __t + _ToDuration{1};
    return __t;
}
template <class _ToDuration, class _Rep, class _Period>
// added by concept-synth, original LN: 20991
requires
requires (_ToDuration o) { o.count(); }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
typename enable_if
<
    __is_duration<_ToDuration>::value,
    _ToDuration
>::type
round(const duration<_Rep, _Period>& __d)
{
    _ToDuration __lower = chrono::floor<_ToDuration>(__d);
    _ToDuration __upper = __lower + _ToDuration{1};
    auto __lowerDiff = __d - __lower;
    auto __upperDiff = __upper - __d;
    if (__lowerDiff < __upperDiff)
        return __lower;
    if (__lowerDiff > __upperDiff)
        return __upper;
    return __lower.count() & 1 ? __upper : __lower;
}
template <class _Rep, class _Period>
class __attribute__((__type_visibility__("default"))) duration
{
    static_assert(!__is_duration<_Rep>::value, "A duration representation can not be a duration");
    static_assert(__is_ratio<_Period>::value, "Second template parameter of duration must be a std::ratio");
    static_assert(_Period::num > 0, "duration period must be positive");
    template <class _R1, class _R2>
    struct __no_overflow
    {
    private:
        static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
        static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
        static const intmax_t __n1 = _R1::num / __gcd_n1_n2;
        static const intmax_t __d1 = _R1::den / __gcd_d1_d2;
        static const intmax_t __n2 = _R2::num / __gcd_n1_n2;
        static const intmax_t __d2 = _R2::den / __gcd_d1_d2;
        static const intmax_t max = -((intmax_t(1) << (sizeof(intmax_t) * 8 - 1)) + 1);
        template <intmax_t _Xp, intmax_t _Yp, bool __overflow>
        struct __mul
        {
            static const intmax_t value = _Xp * _Yp;
        };
        template <intmax_t _Xp, intmax_t _Yp>
        struct __mul<_Xp, _Yp, true>
        {
            static const intmax_t value = 1;
        };
    public:
        static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);
        typedef ratio<__mul<__n1, __d2, !value>::value,
                      __mul<__n2, __d1, !value>::value> type;
    };
public:
    typedef _Rep rep;
    typedef typename _Period::type period;
private:
    rep __rep_;
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
        duration() = default;
    template <class _Rep2>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
        explicit duration(const _Rep2& __r,
            typename enable_if
            <
               is_convertible<const _Rep2&, rep>::value &&
               (treat_as_floating_point<rep>::value ||
               !treat_as_floating_point<_Rep2>::value)
            >::type* = nullptr)
                : __rep_(__r) {}
    template <class _Rep2, class _Period2>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
        duration(const duration<_Rep2, _Period2>& __d,
            typename enable_if
            <
                __no_overflow<_Period2, period>::value && (
                treat_as_floating_point<rep>::value ||
                (__no_overflow<_Period2, period>::type::den == 1 &&
                 !treat_as_floating_point<_Rep2>::value))
            >::type* = nullptr)
                : __rep_(chrono::duration_cast<duration>(__d).count()) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr rep count() const {return __rep_;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr typename common_type<duration>::type operator+() const {return typename common_type<duration>::type(*this);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr typename common_type<duration>::type operator-() const {return typename common_type<duration>::type(-__rep_);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr duration& operator++() {++__rep_; return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr duration operator++(int) {return duration(__rep_++);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr duration& operator--() {--__rep_; return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr duration operator--(int) {return duration(__rep_--);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr duration& operator+=(const duration& __d) {__rep_ += __d.count(); return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr duration& operator-=(const duration& __d) {__rep_ -= __d.count(); return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr duration& operator*=(const rep& __rhs) {__rep_ *= __rhs; return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr duration& operator/=(const rep& __rhs) {__rep_ /= __rhs; return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr duration& operator%=(const rep& __rhs) {__rep_ %= __rhs; return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr duration& operator%=(const duration& __rhs) {__rep_ %= __rhs.count(); return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr duration zero() noexcept {return duration(duration_values<rep>::zero());}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr duration min() noexcept {return duration(duration_values<rep>::min());}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr duration max() noexcept {return duration(duration_values<rep>::max());}
};
typedef duration<long long, nano> nanoseconds;
typedef duration<long long, micro> microseconds;
typedef duration<long long, milli> milliseconds;
typedef duration<long long > seconds;
typedef duration< long, ratio< 60> > minutes;
typedef duration< long, ratio<3600> > hours;
typedef duration< int, ratio_multiply<ratio<24>, hours::period>> days;
typedef duration< int, ratio_multiply<ratio<7>, days::period>> weeks;
typedef duration< int, ratio_multiply<ratio<146097, 400>, days::period>> years;
typedef duration< int, ratio_divide<years::period, ratio<12>>> months;
template <class _LhsDuration, class _RhsDuration>
struct __duration_eq
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    bool operator()(const _LhsDuration& __lhs, const _RhsDuration& __rhs) const
        {
            typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
            return _Ct(__lhs).count() == _Ct(__rhs).count();
        }
};
template <class _LhsDuration>
struct __duration_eq<_LhsDuration, _LhsDuration>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    bool operator()(const _LhsDuration& __lhs, const _LhsDuration& __rhs) const
        {return __lhs.count() == __rhs.count();}
};
template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr
bool
operator==(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return __duration_eq<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);
}
template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr
bool
operator!=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return !(__lhs == __rhs);
}
template <class _LhsDuration, class _RhsDuration>
struct __duration_lt
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    bool operator()(const _LhsDuration& __lhs, const _RhsDuration& __rhs) const
        {
            typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
            return _Ct(__lhs).count() < _Ct(__rhs).count();
        }
};
template <class _LhsDuration>
struct __duration_lt<_LhsDuration, _LhsDuration>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    bool operator()(const _LhsDuration& __lhs, const _LhsDuration& __rhs) const
        {return __lhs.count() < __rhs.count();}
};
template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr
bool
operator< (const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return __duration_lt<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >()(__lhs, __rhs);
}
template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr
bool
operator> (const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return __rhs < __lhs;
}
template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr
bool
operator<=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return !(__rhs < __lhs);
}
template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr
bool
operator>=(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    return !(__lhs < __rhs);
}
template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr
typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
operator+(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
    return _Cd(_Cd(__lhs).count() + _Cd(__rhs).count());
}
template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr
typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
operator-(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
    return _Cd(_Cd(__lhs).count() - _Cd(__rhs).count());
}
template <class _Rep1, class _Period, class _Rep2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr
typename enable_if
<
    is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value,
    duration<typename common_type<_Rep1, _Rep2>::type, _Period>
>::type
operator*(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef duration<_Cr, _Period> _Cd;
    return _Cd(_Cd(__d).count() * static_cast<_Cr>(__s));
}
template <class _Rep1, class _Period, class _Rep2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr
typename enable_if
<
    is_convertible<_Rep1, typename common_type<_Rep1, _Rep2>::type>::value,
    duration<typename common_type<_Rep1, _Rep2>::type, _Period>
>::type
operator*(const _Rep1& __s, const duration<_Rep2, _Period>& __d)
{
    return __d * __s;
}
template <class _Rep1, class _Period, class _Rep2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr
typename enable_if
<
    !__is_duration<_Rep2>::value &&
      is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value,
    duration<typename common_type<_Rep1, _Rep2>::type, _Period>
>::type
operator/(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef duration<_Cr, _Period> _Cd;
    return _Cd(_Cd(__d).count() / static_cast<_Cr>(__s));
}
template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr
typename common_type<_Rep1, _Rep2>::type
operator/(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Ct;
    return _Ct(__lhs).count() / _Ct(__rhs).count();
}
template <class _Rep1, class _Period, class _Rep2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr
typename enable_if
<
    !__is_duration<_Rep2>::value &&
      is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value,
    duration<typename common_type<_Rep1, _Rep2>::type, _Period>
>::type
operator%(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef duration<_Cr, _Period> _Cd;
    return _Cd(_Cd(__d).count() % static_cast<_Cr>(__s));
}
template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr
typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
operator%(const duration<_Rep1, _Period1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef typename common_type<_Rep1, _Rep2>::type _Cr;
    typedef typename common_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _Cd;
    return _Cd(static_cast<_Cr>(_Cd(__lhs).count()) % static_cast<_Cr>(_Cd(__rhs).count()));
}
}
inline namespace literals
{
  inline namespace chrono_literals
  {
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr chrono::hours operator""h(unsigned long long __h)
    {
        return chrono::hours(static_cast<chrono::hours::rep>(__h));
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr chrono::duration<long double, ratio<3600,1>> operator""h(long double __h)
    {
        return chrono::duration<long double, ratio<3600,1>>(__h);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr chrono::minutes operator""min(unsigned long long __m)
    {
        return chrono::minutes(static_cast<chrono::minutes::rep>(__m));
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr chrono::duration<long double, ratio<60,1>> operator""min(long double __m)
    {
        return chrono::duration<long double, ratio<60,1>> (__m);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr chrono::seconds operator""s(unsigned long long __s)
    {
        return chrono::seconds(static_cast<chrono::seconds::rep>(__s));
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr chrono::duration<long double> operator""s(long double __s)
    {
        return chrono::duration<long double> (__s);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr chrono::milliseconds operator""ms(unsigned long long __ms)
    {
        return chrono::milliseconds(static_cast<chrono::milliseconds::rep>(__ms));
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr chrono::duration<long double, milli> operator""ms(long double __ms)
    {
        return chrono::duration<long double, milli>(__ms);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr chrono::microseconds operator""us(unsigned long long __us)
    {
        return chrono::microseconds(static_cast<chrono::microseconds::rep>(__us));
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr chrono::duration<long double, micro> operator""us(long double __us)
    {
        return chrono::duration<long double, micro> (__us);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr chrono::nanoseconds operator""ns(unsigned long long __ns)
    {
        return chrono::nanoseconds(static_cast<chrono::nanoseconds::rep>(__ns));
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr chrono::duration<long double, nano> operator""ns(long double __ns)
    {
        return chrono::duration<long double, nano> (__ns);
    }
}
}
namespace chrono {
   using namespace literals::chrono_literals;
}
}}


namespace std { inline namespace __1 {
namespace chrono
{
template <class _Clock, class _Duration = typename _Clock::duration>
class __attribute__((__type_visibility__("default"))) time_point
{
    static_assert(__is_duration<_Duration>::value,
                  "Second template parameter of time_point must be a std::chrono::duration");
public:
    typedef _Clock clock;
    typedef _Duration duration;
    typedef typename duration::rep rep;
    typedef typename duration::period period;
private:
    duration __d_;
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr time_point() : __d_(duration::zero()) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr explicit time_point(const duration& __d) : __d_(__d) {}
    template <class _Duration2>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    time_point(const time_point<clock, _Duration2>& __t,
        typename enable_if
        <
            is_convertible<_Duration2, duration>::value
        >::type* = nullptr)
            : __d_(__t.time_since_epoch()) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr duration time_since_epoch() const {return __d_;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr time_point& operator+=(const duration& __d) {__d_ += __d; return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr time_point& operator-=(const duration& __d) {__d_ -= __d; return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr time_point min() noexcept {return time_point(duration::min());}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr time_point max() noexcept {return time_point(duration::max());}
};
}
template <class _Clock, class _Duration1, class _Duration2>
struct __attribute__((__type_visibility__("default"))) common_type<chrono::time_point<_Clock, _Duration1>,
                                         chrono::time_point<_Clock, _Duration2> >
{
    typedef chrono::time_point<_Clock, typename common_type<_Duration1, _Duration2>::type> type;
};
namespace chrono {
template <class _ToDuration, class _Clock, class _Duration>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
time_point<_Clock, _ToDuration>
time_point_cast(const time_point<_Clock, _Duration>& __t)
{
    return time_point<_Clock, _ToDuration>(chrono::duration_cast<_ToDuration>(__t.time_since_epoch()));
}
template <class _ToDuration, class _Clock, class _Duration>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
typename enable_if
<
    __is_duration<_ToDuration>::value,
    time_point<_Clock, _ToDuration>
>::type
floor(const time_point<_Clock, _Duration>& __t)
{
    return time_point<_Clock, _ToDuration>{chrono::floor<_ToDuration>(__t.time_since_epoch())};
}
template <class _ToDuration, class _Clock, class _Duration>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
typename enable_if
<
    __is_duration<_ToDuration>::value,
    time_point<_Clock, _ToDuration>
>::type
ceil(const time_point<_Clock, _Duration>& __t)
{
    return time_point<_Clock, _ToDuration>{chrono::ceil<_ToDuration>(__t.time_since_epoch())};
}
template <class _ToDuration, class _Clock, class _Duration>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
typename enable_if
<
    __is_duration<_ToDuration>::value,
    time_point<_Clock, _ToDuration>
>::type
round(const time_point<_Clock, _Duration>& __t)
{
    return time_point<_Clock, _ToDuration>{chrono::round<_ToDuration>(__t.time_since_epoch())};
}
template <class _Rep, class _Period>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
typename enable_if
<
    numeric_limits<_Rep>::is_signed,
    duration<_Rep, _Period>
>::type
abs(duration<_Rep, _Period> __d)
{
    return __d >= __d.zero() ? +__d : -__d;
}
template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool
operator==(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __lhs.time_since_epoch() == __rhs.time_since_epoch();
}
template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool
operator!=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return !(__lhs == __rhs);
}
template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool
operator<(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __lhs.time_since_epoch() < __rhs.time_since_epoch();
}
template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool
operator>(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __rhs < __lhs;
}
template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool
operator<=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return !(__rhs < __lhs);
}
template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool
operator>=(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return !(__lhs < __rhs);
}
template <class _Clock, class _Duration1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type>
operator+(const time_point<_Clock, _Duration1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> _Tr;
    return _Tr (__lhs.time_since_epoch() + __rhs);
}
template <class _Rep1, class _Period1, class _Clock, class _Duration2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
time_point<_Clock, typename common_type<duration<_Rep1, _Period1>, _Duration2>::type>
operator+(const duration<_Rep1, _Period1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __rhs + __lhs;
}
template <class _Clock, class _Duration1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type>
operator-(const time_point<_Clock, _Duration1>& __lhs, const duration<_Rep2, _Period2>& __rhs)
{
    typedef time_point<_Clock, typename common_type<_Duration1, duration<_Rep2, _Period2> >::type> _Ret;
    return _Ret(__lhs.time_since_epoch() -__rhs);
}
template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
typename common_type<_Duration1, _Duration2>::type
operator-(const time_point<_Clock, _Duration1>& __lhs, const time_point<_Clock, _Duration2>& __rhs)
{
    return __lhs.time_since_epoch() - __rhs.time_since_epoch();
}
}
}}
namespace std { inline namespace __1 {
namespace chrono
{
class __attribute__((__visibility__("default"))) steady_clock
{
public:
    typedef nanoseconds duration;
    typedef duration::rep rep;
    typedef duration::period period;
    typedef chrono::time_point<steady_clock, duration> time_point;
    static constexpr const bool is_steady = true;
    static time_point now() noexcept;
};
}
}}
namespace std { inline namespace __1 {
using ::clock_t __attribute__((__using_if_exists__));
using ::size_t __attribute__((__using_if_exists__));
using ::time_t __attribute__((__using_if_exists__));
using ::tm __attribute__((__using_if_exists__));
using ::timespec __attribute__((__using_if_exists__));
using ::clock __attribute__((__using_if_exists__));
using ::difftime __attribute__((__using_if_exists__));
using ::mktime __attribute__((__using_if_exists__));
using ::time __attribute__((__using_if_exists__));
using ::asctime __attribute__((__using_if_exists__));
using ::ctime __attribute__((__using_if_exists__));
using ::gmtime __attribute__((__using_if_exists__));
using ::localtime __attribute__((__using_if_exists__));
using ::strftime __attribute__((__using_if_exists__));
using ::timespec_get __attribute__((__using_if_exists__));
}}
namespace std { inline namespace __1 {
namespace chrono
{
class __attribute__((__visibility__("default"))) system_clock
{
public:
    typedef microseconds duration;
    typedef duration::rep rep;
    typedef duration::period period;
    typedef chrono::time_point<system_clock> time_point;
    static constexpr const bool is_steady = false;
    static time_point now() noexcept;
    static time_t to_time_t (const time_point& __t) noexcept;
    static time_point from_time_t(time_t __t) noexcept;
};
template <class _Duration>
using sys_time = time_point<system_clock, _Duration>;
using sys_seconds = sys_time<seconds>;
using sys_days = sys_time<days>;
}
}}
namespace std { inline namespace __1 {
namespace chrono
{
typedef steady_clock high_resolution_clock;
}
}}
namespace std { inline namespace __1 {
static constexpr const int __libcpp_polling_count = 64;
template<class _Fn, class _BFn>
// added by concept-synth, original LN: 21560
requires
requires (_Fn f) { {f()} -> std::convertible_to<bool>; }
__attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool __libcpp_thread_poll_with_backoff(_Fn&& __f, _BFn&& __bf, chrono::nanoseconds __max_elapsed = chrono::nanoseconds::zero()) {
    auto const __start = chrono::high_resolution_clock::now();
    for (int __count = 0;;) {
      if (__f())
        return true;
      if (__count < __libcpp_polling_count) {
        __count += 1;
        continue;
      }
      chrono::nanoseconds const __elapsed = chrono::high_resolution_clock::now() - __start;
      if (__max_elapsed != chrono::nanoseconds::zero() && __max_elapsed < __elapsed)
          return false;
      if (__bf(__elapsed))
        return false;
    }
}
struct __spinning_backoff_policy {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  bool operator()(chrono::nanoseconds const&) const {
      return false;
  }
};
}}

namespace std { inline namespace __1 {
template <class _TimeSpec>
// added by concept-synth, original LN: 21587
requires
(
 requires (_TimeSpec o) { o.tv_nsec; } &&
 requires (_TimeSpec o) { o.tv_sec; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) inline
_TimeSpec __convert_to_timespec(const chrono::nanoseconds& __ns)
{
  using namespace chrono;
  seconds __s = duration_cast<seconds>(__ns);
  _TimeSpec __ts;
  typedef decltype(__ts.tv_sec) __ts_sec;
  const __ts_sec __ts_sec_max = numeric_limits<__ts_sec>::max();
  if (__s.count() < __ts_sec_max)
  {
    __ts.tv_sec = static_cast<__ts_sec>(__s.count());
    __ts.tv_nsec = static_cast<decltype(__ts.tv_nsec)>((__ns - __s).count());
  }
  else
  {
    __ts.tv_sec = __ts_sec_max;
    __ts.tv_nsec = 999999999;
  }
  return __ts;
}
}}
extern "C" {
extern int * __error(void);
}
#pragma clang assume_nonnull begin
#pragma clang assume_nonnull end

extern "C" {
struct sched_param { int sched_priority; char __opaque[4]; };
extern int sched_yield(void);
extern int sched_get_priority_min(int);
extern int sched_get_priority_max(int);
}
typedef __darwin_pthread_cond_t pthread_cond_t;
typedef __darwin_pthread_condattr_t pthread_condattr_t;
typedef __darwin_pthread_key_t pthread_key_t;
typedef __darwin_pthread_mutex_t pthread_mutex_t;
typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t;
typedef __darwin_pthread_once_t pthread_once_t;
typedef __darwin_pthread_rwlock_t pthread_rwlock_t;
typedef __darwin_pthread_rwlockattr_t pthread_rwlockattr_t;
typedef __darwin_pthread_t pthread_t;

typedef enum : unsigned int { QOS_CLASS_USER_INTERACTIVE __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x21, QOS_CLASS_USER_INITIATED __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x19, QOS_CLASS_DEFAULT __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x15, QOS_CLASS_UTILITY __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x11, QOS_CLASS_BACKGROUND __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x09, QOS_CLASS_UNSPECIFIED __attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0))) = 0x00, } qos_class_t;
extern "C" {
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
qos_class_t
qos_class_self(void);
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
qos_class_t
qos_class_main(void);
}
#pragma clang assume_nonnull begin
extern "C" {
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
int
pthread_attr_set_qos_class_np(pthread_attr_t *__attr,
  qos_class_t __qos_class, int __relative_priority);
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
int
pthread_attr_get_qos_class_np(pthread_attr_t * __attr,
  qos_class_t * _Nullable __qos_class,
  int * _Nullable __relative_priority);
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
int
pthread_set_qos_class_self_np(qos_class_t __qos_class,
  int __relative_priority);
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
int
pthread_get_qos_class_np(pthread_t __pthread,
  qos_class_t * _Nullable __qos_class,
  int * _Nullable __relative_priority);
typedef struct pthread_override_s* pthread_override_t;
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
pthread_override_t
pthread_override_qos_class_start_np(pthread_t __pthread,
  qos_class_t __qos_class, int __relative_priority);
__attribute__((availability(macos,introduced=10.10))) __attribute__((availability(ios,introduced=8.0)))
int
pthread_override_qos_class_end_np(pthread_override_t __override);
}
#pragma clang assume_nonnull end
typedef __darwin_mach_port_t mach_port_t;
#pragma clang assume_nonnull begin
extern "C" {
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_atfork(void (* _Nullable)(void), void (* _Nullable)(void),
  void (* _Nullable)(void));
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_destroy(pthread_attr_t *);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getdetachstate(const pthread_attr_t *, int *);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getguardsize(const pthread_attr_t * , size_t * );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getinheritsched(const pthread_attr_t * , int * );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getschedparam(const pthread_attr_t * ,
  struct sched_param * );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getschedpolicy(const pthread_attr_t * , int * );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getscope(const pthread_attr_t * , int * );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getstack(const pthread_attr_t * ,
  void * _Nullable * _Nonnull , size_t * );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getstackaddr(const pthread_attr_t * ,
  void * _Nullable * _Nonnull );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_getstacksize(const pthread_attr_t * , size_t * );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_init(pthread_attr_t *);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setdetachstate(pthread_attr_t *, int);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setguardsize(pthread_attr_t *, size_t);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setinheritsched(pthread_attr_t *, int);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setschedparam(pthread_attr_t * ,
  const struct sched_param * );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setschedpolicy(pthread_attr_t *, int);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setscope(pthread_attr_t *, int);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setstack(pthread_attr_t *, void *, size_t);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setstackaddr(pthread_attr_t *, void *);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_attr_setstacksize(pthread_attr_t *, size_t);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_cancel(pthread_t) __asm("_" "pthread_cancel" );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_cond_broadcast(pthread_cond_t *);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_cond_destroy(pthread_cond_t *);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_cond_init(
  pthread_cond_t * ,
  const pthread_condattr_t * _Nullable )
  __asm("_" "pthread_cond_init" );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_cond_signal(pthread_cond_t *);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use an asynchronous wait instead of a synchronous wait" "\")")))
int pthread_cond_timedwait(
  pthread_cond_t * , pthread_mutex_t * ,
  const struct timespec * _Nullable )
  __asm("_" "pthread_cond_timedwait" );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use an asynchronous wait instead of a synchronous wait" "\")")))
int pthread_cond_wait(pthread_cond_t * ,
  pthread_mutex_t * ) __asm("_" "pthread_cond_wait" );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_condattr_destroy(pthread_condattr_t *);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_condattr_init(pthread_condattr_t *);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_condattr_getpshared(const pthread_condattr_t * ,
  int * );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_condattr_setpshared(pthread_condattr_t *, int);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_create(pthread_t _Nullable * _Nonnull ,
  const pthread_attr_t * _Nullable ,
  void * _Nullable (* _Nonnull)(void * _Nullable),
  void * _Nullable );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_detach(pthread_t);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_equal(pthread_t _Nullable, pthread_t _Nullable);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Thread lifecycle is owned by Swift Concurrency runtime" "\")")))
void pthread_exit(void * _Nullable) __attribute__((__noreturn__));
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_getconcurrency(void);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_getschedparam(pthread_t , int * _Nullable ,
  struct sched_param * _Nullable );
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use Task Local Values instead" "\")")))
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
void* _Nullable pthread_getspecific(pthread_key_t);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use an asynchronous wait instead of a synchronous wait" "\")")))
int pthread_join(pthread_t , void * _Nullable * _Nullable)
  __asm("_" "pthread_join" );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_key_create(pthread_key_t *, void (* _Nullable)(void *));
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_key_delete(pthread_key_t);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutex_destroy(pthread_mutex_t *);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutex_getprioceiling(const pthread_mutex_t * ,
  int * );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutex_init(pthread_mutex_t * ,
  const pthread_mutexattr_t * _Nullable );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use OSAllocatedUnfairLock's withLock or NSLock for async-safe scoped locking" "\")")))
int pthread_mutex_lock(pthread_mutex_t *);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutex_setprioceiling(pthread_mutex_t * , int,
  int * );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use OSAllocatedUnfairLock's withLockIfAvailable or NSLock for async-safe scoped locking" "\")")))
int pthread_mutex_trylock(pthread_mutex_t *);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use OSAllocatedUnfairLock's withLock or NSLock for async-safe scoped locking" "\")")))
int pthread_mutex_unlock(pthread_mutex_t *);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_destroy(pthread_mutexattr_t *) __asm("_" "pthread_mutexattr_destroy" );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t * ,
  int * );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_getprotocol(const pthread_mutexattr_t * ,
  int * );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_getpshared(const pthread_mutexattr_t * ,
  int * );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_gettype(const pthread_mutexattr_t * ,
  int * );
__attribute__((availability(macos,introduced=10.13.4))) __attribute__((availability(ios,introduced=11.3))) __attribute__((availability(watchos,introduced=4.3))) __attribute__((availability(tvos,introduced=11.3)))
int pthread_mutexattr_getpolicy_np(const pthread_mutexattr_t * ,
  int * );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_init(pthread_mutexattr_t *);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_mutexattr_settype(pthread_mutexattr_t *, int);
__attribute__((availability(macos,introduced=10.7))) __attribute__((availability(ios,introduced=5.0)))
int pthread_mutexattr_setpolicy_np(pthread_mutexattr_t *, int);
__attribute__((availability(swift,unavailable,message="Use lazily initialized globals instead")))
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_once(pthread_once_t *, void (* _Nonnull)(void));
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlock_destroy(pthread_rwlock_t * ) __asm("_" "pthread_rwlock_destroy" );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlock_init(pthread_rwlock_t * ,
  const pthread_rwlockattr_t * _Nullable )
  __asm("_" "pthread_rwlock_init" );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use async-safe scoped locking instead" "\")")))
int pthread_rwlock_rdlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_rdlock" );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use async-safe scoped locking instead" "\")")))
int pthread_rwlock_tryrdlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_tryrdlock" );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use async-safe scoped locking instead" "\")")))
int pthread_rwlock_trywrlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_trywrlock" );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use async-safe scoped locking instead" "\")")))
int pthread_rwlock_wrlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_wrlock" );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use async-safe scoped locking instead" "\")")))
int pthread_rwlock_unlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_unlock" );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t * ,
  int * );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlockattr_init(pthread_rwlockattr_t *);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
pthread_t pthread_self(void);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use Task cancellation instead" "\")")))
int pthread_setcancelstate(int , int * _Nullable)
  __asm("_" "pthread_setcancelstate" );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use Task cancellation instead" "\")")))
int pthread_setcanceltype(int , int * _Nullable)
  __asm("_" "pthread_setcanceltype" );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_setconcurrency(int);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_setschedparam(pthread_t, int, const struct sched_param *);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use Task Local Values instead" "\")")))
int pthread_setspecific(pthread_key_t , const void * _Nullable);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use Task cancellation instead" "\")")))
void pthread_testcancel(void) __asm("_" "pthread_testcancel" );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_is_threaded_np(void);
__attribute__((availability(macos,introduced=10.6))) __attribute__((availability(ios,introduced=3.2)))
int pthread_threadid_np(pthread_t _Nullable,__uint64_t* _Nullable);
__attribute__((availability(macos,introduced=10.6))) __attribute__((availability(ios,introduced=3.2)))
int pthread_getname_np(pthread_t,char*,size_t);
__attribute__((availability(macos,introduced=10.6))) __attribute__((availability(ios,introduced=3.2)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Thread lifecycle is owned by Swift Concurrency runtime" "\")")))
int pthread_setname_np(const char*);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_main_np(void);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
mach_port_t pthread_mach_thread_np(pthread_t);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
size_t pthread_get_stacksize_np(pthread_t);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
void* pthread_get_stackaddr_np(pthread_t);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_cond_signal_thread_np(pthread_cond_t *, pthread_t _Nullable);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use an asynchronous wait instead of a synchronous wait" "\")")))
int pthread_cond_timedwait_relative_np(pthread_cond_t *, pthread_mutex_t *,
  const struct timespec * _Nullable);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_create_suspended_np(
  pthread_t _Nullable * _Nonnull, const pthread_attr_t * _Nullable,
  void * _Nullable (* _Nonnull)(void * _Nullable), void * _Nullable);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_kill(pthread_t, int);
__attribute__((availability(macos,introduced=10.5))) __attribute__((availability(ios,introduced=2.0)))
_Nullable pthread_t pthread_from_mach_thread_np(mach_port_t);
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
int pthread_sigmask(int, const sigset_t * _Nullable, sigset_t * _Nullable)
  __asm("_" "pthread_sigmask" );
__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))
__attribute__((__swift_attr__("@_unavailableFromAsync(message: \"" "Use Task.yield(), or await a condition instead of spinning" "\")")))
void pthread_yield_np(void);
__attribute__((availability(macos,introduced=11.0)))
__attribute__((availability(ios,unavailable))) __attribute__((availability(tvos,unavailable))) __attribute__((availability(watchos,unavailable))) __attribute__((availability(driverkit,unavailable)))
void pthread_jit_write_protect_np(int enabled);
__attribute__((availability(macos,introduced=11.0)))
__attribute__((availability(ios,unavailable))) __attribute__((availability(tvos,unavailable))) __attribute__((availability(watchos,unavailable))) __attribute__((availability(driverkit,unavailable)))
int pthread_jit_write_protect_supported_np(void);
typedef int (*pthread_jit_write_callback_t)(void * _Nullable ctx);
__attribute__((availability(macos,introduced=11.4)))
__attribute__((availability(ios,unavailable))) __attribute__((availability(tvos,unavailable))) __attribute__((availability(watchos,unavailable))) __attribute__((availability(driverkit,unavailable)))
__attribute__((availability(swift,unavailable,message="This interface cannot be safely used from Swift")))
int pthread_jit_write_with_callback_np(
  pthread_jit_write_callback_t _Nonnull callback, void * _Nullable ctx);
__attribute__((availability(macos,introduced=12.1)))
__attribute__((availability(ios,unavailable))) __attribute__((availability(tvos,unavailable))) __attribute__((availability(watchos,unavailable))) __attribute__((availability(driverkit,unavailable)))
void pthread_jit_write_freeze_callbacks_np(void);
__attribute__((availability(macos,introduced=11.0))) __attribute__((availability(ios,introduced=14.2))) __attribute__((availability(tvos,introduced=14.2))) __attribute__((availability(watchos,introduced=7.1)))
int
pthread_cpu_number_np(size_t *cpu_number_out);
}
#pragma clang assume_nonnull end
typedef ::timespec __libcpp_timespec_t;
namespace std { inline namespace __1 {
typedef pthread_mutex_t __libcpp_mutex_t;
typedef pthread_mutex_t __libcpp_recursive_mutex_t;
typedef pthread_cond_t __libcpp_condvar_t;
typedef pthread_once_t __libcpp_exec_once_flag;
  typedef pthread_t __libcpp_thread_id;
typedef pthread_t __libcpp_thread_t;
typedef pthread_key_t __libcpp_tls_key;
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
int __libcpp_recursive_mutex_init(__libcpp_recursive_mutex_t *__m);
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
int __libcpp_recursive_mutex_lock(__libcpp_recursive_mutex_t *__m);
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool __libcpp_recursive_mutex_trylock(__libcpp_recursive_mutex_t *__m);
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
int __libcpp_recursive_mutex_unlock(__libcpp_recursive_mutex_t *__m);
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
int __libcpp_recursive_mutex_destroy(__libcpp_recursive_mutex_t *__m);
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
int __libcpp_mutex_lock(__libcpp_mutex_t *__m);
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool __libcpp_mutex_trylock(__libcpp_mutex_t *__m);
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
int __libcpp_mutex_unlock(__libcpp_mutex_t *__m);
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
int __libcpp_mutex_destroy(__libcpp_mutex_t *__m);
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
int __libcpp_condvar_signal(__libcpp_condvar_t* __cv);
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
int __libcpp_condvar_broadcast(__libcpp_condvar_t* __cv);
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
int __libcpp_condvar_wait(__libcpp_condvar_t* __cv, __libcpp_mutex_t* __m);
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
int __libcpp_condvar_timedwait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m,
                               __libcpp_timespec_t *__ts);
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
int __libcpp_condvar_destroy(__libcpp_condvar_t* __cv);
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
int __libcpp_execute_once(__libcpp_exec_once_flag *__flag,
                          void (*__init_routine)());
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool __libcpp_thread_id_equal(__libcpp_thread_id __t1, __libcpp_thread_id __t2);
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool __libcpp_thread_id_less(__libcpp_thread_id __t1, __libcpp_thread_id __t2);
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool __libcpp_thread_isnull(const __libcpp_thread_t *__t);
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
int __libcpp_thread_create(__libcpp_thread_t *__t, void *(*__func)(void *),
                           void *__arg);
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
__libcpp_thread_id __libcpp_thread_get_current_id();
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
__libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t *__t);
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
int __libcpp_thread_join(__libcpp_thread_t *__t);
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
int __libcpp_thread_detach(__libcpp_thread_t *__t);
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void __libcpp_thread_yield();
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void __libcpp_thread_sleep_for(const chrono::nanoseconds& __ns);
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
int __libcpp_tls_create(__libcpp_tls_key* __key,
                        void(* __at_exit)(void*));
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void *__libcpp_tls_get(__libcpp_tls_key __key);
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
int __libcpp_tls_set(__libcpp_tls_key __key, void *__p);
int __libcpp_recursive_mutex_init(__libcpp_recursive_mutex_t *__m)
{
  pthread_mutexattr_t attr;
  int __ec = pthread_mutexattr_init(&attr);
  if (__ec)
    return __ec;
  __ec = pthread_mutexattr_settype(&attr, 2);
  if (__ec) {
    pthread_mutexattr_destroy(&attr);
    return __ec;
  }
  __ec = pthread_mutex_init(__m, &attr);
  if (__ec) {
    pthread_mutexattr_destroy(&attr);
    return __ec;
  }
  __ec = pthread_mutexattr_destroy(&attr);
  if (__ec) {
    pthread_mutex_destroy(__m);
    return __ec;
  }
  return 0;
}
int __libcpp_recursive_mutex_lock(__libcpp_recursive_mutex_t *__m)
{
  return pthread_mutex_lock(__m);
}
bool __libcpp_recursive_mutex_trylock(__libcpp_recursive_mutex_t *__m)
{
  return pthread_mutex_trylock(__m) == 0;
}
int __libcpp_recursive_mutex_unlock(__libcpp_recursive_mutex_t *__m)
{
  return pthread_mutex_unlock(__m);
}
int __libcpp_recursive_mutex_destroy(__libcpp_recursive_mutex_t *__m)
{
  return pthread_mutex_destroy(__m);
}
int __libcpp_mutex_lock(__libcpp_mutex_t *__m)
{
  return pthread_mutex_lock(__m);
}
bool __libcpp_mutex_trylock(__libcpp_mutex_t *__m)
{
  return pthread_mutex_trylock(__m) == 0;
}
int __libcpp_mutex_unlock(__libcpp_mutex_t *__m)
{
  return pthread_mutex_unlock(__m);
}
int __libcpp_mutex_destroy(__libcpp_mutex_t *__m)
{
  return pthread_mutex_destroy(__m);
}
int __libcpp_condvar_signal(__libcpp_condvar_t *__cv)
{
  return pthread_cond_signal(__cv);
}
int __libcpp_condvar_broadcast(__libcpp_condvar_t *__cv)
{
  return pthread_cond_broadcast(__cv);
}
int __libcpp_condvar_wait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m)
{
  return pthread_cond_wait(__cv, __m);
}
int __libcpp_condvar_timedwait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m,
                               __libcpp_timespec_t *__ts)
{
  return pthread_cond_timedwait(__cv, __m, __ts);
}
int __libcpp_condvar_destroy(__libcpp_condvar_t *__cv)
{
  return pthread_cond_destroy(__cv);
}
int __libcpp_execute_once(__libcpp_exec_once_flag *__flag,
                          void (*__init_routine)()) {
  return pthread_once(__flag, __init_routine);
}
bool __libcpp_thread_id_equal(__libcpp_thread_id __t1, __libcpp_thread_id __t2)
{
  return __t1 == __t2;
}
bool __libcpp_thread_id_less(__libcpp_thread_id __t1, __libcpp_thread_id __t2)
{
  return __t1 < __t2;
}
bool __libcpp_thread_isnull(const __libcpp_thread_t *__t) {
  return __libcpp_thread_get_id(__t) == 0;
}
int __libcpp_thread_create(__libcpp_thread_t *__t, void *(*__func)(void *),
                           void *__arg)
{
  return pthread_create(__t, nullptr, __func, __arg);
}
__libcpp_thread_id __libcpp_thread_get_current_id()
{
  const __libcpp_thread_t thread = pthread_self();
  return __libcpp_thread_get_id(&thread);
}
__libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t *__t)
{
  return *__t;
}
int __libcpp_thread_join(__libcpp_thread_t *__t)
{
  return pthread_join(*__t, nullptr);
}
int __libcpp_thread_detach(__libcpp_thread_t *__t)
{
  return pthread_detach(*__t);
}
void __libcpp_thread_yield()
{
  sched_yield();
}
void __libcpp_thread_sleep_for(const chrono::nanoseconds& __ns)
{
   __libcpp_timespec_t __ts = std::__convert_to_timespec<__libcpp_timespec_t>(__ns);
   while (nanosleep(&__ts, &__ts) == -1 && (*__error()) == 4);
}
int __libcpp_tls_create(__libcpp_tls_key *__key, void (*__at_exit)(void *))
{
  return pthread_key_create(__key, __at_exit);
}
void *__libcpp_tls_get(__libcpp_tls_key __key)
{
  return pthread_getspecific(__key);
}
int __libcpp_tls_set(__libcpp_tls_key __key, void *__p)
{
    return pthread_setspecific(__key, __p);
}
class __attribute__((__visibility__("default"))) thread;
class __attribute__((__visibility__("default"))) __thread_id;
namespace this_thread
{
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __thread_id get_id() noexcept;
}
template<> struct hash<__thread_id>;
class __attribute__((__type_visibility__("default"))) __thread_id
{
    __libcpp_thread_id __id_;
    static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
        bool __lt_impl(__thread_id __x, __thread_id __y) noexcept
        {
        if (__x.__id_ == 0) return __y.__id_ != 0;
        if (__y.__id_ == 0) return false;
        return __libcpp_thread_id_less(__x.__id_, __y.__id_);
        }
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    __thread_id() noexcept : __id_(0) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    void __reset() { __id_ = 0; }
    friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool operator==(__thread_id __x, __thread_id __y) noexcept;
    friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) strong_ordering operator<=>(__thread_id __x, __thread_id __y) noexcept;
    template<class _CharT, class _Traits>
    friend
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, __thread_id __id);
private:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    __thread_id(__libcpp_thread_id __id) : __id_(__id) {}
    friend __thread_id this_thread::get_id() noexcept;
    friend class __attribute__((__visibility__("default"))) thread;
    friend struct __attribute__((__type_visibility__("default"))) hash<__thread_id>;
};
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool operator==(__thread_id __x, __thread_id __y) noexcept {
  if (__x.__id_ == 0)
    return __y.__id_ == 0;
  if (__y.__id_ == 0)
    return false;
  return __libcpp_thread_id_equal(__x.__id_, __y.__id_);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
strong_ordering operator<=>(__thread_id __x, __thread_id __y) noexcept {
  if (__x == __y)
    return strong_ordering::equal;
  if (__thread_id::__lt_impl(__x, __y))
    return strong_ordering::less;
  return strong_ordering::greater;
}
namespace this_thread
{
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
__thread_id
get_id() noexcept
{
    return __libcpp_thread_get_current_id();
}
}
}}
namespace std { inline namespace __1 {
struct __libcpp_timed_backoff_policy {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  bool operator()(chrono::nanoseconds __elapsed) const
  {
      if(__elapsed > chrono::milliseconds(128))
          __libcpp_thread_sleep_for(chrono::milliseconds(8));
      else if(__elapsed > chrono::microseconds(64))
          __libcpp_thread_sleep_for(__elapsed / 2);
      else if(__elapsed > chrono::microseconds(4))
        __libcpp_thread_yield();
      else
        {}
      return false;
  }
};
}}
namespace std { inline namespace __1 {
enum __legacy_memory_order {
    __mo_relaxed,
    __mo_consume,
    __mo_acquire,
    __mo_release,
    __mo_acq_rel,
    __mo_seq_cst
};
typedef underlying_type<__legacy_memory_order>::type __memory_order_underlying_t;
enum class memory_order : __memory_order_underlying_t {
  relaxed = __mo_relaxed,
  consume = __mo_consume,
  acquire = __mo_acquire,
  release = __mo_release,
  acq_rel = __mo_acq_rel,
  seq_cst = __mo_seq_cst
};
inline constexpr auto memory_order_relaxed = memory_order::relaxed;
inline constexpr auto memory_order_consume = memory_order::consume;
inline constexpr auto memory_order_acquire = memory_order::acquire;
inline constexpr auto memory_order_release = memory_order::release;
inline constexpr auto memory_order_acq_rel = memory_order::acq_rel;
inline constexpr auto memory_order_seq_cst = memory_order::seq_cst;
template <typename _Tp> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool __cxx_nonatomic_compare_equal(_Tp const& __lhs, _Tp const& __rhs) {
    return std::memcmp(&__lhs, &__rhs, sizeof(_Tp)) == 0;
}
static_assert((is_same<underlying_type<memory_order>::type, __memory_order_underlying_t>::value),
  "unexpected underlying type for std::memory_order");
template <typename _Tp>
struct __cxx_atomic_base_impl {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    __cxx_atomic_base_impl() noexcept = default;
  constexpr explicit __cxx_atomic_base_impl(_Tp __value) noexcept
    : __a_value(__value) {}
  __extension__ _Atomic(_Tp) __a_value;
};
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) inline
void __cxx_atomic_thread_fence(memory_order __order) noexcept {
    __c11_atomic_thread_fence(static_cast<__memory_order_underlying_t>(__order));
}
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) inline
void __cxx_atomic_signal_fence(memory_order __order) noexcept {
    __c11_atomic_signal_fence(static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void __cxx_atomic_init(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __val) noexcept {
    __c11_atomic_init(&__a->__a_value, __val);
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void __cxx_atomic_init(__cxx_atomic_base_impl<_Tp> * __a, _Tp __val) noexcept {
    __c11_atomic_init(&__a->__a_value, __val);
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void __cxx_atomic_store(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __val, memory_order __order) noexcept {
    __c11_atomic_store(&__a->__a_value, __val, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void __cxx_atomic_store(__cxx_atomic_base_impl<_Tp> * __a, _Tp __val, memory_order __order) noexcept {
    __c11_atomic_store(&__a->__a_value, __val, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp __cxx_atomic_load(__cxx_atomic_base_impl<_Tp> const volatile* __a, memory_order __order) noexcept {
    using __ptr_type = __remove_const_t<decltype(__a->__a_value)>*;
    return __c11_atomic_load(const_cast<__ptr_type>(&__a->__a_value), static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp __cxx_atomic_load(__cxx_atomic_base_impl<_Tp> const* __a, memory_order __order) noexcept {
    using __ptr_type = __remove_const_t<decltype(__a->__a_value)>*;
    return __c11_atomic_load(const_cast<__ptr_type>(&__a->__a_value), static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp __cxx_atomic_exchange(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __value, memory_order __order) noexcept {
    return __c11_atomic_exchange(&__a->__a_value, __value, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp __cxx_atomic_exchange(__cxx_atomic_base_impl<_Tp> * __a, _Tp __value, memory_order __order) noexcept {
    return __c11_atomic_exchange(&__a->__a_value, __value, static_cast<__memory_order_underlying_t>(__order));
}
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) inline constexpr memory_order __to_failure_order(memory_order __order) {
  return __order == memory_order_release ? memory_order_relaxed:
         (__order == memory_order_acq_rel ? memory_order_acquire:
             __order);
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool __cxx_atomic_compare_exchange_strong(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp* __expected, _Tp __value, memory_order __success, memory_order __failure) noexcept {
    return __c11_atomic_compare_exchange_strong(&__a->__a_value, __expected, __value, static_cast<__memory_order_underlying_t>(__success), static_cast<__memory_order_underlying_t>(__to_failure_order(__failure)));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool __cxx_atomic_compare_exchange_strong(__cxx_atomic_base_impl<_Tp> * __a, _Tp* __expected, _Tp __value, memory_order __success, memory_order __failure) noexcept {
    return __c11_atomic_compare_exchange_strong(&__a->__a_value, __expected, __value, static_cast<__memory_order_underlying_t>(__success), static_cast<__memory_order_underlying_t>(__to_failure_order(__failure)));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool __cxx_atomic_compare_exchange_weak(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp* __expected, _Tp __value, memory_order __success, memory_order __failure) noexcept {
    return __c11_atomic_compare_exchange_weak(&__a->__a_value, __expected, __value, static_cast<__memory_order_underlying_t>(__success), static_cast<__memory_order_underlying_t>(__to_failure_order(__failure)));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool __cxx_atomic_compare_exchange_weak(__cxx_atomic_base_impl<_Tp> * __a, _Tp* __expected, _Tp __value, memory_order __success, memory_order __failure) noexcept {
    return __c11_atomic_compare_exchange_weak(&__a->__a_value, __expected, __value, static_cast<__memory_order_underlying_t>(__success), static_cast<__memory_order_underlying_t>(__to_failure_order(__failure)));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp __cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __delta, memory_order __order) noexcept {
    return __c11_atomic_fetch_add(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp __cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp> * __a, _Tp __delta, memory_order __order) noexcept {
    return __c11_atomic_fetch_add(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp* __cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp*> volatile* __a, ptrdiff_t __delta, memory_order __order) noexcept {
    return __c11_atomic_fetch_add(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp* __cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp*> * __a, ptrdiff_t __delta, memory_order __order) noexcept {
    return __c11_atomic_fetch_add(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp __cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __delta, memory_order __order) noexcept {
    return __c11_atomic_fetch_sub(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp __cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp> * __a, _Tp __delta, memory_order __order) noexcept {
    return __c11_atomic_fetch_sub(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp* __cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp*> volatile* __a, ptrdiff_t __delta, memory_order __order) noexcept {
    return __c11_atomic_fetch_sub(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp* __cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp*> * __a, ptrdiff_t __delta, memory_order __order) noexcept {
    return __c11_atomic_fetch_sub(&__a->__a_value, __delta, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp __cxx_atomic_fetch_and(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __pattern, memory_order __order) noexcept {
    return __c11_atomic_fetch_and(&__a->__a_value, __pattern, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp __cxx_atomic_fetch_and(__cxx_atomic_base_impl<_Tp> * __a, _Tp __pattern, memory_order __order) noexcept {
    return __c11_atomic_fetch_and(&__a->__a_value, __pattern, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp __cxx_atomic_fetch_or(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __pattern, memory_order __order) noexcept {
    return __c11_atomic_fetch_or(&__a->__a_value, __pattern, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp __cxx_atomic_fetch_or(__cxx_atomic_base_impl<_Tp> * __a, _Tp __pattern, memory_order __order) noexcept {
    return __c11_atomic_fetch_or(&__a->__a_value, __pattern, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp __cxx_atomic_fetch_xor(__cxx_atomic_base_impl<_Tp> volatile* __a, _Tp __pattern, memory_order __order) noexcept {
    return __c11_atomic_fetch_xor(&__a->__a_value, __pattern, static_cast<__memory_order_underlying_t>(__order));
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp __cxx_atomic_fetch_xor(__cxx_atomic_base_impl<_Tp> * __a, _Tp __pattern, memory_order __order) noexcept {
    return __c11_atomic_fetch_xor(&__a->__a_value, __pattern, static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp kill_dependency(_Tp __y) noexcept
{
    return __y;
}
template <class _Tp>
struct __libcpp_is_always_lock_free {
  static const bool __value = __atomic_always_lock_free(sizeof(_Tp), 0);
};
template <typename _Tp,
          typename _Base = __cxx_atomic_base_impl<_Tp> >
struct __cxx_atomic_impl : public _Base {
    static_assert(is_trivially_copyable<_Tp>::value,
      "std::atomic<T> requires that 'T' be a trivially copyable type");
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __cxx_atomic_impl() noexcept = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr explicit __cxx_atomic_impl(_Tp __value) noexcept
    : _Base(__value) {}
};
    using __cxx_contention_t = int64_t;
using __cxx_atomic_contention_t = __cxx_atomic_impl<__cxx_contention_t>;
__attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("default"))) void __cxx_atomic_notify_one(void const volatile*);
__attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("default"))) void __cxx_atomic_notify_all(void const volatile*);
__attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("default"))) __cxx_contention_t __libcpp_atomic_monitor(void const volatile*);
__attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("default"))) void __libcpp_atomic_wait(void const volatile*, __cxx_contention_t);
__attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("default"))) void __cxx_atomic_notify_one(__cxx_atomic_contention_t const volatile*);
__attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("default"))) void __cxx_atomic_notify_all(__cxx_atomic_contention_t const volatile*);
__attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("default"))) __cxx_contention_t __libcpp_atomic_monitor(__cxx_atomic_contention_t const volatile*);
__attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("default"))) void __libcpp_atomic_wait(__cxx_atomic_contention_t const volatile*, __cxx_contention_t);
template <class _Atp, class _Fn>
struct __libcpp_atomic_wait_backoff_impl {
    _Atp* __a;
    _Fn __test_fn;
    __attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0)))
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool operator()(chrono::nanoseconds __elapsed) const
    {
        if(__elapsed > chrono::microseconds(64))
        {
            auto const __monitor = std::__libcpp_atomic_monitor(__a);
            if(__test_fn())
                return true;
            std::__libcpp_atomic_wait(__a, __monitor);
        }
        else if(__elapsed > chrono::microseconds(4))
            __libcpp_thread_yield();
        else
            {}
        return false;
    }
};
template <class _Atp, class _Fn>
// added by concept-synth, original LN: 22454
requires
requires (_Fn f) { {f()} -> std::convertible_to<bool>; }
__attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0)))
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool __cxx_atomic_wait(_Atp* __a, _Fn && __test_fn)
{
    __libcpp_atomic_wait_backoff_impl<_Atp, typename decay<_Fn>::type> __backoff_fn = {__a, __test_fn};
    return std::__libcpp_thread_poll_with_backoff(__test_fn, __backoff_fn);
}
template <class _Atp, class _Tp>
struct __cxx_atomic_wait_test_fn_impl {
    _Atp* __a;
    _Tp __val;
    memory_order __order;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool operator()() const
    {
        return !std::__cxx_nonatomic_compare_equal(std::__cxx_atomic_load(__a, __order), __val);
    }
};
template <class _Atp, class _Tp>
__attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0)))
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool __cxx_atomic_wait(_Atp* __a, _Tp const __val, memory_order __order)
{
    __cxx_atomic_wait_test_fn_impl<_Atp, _Tp> __test_fn = {__a, __val, __order};
    return std::__cxx_atomic_wait(__a, __test_fn);
}
template <class _Tp, bool = is_integral<_Tp>::value && !is_same<_Tp, bool>::value>
struct __atomic_base
{
    mutable __cxx_atomic_impl<_Tp> __a_;
  static constexpr bool is_always_lock_free = __libcpp_is_always_lock_free<__cxx_atomic_impl<_Tp> >::__value;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool is_lock_free() const volatile noexcept
        {return __c11_atomic_is_lock_free(sizeof(_Tp));}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool is_lock_free() const noexcept
        {return static_cast<__atomic_base const volatile*>(this)->is_lock_free();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    void store(_Tp __d, memory_order __m = memory_order_seq_cst) volatile noexcept
      __attribute__((__diagnose_if__(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {std::__cxx_atomic_store(&__a_, __d, __m);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    void store(_Tp __d, memory_order __m = memory_order_seq_cst) noexcept
      __attribute__((__diagnose_if__(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {std::__cxx_atomic_store(&__a_, __d, __m);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp load(memory_order __m = memory_order_seq_cst) const volatile noexcept
      __attribute__((__diagnose_if__(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return std::__cxx_atomic_load(&__a_, __m);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp load(memory_order __m = memory_order_seq_cst) const noexcept
      __attribute__((__diagnose_if__(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return std::__cxx_atomic_load(&__a_, __m);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    operator _Tp() const volatile noexcept {return load();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    operator _Tp() const noexcept {return load();}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return std::__cxx_atomic_exchange(&__a_, __d, __m);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) noexcept
        {return std::__cxx_atomic_exchange(&__a_, __d, __m);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool compare_exchange_weak(_Tp& __e, _Tp __d,
                               memory_order __s, memory_order __f) volatile noexcept
      __attribute__((__diagnose_if__(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return std::__cxx_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool compare_exchange_weak(_Tp& __e, _Tp __d,
                               memory_order __s, memory_order __f) noexcept
      __attribute__((__diagnose_if__(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return std::__cxx_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool compare_exchange_strong(_Tp& __e, _Tp __d,
                                 memory_order __s, memory_order __f) volatile noexcept
      __attribute__((__diagnose_if__(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return std::__cxx_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool compare_exchange_strong(_Tp& __e, _Tp __d,
                                 memory_order __s, memory_order __f) noexcept
      __attribute__((__diagnose_if__(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
        {return std::__cxx_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool compare_exchange_weak(_Tp& __e, _Tp __d,
                              memory_order __m = memory_order_seq_cst) volatile noexcept
        {return std::__cxx_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool compare_exchange_weak(_Tp& __e, _Tp __d,
                               memory_order __m = memory_order_seq_cst) noexcept
        {return std::__cxx_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool compare_exchange_strong(_Tp& __e, _Tp __d,
                              memory_order __m = memory_order_seq_cst) volatile noexcept
        {return std::__cxx_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool compare_exchange_strong(_Tp& __e, _Tp __d,
                                 memory_order __m = memory_order_seq_cst) noexcept
        {return std::__cxx_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m);}
    __attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void wait(_Tp __v, memory_order __m = memory_order_seq_cst) const volatile noexcept
        {std::__cxx_atomic_wait(&__a_, __v, __m);}
    __attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void wait(_Tp __v, memory_order __m = memory_order_seq_cst) const noexcept
        {std::__cxx_atomic_wait(&__a_, __v, __m);}
    __attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void notify_one() volatile noexcept
        {std::__cxx_atomic_notify_one(&__a_);}
    __attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void notify_one() noexcept
        {std::__cxx_atomic_notify_one(&__a_);}
    __attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void notify_all() volatile noexcept
        {std::__cxx_atomic_notify_all(&__a_);}
    __attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void notify_all() noexcept
        {std::__cxx_atomic_notify_all(&__a_);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    __atomic_base() noexcept(is_nothrow_default_constructible_v<_Tp>) : __a_(_Tp()) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    __atomic_base(_Tp __d) noexcept : __a_(__d) {}
    __atomic_base(const __atomic_base&) = delete;
};
template <class _Tp, bool __b>
constexpr bool __atomic_base<_Tp, __b>::is_always_lock_free;
template <class _Tp>
struct __atomic_base<_Tp, true>
    : public __atomic_base<_Tp, false>
{
    typedef __atomic_base<_Tp, false> __base;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    __atomic_base() noexcept = default;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr __atomic_base(_Tp __d) noexcept : __base(__d) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return std::__cxx_atomic_fetch_add(&this->__a_, __op, __m);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        {return std::__cxx_atomic_fetch_add(&this->__a_, __op, __m);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return std::__cxx_atomic_fetch_sub(&this->__a_, __op, __m);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        {return std::__cxx_atomic_fetch_sub(&this->__a_, __op, __m);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return std::__cxx_atomic_fetch_and(&this->__a_, __op, __m);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        {return std::__cxx_atomic_fetch_and(&this->__a_, __op, __m);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return std::__cxx_atomic_fetch_or(&this->__a_, __op, __m);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        {return std::__cxx_atomic_fetch_or(&this->__a_, __op, __m);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) volatile noexcept
        {return std::__cxx_atomic_fetch_xor(&this->__a_, __op, __m);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept
        {return std::__cxx_atomic_fetch_xor(&this->__a_, __op, __m);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp operator++(int) volatile noexcept {return fetch_add(_Tp(1));}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp operator++(int) noexcept {return fetch_add(_Tp(1));}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp operator--(int) volatile noexcept {return fetch_sub(_Tp(1));}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp operator--(int) noexcept {return fetch_sub(_Tp(1));}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp operator++() volatile noexcept {return fetch_add(_Tp(1)) + _Tp(1);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp operator++() noexcept {return fetch_add(_Tp(1)) + _Tp(1);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp operator--() volatile noexcept {return fetch_sub(_Tp(1)) - _Tp(1);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp operator--() noexcept {return fetch_sub(_Tp(1)) - _Tp(1);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp operator+=(_Tp __op) volatile noexcept {return fetch_add(__op) + __op;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp operator+=(_Tp __op) noexcept {return fetch_add(__op) + __op;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp operator-=(_Tp __op) volatile noexcept {return fetch_sub(__op) - __op;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp operator-=(_Tp __op) noexcept {return fetch_sub(__op) - __op;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp operator&=(_Tp __op) volatile noexcept {return fetch_and(__op) & __op;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp operator&=(_Tp __op) noexcept {return fetch_and(__op) & __op;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp operator|=(_Tp __op) volatile noexcept {return fetch_or(__op) | __op;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp operator|=(_Tp __op) noexcept {return fetch_or(__op) | __op;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp operator^=(_Tp __op) volatile noexcept {return fetch_xor(__op) ^ __op;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp operator^=(_Tp __op) noexcept {return fetch_xor(__op) ^ __op;}
};
template <class _Tp>
struct atomic
    : public __atomic_base<_Tp>
{
    typedef __atomic_base<_Tp> __base;
    typedef _Tp value_type;
    typedef value_type difference_type;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    atomic() = default;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr atomic(_Tp __d) noexcept : __base(__d) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp operator=(_Tp __d) volatile noexcept
        {__base::store(__d); return __d;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp operator=(_Tp __d) noexcept
        {__base::store(__d); return __d;}
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;
};
template <class _Tp>
struct atomic<_Tp*>
    : public __atomic_base<_Tp*>
{
    typedef __atomic_base<_Tp*> __base;
    typedef _Tp* value_type;
    typedef ptrdiff_t difference_type;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    atomic() noexcept = default;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr atomic(_Tp* __d) noexcept : __base(__d) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp* operator=(_Tp* __d) volatile noexcept
        {__base::store(__d); return __d;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp* operator=(_Tp* __d) noexcept
        {__base::store(__d); return __d;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp* fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) volatile noexcept {
        static_assert(!is_function<__remove_pointer_t<_Tp> >::value, "Pointer to function isn't allowed");
        return std::__cxx_atomic_fetch_add(&this->__a_, __op, __m);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp* fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) noexcept {
        static_assert(!is_function<__remove_pointer_t<_Tp> >::value, "Pointer to function isn't allowed");
        return std::__cxx_atomic_fetch_add(&this->__a_, __op, __m);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp* fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) volatile noexcept {
        static_assert(!is_function<__remove_pointer_t<_Tp> >::value, "Pointer to function isn't allowed");
        return std::__cxx_atomic_fetch_sub(&this->__a_, __op, __m);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp* fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) noexcept {
        static_assert(!is_function<__remove_pointer_t<_Tp> >::value, "Pointer to function isn't allowed");
        return std::__cxx_atomic_fetch_sub(&this->__a_, __op, __m);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp* operator++(int) volatile noexcept {return fetch_add(1);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp* operator++(int) noexcept {return fetch_add(1);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp* operator--(int) volatile noexcept {return fetch_sub(1);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp* operator--(int) noexcept {return fetch_sub(1);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp* operator++() volatile noexcept {return fetch_add(1) + 1;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp* operator++() noexcept {return fetch_add(1) + 1;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp* operator--() volatile noexcept {return fetch_sub(1) - 1;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp* operator--() noexcept {return fetch_sub(1) - 1;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp* operator+=(ptrdiff_t __op) volatile noexcept {return fetch_add(__op) + __op;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp* operator+=(ptrdiff_t __op) noexcept {return fetch_add(__op) + __op;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp* operator-=(ptrdiff_t __op) volatile noexcept {return fetch_sub(__op) - __op;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp* operator-=(ptrdiff_t __op) noexcept {return fetch_sub(__op) - __op;}
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;
};
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool
atomic_is_lock_free(const volatile atomic<_Tp>* __o) noexcept
{
    return __o->is_lock_free();
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool
atomic_is_lock_free(const atomic<_Tp>* __o) noexcept
{
    return __o->is_lock_free();
}
template <class _Tp>
__attribute__((deprecated)) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void
atomic_init(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d) noexcept
{
    std::__cxx_atomic_init(&__o->__a_, __d);
}
template <class _Tp>
__attribute__((deprecated)) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void
atomic_init(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d) noexcept
{
    std::__cxx_atomic_init(&__o->__a_, __d);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void
atomic_store(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d) noexcept
{
    __o->store(__d);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void
atomic_store(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d) noexcept
{
    __o->store(__d);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void
atomic_store_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d, memory_order __m) noexcept
  __attribute__((__diagnose_if__(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    __o->store(__d, __m);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void
atomic_store_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d, memory_order __m) noexcept
  __attribute__((__diagnose_if__(__m == memory_order_consume || __m == memory_order_acquire || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    __o->store(__d, __m);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp
atomic_load(const volatile atomic<_Tp>* __o) noexcept
{
    return __o->load();
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp
atomic_load(const atomic<_Tp>* __o) noexcept
{
    return __o->load();
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp
atomic_load_explicit(const volatile atomic<_Tp>* __o, memory_order __m) noexcept
  __attribute__((__diagnose_if__(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->load(__m);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp
atomic_load_explicit(const atomic<_Tp>* __o, memory_order __m) noexcept
  __attribute__((__diagnose_if__(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->load(__m);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp
atomic_exchange(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d) noexcept
{
    return __o->exchange(__d);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp
atomic_exchange(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d) noexcept
{
    return __o->exchange(__d);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp
atomic_exchange_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d, memory_order __m) noexcept
{
    return __o->exchange(__d, __m);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp
atomic_exchange_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __d, memory_order __m) noexcept
{
    return __o->exchange(__d, __m);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool
atomic_compare_exchange_weak(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type* __e, typename atomic<_Tp>::value_type __d) noexcept
{
    return __o->compare_exchange_weak(*__e, __d);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool
atomic_compare_exchange_weak(atomic<_Tp>* __o, typename atomic<_Tp>::value_type* __e, typename atomic<_Tp>::value_type __d) noexcept
{
    return __o->compare_exchange_weak(*__e, __d);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool
atomic_compare_exchange_strong(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type* __e, typename atomic<_Tp>::value_type __d) noexcept
{
    return __o->compare_exchange_strong(*__e, __d);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool
atomic_compare_exchange_strong(atomic<_Tp>* __o, typename atomic<_Tp>::value_type* __e, typename atomic<_Tp>::value_type __d) noexcept
{
    return __o->compare_exchange_strong(*__e, __d);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool
atomic_compare_exchange_weak_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type* __e,
                                      typename atomic<_Tp>::value_type __d,
                                      memory_order __s, memory_order __f) noexcept
  __attribute__((__diagnose_if__(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->compare_exchange_weak(*__e, __d, __s, __f);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool
atomic_compare_exchange_weak_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::value_type* __e, typename atomic<_Tp>::value_type __d,
                                      memory_order __s, memory_order __f) noexcept
  __attribute__((__diagnose_if__(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->compare_exchange_weak(*__e, __d, __s, __f);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool
atomic_compare_exchange_strong_explicit(volatile atomic<_Tp>* __o,
                                        typename atomic<_Tp>::value_type* __e, typename atomic<_Tp>::value_type __d,
                                        memory_order __s, memory_order __f) noexcept
  __attribute__((__diagnose_if__(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->compare_exchange_strong(*__e, __d, __s, __f);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool
atomic_compare_exchange_strong_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::value_type* __e,
                                        typename atomic<_Tp>::value_type __d,
                                        memory_order __s, memory_order __f) noexcept
  __attribute__((__diagnose_if__(__f == memory_order_release || __f == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->compare_exchange_strong(*__e, __d, __s, __f);
}
template <class _Tp>
__attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void atomic_wait(const volatile atomic<_Tp>* __o,
                 typename atomic<_Tp>::value_type __v) noexcept
{
    return __o->wait(__v);
}
template <class _Tp>
__attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void atomic_wait(const atomic<_Tp>* __o,
                 typename atomic<_Tp>::value_type __v) noexcept
{
    return __o->wait(__v);
}
template <class _Tp>
__attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void atomic_wait_explicit(const volatile atomic<_Tp>* __o,
                          typename atomic<_Tp>::value_type __v,
                          memory_order __m) noexcept
  __attribute__((__diagnose_if__(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->wait(__v, __m);
}
template <class _Tp>
__attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void atomic_wait_explicit(const atomic<_Tp>* __o,
                          typename atomic<_Tp>::value_type __v,
                          memory_order __m) noexcept
  __attribute__((__diagnose_if__(__m == memory_order_release || __m == memory_order_acq_rel, "memory order argument to atomic operation is invalid", "warning")))
{
    return __o->wait(__v, __m);
}
template <class _Tp>
__attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void atomic_notify_one(volatile atomic<_Tp>* __o) noexcept
{
    __o->notify_one();
}
template <class _Tp>
__attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void atomic_notify_one(atomic<_Tp>* __o) noexcept
{
    __o->notify_one();
}
template <class _Tp>
__attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void atomic_notify_all(volatile atomic<_Tp>* __o) noexcept
{
    __o->notify_all();
}
template <class _Tp>
__attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void atomic_notify_all(atomic<_Tp>* __o) noexcept
{
    __o->notify_all();
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp
atomic_fetch_add(volatile atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op) noexcept
{
    return __o->fetch_add(__op);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp
atomic_fetch_add(atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op) noexcept
{
    return __o->fetch_add(__op);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp atomic_fetch_add_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op, memory_order __m) noexcept
{
    return __o->fetch_add(__op, __m);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp atomic_fetch_add_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op, memory_order __m) noexcept
{
    return __o->fetch_add(__op, __m);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp atomic_fetch_sub(volatile atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op) noexcept
{
    return __o->fetch_sub(__op);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp atomic_fetch_sub(atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op) noexcept
{
    return __o->fetch_sub(__op);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp atomic_fetch_sub_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op, memory_order __m) noexcept
{
    return __o->fetch_sub(__op, __m);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Tp atomic_fetch_sub_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::difference_type __op, memory_order __m) noexcept
{
    return __o->fetch_sub(__op, __m);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_and(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op) noexcept
{
    return __o->fetch_and(__op);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_and(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op) noexcept
{
    return __o->fetch_and(__op);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_and_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op, memory_order __m) noexcept
{
    return __o->fetch_and(__op, __m);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_and_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op, memory_order __m) noexcept
{
    return __o->fetch_and(__op, __m);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_or(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op) noexcept
{
    return __o->fetch_or(__op);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_or(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op) noexcept
{
    return __o->fetch_or(__op);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_or_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op, memory_order __m) noexcept
{
    return __o->fetch_or(__op, __m);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_or_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op, memory_order __m) noexcept
{
    return __o->fetch_or(__op, __m);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_xor(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op) noexcept
{
    return __o->fetch_xor(__op);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_xor(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op) noexcept
{
    return __o->fetch_xor(__op);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_xor_explicit(volatile atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op, memory_order __m) noexcept
{
    return __o->fetch_xor(__op, __m);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename enable_if
<
    is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
    _Tp
>::type
atomic_fetch_xor_explicit(atomic<_Tp>* __o, typename atomic<_Tp>::value_type __op, memory_order __m) noexcept
{
    return __o->fetch_xor(__op, __m);
}
typedef struct atomic_flag
{
    __cxx_atomic_impl<bool> __a_;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool test(memory_order __m = memory_order_seq_cst) const volatile noexcept
        {return bool(true) == __cxx_atomic_load(&__a_, __m);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool test(memory_order __m = memory_order_seq_cst) const noexcept
        {return bool(true) == __cxx_atomic_load(&__a_, __m);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool test_and_set(memory_order __m = memory_order_seq_cst) volatile noexcept
        {return __cxx_atomic_exchange(&__a_, bool(true), __m);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool test_and_set(memory_order __m = memory_order_seq_cst) noexcept
        {return __cxx_atomic_exchange(&__a_, bool(true), __m);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    void clear(memory_order __m = memory_order_seq_cst) volatile noexcept
        {__cxx_atomic_store(&__a_, bool(false), __m);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    void clear(memory_order __m = memory_order_seq_cst) noexcept
        {__cxx_atomic_store(&__a_, bool(false), __m);}
    __attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    void wait(bool __v, memory_order __m = memory_order_seq_cst) const volatile noexcept
        {__cxx_atomic_wait(&__a_, bool(__v), __m);}
    __attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    void wait(bool __v, memory_order __m = memory_order_seq_cst) const noexcept
        {__cxx_atomic_wait(&__a_, bool(__v), __m);}
    __attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    void notify_one() volatile noexcept
        {__cxx_atomic_notify_one(&__a_);}
    __attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    void notify_one() noexcept
        {__cxx_atomic_notify_one(&__a_);}
    __attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    void notify_all() volatile noexcept
        {__cxx_atomic_notify_all(&__a_);}
    __attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0))) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    void notify_all() noexcept
        {__cxx_atomic_notify_all(&__a_);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    atomic_flag() noexcept : __a_(false) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    atomic_flag(bool __b) noexcept : __a_(__b) {}
    atomic_flag(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) volatile = delete;
} atomic_flag;
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool
atomic_flag_test(const volatile atomic_flag* __o) noexcept
{
    return __o->test();
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool
atomic_flag_test(const atomic_flag* __o) noexcept
{
    return __o->test();
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool
atomic_flag_test_explicit(const volatile atomic_flag* __o, memory_order __m) noexcept
{
    return __o->test(__m);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool
atomic_flag_test_explicit(const atomic_flag* __o, memory_order __m) noexcept
{
    return __o->test(__m);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool
atomic_flag_test_and_set(volatile atomic_flag* __o) noexcept
{
    return __o->test_and_set();
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool
atomic_flag_test_and_set(atomic_flag* __o) noexcept
{
    return __o->test_and_set();
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool
atomic_flag_test_and_set_explicit(volatile atomic_flag* __o, memory_order __m) noexcept
{
    return __o->test_and_set(__m);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool
atomic_flag_test_and_set_explicit(atomic_flag* __o, memory_order __m) noexcept
{
    return __o->test_and_set(__m);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void
atomic_flag_clear(volatile atomic_flag* __o) noexcept
{
    __o->clear();
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void
atomic_flag_clear(atomic_flag* __o) noexcept
{
    __o->clear();
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void
atomic_flag_clear_explicit(volatile atomic_flag* __o, memory_order __m) noexcept
{
    __o->clear(__m);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void
atomic_flag_clear_explicit(atomic_flag* __o, memory_order __m) noexcept
{
    __o->clear(__m);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0)))
void
atomic_flag_wait(const volatile atomic_flag* __o, bool __v) noexcept
{
    __o->wait(__v);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0)))
void
atomic_flag_wait(const atomic_flag* __o, bool __v) noexcept
{
    __o->wait(__v);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0)))
void
atomic_flag_wait_explicit(const volatile atomic_flag* __o,
                          bool __v, memory_order __m) noexcept
{
    __o->wait(__v, __m);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0)))
void
atomic_flag_wait_explicit(const atomic_flag* __o,
                          bool __v, memory_order __m) noexcept
{
    __o->wait(__v, __m);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0)))
void
atomic_flag_notify_one(volatile atomic_flag* __o) noexcept
{
    __o->notify_one();
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0)))
void
atomic_flag_notify_one(atomic_flag* __o) noexcept
{
    __o->notify_one();
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0)))
void
atomic_flag_notify_all(volatile atomic_flag* __o) noexcept
{
    __o->notify_all();
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((availability(macos,strict,introduced=11.0))) __attribute__((availability(ios,strict,introduced=14.0))) __attribute__((availability(tvos,strict,introduced=14.0))) __attribute__((availability(watchos,strict,introduced=7.0)))
void
atomic_flag_notify_all(atomic_flag* __o) noexcept
{
    __o->notify_all();
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void
atomic_thread_fence(memory_order __m) noexcept
{
    __cxx_atomic_thread_fence(__m);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void
atomic_signal_fence(memory_order __m) noexcept
{
    __cxx_atomic_signal_fence(__m);
}
typedef atomic<bool> atomic_bool;
typedef atomic<char> atomic_char;
typedef atomic<signed char> atomic_schar;
typedef atomic<unsigned char> atomic_uchar;
typedef atomic<short> atomic_short;
typedef atomic<unsigned short> atomic_ushort;
typedef atomic<int> atomic_int;
typedef atomic<unsigned int> atomic_uint;
typedef atomic<long> atomic_long;
typedef atomic<unsigned long> atomic_ulong;
typedef atomic<long long> atomic_llong;
typedef atomic<unsigned long long> atomic_ullong;
typedef atomic<char8_t> atomic_char8_t;
typedef atomic<char16_t> atomic_char16_t;
typedef atomic<char32_t> atomic_char32_t;
typedef atomic<wchar_t> atomic_wchar_t;
typedef atomic<int_least8_t> atomic_int_least8_t;
typedef atomic<uint_least8_t> atomic_uint_least8_t;
typedef atomic<int_least16_t> atomic_int_least16_t;
typedef atomic<uint_least16_t> atomic_uint_least16_t;
typedef atomic<int_least32_t> atomic_int_least32_t;
typedef atomic<uint_least32_t> atomic_uint_least32_t;
typedef atomic<int_least64_t> atomic_int_least64_t;
typedef atomic<uint_least64_t> atomic_uint_least64_t;
typedef atomic<int_fast8_t> atomic_int_fast8_t;
typedef atomic<uint_fast8_t> atomic_uint_fast8_t;
typedef atomic<int_fast16_t> atomic_int_fast16_t;
typedef atomic<uint_fast16_t> atomic_uint_fast16_t;
typedef atomic<int_fast32_t> atomic_int_fast32_t;
typedef atomic<uint_fast32_t> atomic_uint_fast32_t;
typedef atomic<int_fast64_t> atomic_int_fast64_t;
typedef atomic<uint_fast64_t> atomic_uint_fast64_t;
typedef atomic< int8_t> atomic_int8_t;
typedef atomic<uint8_t> atomic_uint8_t;
typedef atomic< int16_t> atomic_int16_t;
typedef atomic<uint16_t> atomic_uint16_t;
typedef atomic< int32_t> atomic_int32_t;
typedef atomic<uint32_t> atomic_uint32_t;
typedef atomic< int64_t> atomic_int64_t;
typedef atomic<uint64_t> atomic_uint64_t;
typedef atomic<intptr_t> atomic_intptr_t;
typedef atomic<uintptr_t> atomic_uintptr_t;
typedef atomic<size_t> atomic_size_t;
typedef atomic<ptrdiff_t> atomic_ptrdiff_t;
typedef atomic<intmax_t> atomic_intmax_t;
typedef atomic<uintmax_t> atomic_uintmax_t;
typedef __conditional_t< ::std::__libcpp_is_always_lock_free<__cxx_contention_t>::__value, __cxx_contention_t, long long> __libcpp_signed_lock_free;
typedef __conditional_t< ::std::__libcpp_is_always_lock_free<__cxx_contention_t>::__value, __cxx_contention_t, unsigned long long> __libcpp_unsigned_lock_free;
typedef atomic<__libcpp_signed_lock_free> atomic_signed_lock_free;
typedef atomic<__libcpp_unsigned_lock_free> atomic_unsigned_lock_free;
}}
extern "C" {
    typedef float float_t;
    typedef double double_t;
extern int __math_errhandling(void);
extern int __fpclassifyf(float);
extern int __fpclassifyd(double);
extern int __fpclassifyl(long double);
inline __attribute__ ((__always_inline__)) int __inline_isfinitef(float);
inline __attribute__ ((__always_inline__)) int __inline_isfinited(double);
inline __attribute__ ((__always_inline__)) int __inline_isfinitel(long double);
inline __attribute__ ((__always_inline__)) int __inline_isinff(float);
inline __attribute__ ((__always_inline__)) int __inline_isinfd(double);
inline __attribute__ ((__always_inline__)) int __inline_isinfl(long double);
inline __attribute__ ((__always_inline__)) int __inline_isnanf(float);
inline __attribute__ ((__always_inline__)) int __inline_isnand(double);
inline __attribute__ ((__always_inline__)) int __inline_isnanl(long double);
inline __attribute__ ((__always_inline__)) int __inline_isnormalf(float);
inline __attribute__ ((__always_inline__)) int __inline_isnormald(double);
inline __attribute__ ((__always_inline__)) int __inline_isnormall(long double);
inline __attribute__ ((__always_inline__)) int __inline_signbitf(float);
inline __attribute__ ((__always_inline__)) int __inline_signbitd(double);
inline __attribute__ ((__always_inline__)) int __inline_signbitl(long double);
inline __attribute__ ((__always_inline__)) int __inline_isfinitef(float __x) {
    return __x == __x && __builtin_fabsf(__x) != __builtin_inff();
}
inline __attribute__ ((__always_inline__)) int __inline_isfinited(double __x) {
    return __x == __x && __builtin_fabs(__x) != __builtin_inf();
}
inline __attribute__ ((__always_inline__)) int __inline_isfinitel(long double __x) {
    return __x == __x && __builtin_fabsl(__x) != __builtin_infl();
}
inline __attribute__ ((__always_inline__)) int __inline_isinff(float __x) {
    return __builtin_fabsf(__x) == __builtin_inff();
}
inline __attribute__ ((__always_inline__)) int __inline_isinfd(double __x) {
    return __builtin_fabs(__x) == __builtin_inf();
}
inline __attribute__ ((__always_inline__)) int __inline_isinfl(long double __x) {
    return __builtin_fabsl(__x) == __builtin_infl();
}
inline __attribute__ ((__always_inline__)) int __inline_isnanf(float __x) {
    return __x != __x;
}
inline __attribute__ ((__always_inline__)) int __inline_isnand(double __x) {
    return __x != __x;
}
inline __attribute__ ((__always_inline__)) int __inline_isnanl(long double __x) {
    return __x != __x;
}
inline __attribute__ ((__always_inline__)) int __inline_signbitf(float __x) {
    union { float __f; unsigned int __u; } __u;
    __u.__f = __x;
    return (int)(__u.__u >> 31);
}
inline __attribute__ ((__always_inline__)) int __inline_signbitd(double __x) {
    union { double __f; unsigned long long __u; } __u;
    __u.__f = __x;
    return (int)(__u.__u >> 63);
}
inline __attribute__ ((__always_inline__)) int __inline_signbitl(long double __x) {
    union { long double __f; unsigned long long __u;} __u;
    __u.__f = __x;
    return (int)(__u.__u >> 63);
}
inline __attribute__ ((__always_inline__)) int __inline_isnormalf(float __x) {
    return __inline_isfinitef(__x) && __builtin_fabsf(__x) >= 1.17549435e-38F;
}
inline __attribute__ ((__always_inline__)) int __inline_isnormald(double __x) {
    return __inline_isfinited(__x) && __builtin_fabs(__x) >= 2.2250738585072014e-308;
}
inline __attribute__ ((__always_inline__)) int __inline_isnormall(long double __x) {
    return __inline_isfinitel(__x) && __builtin_fabsl(__x) >= 2.2250738585072014e-308L;
}
extern float acosf(float);
extern double acos(double);
extern long double acosl(long double);
extern float asinf(float);
extern double asin(double);
extern long double asinl(long double);
extern float atanf(float);
extern double atan(double);
extern long double atanl(long double);
extern float atan2f(float, float);
extern double atan2(double, double);
extern long double atan2l(long double, long double);
extern float cosf(float);
extern double cos(double);
extern long double cosl(long double);
extern float sinf(float);
extern double sin(double);
extern long double sinl(long double);
extern float tanf(float);
extern double tan(double);
extern long double tanl(long double);
extern float acoshf(float);
extern double acosh(double);
extern long double acoshl(long double);
extern float asinhf(float);
extern double asinh(double);
extern long double asinhl(long double);
extern float atanhf(float);
extern double atanh(double);
extern long double atanhl(long double);
extern float coshf(float);
extern double cosh(double);
extern long double coshl(long double);
extern float sinhf(float);
extern double sinh(double);
extern long double sinhl(long double);
extern float tanhf(float);
extern double tanh(double);
extern long double tanhl(long double);
extern float expf(float);
extern double exp(double);
extern long double expl(long double);
extern float exp2f(float);
extern double exp2(double);
extern long double exp2l(long double);
extern float expm1f(float);
extern double expm1(double);
extern long double expm1l(long double);
extern float logf(float);
extern double log(double);
extern long double logl(long double);
extern float log10f(float);
extern double log10(double);
extern long double log10l(long double);
extern float log2f(float);
extern double log2(double);
extern long double log2l(long double);
extern float log1pf(float);
extern double log1p(double);
extern long double log1pl(long double);
extern float logbf(float);
extern double logb(double);
extern long double logbl(long double);
extern float modff(float, float *);
extern double modf(double, double *);
extern long double modfl(long double, long double *);
extern float ldexpf(float, int);
extern double ldexp(double, int);
extern long double ldexpl(long double, int);
extern float frexpf(float, int *);
extern double frexp(double, int *);
extern long double frexpl(long double, int *);
extern int ilogbf(float);
extern int ilogb(double);
extern int ilogbl(long double);
extern float scalbnf(float, int);
extern double scalbn(double, int);
extern long double scalbnl(long double, int);
extern float scalblnf(float, long int);
extern double scalbln(double, long int);
extern long double scalblnl(long double, long int);
extern float fabsf(float);
extern double fabs(double);
extern long double fabsl(long double);
extern float cbrtf(float);
extern double cbrt(double);
extern long double cbrtl(long double);
extern float hypotf(float, float);
extern double hypot(double, double);
extern long double hypotl(long double, long double);
extern float powf(float, float);
extern double pow(double, double);
extern long double powl(long double, long double);
extern float sqrtf(float);
extern double sqrt(double);
extern long double sqrtl(long double);
extern float erff(float);
extern double erf(double);
extern long double erfl(long double);
extern float erfcf(float);
extern double erfc(double);
extern long double erfcl(long double);
extern float lgammaf(float);
extern double lgamma(double);
extern long double lgammal(long double);
extern float tgammaf(float);
extern double tgamma(double);
extern long double tgammal(long double);
extern float ceilf(float);
extern double ceil(double);
extern long double ceill(long double);
extern float floorf(float);
extern double floor(double);
extern long double floorl(long double);
extern float nearbyintf(float);
extern double nearbyint(double);
extern long double nearbyintl(long double);
extern float rintf(float);
extern double rint(double);
extern long double rintl(long double);
extern long int lrintf(float);
extern long int lrint(double);
extern long int lrintl(long double);
extern float roundf(float);
extern double round(double);
extern long double roundl(long double);
extern long int lroundf(float);
extern long int lround(double);
extern long int lroundl(long double);
extern long long int llrintf(float);
extern long long int llrint(double);
extern long long int llrintl(long double);
extern long long int llroundf(float);
extern long long int llround(double);
extern long long int llroundl(long double);
extern float truncf(float);
extern double trunc(double);
extern long double truncl(long double);
extern float fmodf(float, float);
extern double fmod(double, double);
extern long double fmodl(long double, long double);
extern float remainderf(float, float);
extern double remainder(double, double);
extern long double remainderl(long double, long double);
extern float remquof(float, float, int *);
extern double remquo(double, double, int *);
extern long double remquol(long double, long double, int *);
extern float copysignf(float, float);
extern double copysign(double, double);
extern long double copysignl(long double, long double);
extern float nanf(const char *);
extern double nan(const char *);
extern long double nanl(const char *);
extern float nextafterf(float, float);
extern double nextafter(double, double);
extern long double nextafterl(long double, long double);
extern double nexttoward(double, long double);
extern float nexttowardf(float, long double);
extern long double nexttowardl(long double, long double);
extern float fdimf(float, float);
extern double fdim(double, double);
extern long double fdiml(long double, long double);
extern float fmaxf(float, float);
extern double fmax(double, double);
extern long double fmaxl(long double, long double);
extern float fminf(float, float);
extern double fmin(double, double);
extern long double fminl(long double, long double);
extern float fmaf(float, float, float);
extern double fma(double, double, double);
extern long double fmal(long double, long double, long double);
extern float __exp10f(float) __attribute__((availability(macos,introduced=10.9))) __attribute__((availability(ios,introduced=7.0)));
extern double __exp10(double) __attribute__((availability(macos,introduced=10.9))) __attribute__((availability(ios,introduced=7.0)));
inline __attribute__ ((__always_inline__)) void __sincosf(float __x, float *__sinp, float *__cosp);
inline __attribute__ ((__always_inline__)) void __sincos(double __x, double *__sinp, double *__cosp);
extern float __cospif(float) __attribute__((availability(macos,introduced=10.9))) __attribute__((availability(ios,introduced=7.0)));
extern double __cospi(double) __attribute__((availability(macos,introduced=10.9))) __attribute__((availability(ios,introduced=7.0)));
extern float __sinpif(float) __attribute__((availability(macos,introduced=10.9))) __attribute__((availability(ios,introduced=7.0)));
extern double __sinpi(double) __attribute__((availability(macos,introduced=10.9))) __attribute__((availability(ios,introduced=7.0)));
extern float __tanpif(float) __attribute__((availability(macos,introduced=10.9))) __attribute__((availability(ios,introduced=7.0)));
extern double __tanpi(double) __attribute__((availability(macos,introduced=10.9))) __attribute__((availability(ios,introduced=7.0)));
inline __attribute__ ((__always_inline__)) void __sincospif(float __x, float *__sinp, float *__cosp);
inline __attribute__ ((__always_inline__)) void __sincospi(double __x, double *__sinp, double *__cosp);
struct __float2 { float __sinval; float __cosval; };
struct __double2 { double __sinval; double __cosval; };
extern struct __float2 __sincosf_stret(float);
extern struct __double2 __sincos_stret(double);
extern struct __float2 __sincospif_stret(float);
extern struct __double2 __sincospi_stret(double);
inline __attribute__ ((__always_inline__)) void __sincosf(float __x, float *__sinp, float *__cosp) {
    const struct __float2 __stret = __sincosf_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}
inline __attribute__ ((__always_inline__)) void __sincos(double __x, double *__sinp, double *__cosp) {
    const struct __double2 __stret = __sincos_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}
inline __attribute__ ((__always_inline__)) void __sincospif(float __x, float *__sinp, float *__cosp) {
    const struct __float2 __stret = __sincospif_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}
inline __attribute__ ((__always_inline__)) void __sincospi(double __x, double *__sinp, double *__cosp) {
    const struct __double2 __stret = __sincospi_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}
extern double j0(double) __attribute__((availability(macos,introduced=10.0))) __attribute__((availability(ios,introduced=3.2)));
extern double j1(double) __attribute__((availability(macos,introduced=10.0))) __attribute__((availability(ios,introduced=3.2)));
extern double jn(int, double) __attribute__((availability(macos,introduced=10.0))) __attribute__((availability(ios,introduced=3.2)));
extern double y0(double) __attribute__((availability(macos,introduced=10.0))) __attribute__((availability(ios,introduced=3.2)));
extern double y1(double) __attribute__((availability(macos,introduced=10.0))) __attribute__((availability(ios,introduced=3.2)));
extern double yn(int, double) __attribute__((availability(macos,introduced=10.0))) __attribute__((availability(ios,introduced=3.2)));
extern double scalb(double, double);
extern int signgam;
}
extern "C++" {
namespace std { inline namespace __1 {
template <class _Tp>
struct __numeric_type
{
   static void __test(...);
   static float __test(float);
   static double __test(char);
   static double __test(int);
   static double __test(unsigned);
   static double __test(long);
   static double __test(unsigned long);
   static double __test(long long);
   static double __test(unsigned long long);
   static double __test(__int128_t);
   static double __test(__uint128_t);
   static double __test(double);
   static long double __test(long double);
   typedef decltype(__test(std::declval<_Tp>())) type;
   static const bool value = _IsNotSame<type, void>::value;
};
template <>
struct __numeric_type<void>
{
   static const bool value = true;
};
template <class _A1, class _A2 = void, class _A3 = void,
          bool = __numeric_type<_A1>::value &&
                 __numeric_type<_A2>::value &&
                 __numeric_type<_A3>::value>
class __promote_imp
{
public:
    static const bool value = false;
};
template <class _A1, class _A2, class _A3>
class __promote_imp<_A1, _A2, _A3, true>
{
private:
    typedef typename __promote_imp<_A1>::type __type1;
    typedef typename __promote_imp<_A2>::type __type2;
    typedef typename __promote_imp<_A3>::type __type3;
public:
    typedef decltype(__type1() + __type2() + __type3()) type;
    static const bool value = true;
};
template <class _A1, class _A2>
class __promote_imp<_A1, _A2, void, true>
{
private:
    typedef typename __promote_imp<_A1>::type __type1;
    typedef typename __promote_imp<_A2>::type __type2;
public:
    typedef decltype(__type1() + __type2()) type;
    static const bool value = true;
};
template <class _A1>
class __promote_imp<_A1, void, void, true>
{
public:
    typedef typename __numeric_type<_A1>::type type;
    static const bool value = true;
};
template <class _A1, class _A2 = void, class _A3 = void>
class __promote : public __promote_imp<_A1, _A2, _A3> {};
}}

template <class _A1, std::__enable_if_t<std::is_floating_point<_A1>::value, int> = 0>
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool signbit(_A1 __x) noexcept {
  return __builtin_signbit(__x);
}
template <class _A1, std::__enable_if_t<std::is_integral<_A1>::value && std::is_signed<_A1>::value, int> = 0>
// added by concept-synth, original LN: 23742
requires
requires (_A1 x0, int x1) { x0 < x1; }
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool signbit(_A1 __x) noexcept {
  return __x < 0;
}
template <class _A1, std::__enable_if_t<std::is_integral<_A1>::value && !std::is_signed<_A1>::value, int> = 0>
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool signbit(_A1) noexcept {
  return false;
}
template <class _A1, std::__enable_if_t<std::is_floating_point<_A1>::value, int> = 0>
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) int fpclassify(_A1 __x) noexcept {
  return __builtin_fpclassify(1, 2, 4, 5, 3, __x);
}
template <class _A1, std::__enable_if_t<std::is_integral<_A1>::value, int> = 0>
// added by concept-synth, original LN: 23754
requires
requires (_A1 x0, int x1) { x0 == x1; }
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) int fpclassify(_A1 __x) noexcept {
  return __x == 0 ? 3 : 4;
}
template <class _A1,
          std::__enable_if_t<std::is_arithmetic<_A1>::value && std::numeric_limits<_A1>::has_infinity, int> = 0>
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool isfinite(_A1 __x) noexcept {
  return __builtin_isfinite((typename std::__promote<_A1>::type)__x);
}
template <class _A1,
          std::__enable_if_t<std::is_arithmetic<_A1>::value && !std::numeric_limits<_A1>::has_infinity, int> = 0>
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool isfinite(_A1) noexcept {
  return true;
}
template <class _A1,
          std::__enable_if_t<std::is_arithmetic<_A1>::value && std::numeric_limits<_A1>::has_infinity, int> = 0>
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool isinf(_A1 __x) noexcept {
  return __builtin_isinf((typename std::__promote<_A1>::type)__x);
}
template <class _A1>
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    typename std::enable_if< std::is_arithmetic<_A1>::value && !std::numeric_limits<_A1>::has_infinity, bool>::type
    isinf(_A1) noexcept {
  return false;
}
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool isinf(float __x) noexcept {
  return __builtin_isinf(__x);
}
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__enable_if__(true, ""))) bool isinf(double __x) noexcept {
  return __builtin_isinf(__x);
}
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool isinf(long double __x) noexcept {
  return __builtin_isinf(__x);
}
template <class _A1, std::__enable_if_t<std::is_floating_point<_A1>::value, int> = 0>
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool isnan(_A1 __x) noexcept {
  return __builtin_isnan(__x);
}
template <class _A1, std::__enable_if_t<std::is_integral<_A1>::value, int> = 0>
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool isnan(_A1) noexcept {
  return false;
}
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool isnan(float __x) noexcept {
  return __builtin_isnan(__x);
}
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__enable_if__(true, ""))) bool isnan(double __x) noexcept {
  return __builtin_isnan(__x);
}
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool isnan(long double __x) noexcept {
  return __builtin_isnan(__x);
}
template <class _A1, std::__enable_if_t<std::is_floating_point<_A1>::value, int> = 0>
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool isnormal(_A1 __x) noexcept {
  return __builtin_isnormal(__x);
}
template <class _A1, std::__enable_if_t<std::is_integral<_A1>::value, int> = 0>
// added by concept-synth, original LN: 23809
requires
requires (_A1 x0, int x1) { x0 != x1; }
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool isnormal(_A1 __x) noexcept {
  return __x != 0;
}
template <class _A1,
          class _A2,
          std::__enable_if_t<std::is_arithmetic<_A1>::value && std::is_arithmetic<_A2>::value, int> = 0>
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool isgreater(_A1 __x, _A2 __y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type type;
  return __builtin_isgreater((type)__x, (type)__y);
}
template <class _A1,
          class _A2,
          std::__enable_if_t<std::is_arithmetic<_A1>::value && std::is_arithmetic<_A2>::value, int> = 0>
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool isgreaterequal(_A1 __x, _A2 __y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type type;
  return __builtin_isgreaterequal((type)__x, (type)__y);
}
template <class _A1,
          class _A2,
          std::__enable_if_t<std::is_arithmetic<_A1>::value && std::is_arithmetic<_A2>::value, int> = 0>
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool isless(_A1 __x, _A2 __y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type type;
  return __builtin_isless((type)__x, (type)__y);
}
template <class _A1,
          class _A2,
          std::__enable_if_t<std::is_arithmetic<_A1>::value && std::is_arithmetic<_A2>::value, int> = 0>
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool islessequal(_A1 __x, _A2 __y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type type;
  return __builtin_islessequal((type)__x, (type)__y);
}
template <class _A1,
          class _A2,
          std::__enable_if_t<std::is_arithmetic<_A1>::value && std::is_arithmetic<_A2>::value, int> = 0>
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool islessgreater(_A1 __x, _A2 __y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type type;
  return __builtin_islessgreater((type)__x, (type)__y);
}
template <class _A1,
          class _A2,
          std::__enable_if_t<std::is_arithmetic<_A1>::value && std::is_arithmetic<_A2>::value, int> = 0>
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool isunordered(_A1 __x, _A2 __y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type type;
  return __builtin_isunordered((type)__x, (type)__y);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float acos(float __x) noexcept {return __builtin_acosf(__x);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double acos(double __x) noexcept {
  return __builtin_acos(__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double acos(long double __x) noexcept {return __builtin_acosl(__x);}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
acos(_A1 __x) noexcept {return __builtin_acos((double)__x);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float asin(float __x) noexcept {return __builtin_asinf(__x);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double asin(double __x) noexcept {
  return __builtin_asin(__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double asin(long double __x) noexcept {return __builtin_asinl(__x);}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
asin(_A1 __x) noexcept {return __builtin_asin((double)__x);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float atan(float __x) noexcept {return __builtin_atanf(__x);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double atan(double __x) noexcept {
  return __builtin_atan(__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double atan(long double __x) noexcept {return __builtin_atanl(__x);}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
atan(_A1 __x) noexcept {return __builtin_atan((double)__x);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float atan2(float __y, float __x) noexcept {return __builtin_atan2f(__y, __x);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double atan2(double __x, double __y) noexcept {
  return __builtin_atan2(__x, __y);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double atan2(long double __y, long double __x) noexcept {return __builtin_atan2l(__y, __x);}
template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::__enable_if_t
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
atan2(_A1 __y, _A2 __x) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::atan2((__result_type)__y, (__result_type)__x);
}
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float ceil(float __x) noexcept {return __builtin_ceilf(__x);}
template <class = int>
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double ceil(double __x) noexcept {
  return __builtin_ceil(__x);
}
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double ceil(long double __x) noexcept {return __builtin_ceill(__x);}
template <class _A1>
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
ceil(_A1 __x) noexcept {return __builtin_ceil((double)__x);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float cos(float __x) noexcept {return __builtin_cosf(__x);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double cos(double __x) noexcept {
  return __builtin_cos(__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double cos(long double __x) noexcept {return __builtin_cosl(__x);}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
cos(_A1 __x) noexcept {return __builtin_cos((double)__x);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float cosh(float __x) noexcept {return __builtin_coshf(__x);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double cosh(double __x) noexcept {
  return __builtin_cosh(__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double cosh(long double __x) noexcept {return __builtin_coshl(__x);}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
cosh(_A1 __x) noexcept {return __builtin_cosh((double)__x);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float exp(float __x) noexcept {return __builtin_expf(__x);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double exp(double __x) noexcept {
  return __builtin_exp(__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double exp(long double __x) noexcept {return __builtin_expl(__x);}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
exp(_A1 __x) noexcept {return __builtin_exp((double)__x);}
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float fabs(float __x) noexcept {return __builtin_fabsf(__x);}
template <class = int>
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double fabs(double __x) noexcept {
  return __builtin_fabs(__x);
}
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double fabs(long double __x) noexcept {return __builtin_fabsl(__x);}
template <class _A1>
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
fabs(_A1 __x) noexcept {return __builtin_fabs((double)__x);}
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float floor(float __x) noexcept {return __builtin_floorf(__x);}
template <class = int>
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double floor(double __x) noexcept {
  return __builtin_floor(__x);
}
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double floor(long double __x) noexcept {return __builtin_floorl(__x);}
template <class _A1>
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
floor(_A1 __x) noexcept {return __builtin_floor((double)__x);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float fmod(float __x, float __y) noexcept {return __builtin_fmodf(__x, __y);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double fmod(double __x, double __y) noexcept {
  return __builtin_fmod(__x, __y);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double fmod(long double __x, long double __y) noexcept {return __builtin_fmodl(__x, __y);}
template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::__enable_if_t
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
fmod(_A1 __x, _A2 __y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::fmod((__result_type)__x, (__result_type)__y);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float frexp(float __x, int* __e) noexcept {return __builtin_frexpf(__x, __e);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double frexp(double __x, int* __e) noexcept {
  return __builtin_frexp(__x, __e);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double frexp(long double __x, int* __e) noexcept {return __builtin_frexpl(__x, __e);}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
frexp(_A1 __x, int* __e) noexcept {return __builtin_frexp((double)__x, __e);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float ldexp(float __x, int __e) noexcept {return __builtin_ldexpf(__x, __e);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double ldexp(double __x, int __e) noexcept {
  return __builtin_ldexp(__x, __e);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double ldexp(long double __x, int __e) noexcept {return __builtin_ldexpl(__x, __e);}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
ldexp(_A1 __x, int __e) noexcept {return __builtin_ldexp((double)__x, __e);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float log(float __x) noexcept {return __builtin_logf(__x);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double log(double __x) noexcept {
  return __builtin_log(__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double log(long double __x) noexcept {return __builtin_logl(__x);}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
log(_A1 __x) noexcept {return __builtin_log((double)__x);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float log10(float __x) noexcept {return __builtin_log10f(__x);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double log10(double __x) noexcept {
  return __builtin_log10(__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double log10(long double __x) noexcept {return __builtin_log10l(__x);}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
log10(_A1 __x) noexcept {return __builtin_log10((double)__x);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float modf(float __x, float* __y) noexcept {return __builtin_modff(__x, __y);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double modf(double __x, double* __y) noexcept {
  return __builtin_modf(__x, __y);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double modf(long double __x, long double* __y) noexcept {return __builtin_modfl(__x, __y);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float pow(float __x, float __y) noexcept {return __builtin_powf(__x, __y);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double pow(double __x, double __y) noexcept {
  return __builtin_pow(__x, __y);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double pow(long double __x, long double __y) noexcept {return __builtin_powl(__x, __y);}
template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::__enable_if_t
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
pow(_A1 __x, _A2 __y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::pow((__result_type)__x, (__result_type)__y);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float sin(float __x) noexcept {return __builtin_sinf(__x);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double sin(double __x) noexcept {
  return __builtin_sin(__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double sin(long double __x) noexcept {return __builtin_sinl(__x);}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
sin(_A1 __x) noexcept {return __builtin_sin((double)__x);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float sinh(float __x) noexcept {return __builtin_sinhf(__x);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double sinh(double __x) noexcept {
  return __builtin_sinh(__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double sinh(long double __x) noexcept {return __builtin_sinhl(__x);}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
sinh(_A1 __x) noexcept {return __builtin_sinh((double)__x);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float sqrt(float __x) noexcept {return __builtin_sqrtf(__x);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double sqrt(double __x) noexcept {
  return __builtin_sqrt(__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double sqrt(long double __x) noexcept {return __builtin_sqrtl(__x);}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
sqrt(_A1 __x) noexcept {return __builtin_sqrt((double)__x);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float tan(float __x) noexcept {return __builtin_tanf(__x);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double tan(double __x) noexcept {
  return __builtin_tan(__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double tan(long double __x) noexcept {return __builtin_tanl(__x);}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
tan(_A1 __x) noexcept {return __builtin_tan((double)__x);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float tanh(float __x) noexcept {return __builtin_tanhf(__x);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double tanh(double __x) noexcept {
  return __builtin_tanh(__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double tanh(long double __x) noexcept {return __builtin_tanhl(__x);}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
tanh(_A1 __x) noexcept {return __builtin_tanh((double)__x);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float acosh(float __x) noexcept {return __builtin_acoshf(__x);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double acosh(double __x) noexcept {
  return __builtin_acosh(__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double acosh(long double __x) noexcept {return __builtin_acoshl(__x);}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
acosh(_A1 __x) noexcept {return __builtin_acosh((double)__x);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float asinh(float __x) noexcept {return __builtin_asinhf(__x);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double asinh(double __x) noexcept {
  return __builtin_asinh(__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double asinh(long double __x) noexcept {return __builtin_asinhl(__x);}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
asinh(_A1 __x) noexcept {return __builtin_asinh((double)__x);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float atanh(float __x) noexcept {return __builtin_atanhf(__x);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double atanh(double __x) noexcept {
  return __builtin_atanh(__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double atanh(long double __x) noexcept {return __builtin_atanhl(__x);}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
atanh(_A1 __x) noexcept {return __builtin_atanh((double)__x);}
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float cbrt(float __x) noexcept {return __builtin_cbrtf(__x);}
template <class = int>
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double cbrt(double __x) noexcept {
  return __builtin_cbrt(__x);
}
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double cbrt(long double __x) noexcept {return __builtin_cbrtl(__x);}
template <class _A1>
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
cbrt(_A1 __x) noexcept {return __builtin_cbrt((double)__x);}
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float copysign(float __x, float __y) noexcept {
  return ::__builtin_copysignf(__x, __y);
}
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double copysign(long double __x, long double __y) noexcept {
  return ::__builtin_copysignl(__x, __y);
}
template <class _A1, class _A2>
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::__enable_if_t
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
    copysign(_A1 __x, _A2 __y) noexcept {
  return ::__builtin_copysign(__x, __y);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float erf(float __x) noexcept {return __builtin_erff(__x);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double erf(double __x) noexcept {
  return __builtin_erf(__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double erf(long double __x) noexcept {return __builtin_erfl(__x);}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
erf(_A1 __x) noexcept {return __builtin_erf((double)__x);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float erfc(float __x) noexcept {return __builtin_erfcf(__x);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double erfc(double __x) noexcept {
  return __builtin_erfc(__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double erfc(long double __x) noexcept {return __builtin_erfcl(__x);}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
erfc(_A1 __x) noexcept {return __builtin_erfc((double)__x);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float exp2(float __x) noexcept {return __builtin_exp2f(__x);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double exp2(double __x) noexcept {
  return __builtin_exp2(__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double exp2(long double __x) noexcept {return __builtin_exp2l(__x);}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
exp2(_A1 __x) noexcept {return __builtin_exp2((double)__x);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float expm1(float __x) noexcept {return __builtin_expm1f(__x);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double expm1(double __x) noexcept {
  return __builtin_expm1(__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double expm1(long double __x) noexcept {return __builtin_expm1l(__x);}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
expm1(_A1 __x) noexcept {return __builtin_expm1((double)__x);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float fdim(float __x, float __y) noexcept {return __builtin_fdimf(__x, __y);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double fdim(double __x, double __y) noexcept {
  return __builtin_fdim(__x, __y);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double fdim(long double __x, long double __y) noexcept {return __builtin_fdiml(__x, __y);}
template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::__enable_if_t
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
fdim(_A1 __x, _A2 __y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::fdim((__result_type)__x, (__result_type)__y);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float fma(float __x, float __y, float __z) noexcept
{
    return __builtin_fmaf(__x, __y, __z);
}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double fma(double __x, double __y, double __z) noexcept {
  return __builtin_fma(__x, __y, __z);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double fma(long double __x, long double __y, long double __z) noexcept
{
    return __builtin_fmal(__x, __y, __z);
}
template <class _A1, class _A2, class _A3>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::__enable_if_t
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value &&
    std::is_arithmetic<_A3>::value,
    std::__promote<_A1, _A2, _A3>
>::type
fma(_A1 __x, _A2 __y, _A3 __z) noexcept
{
    typedef typename std::__promote<_A1, _A2, _A3>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value &&
                     std::_IsSame<_A3, __result_type>::value)), "");
    return __builtin_fma((__result_type)__x, (__result_type)__y, (__result_type)__z);
}
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float fmax(float __x, float __y) noexcept {return __builtin_fmaxf(__x, __y);}
template <class = int>
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double fmax(double __x, double __y) noexcept {
  return __builtin_fmax(__x, __y);
}
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double fmax(long double __x, long double __y) noexcept {return __builtin_fmaxl(__x, __y);}
template <class _A1, class _A2>
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::__enable_if_t
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
fmax(_A1 __x, _A2 __y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::fmax((__result_type)__x, (__result_type)__y);
}
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float fmin(float __x, float __y) noexcept {return __builtin_fminf(__x, __y);}
template <class = int>
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double fmin(double __x, double __y) noexcept {
  return __builtin_fmin(__x, __y);
}
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double fmin(long double __x, long double __y) noexcept {return __builtin_fminl(__x, __y);}
template <class _A1, class _A2>
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::__enable_if_t
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
fmin(_A1 __x, _A2 __y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::fmin((__result_type)__x, (__result_type)__y);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float hypot(float __x, float __y) noexcept {return __builtin_hypotf(__x, __y);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double hypot(double __x, double __y) noexcept {
  return __builtin_hypot(__x, __y);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double hypot(long double __x, long double __y) noexcept {return __builtin_hypotl(__x, __y);}
template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::__enable_if_t
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
hypot(_A1 __x, _A2 __y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::hypot((__result_type)__x, (__result_type)__y);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) int ilogb(float __x) noexcept {return __builtin_ilogbf(__x);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double ilogb(double __x) noexcept {
  return __builtin_ilogb(__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) int ilogb(long double __x) noexcept {return __builtin_ilogbl(__x);}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, int>::type
ilogb(_A1 __x) noexcept {return __builtin_ilogb((double)__x);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float lgamma(float __x) noexcept {return __builtin_lgammaf(__x);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double lgamma(double __x) noexcept {
  return __builtin_lgamma(__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double lgamma(long double __x) noexcept {return __builtin_lgammal(__x);}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
lgamma(_A1 __x) noexcept {return __builtin_lgamma((double)__x);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long long llrint(float __x) noexcept
{
    return __builtin_llrintf(__x);
}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long long llrint(double __x) noexcept {
  return __builtin_llrint(__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long long llrint(long double __x) noexcept
{
    return __builtin_llrintl(__x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, long long>::type
llrint(_A1 __x) noexcept
{
    return __builtin_llrint((double)__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long long llround(float __x) noexcept
{
    return __builtin_llroundf(__x);
}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long long llround(double __x) noexcept {
  return __builtin_llround(__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long long llround(long double __x) noexcept
{
    return __builtin_llroundl(__x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, long long>::type
llround(_A1 __x) noexcept
{
    return __builtin_llround((double)__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float log1p(float __x) noexcept {return __builtin_log1pf(__x);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double log1p(double __x) noexcept {
  return __builtin_log1p(__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double log1p(long double __x) noexcept {return __builtin_log1pl(__x);}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
log1p(_A1 __x) noexcept {return __builtin_log1p((double)__x);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float log2(float __x) noexcept {return __builtin_log2f(__x);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double log2(double __x) noexcept {
  return __builtin_log2(__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double log2(long double __x) noexcept {return __builtin_log2l(__x);}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
log2(_A1 __x) noexcept {return __builtin_log2((double)__x);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float logb(float __x) noexcept {return __builtin_logbf(__x);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double logb(double __x) noexcept {
  return __builtin_logb(__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double logb(long double __x) noexcept {return __builtin_logbl(__x);}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
logb(_A1 __x) noexcept {return __builtin_logb((double)__x);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long lrint(float __x) noexcept
{
    return __builtin_lrintf(__x);
}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long lrint(double __x) noexcept {
  return __builtin_lrint(__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long lrint(long double __x) noexcept
{
    return __builtin_lrintl(__x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, long>::type
lrint(_A1 __x) noexcept
{
    return __builtin_lrint((double)__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long lround(float __x) noexcept
{
    return __builtin_lroundf(__x);
}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long lround(double __x) noexcept {
  return __builtin_lround(__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long lround(long double __x) noexcept
{
    return __builtin_lroundl(__x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, long>::type
lround(_A1 __x) noexcept
{
    return __builtin_lround((double)__x);
}
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float nearbyint(float __x) noexcept {return __builtin_nearbyintf(__x);}
template <class = int>
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double nearbyint(double __x) noexcept {
  return __builtin_nearbyint(__x);
}
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double nearbyint(long double __x) noexcept {return __builtin_nearbyintl(__x);}
template <class _A1>
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
nearbyint(_A1 __x) noexcept {return __builtin_nearbyint((double)__x);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float nextafter(float __x, float __y) noexcept {return __builtin_nextafterf(__x, __y);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double nextafter(double __x, double __y) noexcept {
  return __builtin_nextafter(__x, __y);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double nextafter(long double __x, long double __y) noexcept {return __builtin_nextafterl(__x, __y);}
template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::__enable_if_t
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
nextafter(_A1 __x, _A2 __y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::nextafter((__result_type)__x, (__result_type)__y);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float nexttoward(float __x, long double __y) noexcept {return __builtin_nexttowardf(__x, __y);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double nexttoward(double __x, long double __y) noexcept {
  return __builtin_nexttoward(__x, __y);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double nexttoward(long double __x, long double __y) noexcept {return __builtin_nexttowardl(__x, __y);}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
nexttoward(_A1 __x, long double __y) noexcept {return __builtin_nexttoward((double)__x, __y);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float remainder(float __x, float __y) noexcept {return __builtin_remainderf(__x, __y);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double remainder(double __x, double __y) noexcept {
  return __builtin_remainder(__x, __y);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double remainder(long double __x, long double __y) noexcept {return __builtin_remainderl(__x, __y);}
template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::__enable_if_t
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
remainder(_A1 __x, _A2 __y) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::remainder((__result_type)__x, (__result_type)__y);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float remquo(float __x, float __y, int* __z) noexcept {return __builtin_remquof(__x, __y, __z);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double remquo(double __x, double __y, int* __z) noexcept {
  return __builtin_remquo(__x, __y, __z);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double remquo(long double __x, long double __y, int* __z) noexcept {return __builtin_remquol(__x, __y, __z);}
template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::__enable_if_t
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    std::__promote<_A1, _A2>
>::type
remquo(_A1 __x, _A2 __y, int* __z) noexcept
{
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                     std::_IsSame<_A2, __result_type>::value)), "");
    return ::remquo((__result_type)__x, (__result_type)__y, __z);
}
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float rint(float __x) noexcept
{
    return __builtin_rintf(__x);
}
template <class = int>
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double rint(double __x) noexcept {
  return __builtin_rint(__x);
}
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double rint(long double __x) noexcept
{
    return __builtin_rintl(__x);
}
template <class _A1>
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
rint(_A1 __x) noexcept
{
    return __builtin_rint((double)__x);
}
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float round(float __x) noexcept
{
    return __builtin_round(__x);
}
template <class = int>
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double round(double __x) noexcept {
  return __builtin_round(__x);
}
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double round(long double __x) noexcept
{
    return __builtin_roundl(__x);
}
template <class _A1>
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
round(_A1 __x) noexcept
{
    return __builtin_round((double)__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float scalbln(float __x, long __y) noexcept {return __builtin_scalblnf(__x, __y);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double scalbln(double __x, long __y) noexcept {
  return __builtin_scalbln(__x, __y);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double scalbln(long double __x, long __y) noexcept {return __builtin_scalblnl(__x, __y);}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
scalbln(_A1 __x, long __y) noexcept {return __builtin_scalbln((double)__x, __y);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float scalbn(float __x, int __y) noexcept {return __builtin_scalbnf(__x, __y);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double scalbn(double __x, int __y) noexcept {
  return __builtin_scalbn(__x, __y);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double scalbn(long double __x, int __y) noexcept {return __builtin_scalbnl(__x, __y);}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
scalbn(_A1 __x, int __y) noexcept {return __builtin_scalbn((double)__x, __y);}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float tgamma(float __x) noexcept {return __builtin_tgammaf(__x);}
template <class = int>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double tgamma(double __x) noexcept {
  return __builtin_tgamma(__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double tgamma(long double __x) noexcept {return __builtin_tgammal(__x);}
template <class _A1>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
tgamma(_A1 __x) noexcept {return __builtin_tgamma((double)__x);}
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float trunc(float __x) noexcept
{
    return __builtin_trunc(__x);
}
template <class = int>
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double trunc(double __x) noexcept {
  return __builtin_trunc(__x);
}
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double trunc(long double __x) noexcept
{
    return __builtin_truncl(__x);
}
template <class _A1>
[[nodiscard]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
trunc(_A1 __x) noexcept
{
    return __builtin_trunc((double)__x);
}
}

namespace std { inline namespace __1 {
using ::signbit __attribute__((__using_if_exists__));
using ::fpclassify __attribute__((__using_if_exists__));
using ::isfinite __attribute__((__using_if_exists__));
using ::isinf __attribute__((__using_if_exists__));
using ::isnan __attribute__((__using_if_exists__));
using ::isnormal __attribute__((__using_if_exists__));
using ::isgreater __attribute__((__using_if_exists__));
using ::isgreaterequal __attribute__((__using_if_exists__));
using ::isless __attribute__((__using_if_exists__));
using ::islessequal __attribute__((__using_if_exists__));
using ::islessgreater __attribute__((__using_if_exists__));
using ::isunordered __attribute__((__using_if_exists__));
using ::isunordered __attribute__((__using_if_exists__));
using ::float_t __attribute__((__using_if_exists__));
using ::double_t __attribute__((__using_if_exists__));
using ::abs __attribute__((__using_if_exists__));
using ::acos __attribute__((__using_if_exists__));
using ::acosf __attribute__((__using_if_exists__));
using ::asin __attribute__((__using_if_exists__));
using ::asinf __attribute__((__using_if_exists__));
using ::atan __attribute__((__using_if_exists__));
using ::atanf __attribute__((__using_if_exists__));
using ::atan2 __attribute__((__using_if_exists__));
using ::atan2f __attribute__((__using_if_exists__));
using ::ceil __attribute__((__using_if_exists__));
using ::ceilf __attribute__((__using_if_exists__));
using ::cos __attribute__((__using_if_exists__));
using ::cosf __attribute__((__using_if_exists__));
using ::cosh __attribute__((__using_if_exists__));
using ::coshf __attribute__((__using_if_exists__));
using ::exp __attribute__((__using_if_exists__));
using ::expf __attribute__((__using_if_exists__));
using ::fabs __attribute__((__using_if_exists__));
using ::fabsf __attribute__((__using_if_exists__));
using ::floor __attribute__((__using_if_exists__));
using ::floorf __attribute__((__using_if_exists__));
using ::fmod __attribute__((__using_if_exists__));
using ::fmodf __attribute__((__using_if_exists__));
using ::frexp __attribute__((__using_if_exists__));
using ::frexpf __attribute__((__using_if_exists__));
using ::ldexp __attribute__((__using_if_exists__));
using ::ldexpf __attribute__((__using_if_exists__));
using ::log __attribute__((__using_if_exists__));
using ::logf __attribute__((__using_if_exists__));
using ::log10 __attribute__((__using_if_exists__));
using ::log10f __attribute__((__using_if_exists__));
using ::modf __attribute__((__using_if_exists__));
using ::modff __attribute__((__using_if_exists__));
using ::pow __attribute__((__using_if_exists__));
using ::powf __attribute__((__using_if_exists__));
using ::sin __attribute__((__using_if_exists__));
using ::sinf __attribute__((__using_if_exists__));
using ::sinh __attribute__((__using_if_exists__));
using ::sinhf __attribute__((__using_if_exists__));
using ::sqrt __attribute__((__using_if_exists__));
using ::sqrtf __attribute__((__using_if_exists__));
using ::tan __attribute__((__using_if_exists__));
using ::tanf __attribute__((__using_if_exists__));
using ::tanh __attribute__((__using_if_exists__));
using ::tanhf __attribute__((__using_if_exists__));
using ::acosh __attribute__((__using_if_exists__));
using ::acoshf __attribute__((__using_if_exists__));
using ::asinh __attribute__((__using_if_exists__));
using ::asinhf __attribute__((__using_if_exists__));
using ::atanh __attribute__((__using_if_exists__));
using ::atanhf __attribute__((__using_if_exists__));
using ::cbrt __attribute__((__using_if_exists__));
using ::cbrtf __attribute__((__using_if_exists__));
using ::copysign __attribute__((__using_if_exists__));
using ::copysignf __attribute__((__using_if_exists__));
using ::erf __attribute__((__using_if_exists__));
using ::erff __attribute__((__using_if_exists__));
using ::erfc __attribute__((__using_if_exists__));
using ::erfcf __attribute__((__using_if_exists__));
using ::exp2 __attribute__((__using_if_exists__));
using ::exp2f __attribute__((__using_if_exists__));
using ::expm1 __attribute__((__using_if_exists__));
using ::expm1f __attribute__((__using_if_exists__));
using ::fdim __attribute__((__using_if_exists__));
using ::fdimf __attribute__((__using_if_exists__));
using ::fmaf __attribute__((__using_if_exists__));
using ::fma __attribute__((__using_if_exists__));
using ::fmax __attribute__((__using_if_exists__));
using ::fmaxf __attribute__((__using_if_exists__));
using ::fmin __attribute__((__using_if_exists__));
using ::fminf __attribute__((__using_if_exists__));
using ::hypot __attribute__((__using_if_exists__));
using ::hypotf __attribute__((__using_if_exists__));
using ::ilogb __attribute__((__using_if_exists__));
using ::ilogbf __attribute__((__using_if_exists__));
using ::lgamma __attribute__((__using_if_exists__));
using ::lgammaf __attribute__((__using_if_exists__));
using ::llrint __attribute__((__using_if_exists__));
using ::llrintf __attribute__((__using_if_exists__));
using ::llround __attribute__((__using_if_exists__));
using ::llroundf __attribute__((__using_if_exists__));
using ::log1p __attribute__((__using_if_exists__));
using ::log1pf __attribute__((__using_if_exists__));
using ::log2 __attribute__((__using_if_exists__));
using ::log2f __attribute__((__using_if_exists__));
using ::logb __attribute__((__using_if_exists__));
using ::logbf __attribute__((__using_if_exists__));
using ::lrint __attribute__((__using_if_exists__));
using ::lrintf __attribute__((__using_if_exists__));
using ::lround __attribute__((__using_if_exists__));
using ::lroundf __attribute__((__using_if_exists__));
using ::nan __attribute__((__using_if_exists__));
using ::nanf __attribute__((__using_if_exists__));
using ::nearbyint __attribute__((__using_if_exists__));
using ::nearbyintf __attribute__((__using_if_exists__));
using ::nextafter __attribute__((__using_if_exists__));
using ::nextafterf __attribute__((__using_if_exists__));
using ::nexttoward __attribute__((__using_if_exists__));
using ::nexttowardf __attribute__((__using_if_exists__));
using ::remainder __attribute__((__using_if_exists__));
using ::remainderf __attribute__((__using_if_exists__));
using ::remquo __attribute__((__using_if_exists__));
using ::remquof __attribute__((__using_if_exists__));
using ::rint __attribute__((__using_if_exists__));
using ::rintf __attribute__((__using_if_exists__));
using ::round __attribute__((__using_if_exists__));
using ::roundf __attribute__((__using_if_exists__));
using ::scalbln __attribute__((__using_if_exists__));
using ::scalblnf __attribute__((__using_if_exists__));
using ::scalbn __attribute__((__using_if_exists__));
using ::scalbnf __attribute__((__using_if_exists__));
using ::tgamma __attribute__((__using_if_exists__));
using ::tgammaf __attribute__((__using_if_exists__));
using ::trunc __attribute__((__using_if_exists__));
using ::truncf __attribute__((__using_if_exists__));
using ::acosl __attribute__((__using_if_exists__));
using ::asinl __attribute__((__using_if_exists__));
using ::atanl __attribute__((__using_if_exists__));
using ::atan2l __attribute__((__using_if_exists__));
using ::ceill __attribute__((__using_if_exists__));
using ::cosl __attribute__((__using_if_exists__));
using ::coshl __attribute__((__using_if_exists__));
using ::expl __attribute__((__using_if_exists__));
using ::fabsl __attribute__((__using_if_exists__));
using ::floorl __attribute__((__using_if_exists__));
using ::fmodl __attribute__((__using_if_exists__));
using ::frexpl __attribute__((__using_if_exists__));
using ::ldexpl __attribute__((__using_if_exists__));
using ::logl __attribute__((__using_if_exists__));
using ::log10l __attribute__((__using_if_exists__));
using ::modfl __attribute__((__using_if_exists__));
using ::powl __attribute__((__using_if_exists__));
using ::sinl __attribute__((__using_if_exists__));
using ::sinhl __attribute__((__using_if_exists__));
using ::sqrtl __attribute__((__using_if_exists__));
using ::tanl __attribute__((__using_if_exists__));
using ::tanhl __attribute__((__using_if_exists__));
using ::acoshl __attribute__((__using_if_exists__));
using ::asinhl __attribute__((__using_if_exists__));
using ::atanhl __attribute__((__using_if_exists__));
using ::cbrtl __attribute__((__using_if_exists__));
using ::copysignl __attribute__((__using_if_exists__));
using ::erfl __attribute__((__using_if_exists__));
using ::erfcl __attribute__((__using_if_exists__));
using ::exp2l __attribute__((__using_if_exists__));
using ::expm1l __attribute__((__using_if_exists__));
using ::fdiml __attribute__((__using_if_exists__));
using ::fmal __attribute__((__using_if_exists__));
using ::fmaxl __attribute__((__using_if_exists__));
using ::fminl __attribute__((__using_if_exists__));
using ::hypotl __attribute__((__using_if_exists__));
using ::ilogbl __attribute__((__using_if_exists__));
using ::lgammal __attribute__((__using_if_exists__));
using ::llrintl __attribute__((__using_if_exists__));
using ::llroundl __attribute__((__using_if_exists__));
using ::log1pl __attribute__((__using_if_exists__));
using ::log2l __attribute__((__using_if_exists__));
using ::logbl __attribute__((__using_if_exists__));
using ::lrintl __attribute__((__using_if_exists__));
using ::lroundl __attribute__((__using_if_exists__));
using ::nanl __attribute__((__using_if_exists__));
using ::nearbyintl __attribute__((__using_if_exists__));
using ::nextafterl __attribute__((__using_if_exists__));
using ::nexttowardl __attribute__((__using_if_exists__));
using ::remainderl __attribute__((__using_if_exists__));
using ::remquol __attribute__((__using_if_exists__));
using ::rintl __attribute__((__using_if_exists__));
using ::roundl __attribute__((__using_if_exists__));
using ::scalblnl __attribute__((__using_if_exists__));
using ::scalbnl __attribute__((__using_if_exists__));
using ::tgammal __attribute__((__using_if_exists__));
using ::truncl __attribute__((__using_if_exists__));
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float hypot( float __x, float __y, float __z ) { return sqrt(__x*__x + __y*__y + __z*__z); }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double hypot( double __x, double __y, double __z ) { return sqrt(__x*__x + __y*__y + __z*__z); }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double hypot( long double __x, long double __y, long double __z ) { return sqrt(__x*__x + __y*__y + __z*__z); }
template <class _A1, class _A2, class _A3>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename enable_if_t
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value &&
    is_arithmetic<_A3>::value,
    __promote<_A1, _A2, _A3>
>::type
hypot(_A1 __lcpp_x, _A2 __lcpp_y, _A3 __lcpp_z) noexcept
{
    typedef typename __promote<_A1, _A2, _A3>::type __result_type;
    static_assert((!(is_same<_A1, __result_type>::value &&
                     is_same<_A2, __result_type>::value &&
                     is_same<_A3, __result_type>::value)), "");
    return std::hypot((__result_type)__lcpp_x, (__result_type)__lcpp_y, (__result_type)__lcpp_z);
}
template <class _A1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr typename enable_if<is_floating_point<_A1>::value, bool>::type
__constexpr_isnan(_A1 __lcpp_x) noexcept
{
    return __builtin_isnan(__lcpp_x);
}
template <class _A1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr typename enable_if<!is_floating_point<_A1>::value, bool>::type
__constexpr_isnan(_A1 __lcpp_x) noexcept
{
    return std::isnan(__lcpp_x);
}
template <class _A1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr typename enable_if<is_floating_point<_A1>::value, bool>::type
__constexpr_isinf(_A1 __lcpp_x) noexcept
{
    return __builtin_isinf(__lcpp_x);
}
template <class _A1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr typename enable_if<!is_floating_point<_A1>::value, bool>::type
__constexpr_isinf(_A1 __lcpp_x) noexcept
{
    return std::isinf(__lcpp_x);
}
template <class _A1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr typename enable_if<is_floating_point<_A1>::value, bool>::type
__constexpr_isfinite(_A1 __lcpp_x) noexcept
{
    return __builtin_isfinite(__lcpp_x);
}
template <class _A1>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr typename enable_if<!is_floating_point<_A1>::value, bool>::type
__constexpr_isfinite(_A1 __lcpp_x) noexcept
{
    return __builtin_isfinite(__lcpp_x);
}
constexpr inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) float __constexpr_copysign(float __x, float __y) noexcept {
    return __builtin_copysignf(__x, __y);
}
constexpr inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) double __constexpr_copysign(double __x, double __y) noexcept {
    return __builtin_copysign(__x, __y);
}
constexpr inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) long double
__constexpr_copysign(long double __x, long double __y) noexcept {
    return __builtin_copysignl(__x, __y);
}
template <class _A1, class _A2>
constexpr inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    typename std::__enable_if_t<std::is_arithmetic<_A1>::value && std::is_arithmetic<_A2>::value,
                                std::__promote<_A1, _A2> >::type
    __constexpr_copysign(_A1 __x, _A2 __y) noexcept {
    typedef typename std::__promote<_A1, _A2>::type __result_type;
    static_assert((!(std::_IsSame<_A1, __result_type>::value && std::_IsSame<_A2, __result_type>::value)), "");
    return __builtin_copysign((__result_type)__x, (__result_type)__y);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr float __constexpr_fabs(float __x) noexcept {
    return __builtin_fabsf(__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr double __constexpr_fabs(double __x) noexcept {
    return __builtin_fabs(__x);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr long double __constexpr_fabs(long double __x) noexcept {
    return __builtin_fabsl(__x);
}
template <class _Tp, __enable_if_t<is_integral<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr double __constexpr_fabs(_Tp __x) noexcept {
    return __builtin_fabs(static_cast<double>(__x));
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr float __constexpr_fmax(float __x, float __y) noexcept {
  if (__libcpp_is_constant_evaluated()) {
    if (std::__constexpr_isnan(__x))
      return __y;
    if (std::__constexpr_isnan(__y))
      return __x;
    return __x < __y ? __y : __x;
  }
  return __builtin_fmaxf(__x, __y);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr double __constexpr_fmax(double __x, double __y) noexcept {
  if (__libcpp_is_constant_evaluated()) {
    if (std::__constexpr_isnan(__x))
      return __y;
    if (std::__constexpr_isnan(__y))
      return __x;
    return __x < __y ? __y : __x;
  }
  return __builtin_fmax(__x, __y);
}
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr long double
__constexpr_fmax(long double __x, long double __y) noexcept {
  if (__libcpp_is_constant_evaluated()) {
    if (std::__constexpr_isnan(__x))
      return __y;
    if (std::__constexpr_isnan(__y))
      return __x;
    return __x < __y ? __y : __x;
  }
  return __builtin_fmaxl(__x, __y);
}
template <class _Tp, class _Up, __enable_if_t<is_arithmetic<_Tp>::value && is_arithmetic<_Up>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr typename __promote<_Tp, _Up>::type
__constexpr_fmax(_Tp __x, _Up __y) noexcept {
  using __result_type = typename __promote<_Tp, _Up>::type;
  return std::__constexpr_fmax(static_cast<__result_type>(__x), static_cast<__result_type>(__y));
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Tp __constexpr_logb(_Tp __x) {
  if (__libcpp_is_constant_evaluated()) {
    if (__x == _Tp(0)) {
      return -numeric_limits<_Tp>::infinity();
    }
    if (std::__constexpr_isinf(__x))
      return numeric_limits<_Tp>::infinity();
    if (std::__constexpr_isnan(__x))
      return numeric_limits<_Tp>::quiet_NaN();
    __x = std::__constexpr_fabs(__x);
    unsigned long long __exp = 0;
    while (__x >= numeric_limits<_Tp>::radix) {
      __x /= numeric_limits<_Tp>::radix;
      __exp += 1;
    }
    return _Tp(__exp);
  }
  return __builtin_logb(__x);
}
template <class _Tp>
// added by concept-synth, original LN: 24951
requires
requires (_Tp x0, _Tp x1) { x0 *= x1; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Tp __constexpr_scalbn(_Tp __x, int __exp) {
  if (__libcpp_is_constant_evaluated()) {
    if (__x == _Tp(0))
      return __x;
    if (std::__constexpr_isinf(__x))
      return __x;
    if (__exp == _Tp(0))
      return __x;
    if (std::__constexpr_isnan(__x))
      return numeric_limits<_Tp>::quiet_NaN();
    _Tp __mult(1);
    if (__exp > 0) {
      __mult = numeric_limits<_Tp>::radix;
      --__exp;
    } else {
      ++__exp;
      __exp = -__exp;
      __mult /= numeric_limits<_Tp>::radix;
    }
    while (__exp > 0) {
      if (!(__exp & 1)) {
        __mult *= __mult;
        __exp >>= 1;
      } else {
        __x *= __mult;
        --__exp;
      }
    }
    return __x;
  }
  return __builtin_scalbn(__x, __exp);
}
template <typename _Fp>
// added by concept-synth, original LN: 24984
requires
requires (_Fp x0, _Fp x1) { x0 * x1; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
_Fp __lerp(_Fp __a, _Fp __b, _Fp __t) noexcept {
    if ((__a <= 0 && __b >= 0) || (__a >= 0 && __b <= 0))
        return __t * __b + (1 - __t) * __a;
    if (__t == 1) return __b;
    const _Fp __x = __a + __t * (__b - __a);
    if ((__t > 1) == (__b > __a))
        return __b < __x ? __x : __b;
    else
        return __x < __b ? __x : __b;
}
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr float
lerp(float __a, float __b, float __t) noexcept { return __lerp(__a, __b, __t); }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr double
lerp(double __a, double __b, double __t) noexcept { return __lerp(__a, __b, __t); }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr long double
lerp(long double __a, long double __b, long double __t) noexcept { return __lerp(__a, __b, __t); }
template <class _A1, class _A2, class _A3>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr typename enable_if_t
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value &&
    is_arithmetic<_A3>::value,
    __promote<_A1, _A2, _A3>
>::type
lerp(_A1 __a, _A2 __b, _A3 __t) noexcept
{
    typedef typename __promote<_A1, _A2, _A3>::type __result_type;
    static_assert(!(_IsSame<_A1, __result_type>::value &&
                    _IsSame<_A2, __result_type>::value &&
                    _IsSame<_A3, __result_type>::value));
    return std::__lerp((__result_type)__a, (__result_type)__b, (__result_type)__t);
}
}}
namespace std { inline namespace __1 {
template<size_t _Ip> struct __priority_tag : __priority_tag<_Ip - 1> {};
template<> struct __priority_tag<0> {};
}}

namespace std { inline namespace __1 {
namespace __strong_order {
    struct __fn {
        template<class _Tp, class _Up>
            requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr auto
        __go(_Tp&& __t, _Up&& __u, __priority_tag<2>)
            noexcept(noexcept(strong_ordering(strong_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)))))
            -> decltype( strong_ordering(strong_order(std::forward<_Tp>(__t), std::forward<_Up>(__u))))
            { return strong_ordering(strong_order(std::forward<_Tp>(__t), std::forward<_Up>(__u))); }
        template<class _Tp, class _Up, class _Dp = decay_t<_Tp>>
            requires is_same_v<_Dp, decay_t<_Up>> && is_floating_point_v<_Dp>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr strong_ordering
        __go(_Tp&& __t, _Up&& __u, __priority_tag<1>) noexcept
        {
            if constexpr (numeric_limits<_Dp>::is_iec559 && sizeof(_Dp) == sizeof(int32_t)) {
                int32_t __rx = std::bit_cast<int32_t>(__t);
                int32_t __ry = std::bit_cast<int32_t>(__u);
                __rx = (__rx < 0) ? (numeric_limits<int32_t>::min() - __rx - 1) : __rx;
                __ry = (__ry < 0) ? (numeric_limits<int32_t>::min() - __ry - 1) : __ry;
                return (__rx <=> __ry);
            } else if constexpr (numeric_limits<_Dp>::is_iec559 && sizeof(_Dp) == sizeof(int64_t)) {
                int64_t __rx = std::bit_cast<int64_t>(__t);
                int64_t __ry = std::bit_cast<int64_t>(__u);
                __rx = (__rx < 0) ? (numeric_limits<int64_t>::min() - __rx - 1) : __rx;
                __ry = (__ry < 0) ? (numeric_limits<int64_t>::min() - __ry - 1) : __ry;
                return (__rx <=> __ry);
            } else if (__t < __u) {
                return strong_ordering::less;
            } else if (__t > __u) {
                return strong_ordering::greater;
            } else if (__t == __u) {
                if constexpr (numeric_limits<_Dp>::radix == 2) {
                    return std::signbit(__u) <=> std::signbit(__t);
                } else {
                    if (__t == 0 || std::isinf(__t)) {
                        return std::signbit(__u) <=> std::signbit(__t);
                    } else {
                        int __texp, __uexp;
                        (void)std::frexp(__t, &__texp);
                        (void)std::frexp(__u, &__uexp);
                        return (__t < 0) ? (__texp <=> __uexp) : (__uexp <=> __texp);
                    }
                }
            } else {
                bool __t_is_nan = std::isnan(__t);
                bool __u_is_nan = std::isnan(__u);
                bool __t_is_negative = std::signbit(__t);
                bool __u_is_negative = std::signbit(__u);
                using _IntType = conditional_t<
                    sizeof(__t) == sizeof(int32_t), int32_t, conditional_t<
                    sizeof(__t) == sizeof(int64_t), int64_t, void>
                >;
                if constexpr (is_same_v<_IntType, void>) {
                    static_assert(sizeof(_Dp) == 0, "std::strong_order is unimplemented for this floating-point type");
                } else if (__t_is_nan && __u_is_nan) {
                    if (__t_is_negative != __u_is_negative) {
                        return (__u_is_negative <=> __t_is_negative);
                    } else {
                        return std::bit_cast<_IntType>(__t) <=> std::bit_cast<_IntType>(__u);
                    }
                } else if (__t_is_nan) {
                    return __t_is_negative ? strong_ordering::less : strong_ordering::greater;
                } else {
                    return __u_is_negative ? strong_ordering::greater : strong_ordering::less;
                }
            }
        }
        template<class _Tp, class _Up>
            requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr auto
        __go(_Tp&& __t, _Up&& __u, __priority_tag<0>)
            noexcept(noexcept(strong_ordering(compare_three_way()(std::forward<_Tp>(__t), std::forward<_Up>(__u)))))
            -> decltype( strong_ordering(compare_three_way()(std::forward<_Tp>(__t), std::forward<_Up>(__u))))
            { return strong_ordering(compare_three_way()(std::forward<_Tp>(__t), std::forward<_Up>(__u))); }
        template<class _Tp, class _Up>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr auto operator()(_Tp&& __t, _Up&& __u) const
            noexcept(noexcept(__go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<2>())))
            -> decltype( __go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<2>()))
            { return __go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<2>()); }
    };
}
inline namespace __cpo {
    inline constexpr auto strong_order = __strong_order::__fn{};
}
}}
namespace std { inline namespace __1 {
namespace __weak_order {
    struct __fn {
        template<class _Tp, class _Up>
            requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr auto
        __go(_Tp&& __t, _Up&& __u, __priority_tag<3>)
            noexcept(noexcept(weak_ordering(weak_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)))))
            -> decltype( weak_ordering(weak_order(std::forward<_Tp>(__t), std::forward<_Up>(__u))))
            { return weak_ordering(weak_order(std::forward<_Tp>(__t), std::forward<_Up>(__u))); }
        template<class _Tp, class _Up, class _Dp = decay_t<_Tp>>
            requires is_same_v<_Dp, decay_t<_Up>> && is_floating_point_v<_Dp>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr weak_ordering
        __go(_Tp&& __t, _Up&& __u, __priority_tag<2>) noexcept
        {
            partial_ordering __po = (__t <=> __u);
            if (__po == partial_ordering::less) {
                return weak_ordering::less;
            } else if (__po == partial_ordering::equivalent) {
                return weak_ordering::equivalent;
            } else if (__po == partial_ordering::greater) {
                return weak_ordering::greater;
            } else {
                bool __t_is_nan = std::isnan(__t);
                bool __u_is_nan = std::isnan(__u);
                bool __t_is_negative = std::signbit(__t);
                bool __u_is_negative = std::signbit(__u);
                if (__t_is_nan && __u_is_nan) {
                    return (__u_is_negative <=> __t_is_negative);
                } else if (__t_is_nan) {
                    return __t_is_negative ? weak_ordering::less : weak_ordering::greater;
                } else {
                    return __u_is_negative ? weak_ordering::greater : weak_ordering::less;
                }
            }
        }
        template<class _Tp, class _Up>
            requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr auto
        __go(_Tp&& __t, _Up&& __u, __priority_tag<1>)
            noexcept(noexcept(weak_ordering(compare_three_way()(std::forward<_Tp>(__t), std::forward<_Up>(__u)))))
            -> decltype( weak_ordering(compare_three_way()(std::forward<_Tp>(__t), std::forward<_Up>(__u))))
            { return weak_ordering(compare_three_way()(std::forward<_Tp>(__t), std::forward<_Up>(__u))); }
        template<class _Tp, class _Up>
            requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr auto
        __go(_Tp&& __t, _Up&& __u, __priority_tag<0>)
            noexcept(noexcept(weak_ordering(std::strong_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)))))
            -> decltype( weak_ordering(std::strong_order(std::forward<_Tp>(__t), std::forward<_Up>(__u))))
            { return weak_ordering(std::strong_order(std::forward<_Tp>(__t), std::forward<_Up>(__u))); }
        template<class _Tp, class _Up>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr auto operator()(_Tp&& __t, _Up&& __u) const
            noexcept(noexcept(__go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<3>())))
            -> decltype( __go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<3>()))
            { return __go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<3>()); }
    };
}
inline namespace __cpo {
    inline constexpr auto weak_order = __weak_order::__fn{};
}
}}
namespace std { inline namespace __1 {
namespace __partial_order {
    struct __fn {
        template<class _Tp, class _Up>
            requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr auto
        __go(_Tp&& __t, _Up&& __u, __priority_tag<2>)
            noexcept(noexcept(partial_ordering(partial_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)))))
            -> decltype( partial_ordering(partial_order(std::forward<_Tp>(__t), std::forward<_Up>(__u))))
            { return partial_ordering(partial_order(std::forward<_Tp>(__t), std::forward<_Up>(__u))); }
        template<class _Tp, class _Up>
            requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr auto
        __go(_Tp&& __t, _Up&& __u, __priority_tag<1>)
            noexcept(noexcept(partial_ordering(compare_three_way()(std::forward<_Tp>(__t), std::forward<_Up>(__u)))))
            -> decltype( partial_ordering(compare_three_way()(std::forward<_Tp>(__t), std::forward<_Up>(__u))))
            { return partial_ordering(compare_three_way()(std::forward<_Tp>(__t), std::forward<_Up>(__u))); }
        template<class _Tp, class _Up>
            requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr auto
        __go(_Tp&& __t, _Up&& __u, __priority_tag<0>)
            noexcept(noexcept(partial_ordering(std::weak_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)))))
            -> decltype( partial_ordering(std::weak_order(std::forward<_Tp>(__t), std::forward<_Up>(__u))))
            { return partial_ordering(std::weak_order(std::forward<_Tp>(__t), std::forward<_Up>(__u))); }
        template<class _Tp, class _Up>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr auto operator()(_Tp&& __t, _Up&& __u) const
            noexcept(noexcept(__go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<2>())))
            -> decltype( __go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<2>()))
            { return __go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<2>()); }
    };
}
inline namespace __cpo {
    inline constexpr auto partial_order = __partial_order::__fn{};
}
}}
namespace std { inline namespace __1 {
namespace __compare_partial_order_fallback {
    struct __fn {
        template<class _Tp, class _Up>
            requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr auto
        __go(_Tp&& __t, _Up&& __u, __priority_tag<1>)
            noexcept(noexcept(std::partial_order(std::forward<_Tp>(__t), std::forward<_Up>(__u))))
            -> decltype( std::partial_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)))
            { return std::partial_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)); }
        template<class _Tp, class _Up>
            requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr auto
        __go(_Tp&& __t, _Up&& __u, __priority_tag<0>)
            noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u) ? partial_ordering::equivalent :
                              std::forward<_Tp>(__t) < std::forward<_Up>(__u) ? partial_ordering::less :
                              std::forward<_Up>(__u) < std::forward<_Tp>(__t) ? partial_ordering::greater :
                              partial_ordering::unordered))
            -> decltype( std::forward<_Tp>(__t) == std::forward<_Up>(__u) ? partial_ordering::equivalent :
                              std::forward<_Tp>(__t) < std::forward<_Up>(__u) ? partial_ordering::less :
                              std::forward<_Up>(__u) < std::forward<_Tp>(__t) ? partial_ordering::greater :
                              partial_ordering::unordered)
        {
            return std::forward<_Tp>(__t) == std::forward<_Up>(__u) ? partial_ordering::equivalent :
                              std::forward<_Tp>(__t) < std::forward<_Up>(__u) ? partial_ordering::less :
                              std::forward<_Up>(__u) < std::forward<_Tp>(__t) ? partial_ordering::greater :
                              partial_ordering::unordered;
        }
        template<class _Tp, class _Up>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr auto operator()(_Tp&& __t, _Up&& __u) const
            noexcept(noexcept(__go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<1>())))
            -> decltype( __go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<1>()))
            { return __go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<1>()); }
    };
}
inline namespace __cpo {
    inline constexpr auto compare_partial_order_fallback = __compare_partial_order_fallback::__fn{};
}
}}
namespace std { inline namespace __1 {
namespace __compare_strong_order_fallback {
    struct __fn {
        template<class _Tp, class _Up>
            requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr auto
        __go(_Tp&& __t, _Up&& __u, __priority_tag<1>)
            noexcept(noexcept(std::strong_order(std::forward<_Tp>(__t), std::forward<_Up>(__u))))
            -> decltype( std::strong_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)))
            { return std::strong_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)); }
        template<class _Tp, class _Up>
            requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr auto
        __go(_Tp&& __t, _Up&& __u, __priority_tag<0>)
            noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u) ? strong_ordering::equal :
                              std::forward<_Tp>(__t) < std::forward<_Up>(__u) ? strong_ordering::less :
                              strong_ordering::greater))
            -> decltype( std::forward<_Tp>(__t) == std::forward<_Up>(__u) ? strong_ordering::equal :
                              std::forward<_Tp>(__t) < std::forward<_Up>(__u) ? strong_ordering::less :
                              strong_ordering::greater)
        {
            return std::forward<_Tp>(__t) == std::forward<_Up>(__u) ? strong_ordering::equal :
                              std::forward<_Tp>(__t) < std::forward<_Up>(__u) ? strong_ordering::less :
                              strong_ordering::greater;
        }
        template<class _Tp, class _Up>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr auto operator()(_Tp&& __t, _Up&& __u) const
            noexcept(noexcept(__go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<1>())))
            -> decltype( __go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<1>()))
            { return __go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<1>()); }
    };
}
inline namespace __cpo {
    inline constexpr auto compare_strong_order_fallback = __compare_strong_order_fallback::__fn{};
}
}}
namespace std { inline namespace __1 {
namespace __compare_weak_order_fallback {
    struct __fn {
        template<class _Tp, class _Up>
            requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr auto
        __go(_Tp&& __t, _Up&& __u, __priority_tag<1>)
            noexcept(noexcept(std::weak_order(std::forward<_Tp>(__t), std::forward<_Up>(__u))))
            -> decltype( std::weak_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)))
            { return std::weak_order(std::forward<_Tp>(__t), std::forward<_Up>(__u)); }
        template<class _Tp, class _Up>
            requires is_same_v<decay_t<_Tp>, decay_t<_Up>>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) static constexpr auto
        __go(_Tp&& __t, _Up&& __u, __priority_tag<0>)
            noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u) ? weak_ordering::equivalent :
                              std::forward<_Tp>(__t) < std::forward<_Up>(__u) ? weak_ordering::less :
                              weak_ordering::greater))
            -> decltype( std::forward<_Tp>(__t) == std::forward<_Up>(__u) ? weak_ordering::equivalent :
                              std::forward<_Tp>(__t) < std::forward<_Up>(__u) ? weak_ordering::less :
                              weak_ordering::greater)
        {
            return std::forward<_Tp>(__t) == std::forward<_Up>(__u) ? weak_ordering::equivalent :
                              std::forward<_Tp>(__t) < std::forward<_Up>(__u) ? weak_ordering::less :
                              weak_ordering::greater;
        }
        template<class _Tp, class _Up>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr auto operator()(_Tp&& __t, _Up&& __u) const
            noexcept(noexcept(__go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<1>())))
            -> decltype( __go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<1>()))
            { return __go(std::forward<_Tp>(__t), std::forward<_Up>(__u), __priority_tag<1>()); }
    };
}
inline namespace __cpo {
    inline constexpr auto compare_weak_order_fallback = __compare_weak_order_fallback::__fn{};
}
}}
namespace std { inline namespace __1 {
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) inline constexpr bool is_eq(partial_ordering __c) noexcept { return __c == 0; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) inline constexpr bool is_neq(partial_ordering __c) noexcept { return __c != 0; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) inline constexpr bool is_lt(partial_ordering __c) noexcept { return __c < 0; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) inline constexpr bool is_lteq(partial_ordering __c) noexcept { return __c <= 0; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) inline constexpr bool is_gt(partial_ordering __c) noexcept { return __c > 0; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) inline constexpr bool is_gteq(partial_ordering __c) noexcept { return __c >= 0; }
}}
namespace std { inline namespace __1 {
template<class _Tp, class _Up>
concept common_with =
  same_as<common_type_t<_Tp, _Up>, common_type_t<_Up, _Tp>> &&
  requires {
    static_cast<common_type_t<_Tp, _Up>>(std::declval<_Tp>());
    static_cast<common_type_t<_Tp, _Up>>(std::declval<_Up>());
  } &&
  common_reference_with<
    add_lvalue_reference_t<const _Tp>,
    add_lvalue_reference_t<const _Up>> &&
  common_reference_with<
    add_lvalue_reference_t<common_type_t<_Tp, _Up>>,
    common_reference_t<
      add_lvalue_reference_t<const _Tp>,
      add_lvalue_reference_t<const _Up>>>;
}}

namespace std { inline namespace __1 {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Container>
class __attribute__((__type_visibility__("default"))) back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
#pragma GCC diagnostic pop
protected:
    _Container* container;
public:
    typedef output_iterator_tag iterator_category;
    typedef void value_type;
    typedef ptrdiff_t difference_type;
    typedef void pointer;
    typedef void reference;
    typedef _Container container_type;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr explicit back_insert_iterator(_Container& __x) : container(std::addressof(__x)) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr back_insert_iterator& operator=(const typename _Container::value_type& __value)
        {container->push_back(__value); return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr back_insert_iterator& operator=(typename _Container::value_type&& __value)
        {container->push_back(std::move(__value)); return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr back_insert_iterator& operator*() {return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr back_insert_iterator& operator++() {return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr back_insert_iterator operator++(int) {return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Container* __get_container() const { return container; }
};
template <class ..._Tag> back_insert_iterator(typename _Tag::__allow_ctad...) -> back_insert_iterator<_Tag...>;
template <class _Container>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
back_insert_iterator<_Container>
back_inserter(_Container& __x)
{
    return back_insert_iterator<_Container>(__x);
}
}}
namespace std { inline namespace __1 {
template <class _Iterator, class = __enable_if_t< __is_cpp17_contiguous_iterator<_Iterator>::value > >
struct __bounded_iter {
  using value_type = typename iterator_traits<_Iterator>::value_type;
  using difference_type = typename iterator_traits<_Iterator>::difference_type;
  using pointer = typename iterator_traits<_Iterator>::pointer;
  using reference = typename iterator_traits<_Iterator>::reference;
  using iterator_category = typename iterator_traits<_Iterator>::iterator_category;
  using iterator_concept = contiguous_iterator_tag;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __bounded_iter() = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __bounded_iter(__bounded_iter const&) = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __bounded_iter(__bounded_iter&&) = default;
  template <class _OtherIterator, class = __enable_if_t< is_convertible<_OtherIterator, _Iterator>::value > >
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __bounded_iter(__bounded_iter<_OtherIterator> const& __other) noexcept
      : __current_(__other.__current_),
        __begin_(__other.__begin_),
        __end_(__other.__end_) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __bounded_iter& operator=(__bounded_iter const&) = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __bounded_iter& operator=(__bounded_iter&&) = default;
private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr explicit __bounded_iter(
      _Iterator __current, _Iterator __begin, _Iterator __end)
      : __current_(__current), __begin_(__begin), __end_(__end) {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(__begin <= __end))
#pragma clang diagnostic pop
    );
  }
  template <class _It>
  friend constexpr __bounded_iter<_It> __make_bounded_iter(_It, _It, _It);
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr reference operator*() const noexcept {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(__in_bounds(__current_)))
#pragma clang diagnostic pop
    );
    return *__current_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr pointer operator->() const noexcept {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(__in_bounds(__current_)))
#pragma clang diagnostic pop
    );
    return std::__to_address(__current_);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr reference operator[](difference_type __n) const noexcept {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(__in_bounds(__current_ + __n)))
#pragma clang diagnostic pop
    );
    return __current_[__n];
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __bounded_iter& operator++() noexcept {
    ++__current_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __bounded_iter operator++(int) noexcept {
    __bounded_iter __tmp(*this);
    ++*this;
    return __tmp;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __bounded_iter& operator--() noexcept {
    --__current_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __bounded_iter operator--(int) noexcept {
    __bounded_iter __tmp(*this);
    --*this;
    return __tmp;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __bounded_iter& operator+=(difference_type __n) noexcept {
    __current_ += __n;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr friend __bounded_iter
  operator+(__bounded_iter const& __self, difference_type __n) noexcept {
    __bounded_iter __tmp(__self);
    __tmp += __n;
    return __tmp;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr friend __bounded_iter
  operator+(difference_type __n, __bounded_iter const& __self) noexcept {
    __bounded_iter __tmp(__self);
    __tmp += __n;
    return __tmp;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __bounded_iter& operator-=(difference_type __n) noexcept {
    __current_ -= __n;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr friend __bounded_iter
  operator-(__bounded_iter const& __self, difference_type __n) noexcept {
    __bounded_iter __tmp(__self);
    __tmp -= __n;
    return __tmp;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr friend difference_type
  operator-(__bounded_iter const& __x, __bounded_iter const& __y) noexcept {
    return __x.__current_ - __y.__current_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr friend bool
  operator==(__bounded_iter const& __x, __bounded_iter const& __y) noexcept {
    return __x.__current_ == __y.__current_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr friend bool
  operator!=(__bounded_iter const& __x, __bounded_iter const& __y) noexcept {
    return __x.__current_ != __y.__current_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr friend bool
  operator<(__bounded_iter const& __x, __bounded_iter const& __y) noexcept {
    return __x.__current_ < __y.__current_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr friend bool
  operator>(__bounded_iter const& __x, __bounded_iter const& __y) noexcept {
    return __x.__current_ > __y.__current_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr friend bool
  operator<=(__bounded_iter const& __x, __bounded_iter const& __y) noexcept {
    return __x.__current_ <= __y.__current_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr friend bool
  operator>=(__bounded_iter const& __x, __bounded_iter const& __y) noexcept {
    return __x.__current_ >= __y.__current_;
  }
private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool __in_bounds(_Iterator const& __iter) const {
    return __iter >= __begin_ && __iter < __end_;
  }
  template <class>
  friend struct pointer_traits;
  _Iterator __current_;
  _Iterator __begin_, __end_;
};
template <class _It>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __bounded_iter<_It> __make_bounded_iter(_It __it, _It __begin, _It __end) {
  return __bounded_iter<_It>(std::move(__it), std::move(__begin), std::move(__end));
}
template <class _Iterator>
struct pointer_traits<__bounded_iter<_Iterator> > {
  using pointer = __bounded_iter<_Iterator>;
  using element_type = typename pointer_traits<_Iterator>::element_type;
  using difference_type = typename pointer_traits<_Iterator>::difference_type;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr static element_type* to_address(pointer __it) noexcept {
    return std::__to_address(__it.__current_);
  }
};
}}
namespace std { inline namespace __1 {
struct __attribute__((__visibility__("default"))) in_place_t {
    explicit in_place_t() = default;
};
inline constexpr in_place_t in_place{};
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) in_place_type_t {
    explicit in_place_type_t() = default;
};
template <class _Tp>
inline constexpr in_place_type_t<_Tp> in_place_type{};
template <size_t _Idx>
struct __attribute__((__type_visibility__("default"))) in_place_index_t {
    explicit in_place_index_t() = default;
};
template <size_t _Idx>
inline constexpr in_place_index_t<_Idx> in_place_index{};
template <class _Tp> struct __is_inplace_type_imp : false_type {};
template <class _Tp> struct __is_inplace_type_imp<in_place_type_t<_Tp>> : true_type {};
template <class _Tp>
using __is_inplace_type = __is_inplace_type_imp<__remove_cvref_t<_Tp>>;
template <class _Tp> struct __is_inplace_index_imp : false_type {};
template <size_t _Idx> struct __is_inplace_index_imp<in_place_index_t<_Idx>> : true_type {};
template <class _Tp>
using __is_inplace_index = __is_inplace_index_imp<__remove_cvref_t<_Tp>>;
}}
namespace std { inline namespace __1 {
struct __attribute__((__type_visibility__("default"))) monostate {};
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr bool operator==(monostate, monostate) noexcept { return true; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr strong_ordering operator<=>(monostate, monostate) noexcept {
  return strong_ordering::equal;
}
template <>
struct __attribute__((__type_visibility__("default"))) hash<monostate> {
  using argument_type = monostate;
  using result_type = size_t;
  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) result_type operator()(const argument_type&) const noexcept {
    return 66740831;
  }
};
}}
namespace std { inline namespace __1 {
template <class _Tp>
struct __has_allocator_type
{
private:
    template <class _Up> static false_type __test(...);
    template <class _Up> static true_type __test(typename _Up::allocator_type* = 0);
public:
    static const bool value = decltype(__test<_Tp>(0))::value;
};
template <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>
struct __uses_allocator
    : public integral_constant<bool,
        is_convertible<_Alloc, typename _Tp::allocator_type>::value>
{
};
template <class _Tp, class _Alloc>
struct __uses_allocator<_Tp, _Alloc, false>
    : public false_type
{
};
template <class _Tp, class _Alloc>
struct __attribute__((__type_visibility__("default"))) uses_allocator
    : public __uses_allocator<_Tp, _Alloc>
{
};
template <class _Tp, class _Alloc>
inline constexpr size_t uses_allocator_v = uses_allocator<_Tp, _Alloc>::value;
}}
namespace std { inline namespace __1 {
struct __attribute__((__type_visibility__("default"))) allocator_arg_t { explicit allocator_arg_t() = default; };
             constexpr allocator_arg_t allocator_arg = allocator_arg_t();
template <class _Tp, class _Alloc, class ..._Args>
struct __uses_alloc_ctor_imp
{
    typedef __attribute__((__nodebug__)) __remove_cvref_t<_Alloc> _RawAlloc;
    static const bool __ua = uses_allocator<_Tp, _RawAlloc>::value;
    static const bool __ic =
        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value;
    static const int value = __ua ? 2 - __ic : 0;
};
template <class _Tp, class _Alloc, class ..._Args>
struct __uses_alloc_ctor
    : integral_constant<int, __uses_alloc_ctor_imp<_Tp, _Alloc, _Args...>::value>
    {};
template <class _Tp, class _Allocator, class... _Args>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void __user_alloc_construct_impl (integral_constant<int, 0>, _Tp *__storage, const _Allocator &, _Args &&... __args )
{
    new (__storage) _Tp (std::forward<_Args>(__args)...);
}
template <class _Tp, class _Allocator, class... _Args>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void __user_alloc_construct_impl (integral_constant<int, 1>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )
{
    new (__storage) _Tp (allocator_arg, __a, std::forward<_Args>(__args)...);
}
template <class _Tp, class _Allocator, class... _Args>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void __user_alloc_construct_impl (integral_constant<int, 2>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )
{
    new (__storage) _Tp (std::forward<_Args>(__args)..., __a);
}
}}
namespace std { inline namespace __1 {
template <size_t _Ip, class _Hp,
          bool=is_empty<_Hp>::value && !__libcpp_is_final<_Hp>::value
         >
class __tuple_leaf;
template <size_t _Ip, class _Hp, bool _Ep>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void swap(__tuple_leaf<_Ip, _Hp, _Ep>& __x, __tuple_leaf<_Ip, _Hp, _Ep>& __y)
    noexcept(__is_nothrow_swappable<_Hp>::value)
{
    swap(__x.get(), __y.get());
}
template <size_t _Ip, class _Hp, bool _Ep>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void swap(const __tuple_leaf<_Ip, _Hp, _Ep>& __x, const __tuple_leaf<_Ip, _Hp, _Ep>& __y)
     noexcept(__is_nothrow_swappable<const _Hp>::value) {
  swap(__x.get(), __y.get());
}
template <size_t _Ip, class _Hp, bool>
class __tuple_leaf
{
    _Hp __value_;
    template <class _Tp>
    static constexpr bool __can_bind_reference() {
      return !__reference_binds_to_temporary(_Hp, _Tp);
    }
    constexpr
    __tuple_leaf& operator=(const __tuple_leaf&);
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __tuple_leaf()
             noexcept(is_nothrow_default_constructible<_Hp>::value) : __value_()
       {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}
    template <class _Alloc>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
        __tuple_leaf(integral_constant<int, 0>, const _Alloc&)
            : __value_()
        {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}
    template <class _Alloc>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)
            : __value_(allocator_arg_t(), __a)
        {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}
    template <class _Alloc>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)
            : __value_(__a)
        {static_assert(!is_reference<_Hp>::value,
              "Attempted to default construct a reference element in a tuple");}
    template <class _Tp,
              class = __enable_if_t<
                  _And<
                      _IsNotSame<__remove_cvref_t<_Tp>, __tuple_leaf>,
                      is_constructible<_Hp, _Tp>
                    >::value
                >
            >
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
        explicit __tuple_leaf(_Tp&& __t) noexcept((is_nothrow_constructible<_Hp, _Tp>::value))
            : __value_(std::forward<_Tp>(__t))
        {static_assert(__can_bind_reference<_Tp&&>(),
       "Attempted construction of reference element binds to a temporary whose lifetime has ended");}
    template <class _Tp, class _Alloc>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)
            : __value_(std::forward<_Tp>(__t))
        {static_assert(__can_bind_reference<_Tp&&>(),
       "Attempted construction of reference element binds to a temporary whose lifetime has ended");}
    template <class _Tp, class _Alloc>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)
            : __value_(allocator_arg_t(), __a, std::forward<_Tp>(__t))
        {static_assert(!is_reference<_Hp>::value,
            "Attempted to uses-allocator construct a reference element in a tuple");}
    template <class _Tp, class _Alloc>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)
            : __value_(std::forward<_Tp>(__t), __a)
        {static_assert(!is_reference<_Hp>::value,
           "Attempted to uses-allocator construct a reference element in a tuple");}
    __tuple_leaf(const __tuple_leaf& __t) = default;
    __tuple_leaf(__tuple_leaf&& __t) = default;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    int swap(__tuple_leaf& __t) noexcept(__is_nothrow_swappable<__tuple_leaf>::value)
    {
        std::swap(*this, __t);
        return 0;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    int swap(const __tuple_leaf& __t) const noexcept(__is_nothrow_swappable<const __tuple_leaf>::value) {
        std::swap(*this, __t);
        return 0;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Hp& get() noexcept {return __value_;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr const _Hp& get() const noexcept {return __value_;}
};
template <size_t _Ip, class _Hp>
class __tuple_leaf<_Ip, _Hp, true>
    : private _Hp
{
    constexpr
    __tuple_leaf& operator=(const __tuple_leaf&);
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __tuple_leaf()
             noexcept(is_nothrow_default_constructible<_Hp>::value) {}
    template <class _Alloc>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
        __tuple_leaf(integral_constant<int, 0>, const _Alloc&) {}
    template <class _Alloc>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)
            : _Hp(allocator_arg_t(), __a) {}
    template <class _Alloc>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)
            : _Hp(__a) {}
    template <class _Tp,
              class = __enable_if_t<
                  _And<
                    _IsNotSame<__remove_cvref_t<_Tp>, __tuple_leaf>,
                    is_constructible<_Hp, _Tp>
                  >::value
                >
            >
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
        explicit __tuple_leaf(_Tp&& __t) noexcept((is_nothrow_constructible<_Hp, _Tp>::value))
            : _Hp(std::forward<_Tp>(__t)) {}
    template <class _Tp, class _Alloc>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)
            : _Hp(std::forward<_Tp>(__t)) {}
    template <class _Tp, class _Alloc>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)
            : _Hp(allocator_arg_t(), __a, std::forward<_Tp>(__t)) {}
    template <class _Tp, class _Alloc>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)
            : _Hp(std::forward<_Tp>(__t), __a) {}
    __tuple_leaf(__tuple_leaf const &) = default;
    __tuple_leaf(__tuple_leaf &&) = default;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    int
    swap(__tuple_leaf& __t) noexcept(__is_nothrow_swappable<__tuple_leaf>::value)
    {
        std::swap(*this, __t);
        return 0;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    int swap(const __tuple_leaf& __rhs) const noexcept(__is_nothrow_swappable<const __tuple_leaf>::value) {
        std::swap(*this, __rhs);
        return 0;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Hp& get() noexcept {return static_cast<_Hp&>(*this);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr const _Hp& get() const noexcept {return static_cast<const _Hp&>(*this);}
};
template <class ..._Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void __swallow(_Tp&&...) noexcept {}
template <class _Tp>
struct __all_default_constructible;
template <class ..._Tp>
struct __all_default_constructible<__tuple_types<_Tp...>>
    : __all<is_default_constructible<_Tp>::value...>
{ };
template<class _Indx, class ..._Tp> struct __tuple_impl;
template<size_t ..._Indx, class ..._Tp>
struct __tuple_impl<__tuple_indices<_Indx...>, _Tp...>
    : public __tuple_leaf<_Indx, _Tp>...
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr __tuple_impl()
        noexcept(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}
    template <size_t ..._Uf, class ..._Tf,
              size_t ..._Ul, class ..._Tl, class ..._Up>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
        explicit
        __tuple_impl(__tuple_indices<_Uf...>, __tuple_types<_Tf...>,
                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,
                     _Up&&... __u)
                     noexcept((__all<is_nothrow_constructible<_Tf, _Up>::value...>::value && __all<is_nothrow_default_constructible<_Tl>::value...>::value)) :
            __tuple_leaf<_Uf, _Tf>(std::forward<_Up>(__u))...,
            __tuple_leaf<_Ul, _Tl>()...
            {}
    template <class _Alloc, size_t ..._Uf, class ..._Tf,
              size_t ..._Ul, class ..._Tl, class ..._Up>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
        explicit
        __tuple_impl(allocator_arg_t, const _Alloc& __a,
                     __tuple_indices<_Uf...>, __tuple_types<_Tf...>,
                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,
                     _Up&&... __u) :
            __tuple_leaf<_Uf, _Tf>(__uses_alloc_ctor<_Tf, _Alloc, _Up>(), __a,
            std::forward<_Up>(__u))...,
            __tuple_leaf<_Ul, _Tl>(__uses_alloc_ctor<_Tl, _Alloc>(), __a)...
            {}
    template <class _Tuple,
              class = __enable_if_t<__tuple_constructible<_Tuple, tuple<_Tp...> >::value>
             >
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
        __tuple_impl(_Tuple&& __t) noexcept((__all<is_nothrow_constructible<_Tp, typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))
            : __tuple_leaf<_Indx, _Tp>(std::forward<typename tuple_element<_Indx,
                                       typename __make_tuple_types<_Tuple>::type>::type>(std::get<_Indx>(__t)))...
            {}
    template <class _Alloc, class _Tuple,
              class = __enable_if_t<__tuple_constructible<_Tuple, tuple<_Tp...> >::value>
             >
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
        __tuple_impl(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)
            : __tuple_leaf<_Indx, _Tp>(__uses_alloc_ctor<_Tp, _Alloc, typename tuple_element<_Indx,
                                       typename __make_tuple_types<_Tuple>::type>::type>(), __a,
                                       std::forward<typename tuple_element<_Indx,
                                       typename __make_tuple_types<_Tuple>::type>::type>(std::get<_Indx>(__t)))...
            {}
    __tuple_impl(const __tuple_impl&) = default;
    __tuple_impl(__tuple_impl&&) = default;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    void swap(__tuple_impl& __t)
        noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value)
    {
        std::__swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t))...);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    void swap(const __tuple_impl& __t) const
        noexcept(__all<__is_nothrow_swappable<const _Tp>::value...>::value)
    {
        std::__swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<const __tuple_leaf<_Indx, _Tp>&>(__t))...);
    }
};
template<class _Dest, class _Source, size_t ..._Np>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void __memberwise_copy_assign(_Dest& __dest, _Source const& __source, __tuple_indices<_Np...>) {
    std::__swallow(((std::get<_Np>(__dest) = std::get<_Np>(__source)), void(), 0)...);
}
template<class _Dest, class _Source, class ..._Up, size_t ..._Np>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
void __memberwise_forward_assign(_Dest& __dest, _Source&& __source, __tuple_types<_Up...>, __tuple_indices<_Np...>) {
    std::__swallow(((
        std::get<_Np>(__dest) = std::forward<_Up>(std::get<_Np>(__source))
    ), void(), 0)...);
}
template <class ..._Tp>
class __attribute__((__type_visibility__("default"))) tuple
{
    typedef __tuple_impl<typename __make_tuple_indices<sizeof...(_Tp)>::type, _Tp...> _BaseT;
    _BaseT __base_;
    template <size_t _Jp, class ..._Up> friend constexpr
        typename tuple_element<_Jp, tuple<_Up...> >::type& get(tuple<_Up...>&) noexcept;
    template <size_t _Jp, class ..._Up> friend constexpr
        const typename tuple_element<_Jp, tuple<_Up...> >::type& get(const tuple<_Up...>&) noexcept;
    template <size_t _Jp, class ..._Up> friend constexpr
        typename tuple_element<_Jp, tuple<_Up...> >::type&& get(tuple<_Up...>&&) noexcept;
    template <size_t _Jp, class ..._Up> friend constexpr
        const typename tuple_element<_Jp, tuple<_Up...> >::type&& get(const tuple<_Up...>&&) noexcept;
public:
    template <template<class...> class _IsImpDefault = __is_implicitly_default_constructible, __enable_if_t<
        _And<
            _IsImpDefault<_Tp>...
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    tuple()
        noexcept(_And<is_nothrow_default_constructible<_Tp>...>::value)
    { }
    template <template<class...> class _IsImpDefault = __is_implicitly_default_constructible,
              template<class...> class _IsDefault = is_default_constructible, __enable_if_t<
        _And<
            _IsDefault<_Tp>...,
            _Not<_Lazy<_And, _IsImpDefault<_Tp>...> >
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    explicit tuple()
        noexcept(_And<is_nothrow_default_constructible<_Tp>...>::value)
    { }
    template <class _Alloc, template<class...> class _IsImpDefault = __is_implicitly_default_constructible, __enable_if_t<
        _And<
            _IsImpDefault<_Tp>...
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    tuple(allocator_arg_t, _Alloc const& __a)
      : __base_(allocator_arg_t(), __a,
                    __tuple_indices<>(), __tuple_types<>(),
                    typename __make_tuple_indices<sizeof...(_Tp), 0>::type(),
                    __tuple_types<_Tp...>()) {}
    template <class _Alloc,
              template<class...> class _IsImpDefault = __is_implicitly_default_constructible,
              template<class...> class _IsDefault = is_default_constructible, __enable_if_t<
        _And<
            _IsDefault<_Tp>...,
            _Not<_Lazy<_And, _IsImpDefault<_Tp>...> >
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    explicit tuple(allocator_arg_t, _Alloc const& __a)
      : __base_(allocator_arg_t(), __a,
                    __tuple_indices<>(), __tuple_types<>(),
                    typename __make_tuple_indices<sizeof...(_Tp), 0>::type(),
                    __tuple_types<_Tp...>()) {}
    template <template<class...> class _And = _And, __enable_if_t<
        _And<
            _BoolConstant<sizeof...(_Tp) >= 1>,
            is_copy_constructible<_Tp>...,
            is_convertible<const _Tp&, _Tp>...
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    tuple(const _Tp& ... __t)
        noexcept(_And<is_nothrow_copy_constructible<_Tp>...>::value)
        : __base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}
    template <template<class...> class _And = _And, __enable_if_t<
        _And<
            _BoolConstant<sizeof...(_Tp) >= 1>,
            is_copy_constructible<_Tp>...,
            _Not<_Lazy<_And, is_convertible<const _Tp&, _Tp>...> >
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    explicit tuple(const _Tp& ... __t)
        noexcept(_And<is_nothrow_copy_constructible<_Tp>...>::value)
        : __base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}
    template <class _Alloc, template<class...> class _And = _And, __enable_if_t<
        _And<
            _BoolConstant<sizeof...(_Tp) >= 1>,
            is_copy_constructible<_Tp>...,
            is_convertible<const _Tp&, _Tp>...
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)
        : __base_(allocator_arg_t(), __a,
                typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}
    template <class _Alloc, template<class...> class _And = _And, __enable_if_t<
        _And<
            _BoolConstant<sizeof...(_Tp) >= 1>,
            is_copy_constructible<_Tp>...,
            _Not<_Lazy<_And, is_convertible<const _Tp&, _Tp>...> >
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    explicit tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)
        : __base_(allocator_arg_t(), __a,
                typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...
               ) {}
    template <class ..._Up> struct _IsThisTuple : false_type { };
    template <class _Up> struct _IsThisTuple<_Up> : is_same<__remove_cvref_t<_Up>, tuple> { };
    template <class ..._Up>
    struct _EnableUTypesCtor : _And<
        _BoolConstant<sizeof...(_Tp) >= 1>,
        _Not<_IsThisTuple<_Up...> >,
        is_constructible<_Tp, _Up>...
    > { };
    template <class ..._Up, __enable_if_t<
        _And<
            _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>,
            _EnableUTypesCtor<_Up...>,
            is_convertible<_Up, _Tp>...
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    tuple(_Up&&... __u)
        noexcept((_And<is_nothrow_constructible<_Tp, _Up>...>::value))
        : __base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::forward<_Up>(__u)...) {}
    template <class ..._Up, __enable_if_t<
        _And<
            _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>,
            _EnableUTypesCtor<_Up...>,
            _Not<_Lazy<_And, is_convertible<_Up, _Tp>...> >
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    explicit tuple(_Up&&... __u)
        noexcept((_And<is_nothrow_constructible<_Tp, _Up>...>::value))
        : __base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::forward<_Up>(__u)...) {}
    template <class _Alloc, class ..._Up, __enable_if_t<
        _And<
            _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>,
            _EnableUTypesCtor<_Up...>,
            is_convertible<_Up, _Tp>...
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)
        : __base_(allocator_arg_t(), __a,
                    typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::forward<_Up>(__u)...) {}
    template <class _Alloc, class ..._Up, __enable_if_t<
        _And<
            _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>,
            _EnableUTypesCtor<_Up...>,
            _Not<_Lazy<_And, is_convertible<_Up, _Tp>...> >
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    explicit tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)
        : __base_(allocator_arg_t(), __a,
                    typename __make_tuple_indices<sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                    std::forward<_Up>(__u)...) {}
    tuple(const tuple&) = default;
    tuple(tuple&&) = default;
    template <class _Alloc, template<class...> class _And = _And, __enable_if_t<
        _And<is_copy_constructible<_Tp>...>::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    tuple(allocator_arg_t, const _Alloc& __alloc, const tuple& __t)
        : __base_(allocator_arg_t(), __alloc, __t)
    { }
    template <class _Alloc, template<class...> class _And = _And, __enable_if_t<
        _And<is_move_constructible<_Tp>...>::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    tuple(allocator_arg_t, const _Alloc& __alloc, tuple&& __t)
        : __base_(allocator_arg_t(), __alloc, std::move(__t))
    { }
    template <class _OtherTuple, class _DecayedOtherTuple = __remove_cvref_t<_OtherTuple>, class = void>
    struct _EnableCtorFromUTypesTuple : false_type {};
    template <class _OtherTuple, class... _Up>
    struct _EnableCtorFromUTypesTuple<_OtherTuple, tuple<_Up...>,
               __enable_if_t<sizeof...(_Up) == sizeof...(_Tp)>> : _And<
        _Not<is_same<_OtherTuple, const tuple&> >,
        _Not<is_same<_OtherTuple, tuple&&> >,
        is_constructible<_Tp, __copy_cvref_t<_OtherTuple, _Up> >...,
        _Lazy<_Or, _BoolConstant<sizeof...(_Tp) != 1>,
            _Lazy<_And,
                _Not<is_same<_Tp, _Up> >...,
                _Not<is_convertible<_OtherTuple, _Tp> >...,
                _Not<is_constructible<_Tp, _OtherTuple> >...
            >
        >
    > {};
    template <class ..._Up, __enable_if_t<
        _And<
            _EnableCtorFromUTypesTuple<const tuple<_Up...>&>,
            is_convertible<const _Up&, _Tp>...
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    tuple(const tuple<_Up...>& __t)
        noexcept((_And<is_nothrow_constructible<_Tp, const _Up&>...>::value))
        : __base_(__t)
    { }
    template <class ..._Up, __enable_if_t<
        _And<
            _EnableCtorFromUTypesTuple<const tuple<_Up...>&>,
            _Not<_Lazy<_And, is_convertible<const _Up&, _Tp>...> >
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    explicit tuple(const tuple<_Up...>& __t)
        noexcept((_And<is_nothrow_constructible<_Tp, const _Up&>...>::value))
        : __base_(__t)
    { }
    template <class ..._Up, class _Alloc, __enable_if_t<
        _And<
            _EnableCtorFromUTypesTuple<const tuple<_Up...>&>,
            is_convertible<const _Up&, _Tp>...
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    tuple(allocator_arg_t, const _Alloc& __a, const tuple<_Up...>& __t)
        : __base_(allocator_arg_t(), __a, __t)
    { }
    template <class ..._Up, class _Alloc, __enable_if_t<
        _And<
            _EnableCtorFromUTypesTuple<const tuple<_Up...>&>,
            _Not<_Lazy<_And, is_convertible<const _Up&, _Tp>...> >
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    explicit tuple(allocator_arg_t, const _Alloc& __a, const tuple<_Up...>& __t)
        : __base_(allocator_arg_t(), __a, __t)
    { }
    template <class ..._Up, __enable_if_t<
        _And<
            _EnableCtorFromUTypesTuple<tuple<_Up...>&&>,
            is_convertible<_Up, _Tp>...
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    tuple(tuple<_Up...>&& __t)
        noexcept((_And<is_nothrow_constructible<_Tp, _Up>...>::value))
        : __base_(std::move(__t))
    { }
    template <class ..._Up, __enable_if_t<
        _And<
            _EnableCtorFromUTypesTuple<tuple<_Up...>&&>,
            _Not<_Lazy<_And, is_convertible<_Up, _Tp>...> >
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    explicit tuple(tuple<_Up...>&& __t)
        noexcept((_And<is_nothrow_constructible<_Tp, _Up>...>::value))
        : __base_(std::move(__t))
    { }
    template <class _Alloc, class ..._Up, __enable_if_t<
        _And<
            _EnableCtorFromUTypesTuple<tuple<_Up...>&&>,
            is_convertible<_Up, _Tp>...
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    tuple(allocator_arg_t, const _Alloc& __a, tuple<_Up...>&& __t)
        : __base_(allocator_arg_t(), __a, std::move(__t))
    { }
    template <class _Alloc, class ..._Up, __enable_if_t<
        _And<
            _EnableCtorFromUTypesTuple<tuple<_Up...>&&>,
            _Not<_Lazy<_And, is_convertible<_Up, _Tp>...> >
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    explicit tuple(allocator_arg_t, const _Alloc& __a, tuple<_Up...>&& __t)
        : __base_(allocator_arg_t(), __a, std::move(__t))
    { }
    template <template <class...> class Pred, class _Pair, class _DecayedPair = __remove_cvref_t<_Pair>, class _Tuple = tuple>
    struct _CtorPredicateFromPair : false_type{};
    template <template <class...> class Pred, class _Pair, class _Up1, class _Up2, class _Tp1, class _Tp2>
    struct _CtorPredicateFromPair<Pred, _Pair, pair<_Up1, _Up2>, tuple<_Tp1, _Tp2> > : _And<
        Pred<_Tp1, __copy_cvref_t<_Pair, _Up1> >,
        Pred<_Tp2, __copy_cvref_t<_Pair, _Up2> >
    > {};
    template <class _Pair>
    struct _EnableCtorFromPair : _CtorPredicateFromPair<is_constructible, _Pair>{};
    template <class _Pair>
    struct _NothrowConstructibleFromPair : _CtorPredicateFromPair<is_nothrow_constructible, _Pair>{};
    template <class _Pair, class _DecayedPair = __remove_cvref_t<_Pair>, class _Tuple = tuple>
    struct _BothImplicitlyConvertible : false_type{};
    template <class _Pair, class _Up1, class _Up2, class _Tp1, class _Tp2>
    struct _BothImplicitlyConvertible<_Pair, pair<_Up1, _Up2>, tuple<_Tp1, _Tp2> > : _And<
        is_convertible<__copy_cvref_t<_Pair, _Up1>, _Tp1>,
        is_convertible<__copy_cvref_t<_Pair, _Up2>, _Tp2>
    > {};
    template <class _Up1, class _Up2, template<class...> class _And = _And, __enable_if_t<
        _And<
            _EnableCtorFromPair<const pair<_Up1, _Up2>&>,
            _BothImplicitlyConvertible<const pair<_Up1, _Up2>&>
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    tuple(const pair<_Up1, _Up2>& __p)
        noexcept((_NothrowConstructibleFromPair<const pair<_Up1, _Up2>&>::value))
        : __base_(__p)
    { }
    template <class _Up1, class _Up2, template<class...> class _And = _And, __enable_if_t<
        _And<
            _EnableCtorFromPair<const pair<_Up1, _Up2>&>,
            _Not<_BothImplicitlyConvertible<const pair<_Up1, _Up2>&> >
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    explicit tuple(const pair<_Up1, _Up2>& __p)
        noexcept((_NothrowConstructibleFromPair<const pair<_Up1, _Up2>&>::value))
        : __base_(__p)
    { }
    template <class _Alloc, class _Up1, class _Up2, template<class...> class _And = _And, __enable_if_t<
        _And<
            _EnableCtorFromPair<const pair<_Up1, _Up2>&>,
            _BothImplicitlyConvertible<const pair<_Up1, _Up2>&>
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    tuple(allocator_arg_t, const _Alloc& __a, const pair<_Up1, _Up2>& __p)
        : __base_(allocator_arg_t(), __a, __p)
    { }
    template <class _Alloc, class _Up1, class _Up2, template<class...> class _And = _And, __enable_if_t<
        _And<
            _EnableCtorFromPair<const pair<_Up1, _Up2>&>,
            _Not<_BothImplicitlyConvertible<const pair<_Up1, _Up2>&> >
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    explicit tuple(allocator_arg_t, const _Alloc& __a, const pair<_Up1, _Up2>& __p)
        : __base_(allocator_arg_t(), __a, __p)
    { }
    template <class _Up1, class _Up2, template<class...> class _And = _And, __enable_if_t<
        _And<
            _EnableCtorFromPair<pair<_Up1, _Up2>&&>,
            _BothImplicitlyConvertible<pair<_Up1, _Up2>&&>
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    tuple(pair<_Up1, _Up2>&& __p)
        noexcept((_NothrowConstructibleFromPair<pair<_Up1, _Up2>&&>::value))
        : __base_(std::move(__p))
    { }
    template <class _Up1, class _Up2, template<class...> class _And = _And, __enable_if_t<
        _And<
            _EnableCtorFromPair<pair<_Up1, _Up2>&&>,
            _Not<_BothImplicitlyConvertible<pair<_Up1, _Up2>&&> >
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    explicit tuple(pair<_Up1, _Up2>&& __p)
        noexcept((_NothrowConstructibleFromPair<pair<_Up1, _Up2>&&>::value))
        : __base_(std::move(__p))
    { }
    template <class _Alloc, class _Up1, class _Up2, template<class...> class _And = _And, __enable_if_t<
        _And<
            _EnableCtorFromPair<pair<_Up1, _Up2>&&>,
            _BothImplicitlyConvertible<pair<_Up1, _Up2>&&>
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    tuple(allocator_arg_t, const _Alloc& __a, pair<_Up1, _Up2>&& __p)
        : __base_(allocator_arg_t(), __a, std::move(__p))
    { }
    template <class _Alloc, class _Up1, class _Up2, template<class...> class _And = _And, __enable_if_t<
        _And<
            _EnableCtorFromPair<pair<_Up1, _Up2>&&>,
            _Not<_BothImplicitlyConvertible<pair<_Up1, _Up2>&&> >
        >::value
    , int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    explicit tuple(allocator_arg_t, const _Alloc& __a, pair<_Up1, _Up2>&& __p)
        : __base_(allocator_arg_t(), __a, std::move(__p))
    { }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    tuple& operator=(_If<_And<is_copy_assignable<_Tp>...>::value, tuple, __nat> const& __tuple)
        noexcept((_And<is_nothrow_copy_assignable<_Tp>...>::value))
    {
        std::__memberwise_copy_assign(*this, __tuple,
            typename __make_tuple_indices<sizeof...(_Tp)>::type());
        return *this;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    tuple& operator=(_If<_And<is_move_assignable<_Tp>...>::value, tuple, __nat>&& __tuple)
        noexcept((_And<is_nothrow_move_assignable<_Tp>...>::value))
    {
        std::__memberwise_forward_assign(*this, std::move(__tuple),
            __tuple_types<_Tp...>(),
            typename __make_tuple_indices<sizeof...(_Tp)>::type());
        return *this;
    }
    template<class... _Up, __enable_if_t<
        _And<
            _BoolConstant<sizeof...(_Tp) == sizeof...(_Up)>,
            is_assignable<_Tp&, _Up const&>...
        >::value
    ,int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    tuple& operator=(tuple<_Up...> const& __tuple)
        noexcept((_And<is_nothrow_assignable<_Tp&, _Up const&>...>::value))
    {
        std::__memberwise_copy_assign(*this, __tuple,
            typename __make_tuple_indices<sizeof...(_Tp)>::type());
        return *this;
    }
    template<class... _Up, __enable_if_t<
        _And<
            _BoolConstant<sizeof...(_Tp) == sizeof...(_Up)>,
            is_assignable<_Tp&, _Up>...
        >::value
    ,int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    tuple& operator=(tuple<_Up...>&& __tuple)
        noexcept((_And<is_nothrow_assignable<_Tp&, _Up>...>::value))
    {
        std::__memberwise_forward_assign(*this, std::move(__tuple),
            __tuple_types<_Up...>(),
            typename __make_tuple_indices<sizeof...(_Tp)>::type());
        return *this;
    }
    template <template<class...> class Pred, bool _Const,
              class _Pair, class _DecayedPair = __remove_cvref_t<_Pair>, class _Tuple = tuple>
    struct _AssignPredicateFromPair : false_type {};
    template <template<class...> class Pred, bool _Const,
              class _Pair, class _Up1, class _Up2, class _Tp1, class _Tp2>
    struct _AssignPredicateFromPair<Pred, _Const, _Pair, pair<_Up1, _Up2>, tuple<_Tp1, _Tp2> > :
        _And<Pred<__maybe_const<_Const, _Tp1>&, __copy_cvref_t<_Pair, _Up1> >,
             Pred<__maybe_const<_Const, _Tp2>&, __copy_cvref_t<_Pair, _Up2> >
            > {};
    template <bool _Const, class _Pair>
    struct _EnableAssignFromPair : _AssignPredicateFromPair<is_assignable, _Const, _Pair> {};
    template <bool _Const, class _Pair>
    struct _NothrowAssignFromPair : _AssignPredicateFromPair<is_nothrow_assignable, _Const, _Pair> {};
    template<class _Up1, class _Up2, __enable_if_t<
        _EnableAssignFromPair<false, pair<_Up1, _Up2> const&>::value
    ,int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    tuple& operator=(pair<_Up1, _Up2> const& __pair)
        noexcept((_NothrowAssignFromPair<false, pair<_Up1, _Up2> const&>::value))
    {
        std::get<0>(*this) = __pair.first;
        std::get<1>(*this) = __pair.second;
        return *this;
    }
    template<class _Up1, class _Up2, __enable_if_t<
        _EnableAssignFromPair<false, pair<_Up1, _Up2>&&>::value
    ,int> = 0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    tuple& operator=(pair<_Up1, _Up2>&& __pair)
        noexcept((_NothrowAssignFromPair<false, pair<_Up1, _Up2>&&>::value))
    {
        std::get<0>(*this) = std::forward<_Up1>(__pair.first);
        std::get<1>(*this) = std::forward<_Up2>(__pair.second);
        return *this;
    }
    template<class _Up, size_t _Np, class = __enable_if_t<
        _And<
            _BoolConstant<_Np == sizeof...(_Tp)>,
            is_assignable<_Tp&, _Up const&>...
        >::value
    > >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    tuple& operator=(array<_Up, _Np> const& __array)
        noexcept((_And<is_nothrow_assignable<_Tp&, _Up const&>...>::value))
    {
        std::__memberwise_copy_assign(*this, __array,
            typename __make_tuple_indices<sizeof...(_Tp)>::type());
        return *this;
    }
    template<class _Up, size_t _Np, class = void, class = __enable_if_t<
        _And<
            _BoolConstant<_Np == sizeof...(_Tp)>,
            is_assignable<_Tp&, _Up>...
        >::value
    > >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    tuple& operator=(array<_Up, _Np>&& __array)
        noexcept((_And<is_nothrow_assignable<_Tp&, _Up>...>::value))
    {
        std::__memberwise_forward_assign(*this, std::move(__array),
            __tuple_types<_If<true, _Up, _Tp>...>(),
            typename __make_tuple_indices<sizeof...(_Tp)>::type());
        return *this;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    void swap(tuple& __t) noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value)
        {__base_.swap(__t.__base_);}
};
template <>
class __attribute__((__type_visibility__("default"))) tuple<>
{
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
        tuple() noexcept = default;
    template <class _Alloc>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
        tuple(allocator_arg_t, const _Alloc&) noexcept {}
    template <class _Alloc>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
        tuple(allocator_arg_t, const _Alloc&, const tuple&) noexcept {}
    template <class _Up>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
        tuple(array<_Up, 0>) noexcept {}
    template <class _Alloc, class _Up>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
        tuple(allocator_arg_t, const _Alloc&, array<_Up, 0>) noexcept {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    void swap(tuple&) noexcept {}
};
template <class ..._Tp>
tuple(_Tp...) -> tuple<_Tp...>;
template <class _Tp1, class _Tp2>
tuple(pair<_Tp1, _Tp2>) -> tuple<_Tp1, _Tp2>;
template <class _Alloc, class ..._Tp>
tuple(allocator_arg_t, _Alloc, _Tp...) -> tuple<_Tp...>;
template <class _Alloc, class _Tp1, class _Tp2>
tuple(allocator_arg_t, _Alloc, pair<_Tp1, _Tp2>) -> tuple<_Tp1, _Tp2>;
template <class _Alloc, class ..._Tp>
tuple(allocator_arg_t, _Alloc, tuple<_Tp...>) -> tuple<_Tp...>;
template <class ..._Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
__enable_if_t<__all<__is_swappable<_Tp>::value...>::value, void>
swap(tuple<_Tp...>& __t, tuple<_Tp...>& __u)
                 noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value)
    {__t.swap(__u);}
template <size_t _Ip, class ..._Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(tuple<_Tp...>& __t) noexcept
{
    typedef __attribute__((__nodebug__)) typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<__tuple_leaf<_Ip, type>&>(__t.__base_).get();
}
template <size_t _Ip, class ..._Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
const typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(const tuple<_Tp...>& __t) noexcept
{
    typedef __attribute__((__nodebug__)) typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<const __tuple_leaf<_Ip, type>&>(__t.__base_).get();
}
template <size_t _Ip, class ..._Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(tuple<_Tp...>&& __t) noexcept
{
    typedef __attribute__((__nodebug__)) typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<type&&>(
             static_cast<__tuple_leaf<_Ip, type>&&>(__t.__base_).get());
}
template <size_t _Ip, class ..._Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
const typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(const tuple<_Tp...>&& __t) noexcept
{
    typedef __attribute__((__nodebug__)) typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    return static_cast<const type&&>(
             static_cast<const __tuple_leaf<_Ip, type>&&>(__t.__base_).get());
}
namespace __find_detail {
static constexpr size_t __not_found = static_cast<size_t>(-1);
static constexpr size_t __ambiguous = __not_found - 1;
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr size_t __find_idx_return(size_t __curr_i, size_t __res, bool __matches) {
    return !__matches ? __res :
        (__res == __not_found ? __curr_i : __ambiguous);
}
template <size_t _Nx>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr size_t __find_idx(size_t __i, const bool (&__matches)[_Nx]) {
  return __i == _Nx ? __not_found :
      __find_detail::__find_idx_return(__i, __find_detail::__find_idx(__i + 1, __matches), __matches[__i]);
}
template <class _T1, class ..._Args>
struct __find_exactly_one_checked {
    static constexpr bool __matches[sizeof...(_Args)] = {is_same<_T1, _Args>::value...};
    static constexpr size_t value = __find_detail::__find_idx(0, __matches);
    static_assert(value != __not_found, "type not found in type list" );
    static_assert(value != __ambiguous, "type occurs more than once in type list");
};
template <class _T1>
struct __find_exactly_one_checked<_T1> {
    static_assert(!is_same<_T1, _T1>::value, "type not in empty type list");
};
}
template <typename _T1, typename... _Args>
struct __find_exactly_one_t
    : public __find_detail::__find_exactly_one_checked<_T1, _Args...> {
};
template <class _T1, class... _Args>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr _T1& get(tuple<_Args...>& __tup) noexcept
{
    return std::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
}
template <class _T1, class... _Args>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr _T1 const& get(tuple<_Args...> const& __tup) noexcept
{
    return std::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
}
template <class _T1, class... _Args>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr _T1&& get(tuple<_Args...>&& __tup) noexcept
{
    return std::get<__find_exactly_one_t<_T1, _Args...>::value>(std::move(__tup));
}
template <class _T1, class... _Args>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr _T1 const&& get(tuple<_Args...> const&& __tup) noexcept
{
    return std::get<__find_exactly_one_t<_T1, _Args...>::value>(std::move(__tup));
}
template <class ..._Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
tuple<_Tp&...>
tie(_Tp&... __t) noexcept
{
    return tuple<_Tp&...>(__t...);
}
template <class _Up>
struct __ignore_t
{
    template <class _Tp>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    const __ignore_t& operator=(_Tp&&) const {return *this;}
};
namespace {
  constexpr __ignore_t<unsigned char> ignore = __ignore_t<unsigned char>();
}
template <class... _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
tuple<typename __unwrap_ref_decay<_Tp>::type...>
make_tuple(_Tp&&... __t)
{
    return tuple<typename __unwrap_ref_decay<_Tp>::type...>(std::forward<_Tp>(__t)...);
}
template <class... _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
tuple<_Tp&&...>
forward_as_tuple(_Tp&&... __t) noexcept
{
    return tuple<_Tp&&...>(std::forward<_Tp>(__t)...);
}
template <size_t _Ip>
struct __tuple_equal
{
    template <class _Tp, class _Up>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    bool operator()(const _Tp& __x, const _Up& __y)
    {
        return __tuple_equal<_Ip - 1>()(__x, __y) && std::get<_Ip-1>(__x) == std::get<_Ip-1>(__y);
    }
};
template <>
struct __tuple_equal<0>
{
    template <class _Tp, class _Up>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    bool operator()(const _Tp&, const _Up&)
    {
        return true;
    }
};
template <class ..._Tp, class ..._Up>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool
operator==(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    static_assert (sizeof...(_Tp) == sizeof...(_Up), "Can't compare tuples of different sizes");
    return __tuple_equal<sizeof...(_Tp)>()(__x, __y);
}
template <class ..._Tp, class ..._Up, size_t ..._Is>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
auto
__tuple_compare_three_way(const tuple<_Tp...>& __x, const tuple<_Up...>& __y, index_sequence<_Is...>) {
    common_comparison_category_t<__synth_three_way_result<_Tp, _Up>...> __result = strong_ordering::equal;
    static_cast<void>(((__result = std::__synth_three_way(std::get<_Is>(__x), std::get<_Is>(__y)), __result != 0) || ...));
    return __result;
}
template <class ..._Tp, class ..._Up>
requires (sizeof...(_Tp) == sizeof...(_Up))
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
common_comparison_category_t<__synth_three_way_result<_Tp, _Up>...>
operator<=>(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
{
    return std::__tuple_compare_three_way(__x, __y, index_sequence_for<_Tp...>{});
}
template <class _Tp, class _Up> struct __tuple_cat_type;
template <class ..._Ttypes, class ..._Utypes>
struct __tuple_cat_type<tuple<_Ttypes...>, __tuple_types<_Utypes...> >
{
    typedef __attribute__((__nodebug__)) tuple<_Ttypes..., _Utypes...> type;
};
template <class _ResultTuple, bool _Is_Tuple0TupleLike, class ..._Tuples>
struct __tuple_cat_return_1
{
};
template <class ..._Types, class _Tuple0>
struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0>
{
  using type __attribute__((__nodebug__)) = typename __tuple_cat_type<
      tuple<_Types...>,
      typename __make_tuple_types<__remove_cvref_t<_Tuple0> >::type
    >::type;
};
template <class ..._Types, class _Tuple0, class _Tuple1, class ..._Tuples>
struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0, _Tuple1, _Tuples...>
    : public __tuple_cat_return_1<
                 typename __tuple_cat_type<
                     tuple<_Types...>,
                     typename __make_tuple_types<__remove_cvref_t<_Tuple0> >::type
                 >::type,
                 __tuple_like_ext<__libcpp_remove_reference_t<_Tuple1> >::value,
                 _Tuple1, _Tuples...>
{
};
template <class ..._Tuples> struct __tuple_cat_return;
template <class _Tuple0, class ..._Tuples>
struct __tuple_cat_return<_Tuple0, _Tuples...>
    : public __tuple_cat_return_1<tuple<>,
         __tuple_like_ext<__libcpp_remove_reference_t<_Tuple0> >::value, _Tuple0,
                                                                     _Tuples...>
{
};
template <>
struct __tuple_cat_return<>
{
    typedef __attribute__((__nodebug__)) tuple<> type;
};
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
tuple<>
tuple_cat()
{
    return tuple<>();
}
template <class _Rp, class _Indices, class _Tuple0, class ..._Tuples>
struct __tuple_cat_return_ref_imp;
template <class ..._Types, size_t ..._I0, class _Tuple0>
struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>, _Tuple0>
{
    typedef __attribute__((__nodebug__)) __libcpp_remove_reference_t<_Tuple0> _T0;
    typedef tuple<_Types..., typename __apply_cv<_Tuple0,
                          typename tuple_element<_I0, _T0>::type>::type&&...> type;
};
template <class ..._Types, size_t ..._I0, class _Tuple0, class _Tuple1, class ..._Tuples>
struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>,
                                  _Tuple0, _Tuple1, _Tuples...>
    : public __tuple_cat_return_ref_imp<
         tuple<_Types..., typename __apply_cv<_Tuple0,
               typename tuple_element<_I0,
                  __libcpp_remove_reference_t<_Tuple0> >::type>::type&&...>,
         typename __make_tuple_indices<tuple_size<__libcpp_remove_reference_t<_Tuple1> >::value>::type,
         _Tuple1, _Tuples...>
{
};
template <class _Tuple0, class ..._Tuples>
struct __tuple_cat_return_ref
    : public __tuple_cat_return_ref_imp<tuple<>,
               typename __make_tuple_indices<
                        tuple_size<__libcpp_remove_reference_t<_Tuple0> >::value
               >::type, _Tuple0, _Tuples...>
{
};
template <class _Types, class _I0, class _J0>
struct __tuple_cat;
template <class ..._Types, size_t ..._I0, size_t ..._J0>
struct __tuple_cat<tuple<_Types...>, __tuple_indices<_I0...>, __tuple_indices<_J0...> >
{
    template <class _Tuple0>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&>::type
    operator()(tuple<_Types...> __t, _Tuple0&& __t0)
    {
        (void)__t;
        return std::forward_as_tuple(
            std::forward<_Types>(std::get<_I0>(__t))...,
            std::get<_J0>(std::forward<_Tuple0>(__t0))...);
    }
    template <class _Tuple0, class _Tuple1, class ..._Tuples>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&, _Tuple1&&, _Tuples&&...>::type
    operator()(tuple<_Types...> __t, _Tuple0&& __t0, _Tuple1&& __t1, _Tuples&& ...__tpls)
    {
        (void)__t;
        typedef __attribute__((__nodebug__)) __libcpp_remove_reference_t<_Tuple0> _T0;
        typedef __attribute__((__nodebug__)) __libcpp_remove_reference_t<_Tuple1> _T1;
        return __tuple_cat<
            tuple<_Types...,
                  typename __apply_cv<_Tuple0, typename tuple_element<
                                                   _J0, _T0>::type>::type&&...>,
            typename __make_tuple_indices<sizeof...(_Types) +
                                          tuple_size<_T0>::value>::type,
            typename __make_tuple_indices<tuple_size<_T1>::value>::type>()(
            std::forward_as_tuple(
                std::forward<_Types>(std::get<_I0>(__t))...,
                std::get<_J0>(std::forward<_Tuple0>(__t0))...),
            std::forward<_Tuple1>(__t1), std::forward<_Tuples>(__tpls)...);
    }
};
template <class _Tuple0, class... _Tuples>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
typename __tuple_cat_return<_Tuple0, _Tuples...>::type
tuple_cat(_Tuple0&& __t0, _Tuples&&... __tpls)
{
    typedef __attribute__((__nodebug__)) __libcpp_remove_reference_t<_Tuple0> _T0;
    return __tuple_cat<tuple<>, __tuple_indices<>,
                  typename __make_tuple_indices<tuple_size<_T0>::value>::type>()
                  (tuple<>(), std::forward<_Tuple0>(__t0),
                                            std::forward<_Tuples>(__tpls)...);
}
template <class ..._Tp, class _Alloc>
struct __attribute__((__type_visibility__("default"))) uses_allocator<tuple<_Tp...>, _Alloc>
    : true_type {};
template <class _T1, class _T2>
template <class... _Args1, class... _Args2, size_t ..._I1, size_t ..._I2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
pair<_T1, _T2>::pair(piecewise_construct_t,
                     tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,
                     __tuple_indices<_I1...>, __tuple_indices<_I2...>)
    : first(std::forward<_Args1>(std::get<_I1>( __first_args))...),
      second(std::forward<_Args2>(std::get<_I2>(__second_args))...)
{
}
template <class _Tp>
inline constexpr size_t tuple_size_v = tuple_size<_Tp>::value;
template <class _Fn, class _Tuple, size_t ..._Id>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr decltype(auto) __apply_tuple_impl(_Fn && __f, _Tuple && __t,
                                            __tuple_indices<_Id...>)
noexcept(noexcept(std::__invoke( std::forward<_Fn>(__f), std::get<_Id>(std::forward<_Tuple>(__t))...))) { return std::__invoke( std::forward<_Fn>(__f), std::get<_Id>(std::forward<_Tuple>(__t))...); }
template <class _Fn, class _Tuple>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr decltype(auto) apply(_Fn && __f, _Tuple && __t)
noexcept(noexcept(std::__apply_tuple_impl( std::forward<_Fn>(__f), std::forward<_Tuple>(__t), typename __make_tuple_indices<tuple_size_v<remove_reference_t<_Tuple>>>::type{}))) { return std::__apply_tuple_impl( std::forward<_Fn>(__f), std::forward<_Tuple>(__t), typename __make_tuple_indices<tuple_size_v<remove_reference_t<_Tuple>>>::type{}); }
template <class _Tp, class _Tuple, size_t... _Idx>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr _Tp __make_from_tuple_impl(_Tuple&& __t, __tuple_indices<_Idx...>)
noexcept(noexcept(_Tp(std::get<_Idx>(std::forward<_Tuple>(__t))...))) { return _Tp(std::get<_Idx>(std::forward<_Tuple>(__t))...); }
template <class _Tp, class _Tuple>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr _Tp make_from_tuple(_Tuple&& __t)
noexcept(noexcept(std::__make_from_tuple_impl<_Tp>(std::forward<_Tuple>(__t), typename __make_tuple_indices<tuple_size_v<remove_reference_t<_Tuple>>>::type{}))) { return std::__make_from_tuple_impl<_Tp>(std::forward<_Tuple>(__t), typename __make_tuple_indices<tuple_size_v<remove_reference_t<_Tuple>>>::type{}); }
}}
namespace std
{
struct __type_info_implementations {
  struct __string_impl_base {
    typedef const char* __type_name_t;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__always_inline__))
    constexpr static const char* __type_name_to_string(__type_name_t __v) noexcept {
      return __v;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__always_inline__))
    constexpr static __type_name_t __string_to_type_name(const char* __v) noexcept {
      return __v;
    }
  };
  struct __unique_impl : __string_impl_base {
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__always_inline__))
    static size_t __hash(__type_name_t __v) noexcept {
      return reinterpret_cast<size_t>(__v);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__always_inline__))
    static bool __eq(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return __lhs == __rhs;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__always_inline__))
    static bool __lt(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return __lhs < __rhs;
    }
  };
  struct __non_unique_impl : __string_impl_base {
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__always_inline__))
    static size_t __hash(__type_name_t __ptr) noexcept {
      size_t __hash = 5381;
      while (unsigned char __c = static_cast<unsigned char>(*__ptr++))
        __hash = (__hash * 33) ^ __c;
      return __hash;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__always_inline__))
    static bool __eq(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return __lhs == __rhs || __builtin_strcmp(__lhs, __rhs) == 0;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__always_inline__))
    static bool __lt(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return __builtin_strcmp(__lhs, __rhs) < 0;
    }
  };
  struct __non_unique_arm_rtti_bit_impl {
    typedef uintptr_t __type_name_t;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__always_inline__))
    static const char* __type_name_to_string(__type_name_t __v) noexcept {
      return reinterpret_cast<const char*>(__v &
          ~__non_unique_rtti_bit::value);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__always_inline__))
    static __type_name_t __string_to_type_name(const char* __v) noexcept {
      return reinterpret_cast<__type_name_t>(__v);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__always_inline__))
    static size_t __hash(__type_name_t __v) noexcept {
      if (__is_type_name_unique(__v))
        return __v;
      return __non_unique_impl::__hash(__type_name_to_string(__v));
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__always_inline__))
    static bool __eq(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      if (__lhs == __rhs)
        return true;
      if (__is_type_name_unique(__lhs) || __is_type_name_unique(__rhs))
        return false;
      return __builtin_strcmp(__type_name_to_string(__lhs), __type_name_to_string(__rhs)) == 0;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __attribute__((__always_inline__))
    static bool __lt(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      if (__is_type_name_unique(__lhs) || __is_type_name_unique(__rhs))
        return __lhs < __rhs;
      return __builtin_strcmp(__type_name_to_string(__lhs), __type_name_to_string(__rhs)) < 0;
    }
   private:
    typedef integral_constant<__type_name_t,
      (1ULL << ((8 * sizeof(__type_name_t)) - 1))> __non_unique_rtti_bit;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    static bool __is_type_name_unique(__type_name_t __lhs) noexcept {
      return !(__lhs & __non_unique_rtti_bit::value);
    }
  };
  typedef
    __non_unique_arm_rtti_bit_impl
     __impl;
};
class __attribute__((__visibility__("default"))) [[clang::ptrauth_vtable_pointer(process_independent, no_address_discrimination, no_extra_discrimination)]] type_info
{
  type_info& operator=(const type_info&);
  type_info(const type_info&);
 protected:
    typedef __type_info_implementations::__impl __impl;
    __impl::__type_name_t __type_name;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    explicit type_info(const char* __n)
      : __type_name(__impl::__string_to_type_name(__n)) {}
public:
    __attribute__((availability(macos,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
    virtual ~type_info();
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    const char* name() const noexcept
    {
      return __impl::__type_name_to_string(__type_name);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool before(const type_info& __arg) const noexcept
    {
      return __impl::__lt(__type_name, __arg.__type_name);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    size_t hash_code() const noexcept
    {
      return __impl::__hash(__type_name);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool operator==(const type_info& __arg) const noexcept
    {
      return __impl::__eq(__type_name, __arg.__type_name);
    }
};
class __attribute__((__visibility__("default"))) bad_cast
    : public exception
{
 public:
  bad_cast() noexcept;
  bad_cast(const bad_cast&) noexcept = default;
  ~bad_cast() noexcept override;
  const char* what() const noexcept override;
};
class __attribute__((__visibility__("default"))) bad_typeid
    : public exception
{
 public:
  bad_typeid() noexcept;
  ~bad_typeid() noexcept override;
  const char* what() const noexcept override;
};
}
namespace std { inline namespace __1 {
[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void __throw_bad_cast()
{
    throw bad_cast();
}
}}
namespace std { inline namespace __1 {
template <class _Tp>
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr add_const_t<_Tp>& as_const(_Tp& __t) noexcept { return __t; }
template <class _Tp>
void as_const(const _Tp&&) = delete;
}}


namespace std { inline namespace __1 {
template<class _Tp, class... _Up>
struct _IsSameAsAny : _Or<_IsSame<_Tp, _Up>...> {};
template<class _Tp>
concept __is_safe_integral_cmp = is_integral_v<_Tp> &&
                      !_IsSameAsAny<_Tp, bool, char, char16_t, char32_t
                                    , char8_t
                                    , wchar_t
                                    >::value;
template<__is_safe_integral_cmp _Tp, __is_safe_integral_cmp _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool cmp_equal(_Tp __t, _Up __u) noexcept
{
  if constexpr (is_signed_v<_Tp> == is_signed_v<_Up>)
    return __t == __u;
  else if constexpr (is_signed_v<_Tp>)
    return __t < 0 ? false : make_unsigned_t<_Tp>(__t) == __u;
  else
    return __u < 0 ? false : __t == make_unsigned_t<_Up>(__u);
}
template<__is_safe_integral_cmp _Tp, __is_safe_integral_cmp _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool cmp_not_equal(_Tp __t, _Up __u) noexcept
{
  return !std::cmp_equal(__t, __u);
}
template<__is_safe_integral_cmp _Tp, __is_safe_integral_cmp _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool cmp_less(_Tp __t, _Up __u) noexcept
{
  if constexpr (is_signed_v<_Tp> == is_signed_v<_Up>)
    return __t < __u;
  else if constexpr (is_signed_v<_Tp>)
    return __t < 0 ? true : make_unsigned_t<_Tp>(__t) < __u;
  else
    return __u < 0 ? false : __t < make_unsigned_t<_Up>(__u);
}
template<__is_safe_integral_cmp _Tp, __is_safe_integral_cmp _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool cmp_greater(_Tp __t, _Up __u) noexcept
{
  return std::cmp_less(__u, __t);
}
template<__is_safe_integral_cmp _Tp, __is_safe_integral_cmp _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool cmp_less_equal(_Tp __t, _Up __u) noexcept
{
  return !std::cmp_greater(__t, __u);
}
template<__is_safe_integral_cmp _Tp, __is_safe_integral_cmp _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool cmp_greater_equal(_Tp __t, _Up __u) noexcept
{
  return !std::cmp_less(__t, __u);
}
template<__is_safe_integral_cmp _Tp, __is_safe_integral_cmp _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool in_range(_Up __u) noexcept
{
  return std::cmp_less_equal(__u, numeric_limits<_Tp>::max()) &&
         std::cmp_greater_equal(__u, numeric_limits<_Tp>::min());
}
}}

namespace std { inline namespace __1 {
template <class _Rollback>
struct __exception_guard_exceptions {
  __exception_guard_exceptions() = delete;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr explicit __exception_guard_exceptions(_Rollback __rollback)
      : __rollback_(std::move(__rollback)), __completed_(false) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  __exception_guard_exceptions(__exception_guard_exceptions&& __other)
      noexcept(is_nothrow_move_constructible<_Rollback>::value)
      : __rollback_(std::move(__other.__rollback_)), __completed_(__other.__completed_) {
    __other.__completed_ = true;
  }
  __exception_guard_exceptions(__exception_guard_exceptions const&) = delete;
  __exception_guard_exceptions& operator=(__exception_guard_exceptions const&) = delete;
  __exception_guard_exceptions& operator=(__exception_guard_exceptions&&) = delete;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr void __complete() noexcept { __completed_ = true; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr ~__exception_guard_exceptions() {
    if (!__completed_)
      __rollback_();
  }
private:
  _Rollback __rollback_;
  bool __completed_;
};
template <class ..._Tag> __exception_guard_exceptions(typename _Tag::__allow_ctad...) -> __exception_guard_exceptions<_Tag...>;
template <class _Rollback>
using __exception_guard = __exception_guard_exceptions<_Rollback>;
template <class _Rollback>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr __exception_guard<_Rollback> __make_exception_guard(_Rollback __rollback) {
  return __exception_guard<_Rollback>(std::move(__rollback));
}
}}
namespace std { inline namespace __1 {
}}
namespace std { inline namespace __1 {
namespace rel_ops
{
template<class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool
operator!=(const _Tp& __x, const _Tp& __y)
{
    return !(__x == __y);
}
template<class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool
operator> (const _Tp& __x, const _Tp& __y)
{
    return __y < __x;
}
template<class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool
operator<=(const _Tp& __x, const _Tp& __y)
{
    return !(__y < __x);
}
template<class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool
operator>=(const _Tp& __x, const _Tp& __y)
{
    return !(__x < __y);
}
}
}}

namespace std { inline namespace __1 {
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr typename underlying_type<_Tp>::type
__to_underlying(_Tp __val) noexcept {
  return static_cast<typename underlying_type<_Tp>::type>(__val);
}
}}

namespace std {
class __attribute__((__visibility__("default"))) __attribute__((availability(macos,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=12.0))) __attribute__((availability(tvos,strict,introduced=12.0))) __attribute__((availability(watchos,strict,introduced=5.0))) bad_variant_access : public exception {
public:
   const char* what() const noexcept override;
};
}
namespace std { inline namespace __1 {
template<class _Tp, size_t _Size>
struct __farray {
  static_assert(_Size > 0, "N-dimensional array should never be empty in std::visit");
  _Tp __buf_[_Size] = {};
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  const _Tp &operator[](size_t __n) const noexcept {
      return __buf_[__n];
  }
};
[[noreturn]]
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
__attribute__((availability(macos,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=12.0))) __attribute__((availability(tvos,strict,introduced=12.0))) __attribute__((availability(watchos,strict,introduced=5.0)))
void __throw_bad_variant_access() {
        throw bad_variant_access();
}
template <class... _Types>
class __attribute__((__type_visibility__("default"))) variant;
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) variant_size;
template <class _Tp>
inline constexpr size_t variant_size_v = variant_size<_Tp>::value;
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) variant_size<const _Tp> : variant_size<_Tp> {};
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) variant_size<volatile _Tp> : variant_size<_Tp> {};
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) variant_size<const volatile _Tp>
    : variant_size<_Tp> {};
template <class... _Types>
struct __attribute__((__type_visibility__("default"))) variant_size<variant<_Types...>>
    : integral_constant<size_t, sizeof...(_Types)> {};
template <size_t _Ip, class _Tp>
struct __attribute__((__type_visibility__("default"))) variant_alternative;
template <size_t _Ip, class _Tp>
using variant_alternative_t = typename variant_alternative<_Ip, _Tp>::type;
template <size_t _Ip, class _Tp>
struct __attribute__((__type_visibility__("default"))) variant_alternative<_Ip, const _Tp>
    : add_const<variant_alternative_t<_Ip, _Tp>> {};
template <size_t _Ip, class _Tp>
struct __attribute__((__type_visibility__("default"))) variant_alternative<_Ip, volatile _Tp>
    : add_volatile<variant_alternative_t<_Ip, _Tp>> {};
template <size_t _Ip, class _Tp>
struct __attribute__((__type_visibility__("default"))) variant_alternative<_Ip, const volatile _Tp>
    : add_cv<variant_alternative_t<_Ip, _Tp>> {};
template <size_t _Ip, class... _Types>
struct __attribute__((__type_visibility__("default"))) variant_alternative<_Ip, variant<_Types...>> {
  static_assert(_Ip < sizeof...(_Types), "Index out of bounds in std::variant_alternative<>");
  using type = __type_pack_element<_Ip, _Types...>;
};
inline constexpr size_t variant_npos = static_cast<size_t>(-1);
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr int __choose_index_type(unsigned int __num_elem) {
  if (__num_elem < numeric_limits<unsigned char>::max())
    return 0;
  if (__num_elem < numeric_limits<unsigned short>::max())
    return 1;
  return 2;
}
template <size_t _NumAlts>
using __variant_index_t =
  unsigned int;
template <class _IndexType>
constexpr _IndexType __variant_npos = static_cast<_IndexType>(-1);
template <class... _Types>
class __attribute__((__type_visibility__("default"))) variant;
template <class... _Types>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr variant<_Types...>&
__as_variant(variant<_Types...>& __vs) noexcept {
  return __vs;
}
template <class... _Types>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr const variant<_Types...>&
__as_variant(const variant<_Types...>& __vs) noexcept {
  return __vs;
}
template <class... _Types>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr variant<_Types...>&&
__as_variant(variant<_Types...>&& __vs) noexcept {
  return std::move(__vs);
}
template <class... _Types>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr const variant<_Types...>&&
__as_variant(const variant<_Types...>&& __vs) noexcept {
  return std::move(__vs);
}
namespace __find_detail {
template <class _Tp, class... _Types>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr size_t __find_index() {
  constexpr bool __matches[] = {is_same_v<_Tp, _Types>...};
  size_t __result = __not_found;
  for (size_t __i = 0; __i < sizeof...(_Types); ++__i) {
    if (__matches[__i]) {
      if (__result != __not_found) {
        return __ambiguous;
      }
      __result = __i;
    }
  }
  return __result;
}
template <size_t _Index>
struct __find_unambiguous_index_sfinae_impl
    : integral_constant<size_t, _Index> {};
template <>
struct __find_unambiguous_index_sfinae_impl<__not_found> {};
template <>
struct __find_unambiguous_index_sfinae_impl<__ambiguous> {};
template <class _Tp, class... _Types>
struct __find_unambiguous_index_sfinae
    : __find_unambiguous_index_sfinae_impl<__find_index<_Tp, _Types...>()> {};
}
namespace __variant_detail {
struct __valueless_t {};
enum class _Trait { _TriviallyAvailable, _Available, _Unavailable };
template <typename _Tp,
          template <typename> class _IsTriviallyAvailable,
          template <typename> class _IsAvailable>
constexpr _Trait __trait =
    _IsTriviallyAvailable<_Tp>::value
        ? _Trait::_TriviallyAvailable
        : _IsAvailable<_Tp>::value ? _Trait::_Available : _Trait::_Unavailable;
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr _Trait __common_trait(initializer_list<_Trait> __traits) {
  _Trait __result = _Trait::_TriviallyAvailable;
  for (_Trait __t : __traits) {
    if (static_cast<int>(__t) > static_cast<int>(__result)) {
      __result = __t;
    }
  }
  return __result;
}
template <typename... _Types>
struct __traits {
  static constexpr _Trait __copy_constructible_trait =
      __variant_detail::__common_trait({__trait<_Types,
                              is_trivially_copy_constructible,
                              is_copy_constructible>...});
  static constexpr _Trait __move_constructible_trait =
      __variant_detail::__common_trait({__trait<_Types,
                              is_trivially_move_constructible,
                              is_move_constructible>...});
  static constexpr _Trait __copy_assignable_trait = __variant_detail::__common_trait(
      {__copy_constructible_trait,
       __trait<_Types, is_trivially_copy_assignable, is_copy_assignable>...});
  static constexpr _Trait __move_assignable_trait = __variant_detail::__common_trait(
      {__move_constructible_trait,
       __trait<_Types, is_trivially_move_assignable, is_move_assignable>...});
  static constexpr _Trait __destructible_trait = __variant_detail::__common_trait(
      {__trait<_Types, is_trivially_destructible, is_destructible>...});
};
namespace __access {
struct __union {
  template <class _Vp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  static constexpr auto&& __get_alt(_Vp&& __v, in_place_index_t<0>) {
    return std::forward<_Vp>(__v).__head;
  }
  template <class _Vp, size_t _Ip>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  static constexpr auto&& __get_alt(_Vp&& __v, in_place_index_t<_Ip>) {
    return __get_alt(std::forward<_Vp>(__v).__tail, in_place_index<_Ip - 1>);
  }
};
struct __base {
  template <size_t _Ip, class _Vp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  static constexpr auto&& __get_alt(_Vp&& __v) {
    return __union::__get_alt(std::forward<_Vp>(__v).__data,
                              in_place_index<_Ip>);
  }
};
struct __variant {
  template <size_t _Ip, class _Vp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  static constexpr auto&& __get_alt(_Vp&& __v) {
    return __base::__get_alt<_Ip>(std::forward<_Vp>(__v).__impl_);
  }
};
}
namespace __visitation {
struct __base {
  template <class _Visitor, class... _Vs>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  static constexpr decltype(auto)
  __visit_alt_at(size_t __index, _Visitor&& __visitor, _Vs&&... __vs) {
    constexpr auto __fdiagonal =
        __make_fdiagonal<_Visitor&&,
                         decltype(std::forward<_Vs>(__vs).__as_base())...>();
    return __fdiagonal[__index](std::forward<_Visitor>(__visitor),
                                std::forward<_Vs>(__vs).__as_base()...);
  }
  template <class _Visitor, class... _Vs>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  static constexpr decltype(auto) __visit_alt(_Visitor&& __visitor,
                                              _Vs&&... __vs) {
    constexpr auto __fmatrix =
        __make_fmatrix<_Visitor&&,
                       decltype(std::forward<_Vs>(__vs).__as_base())...>();
    return __at(__fmatrix, __vs.index()...)(
        std::forward<_Visitor>(__visitor),
        std::forward<_Vs>(__vs).__as_base()...);
  }
private:
  template <class _Tp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  static constexpr const _Tp& __at(const _Tp& __elem) { return __elem; }
  template <class _Tp, size_t _Np, typename... _Indices>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  static constexpr auto&& __at(const __farray<_Tp, _Np>& __elems,
                               size_t __index, _Indices... __indices) {
    return __at(__elems[__index], __indices...);
  }
  template <class _Fp, class... _Fs>
  static constexpr void __std_visit_visitor_return_type_check() {
    static_assert(
        __all<is_same_v<_Fp, _Fs>...>::value,
        "`std::visit` requires the visitor to have a single return type.");
  }
  template <class... _Fs>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  static constexpr auto __make_farray(_Fs&&... __fs) {
    __std_visit_visitor_return_type_check<__remove_cvref_t<_Fs>...>();
    using __result = __farray<common_type_t<__remove_cvref_t<_Fs>...>, sizeof...(_Fs)>;
    return __result{{std::forward<_Fs>(__fs)...}};
  }
  template <size_t... _Is>
  struct __dispatcher {
    template <class _Fp, class... _Vs>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    static constexpr decltype(auto) __dispatch(_Fp __f, _Vs... __vs) {
        return std::__invoke(
            static_cast<_Fp>(__f),
            __access::__base::__get_alt<_Is>(static_cast<_Vs>(__vs))...);
    }
  };
  template <class _Fp, class... _Vs, size_t... _Is>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  static constexpr auto __make_dispatch(index_sequence<_Is...>) {
    return __dispatcher<_Is...>::template __dispatch<_Fp, _Vs...>;
  }
  template <size_t _Ip, class _Fp, class... _Vs>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  static constexpr auto __make_fdiagonal_impl() {
    return __make_dispatch<_Fp, _Vs...>(
        index_sequence<((void)__type_identity<_Vs>{}, _Ip)...>{});
  }
  template <class _Fp, class... _Vs, size_t... _Is>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  static constexpr auto __make_fdiagonal_impl(index_sequence<_Is...>) {
    return __base::__make_farray(__make_fdiagonal_impl<_Is, _Fp, _Vs...>()...);
  }
  template <class _Fp, class _Vp, class... _Vs>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  static constexpr auto __make_fdiagonal() {
    constexpr size_t _Np = __remove_cvref_t<_Vp>::__size();
    static_assert(__all<(_Np == __remove_cvref_t<_Vs>::__size())...>::value);
    return __make_fdiagonal_impl<_Fp, _Vp, _Vs...>(make_index_sequence<_Np>{});
  }
  template <class _Fp, class... _Vs, size_t... _Is>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  static constexpr auto __make_fmatrix_impl(index_sequence<_Is...> __is) {
    return __make_dispatch<_Fp, _Vs...>(__is);
  }
  template <class _Fp, class... _Vs, size_t... _Is, size_t... _Js, class... _Ls>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  static constexpr auto __make_fmatrix_impl(index_sequence<_Is...>,
                                            index_sequence<_Js...>,
                                            _Ls... __ls) {
    return __base::__make_farray(__make_fmatrix_impl<_Fp, _Vs...>(
        index_sequence<_Is..., _Js>{}, __ls...)...);
  }
  template <class _Fp, class... _Vs>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  static constexpr auto __make_fmatrix() {
    return __make_fmatrix_impl<_Fp, _Vs...>(
        index_sequence<>{}, make_index_sequence<__remove_cvref_t<_Vs>::__size()>{}...);
  }
};
struct __variant {
  template <class _Visitor, class... _Vs>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  static constexpr decltype(auto)
  __visit_alt_at(size_t __index, _Visitor&& __visitor, _Vs&&... __vs) {
    return __base::__visit_alt_at(__index,
                                  std::forward<_Visitor>(__visitor),
                                  std::forward<_Vs>(__vs).__impl_...);
  }
  template <class _Visitor, class... _Vs>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  static constexpr decltype(auto) __visit_alt(_Visitor&& __visitor,
                                              _Vs&&... __vs) {
    return __base::__visit_alt(
        std::forward<_Visitor>(__visitor),
        std::__as_variant(std::forward<_Vs>(__vs)).__impl_...);
  }
  template <class _Visitor, class... _Vs>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  static constexpr decltype(auto)
  __visit_value_at(size_t __index, _Visitor&& __visitor, _Vs&&... __vs) {
    return __visit_alt_at(
        __index,
        __make_value_visitor(std::forward<_Visitor>(__visitor)),
        std::forward<_Vs>(__vs)...);
  }
  template <class _Visitor, class... _Vs>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  static constexpr decltype(auto) __visit_value(_Visitor&& __visitor,
                                                _Vs&&... __vs) {
    return __visit_alt(
        __make_value_visitor(std::forward<_Visitor>(__visitor)),
        std::forward<_Vs>(__vs)...);
  }
  template <class _Rp, class _Visitor, class... _Vs>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  static constexpr _Rp __visit_value(_Visitor&& __visitor,
                                     _Vs&&... __vs) {
    return __visit_alt(
        __make_value_visitor<_Rp>(std::forward<_Visitor>(__visitor)),
        std::forward<_Vs>(__vs)...);
  }
private:
  template <class _Visitor, class... _Values>
  static constexpr void __std_visit_exhaustive_visitor_check() {
    static_assert(is_invocable_v<_Visitor, _Values...>,
                  "`std::visit` requires the visitor to be exhaustive.");
  }
  template <class _Visitor>
  struct __value_visitor {
    template <class... _Alts>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr decltype(auto) operator()(_Alts&&... __alts) const {
      __std_visit_exhaustive_visitor_check<
          _Visitor,
          decltype((std::forward<_Alts>(__alts).__value))...>();
      return std::__invoke(std::forward<_Visitor>(__visitor),
                             std::forward<_Alts>(__alts).__value...);
    }
    _Visitor&& __visitor;
  };
  template <class _Rp, class _Visitor>
  struct __value_visitor_return_type {
    template <class... _Alts>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr _Rp operator()(_Alts&&... __alts) const {
      __std_visit_exhaustive_visitor_check<
          _Visitor,
          decltype((std::forward<_Alts>(__alts).__value))...>();
      if constexpr (is_void_v<_Rp>) {
        std::__invoke(std::forward<_Visitor>(__visitor),
                        std::forward<_Alts>(__alts).__value...);
      }
      else {
        return std::__invoke(std::forward<_Visitor>(__visitor),
                               std::forward<_Alts>(__alts).__value...);
      }
    }
    _Visitor&& __visitor;
  };
  template <class _Visitor>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  static constexpr auto __make_value_visitor(_Visitor&& __visitor) {
    return __value_visitor<_Visitor>{std::forward<_Visitor>(__visitor)};
  }
  template <class _Rp, class _Visitor>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  static constexpr auto __make_value_visitor(_Visitor&& __visitor) {
    return __value_visitor_return_type<_Rp, _Visitor>{std::forward<_Visitor>(__visitor)};
  }
};
}
template <size_t _Index, class _Tp>
struct __attribute__((__type_visibility__("default"))) __alt {
  using __value_type = _Tp;
  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  explicit constexpr __alt(in_place_t, _Args&&... __args)
      : __value(std::forward<_Args>(__args)...) {}
  __value_type __value;
};
template <_Trait _DestructibleTrait, size_t _Index, class... _Types>
union __attribute__((__type_visibility__("default"))) __union;
template <_Trait _DestructibleTrait, size_t _Index>
union __attribute__((__type_visibility__("default"))) __union<_DestructibleTrait, _Index> {};
template <size_t _Index, class _Tp, class... _Types> union __attribute__((__type_visibility__("default"))) __union<_Trait::_TriviallyAvailable, _Index, _Tp, _Types...> { public: __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) explicit constexpr __union(__valueless_t) noexcept : __dummy{} {} template <class... _Args> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) explicit constexpr __union(in_place_index_t<0>, _Args&&... __args) : __head(in_place, std::forward<_Args>(__args)...) {} template <size_t _Ip, class... _Args> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) explicit constexpr __union(in_place_index_t<_Ip>, _Args&&... __args) : __tail(in_place_index<_Ip - 1>, std::forward<_Args>(__args)...) {} __union(const __union&) = default; __union(__union&&) = default; ~__union() = default; __union& operator=(const __union&) = default; __union& operator=(__union&&) = default; private: char __dummy; __alt<_Index, _Tp> __head; __union<_Trait::_TriviallyAvailable, _Index + 1, _Types...> __tail; friend struct __access::__union; };
template <size_t _Index, class _Tp, class... _Types> union __attribute__((__type_visibility__("default"))) __union<_Trait::_Available, _Index, _Tp, _Types...> { public: __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) explicit constexpr __union(__valueless_t) noexcept : __dummy{} {} template <class... _Args> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) explicit constexpr __union(in_place_index_t<0>, _Args&&... __args) : __head(in_place, std::forward<_Args>(__args)...) {} template <size_t _Ip, class... _Args> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) explicit constexpr __union(in_place_index_t<_Ip>, _Args&&... __args) : __tail(in_place_index<_Ip - 1>, std::forward<_Args>(__args)...) {} __union(const __union&) = default; __union(__union&&) = default; ~__union() {} __union& operator=(const __union&) = default; __union& operator=(__union&&) = default; private: char __dummy; __alt<_Index, _Tp> __head; __union<_Trait::_Available, _Index + 1, _Types...> __tail; friend struct __access::__union; };
template <size_t _Index, class _Tp, class... _Types> union __attribute__((__type_visibility__("default"))) __union<_Trait::_Unavailable, _Index, _Tp, _Types...> { public: __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) explicit constexpr __union(__valueless_t) noexcept : __dummy{} {} template <class... _Args> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) explicit constexpr __union(in_place_index_t<0>, _Args&&... __args) : __head(in_place, std::forward<_Args>(__args)...) {} template <size_t _Ip, class... _Args> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) explicit constexpr __union(in_place_index_t<_Ip>, _Args&&... __args) : __tail(in_place_index<_Ip - 1>, std::forward<_Args>(__args)...) {} __union(const __union&) = default; __union(__union&&) = default; ~__union() = delete; __union& operator=(const __union&) = default; __union& operator=(__union&&) = default; private: char __dummy; __alt<_Index, _Tp> __head; __union<_Trait::_Unavailable, _Index + 1, _Types...> __tail; friend struct __access::__union; };
template <_Trait _DestructibleTrait, class... _Types>
class __attribute__((__type_visibility__("default"))) __base {
public:
  using __index_t = __variant_index_t<sizeof...(_Types)>;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  explicit constexpr __base(__valueless_t __tag) noexcept
      : __data(__tag), __index(__variant_npos<__index_t>) {}
  template <size_t _Ip, class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  explicit constexpr __base(in_place_index_t<_Ip>, _Args&&... __args)
      :
        __data(in_place_index<_Ip>, std::forward<_Args>(__args)...),
        __index(_Ip) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr bool valueless_by_exception() const noexcept {
    return index() == variant_npos;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr size_t index() const noexcept {
    return __index == __variant_npos<__index_t> ? variant_npos : __index;
  }
protected:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr auto&& __as_base() & { return *this; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr auto&& __as_base() && { return std::move(*this); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr auto&& __as_base() const & { return *this; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr auto&& __as_base() const && { return std::move(*this); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  static constexpr size_t __size() { return sizeof...(_Types); }
  __union<_DestructibleTrait, 0, _Types...> __data;
  __index_t __index;
  friend struct __access::__base;
  friend struct __visitation::__base;
};
template <class _Traits, _Trait = _Traits::__destructible_trait>
class __attribute__((__type_visibility__("default"))) __dtor;
template <class... _Types> class __attribute__((__type_visibility__("default"))) __dtor<__traits<_Types...>, _Trait::_TriviallyAvailable> : public __base<_Trait::_TriviallyAvailable, _Types...> { using __base_type = __base<_Trait::_TriviallyAvailable, _Types...>; using __index_t = typename __base_type::__index_t; public: using __base_type::__base_type; using __base_type::operator=; __dtor(const __dtor&) = default; __dtor(__dtor&&) = default; ~__dtor() = default; __dtor& operator=(const __dtor&) = default; __dtor& operator=(__dtor&&) = default; protected: inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void __destroy() noexcept { this->__index = __variant_npos<__index_t>; } };
template <class... _Types> class __attribute__((__type_visibility__("default"))) __dtor<__traits<_Types...>, _Trait::_Available> : public __base<_Trait::_Available, _Types...> { using __base_type = __base<_Trait::_Available, _Types...>; using __index_t = typename __base_type::__index_t; public: using __base_type::__base_type; using __base_type::operator=; __dtor(const __dtor&) = default; __dtor(__dtor&&) = default; ~__dtor() { __destroy(); } __dtor& operator=(const __dtor&) = default; __dtor& operator=(__dtor&&) = default; protected: inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void __destroy() noexcept { if (!this->valueless_by_exception()) { __visitation::__base::__visit_alt( [](auto& __alt) noexcept { using __alt_type = __remove_cvref_t<decltype(__alt)>; __alt.~__alt_type(); }, *this); } this->__index = __variant_npos<__index_t>; } };
template <class... _Types> class __attribute__((__type_visibility__("default"))) __dtor<__traits<_Types...>, _Trait::_Unavailable> : public __base<_Trait::_Unavailable, _Types...> { using __base_type = __base<_Trait::_Unavailable, _Types...>; using __index_t = typename __base_type::__index_t; public: using __base_type::__base_type; using __base_type::operator=; __dtor(const __dtor&) = default; __dtor(__dtor&&) = default; ~__dtor() = delete; __dtor& operator=(const __dtor&) = default; __dtor& operator=(__dtor&&) = default; protected: inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void __destroy() noexcept = delete; };
template <class _Traits>
class __attribute__((__type_visibility__("default"))) __ctor : public __dtor<_Traits> {
  using __base_type = __dtor<_Traits>;
public:
  using __base_type::__base_type;
  using __base_type::operator=;
protected:
  template <size_t _Ip, class _Tp, class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  static _Tp& __construct_alt(__alt<_Ip, _Tp>& __a, _Args&&... __args) {
    ::new ((void*)std::addressof(__a))
        __alt<_Ip, _Tp>(in_place, std::forward<_Args>(__args)...);
    return __a.__value;
  }
  template <class _Rhs>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  static void __generic_construct(__ctor& __lhs, _Rhs&& __rhs) {
    __lhs.__destroy();
    if (!__rhs.valueless_by_exception()) {
      __visitation::__base::__visit_alt_at(
          __rhs.index(),
          [](auto& __lhs_alt, auto&& __rhs_alt) {
            __construct_alt(
                __lhs_alt,
                std::forward<decltype(__rhs_alt)>(__rhs_alt).__value);
          },
          __lhs, std::forward<_Rhs>(__rhs));
      __lhs.__index = __rhs.index();
    }
  }
};
template <class _Traits, _Trait = _Traits::__move_constructible_trait>
class __attribute__((__type_visibility__("default"))) __move_constructor;
template <class... _Types> class __attribute__((__type_visibility__("default"))) __move_constructor<__traits<_Types...>, _Trait::_TriviallyAvailable> : public __ctor<__traits<_Types...>> { using __base_type = __ctor<__traits<_Types...>>; public: using __base_type::__base_type; using __base_type::operator=; __move_constructor(const __move_constructor&) = default; __move_constructor(__move_constructor&& __that) = default; ~__move_constructor() = default; __move_constructor& operator=(const __move_constructor&) = default; __move_constructor& operator=(__move_constructor&&) = default; };
template <class... _Types> class __attribute__((__type_visibility__("default"))) __move_constructor<__traits<_Types...>, _Trait::_Available> : public __ctor<__traits<_Types...>> { using __base_type = __ctor<__traits<_Types...>>; public: using __base_type::__base_type; using __base_type::operator=; __move_constructor(const __move_constructor&) = default; __move_constructor(__move_constructor&& __that) noexcept( __all<is_nothrow_move_constructible_v<_Types>...>::value) : __move_constructor(__valueless_t{}) { this->__generic_construct(*this, std::move(__that)); } ~__move_constructor() = default; __move_constructor& operator=(const __move_constructor&) = default; __move_constructor& operator=(__move_constructor&&) = default; };
template <class... _Types> class __attribute__((__type_visibility__("default"))) __move_constructor<__traits<_Types...>, _Trait::_Unavailable> : public __ctor<__traits<_Types...>> { using __base_type = __ctor<__traits<_Types...>>; public: using __base_type::__base_type; using __base_type::operator=; __move_constructor(const __move_constructor&) = default; __move_constructor(__move_constructor&&) = delete; ~__move_constructor() = default; __move_constructor& operator=(const __move_constructor&) = default; __move_constructor& operator=(__move_constructor&&) = default; };
template <class _Traits, _Trait = _Traits::__copy_constructible_trait>
class __attribute__((__type_visibility__("default"))) __copy_constructor;
template <class... _Types> class __attribute__((__type_visibility__("default"))) __copy_constructor<__traits<_Types...>, _Trait::_TriviallyAvailable> : public __move_constructor<__traits<_Types...>> { using __base_type = __move_constructor<__traits<_Types...>>; public: using __base_type::__base_type; using __base_type::operator=; __copy_constructor(const __copy_constructor& __that) = default; __copy_constructor(__copy_constructor&&) = default; ~__copy_constructor() = default; __copy_constructor& operator=(const __copy_constructor&) = default; __copy_constructor& operator=(__copy_constructor&&) = default; };
template <class... _Types> class __attribute__((__type_visibility__("default"))) __copy_constructor<__traits<_Types...>, _Trait::_Available> : public __move_constructor<__traits<_Types...>> { using __base_type = __move_constructor<__traits<_Types...>>; public: using __base_type::__base_type; using __base_type::operator=; __copy_constructor(const __copy_constructor& __that) : __copy_constructor(__valueless_t{}) { this->__generic_construct(*this, __that); } __copy_constructor(__copy_constructor&&) = default; ~__copy_constructor() = default; __copy_constructor& operator=(const __copy_constructor&) = default; __copy_constructor& operator=(__copy_constructor&&) = default; };
template <class... _Types> class __attribute__((__type_visibility__("default"))) __copy_constructor<__traits<_Types...>, _Trait::_Unavailable> : public __move_constructor<__traits<_Types...>> { using __base_type = __move_constructor<__traits<_Types...>>; public: using __base_type::__base_type; using __base_type::operator=; __copy_constructor(const __copy_constructor&) = delete; __copy_constructor(__copy_constructor&&) = default; ~__copy_constructor() = default; __copy_constructor& operator=(const __copy_constructor&) = default; __copy_constructor& operator=(__copy_constructor&&) = default; };
template <class _Traits>
class __attribute__((__type_visibility__("default"))) __assignment : public __copy_constructor<_Traits> {
  using __base_type = __copy_constructor<_Traits>;
public:
  using __base_type::__base_type;
  using __base_type::operator=;
  template <size_t _Ip, class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  auto& __emplace(_Args&&... __args) {
    this->__destroy();
    auto& __res = this->__construct_alt(__access::__base::__get_alt<_Ip>(*this),
                          std::forward<_Args>(__args)...);
    this->__index = _Ip;
    return __res;
  }
protected:
  template <size_t _Ip, class _Tp, class _Arg>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  void __assign_alt(__alt<_Ip, _Tp>& __a, _Arg&& __arg) {
    if (this->index() == _Ip) {
      __a.__value = std::forward<_Arg>(__arg);
    } else {
      struct {
        void operator()(true_type) const {
          __this->__emplace<_Ip>(std::forward<_Arg>(__arg));
        }
        void operator()(false_type) const {
          __this->__emplace<_Ip>(_Tp(std::forward<_Arg>(__arg)));
        }
        __assignment* __this;
        _Arg&& __arg;
      } __impl{this, std::forward<_Arg>(__arg)};
      __impl(bool_constant<is_nothrow_constructible_v<_Tp, _Arg> ||
                           !is_nothrow_move_constructible_v<_Tp>>{});
    }
  }
  template <class _That>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  void __generic_assign(_That&& __that) {
    if (this->valueless_by_exception() && __that.valueless_by_exception()) {
    } else if (__that.valueless_by_exception()) {
      this->__destroy();
    } else {
      __visitation::__base::__visit_alt_at(
          __that.index(),
          [this](auto& __this_alt, auto&& __that_alt) {
            this->__assign_alt(
                __this_alt,
                std::forward<decltype(__that_alt)>(__that_alt).__value);
          },
          *this, std::forward<_That>(__that));
    }
  }
};
template <class _Traits, _Trait = _Traits::__move_assignable_trait>
class __attribute__((__type_visibility__("default"))) __move_assignment;
template <class... _Types> class __attribute__((__type_visibility__("default"))) __move_assignment<__traits<_Types...>, _Trait::_TriviallyAvailable> : public __assignment<__traits<_Types...>> { using __base_type = __assignment<__traits<_Types...>>; public: using __base_type::__base_type; using __base_type::operator=; __move_assignment(const __move_assignment&) = default; __move_assignment(__move_assignment&&) = default; ~__move_assignment() = default; __move_assignment& operator=(const __move_assignment&) = default; __move_assignment& operator=(__move_assignment&& __that) = default; };
template <class... _Types> class __attribute__((__type_visibility__("default"))) __move_assignment<__traits<_Types...>, _Trait::_Available> : public __assignment<__traits<_Types...>> { using __base_type = __assignment<__traits<_Types...>>; public: using __base_type::__base_type; using __base_type::operator=; __move_assignment(const __move_assignment&) = default; __move_assignment(__move_assignment&&) = default; ~__move_assignment() = default; __move_assignment& operator=(const __move_assignment&) = default; __move_assignment& operator=(__move_assignment&& __that) noexcept( __all<(is_nothrow_move_constructible_v<_Types> && is_nothrow_move_assignable_v<_Types>)...>::value) { this->__generic_assign(std::move(__that)); return *this; } };
template <class... _Types> class __attribute__((__type_visibility__("default"))) __move_assignment<__traits<_Types...>, _Trait::_Unavailable> : public __assignment<__traits<_Types...>> { using __base_type = __assignment<__traits<_Types...>>; public: using __base_type::__base_type; using __base_type::operator=; __move_assignment(const __move_assignment&) = default; __move_assignment(__move_assignment&&) = default; ~__move_assignment() = default; __move_assignment& operator=(const __move_assignment&) = default; __move_assignment& operator=(__move_assignment&&) = delete; };
template <class _Traits, _Trait = _Traits::__copy_assignable_trait>
class __attribute__((__type_visibility__("default"))) __copy_assignment;
template <class... _Types> class __attribute__((__type_visibility__("default"))) __copy_assignment<__traits<_Types...>, _Trait::_TriviallyAvailable> : public __move_assignment<__traits<_Types...>> { using __base_type = __move_assignment<__traits<_Types...>>; public: using __base_type::__base_type; using __base_type::operator=; __copy_assignment(const __copy_assignment&) = default; __copy_assignment(__copy_assignment&&) = default; ~__copy_assignment() = default; __copy_assignment& operator=(const __copy_assignment& __that) = default; __copy_assignment& operator=(__copy_assignment&&) = default; };
template <class... _Types> class __attribute__((__type_visibility__("default"))) __copy_assignment<__traits<_Types...>, _Trait::_Available> : public __move_assignment<__traits<_Types...>> { using __base_type = __move_assignment<__traits<_Types...>>; public: using __base_type::__base_type; using __base_type::operator=; __copy_assignment(const __copy_assignment&) = default; __copy_assignment(__copy_assignment&&) = default; ~__copy_assignment() = default; __copy_assignment& operator=(const __copy_assignment& __that) { this->__generic_assign(__that); return *this; } __copy_assignment& operator=(__copy_assignment&&) = default; };
template <class... _Types> class __attribute__((__type_visibility__("default"))) __copy_assignment<__traits<_Types...>, _Trait::_Unavailable> : public __move_assignment<__traits<_Types...>> { using __base_type = __move_assignment<__traits<_Types...>>; public: using __base_type::__base_type; using __base_type::operator=; __copy_assignment(const __copy_assignment&) = default; __copy_assignment(__copy_assignment&&) = default; ~__copy_assignment() = default; __copy_assignment& operator=(const __copy_assignment&) = delete; __copy_assignment& operator=(__copy_assignment&&) = default; };
template <class... _Types>
class __attribute__((__type_visibility__("default"))) __impl
    : public __copy_assignment<__traits<_Types...>> {
  using __base_type = __copy_assignment<__traits<_Types...>>;
public:
  using __base_type::__base_type;
  __impl(__impl const&) = default;
  __impl(__impl&&) = default;
  __impl& operator=(__impl const&) = default;
  __impl& operator=(__impl&&) = default;
  template <size_t _Ip, class _Arg>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  void __assign(_Arg&& __arg) {
    this->__assign_alt(__access::__base::__get_alt<_Ip>(*this),
                       std::forward<_Arg>(__arg));
  }
  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  void __swap(__impl& __that) {
    if (this->valueless_by_exception() && __that.valueless_by_exception()) {
    } else if (this->index() == __that.index()) {
      __visitation::__base::__visit_alt_at(
          this->index(),
          [](auto& __this_alt, auto& __that_alt) {
            using std::swap;
            swap(__this_alt.__value, __that_alt.__value);
          },
          *this,
          __that);
    } else {
      __impl* __lhs = this;
      __impl* __rhs = std::addressof(__that);
      if (__lhs->__move_nothrow() && !__rhs->__move_nothrow()) {
        std::swap(__lhs, __rhs);
      }
      __impl __tmp(std::move(*__rhs));
      if constexpr (__all<is_nothrow_move_constructible_v<_Types>...>::value) {
        this->__generic_construct(*__rhs, std::move(*__lhs));
      } else {
        try {
          this->__generic_construct(*__rhs, std::move(*__lhs));
        } catch (...) {
          if (__tmp.__move_nothrow()) {
            this->__generic_construct(*__rhs, std::move(__tmp));
          }
          throw;
        }
      }
      this->__generic_construct(*__lhs, std::move(__tmp));
    }
  }
private:
  inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  bool __move_nothrow() const {
    constexpr bool __results[] = {is_nothrow_move_constructible_v<_Types>...};
    return this->valueless_by_exception() || __results[this->index()];
  }
};
struct __no_narrowing_check {
  template <class _Dest, class _Source>
  using _Apply = __type_identity<_Dest>;
};
struct __narrowing_check {
  template <class _Dest>
  static auto __test_impl(_Dest (&&)[1]) -> __type_identity<_Dest>;
  template <class _Dest, class _Source>
  using _Apply __attribute__((__nodebug__)) = decltype(__test_impl<_Dest>({std::declval<_Source>()}));
};
template <class _Dest, class _Source>
using __check_for_narrowing __attribute__((__nodebug__)) =
  typename _If<
    is_arithmetic<_Dest>::value,
    __narrowing_check,
    __no_narrowing_check
  >::template _Apply<_Dest, _Source>;
template <class _Tp, size_t _Idx>
struct __overload {
  template <class _Up>
  auto operator()(_Tp, _Up&&) const -> __check_for_narrowing<_Tp, _Up>;
};
template <class _Tp, size_t>
struct __overload_bool {
  template <class _Up, class _Ap = __remove_cvref_t<_Up>>
  auto operator()(bool, _Up&&) const
      -> enable_if_t<is_same_v<_Ap, bool>, __type_identity<_Tp>>;
};
template <size_t _Idx>
struct __overload<bool, _Idx> : __overload_bool<bool, _Idx> {};
template <size_t _Idx>
struct __overload<bool const, _Idx> : __overload_bool<bool const, _Idx> {};
template <size_t _Idx>
struct __overload<bool volatile, _Idx> : __overload_bool<bool volatile, _Idx> {};
template <size_t _Idx>
struct __overload<bool const volatile, _Idx> : __overload_bool<bool const volatile, _Idx> {};
template <class ..._Bases>
struct __all_overloads : _Bases... {
  void operator()() const;
  using _Bases::operator()...;
};
template <class IdxSeq>
struct __make_overloads_imp;
template <size_t ..._Idx>
struct __make_overloads_imp<__tuple_indices<_Idx...> > {
  template <class ..._Types>
  using _Apply __attribute__((__nodebug__)) = __all_overloads<__overload<_Types, _Idx>...>;
};
template <class ..._Types>
using _MakeOverloads __attribute__((__nodebug__)) = typename __make_overloads_imp<
    __make_indices_imp<sizeof...(_Types), 0> >::template _Apply<_Types...>;
template <class _Tp, class... _Types>
using __best_match_t =
    typename invoke_result_t<_MakeOverloads<_Types...>, _Tp, _Tp>::type;
}
template <class... _Types>
class __attribute__((__type_visibility__("default"))) variant
    : private __sfinae_ctor_base<
          __all<is_copy_constructible_v<_Types>...>::value,
          __all<is_move_constructible_v<_Types>...>::value>,
      private __sfinae_assign_base<
          __all<(is_copy_constructible_v<_Types> &&
                 is_copy_assignable_v<_Types>)...>::value,
          __all<(is_move_constructible_v<_Types> &&
                 is_move_assignable_v<_Types>)...>::value> {
  static_assert(0 < sizeof...(_Types),
                "variant must consist of at least one alternative.");
  static_assert(__all<!is_array_v<_Types>...>::value,
                "variant can not have an array type as an alternative.");
  static_assert(__all<!is_reference_v<_Types>...>::value,
                "variant can not have a reference type as an alternative.");
  static_assert(__all<!is_void_v<_Types>...>::value,
                "variant can not have a void type as an alternative.");
  using __first_type = variant_alternative_t<0, variant>;
public:
  template <bool _Dummy = true,
            enable_if_t<__dependent_type<is_default_constructible<__first_type>,
                                         _Dummy>::value,
                        int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr variant() noexcept(is_nothrow_default_constructible_v<__first_type>)
      : __impl_(in_place_index<0>) {}
  constexpr variant(const variant&) = default;
  constexpr variant(variant&&) = default;
  template <
      class _Arg,
      enable_if_t<!is_same_v<__remove_cvref_t<_Arg>, variant>, int> = 0,
      enable_if_t<!__is_inplace_type<__remove_cvref_t<_Arg>>::value, int> = 0,
      enable_if_t<!__is_inplace_index<__remove_cvref_t<_Arg>>::value, int> = 0,
      class _Tp = __variant_detail::__best_match_t<_Arg, _Types...>,
      size_t _Ip =
          __find_detail::__find_unambiguous_index_sfinae<_Tp, _Types...>::value,
      enable_if_t<is_constructible_v<_Tp, _Arg>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr variant(_Arg&& __arg) noexcept(
      is_nothrow_constructible_v<_Tp, _Arg>)
      : __impl_(in_place_index<_Ip>, std::forward<_Arg>(__arg)) {}
  template <size_t _Ip, class... _Args,
            class = enable_if_t<(_Ip < sizeof...(_Types)), int>,
            class _Tp = variant_alternative_t<_Ip, variant<_Types...>>,
            enable_if_t<is_constructible_v<_Tp, _Args...>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  explicit constexpr variant(
      in_place_index_t<_Ip>,
      _Args&&... __args) noexcept(is_nothrow_constructible_v<_Tp, _Args...>)
      : __impl_(in_place_index<_Ip>, std::forward<_Args>(__args)...) {}
  template <
      size_t _Ip,
      class _Up,
      class... _Args,
      enable_if_t<(_Ip < sizeof...(_Types)), int> = 0,
      class _Tp = variant_alternative_t<_Ip, variant<_Types...>>,
      enable_if_t<is_constructible_v<_Tp, initializer_list<_Up>&, _Args...>,
                  int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  explicit constexpr variant(
      in_place_index_t<_Ip>,
      initializer_list<_Up> __il,
      _Args&&... __args) noexcept(
      is_nothrow_constructible_v<_Tp, initializer_list<_Up>&, _Args...>)
      : __impl_(in_place_index<_Ip>, __il, std::forward<_Args>(__args)...) {}
  template <
      class _Tp,
      class... _Args,
      size_t _Ip =
          __find_detail::__find_unambiguous_index_sfinae<_Tp, _Types...>::value,
      enable_if_t<is_constructible_v<_Tp, _Args...>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  explicit constexpr variant(in_place_type_t<_Tp>, _Args&&... __args) noexcept(
      is_nothrow_constructible_v<_Tp, _Args...>)
      : __impl_(in_place_index<_Ip>, std::forward<_Args>(__args)...) {}
  template <
      class _Tp,
      class _Up,
      class... _Args,
      size_t _Ip =
          __find_detail::__find_unambiguous_index_sfinae<_Tp, _Types...>::value,
      enable_if_t<is_constructible_v<_Tp, initializer_list<_Up>&, _Args...>,
                  int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  explicit constexpr variant(
      in_place_type_t<_Tp>,
      initializer_list<_Up> __il,
      _Args&&... __args) noexcept(
      is_nothrow_constructible_v<_Tp, initializer_list< _Up>&, _Args...>)
      : __impl_(in_place_index<_Ip>, __il, std::forward<_Args>(__args)...) {}
  ~variant() = default;
  constexpr variant& operator=(const variant&) = default;
  constexpr variant& operator=(variant&&) = default;
  template <
      class _Arg,
      enable_if_t<!is_same_v<__remove_cvref_t<_Arg>, variant>, int> = 0,
      class _Tp = __variant_detail::__best_match_t<_Arg, _Types...>,
      size_t _Ip =
          __find_detail::__find_unambiguous_index_sfinae<_Tp, _Types...>::value,
      enable_if_t<is_assignable_v<_Tp&, _Arg> && is_constructible_v<_Tp, _Arg>,
                  int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  variant& operator=(_Arg&& __arg) noexcept(
      is_nothrow_assignable_v<_Tp&, _Arg> &&
      is_nothrow_constructible_v<_Tp, _Arg>) {
    __impl_.template __assign<_Ip>(std::forward<_Arg>(__arg));
    return *this;
  }
  template <
      size_t _Ip,
      class... _Args,
      enable_if_t<(_Ip < sizeof...(_Types)), int> = 0,
      class _Tp = variant_alternative_t<_Ip, variant<_Types...>>,
      enable_if_t<is_constructible_v<_Tp, _Args...>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  _Tp& emplace(_Args&&... __args) {
    return __impl_.template __emplace<_Ip>(std::forward<_Args>(__args)...);
  }
  template <
      size_t _Ip,
      class _Up,
      class... _Args,
      enable_if_t<(_Ip < sizeof...(_Types)), int> = 0,
      class _Tp = variant_alternative_t<_Ip, variant<_Types...>>,
      enable_if_t<is_constructible_v<_Tp, initializer_list<_Up>&, _Args...>,
                  int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  _Tp& emplace(initializer_list<_Up> __il, _Args&&... __args) {
    return __impl_.template __emplace<_Ip>(__il, std::forward<_Args>(__args)...);
  }
  template <
      class _Tp,
      class... _Args,
      size_t _Ip =
          __find_detail::__find_unambiguous_index_sfinae<_Tp, _Types...>::value,
      enable_if_t<is_constructible_v<_Tp, _Args...>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  _Tp& emplace(_Args&&... __args) {
    return __impl_.template __emplace<_Ip>(std::forward<_Args>(__args)...);
  }
  template <
      class _Tp,
      class _Up,
      class... _Args,
      size_t _Ip =
          __find_detail::__find_unambiguous_index_sfinae<_Tp, _Types...>::value,
      enable_if_t<is_constructible_v<_Tp, initializer_list<_Up>&, _Args...>,
                  int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  _Tp& emplace(initializer_list<_Up> __il, _Args&&... __args) {
    return __impl_.template __emplace<_Ip>(__il, std::forward<_Args>(__args)...);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr bool valueless_by_exception() const noexcept {
    return __impl_.valueless_by_exception();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr size_t index() const noexcept { return __impl_.index(); }
  template <
      bool _Dummy = true,
      enable_if_t<
          __all<(
              __dependent_type<is_move_constructible<_Types>, _Dummy>::value &&
              __dependent_type<is_swappable<_Types>, _Dummy>::value)...>::value,
          int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  void swap(variant& __that) noexcept(
      __all<(is_nothrow_move_constructible_v<_Types> &&
             is_nothrow_swappable_v<_Types>)...>::value) {
    __impl_.__swap(__that.__impl_);
  }
private:
  __variant_detail::__impl<_Types...> __impl_;
  friend struct __variant_detail::__access::__variant;
  friend struct __variant_detail::__visitation::__variant;
};
template <size_t _Ip, class... _Types>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr bool __holds_alternative(const variant<_Types...>& __v) noexcept {
  return __v.index() == _Ip;
}
template <class _Tp, class... _Types>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr bool holds_alternative(const variant<_Types...>& __v) noexcept {
  return std::__holds_alternative<__find_exactly_one_t<_Tp, _Types...>::value>(__v);
}
template <size_t _Ip, class _Vp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
__attribute__((availability(macos,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=12.0))) __attribute__((availability(tvos,strict,introduced=12.0))) __attribute__((availability(watchos,strict,introduced=5.0)))
constexpr auto&& __generic_get(_Vp&& __v) {
  using __variant_detail::__access::__variant;
  if (!std::__holds_alternative<_Ip>(__v)) {
    __throw_bad_variant_access();
  }
  return __variant::__get_alt<_Ip>(std::forward<_Vp>(__v)).__value;
}
template <size_t _Ip, class... _Types>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
__attribute__((availability(macos,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=12.0))) __attribute__((availability(tvos,strict,introduced=12.0))) __attribute__((availability(watchos,strict,introduced=5.0)))
constexpr variant_alternative_t<_Ip, variant<_Types...>>& get(
    variant<_Types...>& __v) {
  static_assert(_Ip < sizeof...(_Types));
  static_assert(!is_void_v<variant_alternative_t<_Ip, variant<_Types...>>>);
  return std::__generic_get<_Ip>(__v);
}
template <size_t _Ip, class... _Types>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
__attribute__((availability(macos,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=12.0))) __attribute__((availability(tvos,strict,introduced=12.0))) __attribute__((availability(watchos,strict,introduced=5.0)))
constexpr variant_alternative_t<_Ip, variant<_Types...>>&& get(
    variant<_Types...>&& __v) {
  static_assert(_Ip < sizeof...(_Types));
  static_assert(!is_void_v<variant_alternative_t<_Ip, variant<_Types...>>>);
  return std::__generic_get<_Ip>(std::move(__v));
}
template <size_t _Ip, class... _Types>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
__attribute__((availability(macos,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=12.0))) __attribute__((availability(tvos,strict,introduced=12.0))) __attribute__((availability(watchos,strict,introduced=5.0)))
constexpr const variant_alternative_t<_Ip, variant<_Types...>>& get(
    const variant<_Types...>& __v) {
  static_assert(_Ip < sizeof...(_Types));
  static_assert(!is_void_v<variant_alternative_t<_Ip, variant<_Types...>>>);
  return std::__generic_get<_Ip>(__v);
}
template <size_t _Ip, class... _Types>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
__attribute__((availability(macos,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=12.0))) __attribute__((availability(tvos,strict,introduced=12.0))) __attribute__((availability(watchos,strict,introduced=5.0)))
constexpr const variant_alternative_t<_Ip, variant<_Types...>>&& get(
    const variant<_Types...>&& __v) {
  static_assert(_Ip < sizeof...(_Types));
  static_assert(!is_void_v<variant_alternative_t<_Ip, variant<_Types...>>>);
  return std::__generic_get<_Ip>(std::move(__v));
}
template <class _Tp, class... _Types>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
__attribute__((availability(macos,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=12.0))) __attribute__((availability(tvos,strict,introduced=12.0))) __attribute__((availability(watchos,strict,introduced=5.0)))
constexpr _Tp& get(variant<_Types...>& __v) {
  static_assert(!is_void_v<_Tp>);
  return std::get<__find_exactly_one_t<_Tp, _Types...>::value>(__v);
}
template <class _Tp, class... _Types>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
__attribute__((availability(macos,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=12.0))) __attribute__((availability(tvos,strict,introduced=12.0))) __attribute__((availability(watchos,strict,introduced=5.0)))
constexpr _Tp&& get(variant<_Types...>&& __v) {
  static_assert(!is_void_v<_Tp>);
  return std::get<__find_exactly_one_t<_Tp, _Types...>::value>(
      std::move(__v));
}
template <class _Tp, class... _Types>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
__attribute__((availability(macos,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=12.0))) __attribute__((availability(tvos,strict,introduced=12.0))) __attribute__((availability(watchos,strict,introduced=5.0)))
constexpr const _Tp& get(const variant<_Types...>& __v) {
  static_assert(!is_void_v<_Tp>);
  return std::get<__find_exactly_one_t<_Tp, _Types...>::value>(__v);
}
template <class _Tp, class... _Types>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
__attribute__((availability(macos,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=12.0))) __attribute__((availability(tvos,strict,introduced=12.0))) __attribute__((availability(watchos,strict,introduced=5.0)))
constexpr const _Tp&& get(const variant<_Types...>&& __v) {
  static_assert(!is_void_v<_Tp>);
  return std::get<__find_exactly_one_t<_Tp, _Types...>::value>(
      std::move(__v));
}
template <size_t _Ip, class _Vp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr auto* __generic_get_if(_Vp* __v) noexcept {
  using __variant_detail::__access::__variant;
  return __v && std::__holds_alternative<_Ip>(*__v)
             ? std::addressof(__variant::__get_alt<_Ip>(*__v).__value)
             : nullptr;
}
template <size_t _Ip, class... _Types>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr add_pointer_t<variant_alternative_t<_Ip, variant<_Types...>>>
get_if(variant<_Types...>* __v) noexcept {
  static_assert(_Ip < sizeof...(_Types));
  static_assert(!is_void_v<variant_alternative_t<_Ip, variant<_Types...>>>);
  return std::__generic_get_if<_Ip>(__v);
}
template <size_t _Ip, class... _Types>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr add_pointer_t<const variant_alternative_t<_Ip, variant<_Types...>>>
get_if(const variant<_Types...>* __v) noexcept {
  static_assert(_Ip < sizeof...(_Types));
  static_assert(!is_void_v<variant_alternative_t<_Ip, variant<_Types...>>>);
  return std::__generic_get_if<_Ip>(__v);
}
template <class _Tp, class... _Types>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr add_pointer_t<_Tp>
get_if(variant<_Types...>* __v) noexcept {
  static_assert(!is_void_v<_Tp>);
  return std::get_if<__find_exactly_one_t<_Tp, _Types...>::value>(__v);
}
template <class _Tp, class... _Types>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr add_pointer_t<const _Tp>
get_if(const variant<_Types...>* __v) noexcept {
  static_assert(!is_void_v<_Tp>);
  return std::get_if<__find_exactly_one_t<_Tp, _Types...>::value>(__v);
}
template <class _Operator>
struct __convert_to_bool {
  template <class _T1, class _T2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr bool operator()(_T1 && __t1, _T2&& __t2) const {
    static_assert(is_convertible<decltype(_Operator{}(std::forward<_T1>(__t1), std::forward<_T2>(__t2))), bool>::value,
        "the relational operator does not return a type which is implicitly convertible to bool");
    return _Operator{}(std::forward<_T1>(__t1), std::forward<_T2>(__t2));
  }
};
template <class... _Types>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr bool operator==(const variant<_Types...>& __lhs,
                          const variant<_Types...>& __rhs) {
  using __variant_detail::__visitation::__variant;
  if (__lhs.index() != __rhs.index()) return false;
  if (__lhs.valueless_by_exception()) return true;
  return __variant::__visit_value_at(__lhs.index(), __convert_to_bool<equal_to<>>{}, __lhs, __rhs);
}
template <class... _Types> requires (three_way_comparable<_Types> && ...)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr common_comparison_category_t<compare_three_way_result_t<_Types>...>
operator<=>(const variant<_Types...>& __lhs, const variant<_Types...>& __rhs) {
  using __variant_detail::__visitation::__variant;
  using __result_t = common_comparison_category_t<compare_three_way_result_t<_Types>...>;
  if (__lhs.valueless_by_exception() && __rhs.valueless_by_exception())
    return strong_ordering::equal;
  if (__lhs.valueless_by_exception())
    return strong_ordering::less;
  if (__rhs.valueless_by_exception())
    return strong_ordering::greater;
  if (auto __c = __lhs.index() <=> __rhs.index(); __c != 0)
    return __c;
  auto __three_way = []<class _Type>(const _Type& __v, const _Type& __w) -> __result_t { return __v <=> __w; };
  return __variant::__visit_value_at(__lhs.index(), __three_way, __lhs, __rhs);
}
template <class... _Types>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr bool operator!=(const variant<_Types...>& __lhs,
                          const variant<_Types...>& __rhs) {
  using __variant_detail::__visitation::__variant;
  if (__lhs.index() != __rhs.index()) return true;
  if (__lhs.valueless_by_exception()) return false;
  return __variant::__visit_value_at(
      __lhs.index(), __convert_to_bool<not_equal_to<>>{}, __lhs, __rhs);
}
template <class... _Types>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr bool operator<(const variant<_Types...>& __lhs,
                         const variant<_Types...>& __rhs) {
  using __variant_detail::__visitation::__variant;
  if (__rhs.valueless_by_exception()) return false;
  if (__lhs.valueless_by_exception()) return true;
  if (__lhs.index() < __rhs.index()) return true;
  if (__lhs.index() > __rhs.index()) return false;
  return __variant::__visit_value_at(__lhs.index(), __convert_to_bool<less<>>{}, __lhs, __rhs);
}
template <class... _Types>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr bool operator>(const variant<_Types...>& __lhs,
                         const variant<_Types...>& __rhs) {
  using __variant_detail::__visitation::__variant;
  if (__lhs.valueless_by_exception()) return false;
  if (__rhs.valueless_by_exception()) return true;
  if (__lhs.index() > __rhs.index()) return true;
  if (__lhs.index() < __rhs.index()) return false;
  return __variant::__visit_value_at(__lhs.index(), __convert_to_bool<greater<>>{}, __lhs, __rhs);
}
template <class... _Types>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr bool operator<=(const variant<_Types...>& __lhs,
                          const variant<_Types...>& __rhs) {
  using __variant_detail::__visitation::__variant;
  if (__lhs.valueless_by_exception()) return true;
  if (__rhs.valueless_by_exception()) return false;
  if (__lhs.index() < __rhs.index()) return true;
  if (__lhs.index() > __rhs.index()) return false;
  return __variant::__visit_value_at(
      __lhs.index(), __convert_to_bool<less_equal<>>{}, __lhs, __rhs);
}
template <class... _Types>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr bool operator>=(const variant<_Types...>& __lhs,
                          const variant<_Types...>& __rhs) {
  using __variant_detail::__visitation::__variant;
  if (__rhs.valueless_by_exception()) return true;
  if (__lhs.valueless_by_exception()) return false;
  if (__lhs.index() > __rhs.index()) return true;
  if (__lhs.index() < __rhs.index()) return false;
  return __variant::__visit_value_at(
      __lhs.index(), __convert_to_bool<greater_equal<>>{}, __lhs, __rhs);
}
template <class... _Vs>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
__attribute__((availability(macos,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=12.0))) __attribute__((availability(tvos,strict,introduced=12.0))) __attribute__((availability(watchos,strict,introduced=5.0)))
constexpr void __throw_if_valueless(_Vs&&... __vs) {
  const bool __valueless =
      (... || std::__as_variant(__vs).valueless_by_exception());
  if (__valueless) {
    __throw_bad_variant_access();
  }
}
template <
    class _Visitor, class... _Vs,
    typename = void_t<decltype(std::__as_variant(std::declval<_Vs>()))...> >
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
__attribute__((availability(macos,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=12.0))) __attribute__((availability(tvos,strict,introduced=12.0))) __attribute__((availability(watchos,strict,introduced=5.0)))
constexpr decltype(auto) visit(_Visitor&& __visitor, _Vs&&... __vs) {
  using __variant_detail::__visitation::__variant;
  std::__throw_if_valueless(std::forward<_Vs>(__vs)...);
  return __variant::__visit_value(std::forward<_Visitor>(__visitor),
                                  std::forward<_Vs>(__vs)...);
}
template <
    class _Rp, class _Visitor, class... _Vs,
    typename = void_t<decltype(std::__as_variant(std::declval<_Vs>()))...> >
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
__attribute__((availability(macos,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=12.0))) __attribute__((availability(tvos,strict,introduced=12.0))) __attribute__((availability(watchos,strict,introduced=5.0)))
constexpr _Rp visit(_Visitor&& __visitor, _Vs&&... __vs) {
  using __variant_detail::__visitation::__variant;
  std::__throw_if_valueless(std::forward<_Vs>(__vs)...);
  return __variant::__visit_value<_Rp>(std::forward<_Visitor>(__visitor),
                                       std::forward<_Vs>(__vs)...);
}
template <class... _Types>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
auto swap(variant<_Types...>& __lhs, variant<_Types...>& __rhs)
  noexcept(noexcept(__lhs.swap(__rhs)))
  -> decltype( __lhs.swap(__rhs))
  { return __lhs.swap(__rhs); }
template <class... _Types>
struct __attribute__((__type_visibility__("default"))) hash<
    __enable_hash_helper<variant<_Types...>, remove_const_t<_Types>...>> {
  using argument_type = variant<_Types...>;
  using result_type = size_t;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  result_type operator()(const argument_type& __v) const {
    using __variant_detail::__visitation::__variant;
    size_t __res =
        __v.valueless_by_exception()
               ? 299792458
               : __variant::__visit_alt(
                     [](const auto& __alt) {
                       using __alt_type = __remove_cvref_t<decltype(__alt)>;
                       using __value_type = remove_const_t<
                         typename __alt_type::__value_type>;
                       return hash<__value_type>{}(__alt.__value);
                     },
                     __v);
    return std::__hash_combine(__res, hash<size_t>{}(__v.index()));
  }
};
template <size_t _Ip, class _Vp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr auto&& __unchecked_get(_Vp&& __v) noexcept {
  using __variant_detail::__access::__variant;
  return __variant::__get_alt<_Ip>(std::forward<_Vp>(__v)).__value;
}
template <class _Tp, class... _Types>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr auto&& __unchecked_get(const variant<_Types...>& __v) noexcept {
  return std::__unchecked_get<__find_exactly_one_t<_Tp, _Types...>::value>(__v);
}
template <class _Tp, class... _Types>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr auto&& __unchecked_get(variant<_Types...>& __v) noexcept {
  return std::__unchecked_get<__find_exactly_one_t<_Tp, _Types...>::value>(__v);
}
}}
namespace std { inline namespace __1 {
template<class _Iter>
concept __can_use_postfix_proxy =
  constructible_from<iter_value_t<_Iter>, iter_reference_t<_Iter>> &&
  move_constructible<iter_value_t<_Iter>>;
template<input_or_output_iterator _Iter, sentinel_for<_Iter> _Sent>
  requires (!same_as<_Iter, _Sent> && copyable<_Iter>)
class common_iterator {
  struct __proxy {
    constexpr const iter_value_t<_Iter>* operator->() const noexcept {
      return std::addressof(__value_);
    }
    iter_value_t<_Iter> __value_;
  };
  struct __postfix_proxy {
    constexpr const iter_value_t<_Iter>& operator*() const noexcept {
      return __value_;
    }
    iter_value_t<_Iter> __value_;
  };
public:
  variant<_Iter, _Sent> __hold_;
  common_iterator() requires default_initializable<_Iter> = default;
  constexpr common_iterator(_Iter __i) : __hold_(in_place_type<_Iter>, std::move(__i)) {}
  constexpr common_iterator(_Sent __s) : __hold_(in_place_type<_Sent>, std::move(__s)) {}
  template<class _I2, class _S2>
    requires convertible_to<const _I2&, _Iter> && convertible_to<const _S2&, _Sent>
  constexpr common_iterator(const common_iterator<_I2, _S2>& __other)
    : __hold_([&]() -> variant<_Iter, _Sent> {
      (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
      __builtin_assume(static_cast<bool>(!__other.__hold_.valueless_by_exception()))
#pragma clang diagnostic pop
      );
      if (__other.__hold_.index() == 0)
        return variant<_Iter, _Sent>{in_place_index<0>, std::__unchecked_get<0>(__other.__hold_)};
      return variant<_Iter, _Sent>{in_place_index<1>, std::__unchecked_get<1>(__other.__hold_)};
    }()) {}
  template<class _I2, class _S2>
    requires convertible_to<const _I2&, _Iter> && convertible_to<const _S2&, _Sent> &&
             assignable_from<_Iter&, const _I2&> && assignable_from<_Sent&, const _S2&>
  common_iterator& operator=(const common_iterator<_I2, _S2>& __other) {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(!__other.__hold_.valueless_by_exception()))
#pragma clang diagnostic pop
    );
    auto __idx = __hold_.index();
    auto __other_idx = __other.__hold_.index();
    if (__idx == 0 && __other_idx == 0)
      std::__unchecked_get<0>(__hold_) = std::__unchecked_get<0>(__other.__hold_);
    else if (__idx == 1 && __other_idx == 1)
      std::__unchecked_get<1>(__hold_) = std::__unchecked_get<1>(__other.__hold_);
    else if (__other_idx == 1)
      __hold_.template emplace<1>(std::__unchecked_get<1>(__other.__hold_));
    else if (__other_idx == 0)
      __hold_.template emplace<0>(std::__unchecked_get<0>(__other.__hold_));
    return *this;
  }
  constexpr decltype(auto) operator*()
  {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(std::holds_alternative<_Iter>(__hold_)))
#pragma clang diagnostic pop
    );
    return *std::__unchecked_get<_Iter>(__hold_);
  }
  constexpr decltype(auto) operator*() const
    requires __dereferenceable<const _Iter>
  {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(std::holds_alternative<_Iter>(__hold_)))
#pragma clang diagnostic pop
    );
    return *std::__unchecked_get<_Iter>(__hold_);
  }
  template<class _I2 = _Iter>
  decltype(auto) operator->() const
    requires indirectly_readable<const _I2> &&
    (requires(const _I2& __i) { __i.operator->(); } ||
     is_reference_v<iter_reference_t<_I2>> ||
     constructible_from<iter_value_t<_I2>, iter_reference_t<_I2>>)
  {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(std::holds_alternative<_Iter>(__hold_)))
#pragma clang diagnostic pop
    );
    if constexpr (is_pointer_v<_Iter> || requires(const _Iter& __i) { __i.operator->(); }) {
      return std::__unchecked_get<_Iter>(__hold_);
    } else if constexpr (is_reference_v<iter_reference_t<_Iter>>) {
      auto&& __tmp = *std::__unchecked_get<_Iter>(__hold_);
      return std::addressof(__tmp);
    } else {
      return __proxy{*std::__unchecked_get<_Iter>(__hold_)};
    }
  }
  common_iterator& operator++() {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(std::holds_alternative<_Iter>(__hold_)))
#pragma clang diagnostic pop
    );
    ++std::__unchecked_get<_Iter>(__hold_); return *this;
  }
  decltype(auto) operator++(int) {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(std::holds_alternative<_Iter>(__hold_)))
#pragma clang diagnostic pop
    );
    if constexpr (forward_iterator<_Iter>) {
      auto __tmp = *this;
      ++*this;
      return __tmp;
    } else if constexpr (requires (_Iter& __i) { { *__i++ } -> __can_reference; } ||
                         !__can_use_postfix_proxy<_Iter>) {
      return std::__unchecked_get<_Iter>(__hold_)++;
    } else {
      auto __p = __postfix_proxy{**this};
      ++*this;
      return __p;
    }
  }
  template<class _I2, sentinel_for<_Iter> _S2>
    requires sentinel_for<_Sent, _I2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator==(const common_iterator& __x, const common_iterator<_I2, _S2>& __y) {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(!__x.__hold_.valueless_by_exception()))
#pragma clang diagnostic pop
    );
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(!__y.__hold_.valueless_by_exception()))
#pragma clang diagnostic pop
    );
    auto __x_index = __x.__hold_.index();
    auto __y_index = __y.__hold_.index();
    if (__x_index == __y_index)
      return true;
    if (__x_index == 0)
      return std::__unchecked_get<_Iter>(__x.__hold_) == std::__unchecked_get<_S2>(__y.__hold_);
    return std::__unchecked_get<_Sent>(__x.__hold_) == std::__unchecked_get<_I2>(__y.__hold_);
  }
  template<class _I2, sentinel_for<_Iter> _S2>
    requires sentinel_for<_Sent, _I2> && equality_comparable_with<_Iter, _I2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator==(const common_iterator& __x, const common_iterator<_I2, _S2>& __y) {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(!__x.__hold_.valueless_by_exception()))
#pragma clang diagnostic pop
    );
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(!__y.__hold_.valueless_by_exception()))
#pragma clang diagnostic pop
    );
    auto __x_index = __x.__hold_.index();
    auto __y_index = __y.__hold_.index();
    if (__x_index == 1 && __y_index == 1)
      return true;
    if (__x_index == 0 && __y_index == 0)
      return std::__unchecked_get<_Iter>(__x.__hold_) == std::__unchecked_get<_I2>(__y.__hold_);
    if (__x_index == 0)
      return std::__unchecked_get<_Iter>(__x.__hold_) == std::__unchecked_get<_S2>(__y.__hold_);
    return std::__unchecked_get<_Sent>(__x.__hold_) == std::__unchecked_get<_I2>(__y.__hold_);
  }
  template<sized_sentinel_for<_Iter> _I2, sized_sentinel_for<_Iter> _S2>
    requires sized_sentinel_for<_Sent, _I2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr iter_difference_t<_I2> operator-(const common_iterator& __x, const common_iterator<_I2, _S2>& __y) {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(!__x.__hold_.valueless_by_exception()))
#pragma clang diagnostic pop
    );
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(!__y.__hold_.valueless_by_exception()))
#pragma clang diagnostic pop
    );
    auto __x_index = __x.__hold_.index();
    auto __y_index = __y.__hold_.index();
    if (__x_index == 1 && __y_index == 1)
      return 0;
    if (__x_index == 0 && __y_index == 0)
      return std::__unchecked_get<_Iter>(__x.__hold_) - std::__unchecked_get<_I2>(__y.__hold_);
    if (__x_index == 0)
      return std::__unchecked_get<_Iter>(__x.__hold_) - std::__unchecked_get<_S2>(__y.__hold_);
    return std::__unchecked_get<_Sent>(__x.__hold_) - std::__unchecked_get<_I2>(__y.__hold_);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) friend constexpr iter_rvalue_reference_t<_Iter> iter_move(const common_iterator& __i)
    noexcept(noexcept(ranges::iter_move(std::declval<const _Iter&>())))
      requires input_iterator<_Iter>
  {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(std::holds_alternative<_Iter>(__i.__hold_)))
#pragma clang diagnostic pop
    );
    return ranges::iter_move( std::__unchecked_get<_Iter>(__i.__hold_));
  }
  template<indirectly_swappable<_Iter> _I2, class _S2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) friend constexpr void iter_swap(const common_iterator& __x, const common_iterator<_I2, _S2>& __y)
      noexcept(noexcept(ranges::iter_swap(std::declval<const _Iter&>(), std::declval<const _I2&>())))
  {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(std::holds_alternative<_Iter>(__x.__hold_)))
#pragma clang diagnostic pop
    );
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(std::holds_alternative<_I2>(__y.__hold_)))
#pragma clang diagnostic pop
    );
    return ranges::iter_swap(std::__unchecked_get<_Iter>(__x.__hold_), std::__unchecked_get<_I2>(__y.__hold_));
  }
};
template<class _Iter, class _Sent>
struct incrementable_traits<common_iterator<_Iter, _Sent>> {
  using difference_type = iter_difference_t<_Iter>;
};
template<class _Iter>
concept __denotes_forward_iter =
  requires { typename iterator_traits<_Iter>::iterator_category; } &&
  derived_from<typename iterator_traits<_Iter>::iterator_category, forward_iterator_tag>;
template<class _Iter, class _Sent>
concept __common_iter_has_ptr_op = requires(const common_iterator<_Iter, _Sent>& __a) {
  __a.operator->();
};
template<class, class>
struct __arrow_type_or_void {
    using type = void;
};
template<class _Iter, class _Sent>
  requires __common_iter_has_ptr_op<_Iter, _Sent>
struct __arrow_type_or_void<_Iter, _Sent> {
    using type = decltype(std::declval<const common_iterator<_Iter, _Sent>&>().operator->());
};
template<input_iterator _Iter, class _Sent>
struct iterator_traits<common_iterator<_Iter, _Sent>> {
  using iterator_concept = _If<forward_iterator<_Iter>,
                               forward_iterator_tag,
                               input_iterator_tag>;
  using iterator_category = _If<__denotes_forward_iter<_Iter>,
                                forward_iterator_tag,
                                input_iterator_tag>;
  using pointer = typename __arrow_type_or_void<_Iter, _Sent>::type;
  using value_type = iter_value_t<_Iter>;
  using difference_type = iter_difference_t<_Iter>;
  using reference = iter_reference_t<_Iter>;
};
}}

namespace std { inline namespace __1 {
struct default_sentinel_t { };
inline constexpr default_sentinel_t default_sentinel{};
}}
namespace std { inline namespace __1 {
template<class>
struct __counted_iterator_concept {};
template<class _Iter>
  requires requires { typename _Iter::iterator_concept; }
struct __counted_iterator_concept<_Iter> {
  using iterator_concept = typename _Iter::iterator_concept;
};
template<class>
struct __counted_iterator_category {};
template<class _Iter>
  requires requires { typename _Iter::iterator_category; }
struct __counted_iterator_category<_Iter> {
  using iterator_category = typename _Iter::iterator_category;
};
template<class>
struct __counted_iterator_value_type {};
template<indirectly_readable _Iter>
struct __counted_iterator_value_type<_Iter> {
  using value_type = iter_value_t<_Iter>;
};
template<input_or_output_iterator _Iter>
class counted_iterator
  : public __counted_iterator_concept<_Iter>
  , public __counted_iterator_category<_Iter>
  , public __counted_iterator_value_type<_Iter>
{
public:
  [[no_unique_address]] _Iter __current_ = _Iter();
  iter_difference_t<_Iter> __count_ = 0;
  using iterator_type = _Iter;
  using difference_type = iter_difference_t<_Iter>;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr counted_iterator() requires default_initializable<_Iter> = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr counted_iterator(_Iter __iter, iter_difference_t<_Iter> __n)
   : __current_(std::move(__iter)), __count_(__n) {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(__n >= 0))
#pragma clang diagnostic pop
    );
  }
  template<class _I2>
    requires convertible_to<const _I2&, _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr counted_iterator(const counted_iterator<_I2>& __other)
   : __current_(__other.__current_), __count_(__other.__count_) {}
  template<class _I2>
    requires assignable_from<_Iter&, const _I2&>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr counted_iterator& operator=(const counted_iterator<_I2>& __other) {
    __current_ = __other.__current_;
    __count_ = __other.__count_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr const _Iter& base() const& noexcept { return __current_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr _Iter base() && { return std::move(__current_); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr iter_difference_t<_Iter> count() const noexcept { return __count_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr decltype(auto) operator*() {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(__count_ > 0))
#pragma clang diagnostic pop
    );
    return *__current_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr decltype(auto) operator*() const
    requires __dereferenceable<const _Iter>
  {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(__count_ > 0))
#pragma clang diagnostic pop
    );
    return *__current_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr auto operator->() const noexcept
    requires contiguous_iterator<_Iter>
  {
    return std::to_address(__current_);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr counted_iterator& operator++() {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(__count_ > 0))
#pragma clang diagnostic pop
    );
    ++__current_;
    --__count_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  decltype(auto) operator++(int) {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(__count_ > 0))
#pragma clang diagnostic pop
    );
    --__count_;
    try { return __current_++; }
    catch(...) { ++__count_; throw; }
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr counted_iterator operator++(int)
    requires forward_iterator<_Iter>
  {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(__count_ > 0))
#pragma clang diagnostic pop
    );
    counted_iterator __tmp = *this;
    ++*this;
    return __tmp;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr counted_iterator& operator--()
    requires bidirectional_iterator<_Iter>
  {
    --__current_;
    ++__count_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr counted_iterator operator--(int)
    requires bidirectional_iterator<_Iter>
  {
    counted_iterator __tmp = *this;
    --*this;
    return __tmp;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr counted_iterator operator+(iter_difference_t<_Iter> __n) const
    requires random_access_iterator<_Iter>
  {
    return counted_iterator(__current_ + __n, __count_ - __n);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr counted_iterator operator+(
    iter_difference_t<_Iter> __n, const counted_iterator& __x)
    requires random_access_iterator<_Iter>
  {
    return __x + __n;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr counted_iterator& operator+=(iter_difference_t<_Iter> __n)
    requires random_access_iterator<_Iter>
  {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(__n <= __count_))
#pragma clang diagnostic pop
    );
    __current_ += __n;
    __count_ -= __n;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr counted_iterator operator-(iter_difference_t<_Iter> __n) const
    requires random_access_iterator<_Iter>
  {
    return counted_iterator(__current_ - __n, __count_ + __n);
  }
  template<common_with<_Iter> _I2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr iter_difference_t<_I2> operator-(
    const counted_iterator& __lhs, const counted_iterator<_I2>& __rhs)
  {
    return __rhs.__count_ - __lhs.__count_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr iter_difference_t<_Iter> operator-(
    const counted_iterator& __lhs, default_sentinel_t)
  {
    return -__lhs.__count_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr iter_difference_t<_Iter> operator-(
    default_sentinel_t, const counted_iterator& __rhs)
  {
    return __rhs.__count_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr counted_iterator& operator-=(iter_difference_t<_Iter> __n)
    requires random_access_iterator<_Iter>
  {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(-__n <= __count_))
#pragma clang diagnostic pop
    );
    __current_ -= __n;
    __count_ += __n;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr decltype(auto) operator[](iter_difference_t<_Iter> __n) const
    requires random_access_iterator<_Iter>
  {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(__n < __count_))
#pragma clang diagnostic pop
    );
    return __current_[__n];
  }
  template<common_with<_Iter> _I2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator==(
    const counted_iterator& __lhs, const counted_iterator<_I2>& __rhs)
  {
    return __lhs.__count_ == __rhs.__count_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr bool operator==(
    const counted_iterator& __lhs, default_sentinel_t)
  {
    return __lhs.__count_ == 0;
  }
  template<common_with<_Iter> _I2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) friend constexpr strong_ordering operator<=>(
    const counted_iterator& __lhs, const counted_iterator<_I2>& __rhs)
  {
    return __rhs.__count_ <=> __lhs.__count_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr iter_rvalue_reference_t<_Iter> iter_move(const counted_iterator& __i)
    noexcept(noexcept(ranges::iter_move(__i.__current_)))
      requires input_iterator<_Iter>
  {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(__i.__count_ > 0))
#pragma clang diagnostic pop
    );
    return ranges::iter_move(__i.__current_);
  }
  template<indirectly_swappable<_Iter> _I2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  friend constexpr void iter_swap(const counted_iterator& __x, const counted_iterator<_I2>& __y)
    noexcept(noexcept(ranges::iter_swap(__x.__current_, __y.__current_)))
  {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(__x.__count_ > 0 && __y.__count_ > 0))
#pragma clang diagnostic pop
    );
    return ranges::iter_swap(__x.__current_, __y.__current_);
  }
};
template <class ..._Tag> counted_iterator(typename _Tag::__allow_ctad...) -> counted_iterator<_Tag...>;
template<input_iterator _Iter>
  requires same_as<_ITER_TRAITS<_Iter>, iterator_traits<_Iter>>
struct iterator_traits<counted_iterator<_Iter>> : iterator_traits<_Iter> {
  using pointer = conditional_t<contiguous_iterator<_Iter>,
                                add_pointer_t<iter_reference_t<_Iter>>, void>;
};
}}
namespace std { inline namespace __1 {
template <class _Cont>
// added by concept-synth, original LN: 28737
requires
requires (_Cont o) { o.data(); } constexpr
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
auto data(_Cont& __c)
noexcept(noexcept(__c.data()))
-> decltype (__c.data())
{ return __c.data(); }
template <class _Cont>
// added by concept-synth, original LN: 28743
requires
requires (_Cont o) { o.data(); } constexpr
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
auto data(const _Cont& __c)
noexcept(noexcept(__c.data()))
-> decltype (__c.data())
{ return __c.data(); }
template <class _Tp, size_t _Sz>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr _Tp* data(_Tp (&__array)[_Sz]) noexcept { return __array; }
template <class _Ep>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr const _Ep* data(initializer_list<_Ep> __il) noexcept { return __il.begin(); }
}}
namespace std { inline namespace __1 {
template <class _Cont>
// added by concept-synth, original LN: 28757
requires
requires (_Cont o) { o.empty(); }
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr auto empty(const _Cont& __c)
noexcept(noexcept(__c.empty()))
-> decltype (__c.empty())
{ return __c.empty(); }
template <class _Tp, size_t _Sz>
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr bool empty(const _Tp (&)[_Sz]) noexcept { return false; }
template <class _Ep>
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr bool empty(initializer_list<_Ep> __il) noexcept { return __il.size() == 0; }
}}
namespace std { inline namespace __1 {
template <class _Container, class _Predicate>
// added by concept-synth, original LN: 28771
requires
(
 requires (_Container o) { o.begin(); } &&
 requires (_Container o) { o.end(); } &&
 requires (_Container o) { o.size(); }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
typename _Container::size_type
__libcpp_erase_if_container(_Container& __c, _Predicate& __pred) {
  typename _Container::size_type __old_size = __c.size();
  const typename _Container::iterator __last = __c.end();
  for (typename _Container::iterator __iter = __c.begin(); __iter != __last;) {
    if (__pred(*__iter))
      __iter = __c.erase(__iter);
    else
      ++__iter;
  }
  return __old_size - __c.size();
}
}}
namespace std { inline namespace __1 {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Container>
class __attribute__((__type_visibility__("default"))) front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
#pragma GCC diagnostic pop
protected:
    _Container* container;
public:
    typedef output_iterator_tag iterator_category;
    typedef void value_type;
    typedef ptrdiff_t difference_type;
    typedef void pointer;
    typedef void reference;
    typedef _Container container_type;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr explicit front_insert_iterator(_Container& __x) : container(std::addressof(__x)) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr front_insert_iterator& operator=(const typename _Container::value_type& __value)
        {container->push_front(__value); return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr front_insert_iterator& operator=(typename _Container::value_type&& __value)
        {container->push_front(std::move(__value)); return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr front_insert_iterator& operator*() {return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr front_insert_iterator& operator++() {return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr front_insert_iterator operator++(int) {return *this;}
};
template <class ..._Tag> front_insert_iterator(typename _Tag::__allow_ctad...) -> front_insert_iterator<_Tag...>;
template <class _Container>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
front_insert_iterator<_Container>
front_inserter(_Container& __x)
{
    return front_insert_iterator<_Container>(__x);
}
}}
namespace std { inline namespace __1 {
template <class _Container>
using __insert_iterator_iter_t = ranges::iterator_t<_Container>;
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Container>
class __attribute__((__type_visibility__("default"))) insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
#pragma GCC diagnostic pop
protected:
    _Container* container;
    __insert_iterator_iter_t<_Container> iter;
public:
    typedef output_iterator_tag iterator_category;
    typedef void value_type;
    typedef ptrdiff_t difference_type;
    typedef void pointer;
    typedef void reference;
    typedef _Container container_type;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr insert_iterator(_Container& __x, __insert_iterator_iter_t<_Container> __i)
        : container(std::addressof(__x)), iter(__i) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr insert_iterator& operator=(const typename _Container::value_type& __value)
        {iter = container->insert(iter, __value); ++iter; return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr insert_iterator& operator=(typename _Container::value_type&& __value)
        {iter = container->insert(iter, std::move(__value)); ++iter; return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr insert_iterator& operator*() {return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr insert_iterator& operator++() {return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr insert_iterator& operator++(int) {return *this;}
};
template <class _Container>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
insert_iterator<_Container>
inserter(_Container& __x, __insert_iterator_iter_t<_Container> __i)
{
    return insert_iterator<_Container>(__x, __i);
}
}}
namespace std { inline namespace __1 {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Tp, class _CharT = char,
          class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>
class __attribute__((__type_visibility__("default"))) istream_iterator
    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&>
{
#pragma GCC diagnostic pop
public:
    typedef input_iterator_tag iterator_category;
    typedef _Tp value_type;
    typedef _Distance difference_type;
    typedef const _Tp* pointer;
    typedef const _Tp& reference;
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_istream<_CharT,_Traits> istream_type;
private:
    istream_type* __in_stream_;
    _Tp __value_;
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr istream_iterator() : __in_stream_(nullptr), __value_() {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr istream_iterator(default_sentinel_t) : istream_iterator() {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) istream_iterator(istream_type& __s) : __in_stream_(std::addressof(__s))
        {
            if (!(*__in_stream_ >> __value_))
                __in_stream_ = nullptr;
        }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) const _Tp& operator*() const {return __value_;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) const _Tp* operator->() const {return std::addressof((operator*()));}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) istream_iterator& operator++()
        {
            if (!(*__in_stream_ >> __value_))
                __in_stream_ = nullptr;
            return *this;
        }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) istream_iterator operator++(int)
        {istream_iterator __t(*this); ++(*this); return __t;}
    template <class _Up, class _CharU, class _TraitsU, class _DistanceU>
    friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool
    operator==(const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU>& __x,
               const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU>& __y);
    friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool operator==(const istream_iterator& __i, default_sentinel_t) {
      return __i.__in_stream_ == nullptr;
    }
};
template <class _Tp, class _CharT, class _Traits, class _Distance>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool
operator==(const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __x,
           const istream_iterator<_Tp, _CharT, _Traits, _Distance>& __y)
{
    return __x.__in_stream_ == __y.__in_stream_;
}
}}
namespace std { inline namespace __1 {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template<class _CharT, class _Traits>
class __attribute__((__type_visibility__("default"))) istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT,
                      typename _Traits::off_type, _CharT*,
                      _CharT>
{
#pragma GCC diagnostic pop
public:
    typedef input_iterator_tag iterator_category;
    typedef _CharT value_type;
    typedef typename _Traits::off_type difference_type;
    typedef _CharT* pointer;
    typedef _CharT reference;
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename _Traits::int_type int_type;
    typedef basic_streambuf<_CharT,_Traits> streambuf_type;
    typedef basic_istream<_CharT,_Traits> istream_type;
private:
    mutable streambuf_type* __sbuf_;
    class __proxy
    {
        char_type __keep_;
        streambuf_type* __sbuf_;
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
        explicit __proxy(char_type __c, streambuf_type* __s)
            : __keep_(__c), __sbuf_(__s) {}
        friend class istreambuf_iterator;
    public:
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) char_type operator*() const {return __keep_;}
    };
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool __test_for_eof() const
    {
        if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))
            __sbuf_ = nullptr;
        return __sbuf_ == nullptr;
    }
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr istreambuf_iterator() noexcept : __sbuf_(nullptr) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr istreambuf_iterator(default_sentinel_t) noexcept
        : istreambuf_iterator() {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) istreambuf_iterator(istream_type& __s) noexcept
        : __sbuf_(__s.rdbuf()) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) istreambuf_iterator(streambuf_type* __s) noexcept
        : __sbuf_(__s) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) istreambuf_iterator(const __proxy& __p) noexcept
        : __sbuf_(__p.__sbuf_) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) char_type operator*() const
        {return static_cast<char_type>(__sbuf_->sgetc());}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) istreambuf_iterator& operator++()
        {
            __sbuf_->sbumpc();
            return *this;
        }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __proxy operator++(int)
        {
            return __proxy(__sbuf_->sbumpc(), __sbuf_);
        }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool equal(const istreambuf_iterator& __b) const
        {return __test_for_eof() == __b.__test_for_eof();}
    friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool operator==(const istreambuf_iterator& __i, default_sentinel_t) {
      return __i.__test_for_eof();
    }
};
template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool operator==(const istreambuf_iterator<_CharT,_Traits>& __a,
                const istreambuf_iterator<_CharT,_Traits>& __b)
                {return __a.equal(__b);}
}}
namespace std { inline namespace __1 {
template <semiregular _Sent>
class __attribute__((__type_visibility__("default"))) move_sentinel
{
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  move_sentinel() = default;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  explicit move_sentinel(_Sent __s) : __last_(std::move(__s)) {}
  template <class _S2>
    requires convertible_to<const _S2&, _Sent>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  move_sentinel(const move_sentinel<_S2>& __s) : __last_(__s.base()) {}
  template <class _S2>
    requires assignable_from<_Sent&, const _S2&>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  move_sentinel& operator=(const move_sentinel<_S2>& __s)
    { __last_ = __s.base(); return *this; }
  constexpr _Sent base() const { return __last_; }
private:
    _Sent __last_ = _Sent();
};
template <class ..._Tag> move_sentinel(typename _Tag::__allow_ctad...) -> move_sentinel<_Tag...>;
}}
namespace std { inline namespace __1 {
template<class _Iter, class = void>
struct __move_iter_category_base {};
template<class _Iter>
  requires requires { typename iterator_traits<_Iter>::iterator_category; }
struct __move_iter_category_base<_Iter> {
    using iterator_category = _If<
        derived_from<typename iterator_traits<_Iter>::iterator_category, random_access_iterator_tag>,
        random_access_iterator_tag,
        typename iterator_traits<_Iter>::iterator_category
    >;
};
template<class _Iter, class _Sent>
concept __move_iter_comparable = requires {
    { std::declval<const _Iter&>() == std::declval<_Sent>() } -> convertible_to<bool>;
};
template <class _Iter>
class __attribute__((__type_visibility__("default"))) move_iterator
    : public __move_iter_category_base<_Iter>
{
public:
    using iterator_type = _Iter;
    using iterator_concept = input_iterator_tag;
    using value_type = iter_value_t<_Iter>;
    using difference_type = iter_difference_t<_Iter>;
    using pointer = _Iter;
    using reference = iter_rvalue_reference_t<_Iter>;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    explicit move_iterator(_Iter __i) : __current_(std::move(__i)) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    move_iterator& operator++() { ++__current_; return *this; }
    __attribute__((deprecated)) __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    pointer operator->() const { return __current_; }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    move_iterator() requires is_constructible_v<_Iter> : __current_() {}
    template <class _Up>
        requires (!_IsSame<_Up, _Iter>::value) && convertible_to<const _Up&, _Iter>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    move_iterator(const move_iterator<_Up>& __u) : __current_(__u.base()) {}
    template <class _Up>
        requires (!_IsSame<_Up, _Iter>::value) &&
                 convertible_to<const _Up&, _Iter> &&
                 assignable_from<_Iter&, const _Up&>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    move_iterator& operator=(const move_iterator<_Up>& __u) {
        __current_ = __u.base();
        return *this;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr const _Iter& base() const & noexcept { return __current_; }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Iter base() && { return std::move(__current_); }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    reference operator*() const { return ranges::iter_move(__current_); }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    reference operator[](difference_type __n) const { return ranges::iter_move(__current_ + __n); }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    auto operator++(int)
        requires forward_iterator<_Iter>
    {
        move_iterator __tmp(*this); ++__current_; return __tmp;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    void operator++(int) { ++__current_; }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    move_iterator& operator--() { --__current_; return *this; }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    move_iterator operator--(int) { move_iterator __tmp(*this); --__current_; return __tmp; }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    move_iterator operator+(difference_type __n) const { return move_iterator(__current_ + __n); }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    move_iterator& operator+=(difference_type __n) { __current_ += __n; return *this; }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    move_iterator operator-(difference_type __n) const { return move_iterator(__current_ - __n); }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    move_iterator& operator-=(difference_type __n) { __current_ -= __n; return *this; }
    template<sentinel_for<_Iter> _Sent>
    friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    bool operator==(const move_iterator& __x, const move_sentinel<_Sent>& __y)
        requires __move_iter_comparable<_Iter, _Sent>
    {
        return __x.base() == __y.base();
    }
    template<sized_sentinel_for<_Iter> _Sent>
    friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    iter_difference_t<_Iter> operator-(const move_sentinel<_Sent>& __x, const move_iterator& __y)
    {
        return __x.base() - __y.base();
    }
    template<sized_sentinel_for<_Iter> _Sent>
    friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    iter_difference_t<_Iter> operator-(const move_iterator& __x, const move_sentinel<_Sent>& __y)
    {
        return __x.base() - __y.base();
    }
    friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    iter_rvalue_reference_t<_Iter> iter_move(const move_iterator& __i)
        noexcept(noexcept(ranges::iter_move(__i.__current_)))
    {
        return ranges::iter_move(__i.__current_);
    }
    template<indirectly_swappable<_Iter> _It2>
    friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    void iter_swap(const move_iterator& __x, const move_iterator<_It2>& __y)
        noexcept(noexcept(ranges::iter_swap(__x.__current_, __y.__current_)))
    {
        return ranges::iter_swap(__x.__current_, __y.__current_);
    }
private:
    template<class _It2> friend class move_iterator;
    _Iter __current_;
};
template <class ..._Tag> move_iterator(typename _Tag::__allow_ctad...) -> move_iterator<_Tag...>;
template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool operator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() == __y.base();
}
template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool operator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() < __y.base();
}
template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool operator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() > __y.base();
}
template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool operator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() <= __y.base();
}
template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool operator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
{
    return __x.base() >= __y.base();
}
template <class _Iter1, three_way_comparable_with<_Iter1> _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
auto operator<=>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
    -> compare_three_way_result_t<_Iter1, _Iter2>
{
    return __x.base() <=> __y.base();
}
template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
auto operator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
    -> decltype(__x.base() - __y.base())
{
    return __x.base() - __y.base();
}
template <class _Iter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
move_iterator<_Iter> operator+(iter_difference_t<_Iter> __n, const move_iterator<_Iter>& __x)
    requires requires { { __x.base() + __n } -> same_as<_Iter>; }
{
    return __x + __n;
}
template <class _Iter>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
move_iterator<_Iter>
make_move_iterator(_Iter __i)
{
    return move_iterator<_Iter>(std::move(__i));
}
}}
namespace std { inline namespace __1 {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> >
class __attribute__((__type_visibility__("default"))) ostream_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
#pragma GCC diagnostic pop
public:
    typedef output_iterator_tag iterator_category;
    typedef void value_type;
    typedef ptrdiff_t difference_type;
    typedef void pointer;
    typedef void reference;
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_ostream<_CharT, _Traits> ostream_type;
private:
    ostream_type* __out_stream_;
    const char_type* __delim_;
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) ostream_iterator(ostream_type& __s) noexcept
        : __out_stream_(std::addressof(__s)), __delim_(nullptr) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) ostream_iterator(ostream_type& __s, const _CharT* __delimiter) noexcept
        : __out_stream_(std::addressof(__s)), __delim_(__delimiter) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) ostream_iterator& operator=(const _Tp& __value)
        {
            *__out_stream_ << __value;
            if (__delim_)
                *__out_stream_ << __delim_;
            return *this;
        }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) ostream_iterator& operator*() {return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) ostream_iterator& operator++() {return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) ostream_iterator& operator++(int) {return *this;}
};
}}
namespace std { inline namespace __1 {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template <class _CharT, class _Traits>
class __attribute__((__type_visibility__("default"))) ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
#pragma GCC diagnostic pop
public:
    typedef output_iterator_tag iterator_category;
    typedef void value_type;
    typedef ptrdiff_t difference_type;
    typedef void pointer;
    typedef void reference;
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_streambuf<_CharT, _Traits> streambuf_type;
    typedef basic_ostream<_CharT, _Traits> ostream_type;
private:
    streambuf_type* __sbuf_;
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) ostreambuf_iterator(ostream_type& __s) noexcept
        : __sbuf_(__s.rdbuf()) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) ostreambuf_iterator(streambuf_type* __s) noexcept
        : __sbuf_(__s) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) ostreambuf_iterator& operator=(_CharT __c)
        {
            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))
                __sbuf_ = nullptr;
            return *this;
        }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) ostreambuf_iterator& operator*() {return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) ostreambuf_iterator& operator++() {return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) ostreambuf_iterator& operator++(int) {return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool failed() const noexcept {return __sbuf_ == nullptr;}
    template <class _Ch, class _Tr>
    friend
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    ostreambuf_iterator<_Ch, _Tr>
    __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s,
                     const _Ch* __ob, const _Ch* __op, const _Ch* __oe,
                     ios_base& __iob, _Ch __fl);
};
}}
namespace std { inline namespace __1 {
template <class _Tp, size_t _Np>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
reverse_iterator<_Tp*> rbegin(_Tp (&__array)[_Np])
{
    return reverse_iterator<_Tp*>(__array + _Np);
}
template <class _Tp, size_t _Np>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
reverse_iterator<_Tp*> rend(_Tp (&__array)[_Np])
{
    return reverse_iterator<_Tp*>(__array);
}
template <class _Ep>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
reverse_iterator<const _Ep*> rbegin(initializer_list<_Ep> __il)
{
    return reverse_iterator<const _Ep*>(__il.end());
}
template <class _Ep>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
reverse_iterator<const _Ep*> rend(initializer_list<_Ep> __il)
{
    return reverse_iterator<const _Ep*>(__il.begin());
}
template <class _Cp>
// added by concept-synth, original LN: 29296
requires
requires (_Cp o) { o.rbegin(); }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
auto rbegin(_Cp& __c) -> decltype(__c.rbegin())
{
    return __c.rbegin();
}
template <class _Cp>
// added by concept-synth, original LN: 29302
requires
requires (_Cp o) { o.rbegin(); }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
auto rbegin(const _Cp& __c) -> decltype(__c.rbegin())
{
    return __c.rbegin();
}
template <class _Cp>
// added by concept-synth, original LN: 29308
requires
requires (_Cp o) { o.rend(); }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
auto rend(_Cp& __c) -> decltype(__c.rend())
{
    return __c.rend();
}
template <class _Cp>
// added by concept-synth, original LN: 29314
requires
requires (_Cp o) { o.rend(); }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
auto rend(const _Cp& __c) -> decltype(__c.rend())
{
    return __c.rend();
}
template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
auto crbegin(const _Cp& __c) -> decltype(std::rbegin(__c))
{
    return std::rbegin(__c);
}
template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
auto crend(const _Cp& __c) -> decltype(std::rend(__c))
{
    return std::rend(__c);
}
}}

namespace std { inline namespace __1 {
template <class _Cont>
// added by concept-synth, original LN: 29335
requires
requires (_Cont o) { o.size(); }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr auto size(const _Cont& __c)
noexcept(noexcept(__c.size()))
-> decltype (__c.size())
{ return __c.size(); }
template <class _Tp, size_t _Sz>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr size_t size(const _Tp (&)[_Sz]) noexcept { return _Sz; }
template <class _Cont>
// added by concept-synth, original LN: 29344
requires
requires (_Cont o) { o.size(); }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr auto ssize(const _Cont& __c)
noexcept(noexcept(static_cast<common_type_t<ptrdiff_t, make_signed_t<decltype(__c.size())>>>(__c.size())))
-> common_type_t<ptrdiff_t, make_signed_t<decltype(__c.size())>>
{ return static_cast<common_type_t<ptrdiff_t, make_signed_t<decltype(__c.size())>>>(__c.size()); }
#pragma clang diagnostic push
template <class _Tp, ptrdiff_t _Sz>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr ptrdiff_t ssize(const _Tp (&)[_Sz]) noexcept { return _Sz; }
#pragma clang diagnostic pop
}}
namespace std { inline namespace __1 {
__attribute__((__visibility__("default"))) void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);
}}
namespace std { inline namespace __1 {
template <class _Pointer>
struct __allocation_result {
  _Pointer ptr;
  size_t count;
};
template <class _Alloc>
[[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
__allocation_result<typename allocator_traits<_Alloc>::pointer> __allocate_at_least(_Alloc& __alloc, size_t __n) {
  return {__alloc.allocate(__n), __n};
}
}}
namespace std { inline namespace __1 {
template<class _Alloc>
struct __allocation_guard {
    using _Pointer = typename allocator_traits<_Alloc>::pointer;
    using _Size = typename allocator_traits<_Alloc>::size_type;
    template<class _AllocT>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    explicit __allocation_guard(_AllocT __alloc, _Size __n)
        : __alloc_(std::move(__alloc))
        , __n_(__n)
        , __ptr_(allocator_traits<_Alloc>::allocate(__alloc_, __n_))
    { }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    ~__allocation_guard() noexcept {
        if (__ptr_ != nullptr) {
            allocator_traits<_Alloc>::deallocate(__alloc_, __ptr_, __n_);
        }
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Pointer __release_ptr() noexcept {
        _Pointer __tmp = __ptr_;
        __ptr_ = nullptr;
        return __tmp;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Pointer __get() const noexcept {
        return __ptr_;
    }
private:
    _Alloc __alloc_;
    _Size __n_;
    _Pointer __ptr_;
};
}}
namespace std { inline namespace __1 {
class __attribute__((__visibility__("hidden"))) __libcpp_refstring
{
    const char* __imp_;
    bool __uses_refcount() const;
public:
    explicit __libcpp_refstring(const char* __msg);
    __libcpp_refstring(const __libcpp_refstring& __s) noexcept;
    __libcpp_refstring& operator=(const __libcpp_refstring& __s) noexcept;
    ~__libcpp_refstring();
    const char* c_str() const noexcept {return __imp_;}
};
}}
namespace std
{
class __attribute__((__visibility__("default"))) logic_error
    : public exception
{
private:
    std::__libcpp_refstring __imp_;
public:
    explicit logic_error(const string&);
    explicit logic_error(const char*);
    logic_error(const logic_error&) noexcept;
    logic_error& operator=(const logic_error&) noexcept;
    ~logic_error() noexcept override;
    const char* what() const noexcept override;
};
class __attribute__((__visibility__("default"))) runtime_error
    : public exception
{
private:
    std::__libcpp_refstring __imp_;
public:
    explicit runtime_error(const string&);
    explicit runtime_error(const char*);
    runtime_error(const runtime_error&) noexcept;
    runtime_error& operator=(const runtime_error&) noexcept;
    ~runtime_error() noexcept override;
    const char* what() const noexcept override;
};
class __attribute__((__visibility__("default"))) domain_error
    : public logic_error
{
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) explicit domain_error(const string& __s) : logic_error(__s) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) explicit domain_error(const char* __s) : logic_error(__s) {}
    domain_error(const domain_error&) noexcept = default;
    ~domain_error() noexcept override;
};
class __attribute__((__visibility__("default"))) invalid_argument
    : public logic_error
{
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) explicit invalid_argument(const string& __s) : logic_error(__s) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) explicit invalid_argument(const char* __s) : logic_error(__s) {}
    invalid_argument(const invalid_argument&) noexcept = default;
    ~invalid_argument() noexcept override;
};
class __attribute__((__visibility__("default"))) length_error
    : public logic_error
{
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) explicit length_error(const string& __s) : logic_error(__s) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) explicit length_error(const char* __s) : logic_error(__s) {}
    length_error(const length_error&) noexcept = default;
    ~length_error() noexcept override;
};
class __attribute__((__visibility__("default"))) out_of_range
    : public logic_error
{
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) explicit out_of_range(const string& __s) : logic_error(__s) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) explicit out_of_range(const char* __s) : logic_error(__s) {}
    out_of_range(const out_of_range&) noexcept = default;
    ~out_of_range() noexcept override;
};
class __attribute__((__visibility__("default"))) range_error
    : public runtime_error
{
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) explicit range_error(const string& __s) : runtime_error(__s) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) explicit range_error(const char* __s) : runtime_error(__s) {}
    range_error(const range_error&) noexcept = default;
    ~range_error() noexcept override;
};
class __attribute__((__visibility__("default"))) overflow_error
    : public runtime_error
{
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) explicit overflow_error(const string& __s) : runtime_error(__s) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) explicit overflow_error(const char* __s) : runtime_error(__s) {}
    overflow_error(const overflow_error&) noexcept = default;
    ~overflow_error() noexcept override;
};
class __attribute__((__visibility__("default"))) underflow_error
    : public runtime_error
{
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) explicit underflow_error(const string& __s) : runtime_error(__s) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) explicit underflow_error(const char* __s) : runtime_error(__s) {}
    underflow_error(const underflow_error&) noexcept = default;
    ~underflow_error() noexcept override;
};
}
namespace std { inline namespace __1 {
[[noreturn]] __attribute__((__visibility__("default"))) void __throw_runtime_error(const char*);
[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void __throw_logic_error(const char*__msg)
{
    throw logic_error(__msg);
}
[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void __throw_domain_error(const char*__msg)
{
    throw domain_error(__msg);
}
[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void __throw_invalid_argument(const char*__msg)
{
    throw invalid_argument(__msg);
}
[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void __throw_length_error(const char*__msg)
{
    throw length_error(__msg);
}
[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void __throw_out_of_range(const char*__msg)
{
    throw out_of_range(__msg);
}
[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void __throw_range_error(const char*__msg)
{
    throw range_error(__msg);
}
[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void __throw_overflow_error(const char*__msg)
{
    throw overflow_error(__msg);
}
[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void __throw_underflow_error(const char*__msg)
{
    throw underflow_error(__msg);
}
}}
namespace std { inline namespace __1 {
template <class _Tp> class allocator;
template <bool _Cond, class _Unique>
struct __non_trivial_if { };
template <class _Unique>
struct __non_trivial_if<true, _Unique> {
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr __non_trivial_if() noexcept { }
};
template <class _Tp>
class __attribute__((__type_visibility__("default"))) allocator
    : private __non_trivial_if<!is_void<_Tp>::value, allocator<_Tp> >
{
    static_assert(!is_volatile<_Tp>::value, "std::allocator does not support volatile types");
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Tp value_type;
    typedef true_type propagate_on_container_move_assignment;
    typedef true_type is_always_equal;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    allocator() noexcept = default;
    template <class _Up>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    allocator(const allocator<_Up>&) noexcept { }
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    _Tp* allocate(size_t __n) {
        if (__n > allocator_traits<allocator>::max_size(*this))
            __throw_bad_array_new_length();
        if (__libcpp_is_constant_evaluated()) {
            return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
        } else {
            return static_cast<_Tp*>(std::__libcpp_allocate(__n * sizeof(_Tp), alignof(_Tp)));
        }
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    void deallocate(_Tp* __p, size_t __n) noexcept {
        if (__libcpp_is_constant_evaluated()) {
            ::operator delete(__p);
        } else {
            std::__libcpp_deallocate((void*)__p, __n * sizeof(_Tp), alignof(_Tp));
        }
    }
};
template <class _Tp>
class __attribute__((__type_visibility__("default"))) allocator<const _Tp>
    : private __non_trivial_if<!is_void<_Tp>::value, allocator<const _Tp> >
{
    static_assert(!is_volatile<_Tp>::value, "std::allocator does not support volatile types");
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef const _Tp value_type;
    typedef true_type propagate_on_container_move_assignment;
    typedef true_type is_always_equal;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    allocator() noexcept = default;
    template <class _Up>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    allocator(const allocator<_Up>&) noexcept { }
    [[nodiscard]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    const _Tp* allocate(size_t __n) {
        if (__n > allocator_traits<allocator>::max_size(*this))
            __throw_bad_array_new_length();
        if (__libcpp_is_constant_evaluated()) {
            return static_cast<const _Tp*>(::operator new(__n * sizeof(_Tp)));
        } else {
            return static_cast<const _Tp*>(std::__libcpp_allocate(__n * sizeof(_Tp), alignof(_Tp)));
        }
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    void deallocate(const _Tp* __p, size_t __n) {
        if (__libcpp_is_constant_evaluated()) {
            ::operator delete(const_cast<_Tp*>(__p));
        } else {
            std::__libcpp_deallocate((void*) const_cast<_Tp *>(__p), __n * sizeof(_Tp), alignof(_Tp));
        }
    }
};
template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool operator==(const allocator<_Tp>&, const allocator<_Up>&) noexcept {return true;}
template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
bool operator!=(const allocator<_Tp>&, const allocator<_Up>&) noexcept {return false;}
}}
namespace std { inline namespace __1 {
template <size_t _Np, class _Tp>
[[nodiscard]]
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr _Tp* assume_aligned(_Tp* __ptr) {
  static_assert(_Np != 0 && (_Np & (_Np - 1)) == 0,
    "std::assume_aligned<N>(p) requires N to be a power of two");
  if (is_constant_evaluated()) {
    return __ptr;
  } else {
    (
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wassume"
    __builtin_assume(static_cast<bool>(reinterpret_cast<uintptr_t>(__ptr) % _Np == 0))
#pragma clang diagnostic pop
    );
    return static_cast<_Tp*>(__builtin_assume_aligned(__ptr, _Np));
  }
}
}}
namespace std { inline namespace __1 {
namespace ranges {
template <class _Ip>
concept __nothrow_input_iterator =
    input_iterator<_Ip> &&
    is_lvalue_reference_v<iter_reference_t<_Ip>> &&
    same_as<remove_cvref_t<iter_reference_t<_Ip>>, iter_value_t<_Ip>>;
template <class _Sp, class _Ip>
concept __nothrow_sentinel_for = sentinel_for<_Sp, _Ip>;
template <class _Rp>
concept __nothrow_input_range =
    range<_Rp> &&
    __nothrow_input_iterator<iterator_t<_Rp>> &&
    __nothrow_sentinel_for<sentinel_t<_Rp>, iterator_t<_Rp>>;
template <class _Ip>
concept __nothrow_forward_iterator =
    __nothrow_input_iterator<_Ip> &&
    forward_iterator<_Ip> &&
    __nothrow_sentinel_for<_Ip, _Ip>;
template <class _Rp>
concept __nothrow_forward_range =
    __nothrow_input_range<_Rp> &&
    __nothrow_forward_iterator<iterator_t<_Rp>>;
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __construct_at {
struct __fn {
  template<class _Tp, class... _Args, class = decltype(
    ::new (std::declval<void*>()) _Tp(std::declval<_Args>()...)
  )>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr _Tp* operator()(_Tp* __location, _Args&& ...__args) const {
    return std::construct_at(__location, std::forward<_Args>(__args)...);
  }
};
}
inline namespace __cpo {
  inline constexpr auto construct_at = __construct_at::__fn{};
}
namespace __destroy_at {
struct __fn {
  template <destructible _Tp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr void operator()(_Tp* __location) const noexcept {
    std::destroy_at(__location);
  }
};
}
inline namespace __cpo {
  inline constexpr auto destroy_at = __destroy_at::__fn{};
}
namespace __destroy {
struct __fn {
  template <__nothrow_input_iterator _InputIterator, __nothrow_sentinel_for<_InputIterator> _Sentinel>
    requires destructible<iter_value_t<_InputIterator>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr _InputIterator operator()(_InputIterator __first, _Sentinel __last) const noexcept {
    return std::__destroy(std::move(__first), std::move(__last));
  }
  template <__nothrow_input_range _InputRange>
    requires destructible<range_value_t<_InputRange>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr borrowed_iterator_t<_InputRange> operator()(_InputRange&& __range) const noexcept {
    return (*this)(ranges::begin(__range), ranges::end(__range));
  }
};
}
inline namespace __cpo {
  inline constexpr auto destroy = __destroy::__fn{};
}
namespace __destroy_n {
struct __fn {
  template <__nothrow_input_iterator _InputIterator>
    requires destructible<iter_value_t<_InputIterator>>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
  constexpr _InputIterator operator()(_InputIterator __first, iter_difference_t<_InputIterator> __n) const noexcept {
    return std::destroy_n(std::move(__first), __n);
  }
};
}
inline namespace __cpo {
  inline constexpr auto destroy_n = __destroy_n::__fn{};
}
}
}}
namespace std { inline namespace __1 {
struct __unreachable_sentinel {
  template <class _Iter>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) friend constexpr bool operator!=(const _Iter&, __unreachable_sentinel) noexcept {
    return true;
  }
};
template <class _ValueType, class _InputIterator, class _Sentinel1, class _ForwardIterator, class _Sentinel2>
// added by concept-synth, original LN: 29753
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
) &&
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) pair<_InputIterator, _ForwardIterator>
__uninitialized_copy(_InputIterator __ifirst, _Sentinel1 __ilast,
                     _ForwardIterator __ofirst, _Sentinel2 __olast) {
  _ForwardIterator __idx = __ofirst;
  try {
    for (; __ifirst != __ilast && __idx != __olast; ++__ifirst, (void)++__idx)
      ::new (std::__voidify(*__idx)) _ValueType(*__ifirst);
  } catch (...) {
    std::__destroy(__ofirst, __idx);
    throw;
  }
  return pair<_InputIterator, _ForwardIterator>(std::move(__ifirst), std::move(__idx));
}
template <class _InputIterator, class _ForwardIterator>
// added by concept-synth, original LN: 29767
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
) &&
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_ForwardIterator uninitialized_copy(_InputIterator __ifirst, _InputIterator __ilast,
                                    _ForwardIterator __ofirst) {
  typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
  auto __result = std::__uninitialized_copy<_ValueType>(std::move(__ifirst), std::move(__ilast),
                                                          std::move(__ofirst), __unreachable_sentinel());
  return std::move(__result.second);
}
template <class _ValueType, class _InputIterator, class _Size, class _ForwardIterator, class _Sentinel>
// added by concept-synth, original LN: 29776
requires
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
) &&
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
) &&
requires (_Size x0) { --x0; }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) pair<_InputIterator, _ForwardIterator>
__uninitialized_copy_n(_InputIterator __ifirst, _Size __n,
                       _ForwardIterator __ofirst, _Sentinel __olast) {
  _ForwardIterator __idx = __ofirst;
  try {
    for (; __n > 0 && __idx != __olast; ++__ifirst, (void)++__idx, (void)--__n)
      ::new (std::__voidify(*__idx)) _ValueType(*__ifirst);
  } catch (...) {
    std::__destroy(__ofirst, __idx);
    throw;
  }
  return pair<_InputIterator, _ForwardIterator>(std::move(__ifirst), std::move(__idx));
}
template <class _InputIterator, class _Size, class _ForwardIterator>
// added by concept-synth, original LN: 29790
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
) &&
(
 requires (_InputIterator x0) { *x0; } &&
 requires (_InputIterator x0) { ++x0; }
) &&
requires (_Size x0) { --x0; }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) _ForwardIterator uninitialized_copy_n(_InputIterator __ifirst, _Size __n,
                                                                   _ForwardIterator __ofirst) {
  typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
  auto __result = std::__uninitialized_copy_n<_ValueType>(std::move(__ifirst), __n, std::move(__ofirst),
                                                            __unreachable_sentinel());
  return std::move(__result.second);
}
template <class _ValueType, class _ForwardIterator, class _Sentinel, class _Tp>
// added by concept-synth, original LN: 29798
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_ForwardIterator __uninitialized_fill(_ForwardIterator __first, _Sentinel __last, const _Tp& __x)
{
    _ForwardIterator __idx = __first;
    try
    {
        for (; __idx != __last; ++__idx)
            ::new (std::__voidify(*__idx)) _ValueType(__x);
    }
    catch (...)
    {
        std::__destroy(__first, __idx);
        throw;
    }
    return __idx;
}
template <class _ForwardIterator, class _Tp>
// added by concept-synth, original LN: 29815
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __x)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
    (void)std::__uninitialized_fill<_ValueType>(__first, __last, __x);
}
template <class _ValueType, class _ForwardIterator, class _Size, class _Tp>
// added by concept-synth, original LN: 29822
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
) &&
requires (_Size x0) { --x0; }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_ForwardIterator __uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
{
    _ForwardIterator __idx = __first;
    try
    {
        for (; __n > 0; ++__idx, (void) --__n)
            ::new (std::__voidify(*__idx)) _ValueType(__x);
    }
    catch (...)
    {
        std::__destroy(__first, __idx);
        throw;
    }
    return __idx;
}
template <class _ForwardIterator, class _Size, class _Tp>
// added by concept-synth, original LN: 29839
requires
requires (_Size x0) { --x0; } &&
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_ForwardIterator uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
{
    typedef typename iterator_traits<_ForwardIterator>::value_type _ValueType;
    return std::__uninitialized_fill_n<_ValueType>(__first, __n, __x);
}
template <class _ValueType, class _ForwardIterator, class _Sentinel>
// added by concept-synth, original LN: 29846
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_ForwardIterator __uninitialized_default_construct(_ForwardIterator __first, _Sentinel __last) {
    auto __idx = __first;
    try {
    for (; __idx != __last; ++__idx)
        ::new (std::__voidify(*__idx)) _ValueType;
    } catch (...) {
        std::__destroy(__first, __idx);
        throw;
    }
    return __idx;
}
template <class _ForwardIterator>
// added by concept-synth, original LN: 29859
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void uninitialized_default_construct(_ForwardIterator __first, _ForwardIterator __last) {
    using _ValueType = typename iterator_traits<_ForwardIterator>::value_type;
    (void)std::__uninitialized_default_construct<_ValueType>(
        std::move(__first), std::move(__last));
}
template <class _ValueType, class _ForwardIterator, class _Size>
// added by concept-synth, original LN: 29866
requires
requires (_Size x0) { --x0; } &&
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_ForwardIterator __uninitialized_default_construct_n(_ForwardIterator __first, _Size __n) {
    auto __idx = __first;
    try {
    for (; __n > 0; ++__idx, (void) --__n)
        ::new (std::__voidify(*__idx)) _ValueType;
    } catch (...) {
        std::__destroy(__first, __idx);
        throw;
    }
    return __idx;
}
template <class _ForwardIterator, class _Size>
// added by concept-synth, original LN: 29879
requires
requires (_Size x0) { --x0; } &&
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_ForwardIterator uninitialized_default_construct_n(_ForwardIterator __first, _Size __n) {
    using _ValueType = typename iterator_traits<_ForwardIterator>::value_type;
    return std::__uninitialized_default_construct_n<_ValueType>(std::move(__first), __n);
}
template <class _ValueType, class _ForwardIterator, class _Sentinel>
// added by concept-synth, original LN: 29885
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_ForwardIterator __uninitialized_value_construct(_ForwardIterator __first, _Sentinel __last) {
    auto __idx = __first;
    try {
    for (; __idx != __last; ++__idx)
        ::new (std::__voidify(*__idx)) _ValueType();
    } catch (...) {
        std::__destroy(__first, __idx);
        throw;
    }
    return __idx;
}
template <class _ForwardIterator>
// added by concept-synth, original LN: 29898
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void uninitialized_value_construct(_ForwardIterator __first, _ForwardIterator __last) {
    using _ValueType = typename iterator_traits<_ForwardIterator>::value_type;
    (void)std::__uninitialized_value_construct<_ValueType>(
        std::move(__first), std::move(__last));
}
template <class _ValueType, class _ForwardIterator, class _Size>
// added by concept-synth, original LN: 29905
requires
requires (_Size x0) { --x0; } &&
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_ForwardIterator __uninitialized_value_construct_n(_ForwardIterator __first, _Size __n) {
    auto __idx = __first;
    try {
    for (; __n > 0; ++__idx, (void) --__n)
        ::new (std::__voidify(*__idx)) _ValueType();
    } catch (...) {
        std::__destroy(__first, __idx);
        throw;
    }
    return __idx;
}
template <class _ForwardIterator, class _Size>
// added by concept-synth, original LN: 29918
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
) &&
requires (_Size x0) { --x0; }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_ForwardIterator uninitialized_value_construct_n(_ForwardIterator __first, _Size __n) {
    using _ValueType = typename iterator_traits<_ForwardIterator>::value_type;
    return std::__uninitialized_value_construct_n<_ValueType>(std::move(__first), __n);
}
template <class _ValueType, class _InputIterator, class _Sentinel1, class _ForwardIterator, class _Sentinel2,
          class _IterMove>
// added by concept-synth, original LN: 29924
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
) &&
requires (_IterMove f, _InputIterator x0) { f(x0); } &&
requires (_InputIterator x0) { ++x0; }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) pair<_InputIterator, _ForwardIterator>
__uninitialized_move(_InputIterator __ifirst, _Sentinel1 __ilast,
                     _ForwardIterator __ofirst, _Sentinel2 __olast, _IterMove __iter_move) {
  auto __idx = __ofirst;
  try {
    for (; __ifirst != __ilast && __idx != __olast; ++__idx, (void)++__ifirst) {
      ::new (std::__voidify(*__idx)) _ValueType(__iter_move(__ifirst));
    }
  } catch (...) {
    std::__destroy(__ofirst, __idx);
    throw;
  }
  return {std::move(__ifirst), std::move(__idx)};
}
template <class _InputIterator, class _ForwardIterator>
// added by concept-synth, original LN: 29940
requires
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
) &&
requires (_InputIterator x0) { ++x0; }
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) _ForwardIterator uninitialized_move(_InputIterator __ifirst, _InputIterator __ilast,
                                                                 _ForwardIterator __ofirst) {
  using _ValueType = typename iterator_traits<_ForwardIterator>::value_type;
  auto __iter_move = [](auto&& __iter) -> decltype(auto) { return std::move(*__iter); };
  auto __result = std::__uninitialized_move<_ValueType>(std::move(__ifirst), std::move(__ilast),
                                                          std::move(__ofirst), __unreachable_sentinel(), __iter_move);
  return std::move(__result.second);
}
template <class _ValueType, class _InputIterator, class _Size, class _ForwardIterator, class _Sentinel, class _IterMove>
// added by concept-synth, original LN: 29949
requires
requires (_Size x0) { --x0; } &&
requires (_IterMove f, _InputIterator x0) { f(x0); } &&
requires (_InputIterator x0) { ++x0; } &&
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) pair<_InputIterator, _ForwardIterator>
__uninitialized_move_n(_InputIterator __ifirst, _Size __n,
                       _ForwardIterator __ofirst, _Sentinel __olast, _IterMove __iter_move) {
  auto __idx = __ofirst;
  try {
    for (; __n > 0 && __idx != __olast; ++__idx, (void)++__ifirst, --__n)
      ::new (std::__voidify(*__idx)) _ValueType(__iter_move(__ifirst));
  } catch (...) {
    std::__destroy(__ofirst, __idx);
    throw;
  }
  return {std::move(__ifirst), std::move(__idx)};
}
template <class _InputIterator, class _Size, class _ForwardIterator>
// added by concept-synth, original LN: 29963
requires
requires (_Size x0) { --x0; } &&
requires (_InputIterator x0) { ++x0; } &&
(
 requires (_ForwardIterator x0) { *x0; } &&
 requires (_ForwardIterator x0) { ++x0; }
)
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) pair<_InputIterator, _ForwardIterator>
uninitialized_move_n(_InputIterator __ifirst, _Size __n, _ForwardIterator __ofirst) {
  using _ValueType = typename iterator_traits<_ForwardIterator>::value_type;
  auto __iter_move = [](auto&& __iter) -> decltype(auto) { return std::move(*__iter); };
  return std::__uninitialized_move_n<_ValueType>(std::move(__ifirst), __n, std::move(__ofirst),
                                                   __unreachable_sentinel(), __iter_move);
}
template<class _Alloc, class _BidirIter, class = __enable_if_t<
    __is_cpp17_bidirectional_iterator<_BidirIter>::value
>>
// added by concept-synth, original LN: 29971
requires
(
 requires (_BidirIter x0) { *x0; } &&
 requires (_BidirIter x0) { --x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr void __allocator_destroy_multidimensional(_Alloc& __alloc, _BidirIter __first, _BidirIter __last) noexcept {
    using _ValueType = typename iterator_traits<_BidirIter>::value_type;
    static_assert(is_same_v<typename allocator_traits<_Alloc>::value_type, _ValueType>,
        "The allocator should already be rebound to the correct type");
    if (__first == __last)
        return;
    if constexpr (is_array_v<_ValueType>) {
        static_assert(!__libcpp_is_unbounded_array<_ValueType>::value,
            "arrays of unbounded arrays don't exist, but if they did we would mess up here");
        using _Element = remove_extent_t<_ValueType>;
        __allocator_traits_rebind_t<_Alloc, _Element> __elem_alloc(__alloc);
        do {
            --__last;
            decltype(auto) __array = *__last;
            std::__allocator_destroy_multidimensional(__elem_alloc, __array, __array + extent_v<_ValueType>);
        } while (__last != __first);
    } else {
        do {
            --__last;
            allocator_traits<_Alloc>::destroy(__alloc, std::addressof(*__last));
        } while (__last != __first);
    }
}
template<class _Alloc, class _Tp>
// added by concept-synth, original LN: 29998
requires
(
 requires (_Tp x0) { *x0; } &&
 requires (_Tp x0) { --x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr void __allocator_construct_at_multidimensional(_Alloc& __alloc, _Tp* __loc) {
    static_assert(is_same_v<typename allocator_traits<_Alloc>::value_type, _Tp>,
        "The allocator should already be rebound to the correct type");
    if constexpr (is_array_v<_Tp>) {
        using _Element = remove_extent_t<_Tp>;
        __allocator_traits_rebind_t<_Alloc, _Element> __elem_alloc(__alloc);
        size_t __i = 0;
        _Tp& __array = *__loc;
        auto __guard = std::__make_exception_guard([&]() {
          std::__allocator_destroy_multidimensional(__elem_alloc, __array, __array + __i);
        });
        for (; __i != extent_v<_Tp>; ++__i) {
            std::__allocator_construct_at_multidimensional(__elem_alloc, std::addressof(__array[__i]));
        }
        __guard.__complete();
    } else {
        allocator_traits<_Alloc>::construct(__alloc, __loc);
    }
}
template<class _Alloc, class _Tp, class _Arg>
// added by concept-synth, original LN: 30019
requires
(
 requires (_Tp x0) { *x0; } &&
 requires (_Tp x0) { --x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
constexpr void __allocator_construct_at_multidimensional(_Alloc& __alloc, _Tp* __loc, _Arg const& __arg) {
    static_assert(is_same_v<typename allocator_traits<_Alloc>::value_type, _Tp>,
        "The allocator should already be rebound to the correct type");
    if constexpr (is_array_v<_Tp>) {
        static_assert(is_array_v<_Arg>,
            "Provided non-array initialization argument to __allocator_construct_at_multidimensional when "
            "trying to construct an array.");
        using _Element = remove_extent_t<_Tp>;
        __allocator_traits_rebind_t<_Alloc, _Element> __elem_alloc(__alloc);
        size_t __i = 0;
        _Tp& __array = *__loc;
        auto __guard = std::__make_exception_guard([&]() {
          std::__allocator_destroy_multidimensional(__elem_alloc, __array, __array + __i);
        });
        for (; __i != extent_v<_Tp>; ++__i) {
            std::__allocator_construct_at_multidimensional(__elem_alloc, std::addressof(__array[__i]), __arg[__i]);
        }
        __guard.__complete();
    } else {
        allocator_traits<_Alloc>::construct(__alloc, __loc, __arg);
    }
}
template<class _Alloc, class _BidirIter, class _Tp, class _Size = typename iterator_traits<_BidirIter>::difference_type>
// added by concept-synth, original LN: 30043
requires
requires (_Size x0) { --x0; } &&
(
 requires (_BidirIter x0) { *x0; } &&
 requires (_BidirIter x0) { ++x0; } &&
 requires (_BidirIter x0) { --x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr void
__uninitialized_allocator_fill_n_multidimensional(_Alloc& __alloc, _BidirIter __it, _Size __n, _Tp const& __value) {
    using _ValueType = typename iterator_traits<_BidirIter>::value_type;
    __allocator_traits_rebind_t<_Alloc, _ValueType> __value_alloc(__alloc);
    _BidirIter __begin = __it;
    auto __guard = std::__make_exception_guard([&]() { std::__allocator_destroy_multidimensional(__value_alloc, __begin, __it); });
    for (; __n != 0; --__n, ++__it) {
        std::__allocator_construct_at_multidimensional(__value_alloc, std::addressof(*__it), __value);
    }
    __guard.__complete();
}
template <class _Alloc, class _BidirIter, class _Size = typename iterator_traits<_BidirIter>::difference_type>
// added by concept-synth, original LN: 30055
requires
requires (_Size x0) { --x0; } &&
(
 requires (_BidirIter x0) { *x0; } &&
 requires (_BidirIter x0) { ++x0; } &&
 requires (_BidirIter x0) { --x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr void
__uninitialized_allocator_value_construct_n_multidimensional(_Alloc& __alloc, _BidirIter __it, _Size __n) {
    using _ValueType = typename iterator_traits<_BidirIter>::value_type;
    __allocator_traits_rebind_t<_Alloc, _ValueType> __value_alloc(__alloc);
    _BidirIter __begin = __it;
    auto __guard = std::__make_exception_guard([&]() { std::__allocator_destroy_multidimensional(__value_alloc, __begin, __it); });
    for (; __n != 0; --__n, ++__it) {
        std::__allocator_construct_at_multidimensional(__value_alloc, std::addressof(*__it));
    }
    __guard.__complete();
}
template <class _Alloc, class _Iter, class _Sent>
// added by concept-synth, original LN: 30067
requires
requires (_Iter x0) { ++x0; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr void
__allocator_destroy(_Alloc& __alloc, _Iter __first, _Sent __last) {
  for (; __first != __last; ++__first)
     allocator_traits<_Alloc>::destroy(__alloc, std::__to_address(__first));
}
template <class _Alloc, class _Iter>
class _AllocatorDestroyRangeReverse {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
  _AllocatorDestroyRangeReverse(_Alloc& __alloc, _Iter& __first, _Iter& __last)
      : __alloc_(__alloc), __first_(__first), __last_(__last) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr void operator()() const {
    std::__allocator_destroy(__alloc_, std::reverse_iterator<_Iter>(__last_), std::reverse_iterator<_Iter>(__first_));
  }
private:
  _Alloc& __alloc_;
  _Iter& __first_;
  _Iter& __last_;
};
template <class _Alloc, class _Iter1, class _Sent1, class _Iter2>
// added by concept-synth, original LN: 30087
requires
requires (_Iter2 x0) { ++x0; } &&
(
 requires (_Iter1 x0) { ++x0; } &&
 requires (_Iter1 x0) { *x0; }
)
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Iter2
__uninitialized_allocator_copy(_Alloc& __alloc, _Iter1 __first1, _Sent1 __last1, _Iter2 __first2) {
  auto __destruct_first = __first2;
  auto __guard =
      std::__make_exception_guard(_AllocatorDestroyRangeReverse<_Alloc, _Iter2>(__alloc, __destruct_first, __first2));
  while (__first1 != __last1) {
    allocator_traits<_Alloc>::construct(__alloc, std::__to_address(__first2), *__first1);
    ++__first1;
    ++__first2;
  }
  __guard.__complete();
  return __first2;
}
template <class _Alloc, class _Type>
struct __allocator_has_trivial_copy_construct : _Not<__has_construct<_Alloc, _Type*, const _Type&> > {};
template <class _Type>
struct __allocator_has_trivial_copy_construct<allocator<_Type>, _Type> : true_type {};
template <class _Alloc,
          class _Type,
          class _RawType = __remove_const_t<_Type>,
          __enable_if_t<
              is_trivially_copy_constructible<_RawType>::value && is_trivially_copy_assignable<_RawType>::value &&
              __allocator_has_trivial_copy_construct<_Alloc, _RawType>::value>* = nullptr>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Type*
__uninitialized_allocator_copy(_Alloc&, const _Type* __first1, const _Type* __last1, _Type* __first2) {
  if (__libcpp_is_constant_evaluated()) {
    while (__first1 != __last1) {
      std::__construct_at(std::__to_address(__first2), *__first1);
      ++__first1;
      ++__first2;
    }
    return __first2;
  } else {
    return std::copy(__first1, __last1, const_cast<_RawType*>(__first2));
  }
}
template <class _Alloc, class _Iter1, class _Sent1, class _Iter2>
// added by concept-synth, original LN: 30124
requires
(
 requires (_Iter1 x0) { ++x0; } &&
 requires (_Iter1 x0) { *x0; }
) &&
requires (_Iter2 x0) { ++x0; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Iter2 __uninitialized_allocator_move_if_noexcept(
    _Alloc& __alloc, _Iter1 __first1, _Sent1 __last1, _Iter2 __first2) {
  static_assert(__is_cpp17_move_insertable<_Alloc>::value,
                "The specified type does not meet the requirements of Cpp17MoveInsertable");
  auto __destruct_first = __first2;
  auto __guard =
      std::__make_exception_guard(_AllocatorDestroyRangeReverse<_Alloc, _Iter2>(__alloc, __destruct_first, __first2));
  while (__first1 != __last1) {
    allocator_traits<_Alloc>::construct(__alloc, std::__to_address(__first2), std::move_if_noexcept(*__first1));
    ++__first1;
    ++__first2;
  }
  __guard.__complete();
  return __first2;
}
template <class _Alloc, class _Type>
struct __allocator_has_trivial_move_construct : _Not<__has_construct<_Alloc, _Type*, _Type&&> > {};
template <class _Type>
struct __allocator_has_trivial_move_construct<allocator<_Type>, _Type> : true_type {};
template <
    class _Alloc,
    class _Iter1,
    class _Iter2,
    class _Type = typename iterator_traits<_Iter1>::value_type,
    class = __enable_if_t<is_trivially_move_constructible<_Type>::value && is_trivially_move_assignable<_Type>::value &&
                          __allocator_has_trivial_move_construct<_Alloc, _Type>::value> >
// added by concept-synth, original LN: 30144
requires
(
 requires (_Iter1 x0) { ++x0; } &&
 requires (_Iter1 x0) { *x0; }
) &&
requires (_Iter2 x0) { ++x0; }
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Iter2
__uninitialized_allocator_move_if_noexcept(_Alloc&, _Iter1 __first1, _Iter1 __last1, _Iter2 __first2) {
  if (__libcpp_is_constant_evaluated()) {
    while (__first1 != __last1) {
      std::__construct_at(std::__to_address(__first2), std::move(*__first1));
      ++__first1;
      ++__first2;
    }
    return __first2;
  } else {
    return std::move(__first1, __last1, __first2);
  }
}
}}
namespace std { inline namespace __1 {
namespace ranges {
namespace __uninitialized_default_construct {
struct __fn {
  template <__nothrow_forward_iterator _ForwardIterator,
            __nothrow_sentinel_for<_ForwardIterator> _Sentinel>
    requires default_initializable<iter_value_t<_ForwardIterator>>
  _ForwardIterator operator()(_ForwardIterator __first, _Sentinel __last) const {
    using _ValueType = remove_reference_t<iter_reference_t<_ForwardIterator>>;
    return std::__uninitialized_default_construct<_ValueType>(
        std::move(__first), std::move(__last));
  }
  template <__nothrow_forward_range _ForwardRange>
    requires default_initializable<range_value_t<_ForwardRange>>
  borrowed_iterator_t<_ForwardRange> operator()(_ForwardRange&& __range) const {
    return (*this)(ranges::begin(__range), ranges::end(__range));
  }
};
}
inline namespace __cpo {
  inline constexpr auto uninitialized_default_construct = __uninitialized_default_construct::__fn{};
}
namespace __uninitialized_default_construct_n {
struct __fn {
  template <__nothrow_forward_iterator _ForwardIterator>
    requires default_initializable<iter_value_t<_ForwardIterator>>
  _ForwardIterator operator()(_ForwardIterator __first,
                              iter_difference_t<_ForwardIterator> __n) const {
    using _ValueType = remove_reference_t<iter_reference_t<_ForwardIterator>>;
    return std::__uninitialized_default_construct_n<_ValueType>(std::move(__first), __n);
  }
};
}
inline namespace __cpo {
  inline constexpr auto uninitialized_default_construct_n = __uninitialized_default_construct_n::__fn{};
}
namespace __uninitialized_value_construct {
struct __fn {
  template <__nothrow_forward_iterator _ForwardIterator,
            __nothrow_sentinel_for<_ForwardIterator> _Sentinel>
    requires default_initializable<iter_value_t<_ForwardIterator>>
  _ForwardIterator operator()(_ForwardIterator __first, _Sentinel __last) const {
    using _ValueType = remove_reference_t<iter_reference_t<_ForwardIterator>>;
    return std::__uninitialized_value_construct<_ValueType>(
        std::move(__first), std::move(__last));
  }
  template <__nothrow_forward_range _ForwardRange>
    requires default_initializable<range_value_t<_ForwardRange>>
  borrowed_iterator_t<_ForwardRange> operator()(_ForwardRange&& __range) const {
    return (*this)(ranges::begin(__range), ranges::end(__range));
  }
};
}
inline namespace __cpo {
  inline constexpr auto uninitialized_value_construct = __uninitialized_value_construct::__fn{};
}
namespace __uninitialized_value_construct_n {
struct __fn {
  template <__nothrow_forward_iterator _ForwardIterator>
    requires default_initializable<iter_value_t<_ForwardIterator>>
  _ForwardIterator operator()(_ForwardIterator __first,
                              iter_difference_t<_ForwardIterator> __n) const {
    using _ValueType = remove_reference_t<iter_reference_t<_ForwardIterator>>;
    return std::__uninitialized_value_construct_n<_ValueType>(std::move(__first), __n);
  }
};
}
inline namespace __cpo {
  inline constexpr auto uninitialized_value_construct_n = __uninitialized_value_construct_n::__fn{};
}
namespace __uninitialized_fill {
struct __fn {
  template <__nothrow_forward_iterator _ForwardIterator,
            __nothrow_sentinel_for<_ForwardIterator> _Sentinel,
            class _Tp>
    requires constructible_from<iter_value_t<_ForwardIterator>, const _Tp&>
  _ForwardIterator operator()(_ForwardIterator __first, _Sentinel __last, const _Tp& __x) const {
    using _ValueType = remove_reference_t<iter_reference_t<_ForwardIterator>>;
    return std::__uninitialized_fill<_ValueType>(std::move(__first), std::move(__last), __x);
  }
  template <__nothrow_forward_range _ForwardRange, class _Tp>
    requires constructible_from<range_value_t<_ForwardRange>, const _Tp&>
  borrowed_iterator_t<_ForwardRange> operator()(_ForwardRange&& __range, const _Tp& __x) const {
    return (*this)(ranges::begin(__range), ranges::end(__range), __x);
  }
};
}
inline namespace __cpo {
  inline constexpr auto uninitialized_fill = __uninitialized_fill::__fn{};
}
namespace __uninitialized_fill_n {
struct __fn {
  template <__nothrow_forward_iterator _ForwardIterator, class _Tp>
    requires constructible_from<iter_value_t<_ForwardIterator>, const _Tp&>
  _ForwardIterator operator()(_ForwardIterator __first,
                              iter_difference_t<_ForwardIterator> __n,
                              const _Tp& __x) const {
    using _ValueType = remove_reference_t<iter_reference_t<_ForwardIterator>>;
    return std::__uninitialized_fill_n<_ValueType>(std::move(__first), __n, __x);
  }
};
}
inline namespace __cpo {
  inline constexpr auto uninitialized_fill_n = __uninitialized_fill_n::__fn{};
}
template <class _InputIterator, class _OutputIterator>
using uninitialized_copy_result = in_out_result<_InputIterator, _OutputIterator>;
namespace __uninitialized_copy {
struct __fn {
  template <input_iterator _InputIterator,
            sentinel_for<_InputIterator> _Sentinel1,
            __nothrow_forward_iterator _OutputIterator,
            __nothrow_sentinel_for<_OutputIterator> _Sentinel2>
    requires constructible_from<iter_value_t<_OutputIterator>, iter_reference_t<_InputIterator>>
  uninitialized_copy_result<_InputIterator, _OutputIterator>
  operator()(_InputIterator __ifirst, _Sentinel1 __ilast, _OutputIterator __ofirst, _Sentinel2 __olast) const {
    using _ValueType = remove_reference_t<iter_reference_t<_OutputIterator>>;
    auto __result = std::__uninitialized_copy<_ValueType>(std::move(__ifirst), std::move(__ilast),
                                                            std::move(__ofirst), std::move(__olast));
    return {std::move(__result.first), std::move(__result.second)};
  }
  template <input_range _InputRange, __nothrow_forward_range _OutputRange>
    requires constructible_from<range_value_t<_OutputRange>, range_reference_t<_InputRange>>
  uninitialized_copy_result<borrowed_iterator_t<_InputRange>, borrowed_iterator_t<_OutputRange>>
  operator()( _InputRange&& __in_range, _OutputRange&& __out_range) const {
    return (*this)(ranges::begin(__in_range), ranges::end(__in_range),
                   ranges::begin(__out_range), ranges::end(__out_range));
  }
};
}
inline namespace __cpo {
  inline constexpr auto uninitialized_copy = __uninitialized_copy::__fn{};
}
template <class _InputIterator, class _OutputIterator>
using uninitialized_copy_n_result = in_out_result<_InputIterator, _OutputIterator>;
namespace __uninitialized_copy_n {
struct __fn {
  template <input_iterator _InputIterator,
           __nothrow_forward_iterator _OutputIterator,
           __nothrow_sentinel_for<_OutputIterator> _Sentinel>
    requires constructible_from<iter_value_t<_OutputIterator>, iter_reference_t<_InputIterator>>
  uninitialized_copy_n_result<_InputIterator, _OutputIterator>
  operator()(_InputIterator __ifirst, iter_difference_t<_InputIterator> __n,
             _OutputIterator __ofirst, _Sentinel __olast) const {
    using _ValueType = remove_reference_t<iter_reference_t<_OutputIterator>>;
    auto __result = std::__uninitialized_copy_n<_ValueType>(std::move(__ifirst), __n,
                                                              std::move(__ofirst), std::move(__olast));
    return {std::move(__result.first), std::move(__result.second)};
  }
};
}
inline namespace __cpo {
  inline constexpr auto uninitialized_copy_n = __uninitialized_copy_n::__fn{};
}
template <class _InputIterator, class _OutputIterator>
using uninitialized_move_result = in_out_result<_InputIterator, _OutputIterator>;
namespace __uninitialized_move {
struct __fn {
  template <input_iterator _InputIterator,
            sentinel_for<_InputIterator> _Sentinel1,
            __nothrow_forward_iterator _OutputIterator,
            __nothrow_sentinel_for<_OutputIterator> _Sentinel2>
    requires constructible_from<iter_value_t<_OutputIterator>, iter_rvalue_reference_t<_InputIterator>>
  uninitialized_move_result<_InputIterator, _OutputIterator>
  operator()(_InputIterator __ifirst, _Sentinel1 __ilast, _OutputIterator __ofirst, _Sentinel2 __olast) const {
    using _ValueType = remove_reference_t<iter_reference_t<_OutputIterator>>;
    auto __iter_move = [](auto&& __iter) -> decltype(auto) { return ranges::iter_move(__iter); };
    auto __result = std::__uninitialized_move<_ValueType>(std::move(__ifirst), std::move(__ilast),
                                                            std::move(__ofirst), std::move(__olast), __iter_move);
    return {std::move(__result.first), std::move(__result.second)};
  }
  template <input_range _InputRange, __nothrow_forward_range _OutputRange>
    requires constructible_from<range_value_t<_OutputRange>, range_rvalue_reference_t<_InputRange>>
  uninitialized_move_result<borrowed_iterator_t<_InputRange>, borrowed_iterator_t<_OutputRange>>
  operator()(_InputRange&& __in_range, _OutputRange&& __out_range) const {
    return (*this)(ranges::begin(__in_range), ranges::end(__in_range),
                   ranges::begin(__out_range), ranges::end(__out_range));
  }
};
}
inline namespace __cpo {
  inline constexpr auto uninitialized_move = __uninitialized_move::__fn{};
}
template <class _InputIterator, class _OutputIterator>
using uninitialized_move_n_result = in_out_result<_InputIterator, _OutputIterator>;
namespace __uninitialized_move_n {
struct __fn {
  template <input_iterator _InputIterator,
           __nothrow_forward_iterator _OutputIterator,
           __nothrow_sentinel_for<_OutputIterator> _Sentinel>
    requires constructible_from<iter_value_t<_OutputIterator>, iter_rvalue_reference_t<_InputIterator>>
  uninitialized_move_n_result<_InputIterator, _OutputIterator>
  operator()(_InputIterator __ifirst, iter_difference_t<_InputIterator> __n,
             _OutputIterator __ofirst, _Sentinel __olast) const {
    using _ValueType = remove_reference_t<iter_reference_t<_OutputIterator>>;
    auto __iter_move = [](auto&& __iter) -> decltype(auto) { return ranges::iter_move(__iter); };
    auto __result = std::__uninitialized_move_n<_ValueType>(std::move(__ifirst), __n,
                                                              std::move(__ofirst), std::move(__olast), __iter_move);
    return {std::move(__result.first), std::move(__result.second)};
  }
};
}
inline namespace __cpo {
  inline constexpr auto uninitialized_move_n = __uninitialized_move_n::__fn{};
}
}
}}
namespace std { inline namespace __1 {
}}
namespace std { inline namespace __1 {
template <class _Tp>
struct __has_result_type
{
private:
    template <class _Up> static false_type __test(...);
    template <class _Up> static true_type __test(typename _Up::result_type* = 0);
public:
    static const bool value = decltype(__test<_Tp>(0))::value;
};
template <class _Tp>
struct __derives_from_unary_function
{
private:
    struct __two {char __lx; char __lxx;};
    static __two __test(...);
    template <class _Ap, class _Rp>
        static __unary_function<_Ap, _Rp>
        __test(const volatile __unary_function<_Ap, _Rp>*);
public:
    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;
    typedef decltype(__test((_Tp*)0)) type;
};
template <class _Tp>
struct __derives_from_binary_function
{
private:
    struct __two {char __lx; char __lxx;};
    static __two __test(...);
    template <class _A1, class _A2, class _Rp>
        static __binary_function<_A1, _A2, _Rp>
        __test(const volatile __binary_function<_A1, _A2, _Rp>*);
public:
    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;
    typedef decltype(__test((_Tp*)0)) type;
};
template <class _Tp, bool = __derives_from_unary_function<_Tp>::value>
struct __maybe_derive_from_unary_function
    : public __derives_from_unary_function<_Tp>::type
{
};
template <class _Tp>
struct __maybe_derive_from_unary_function<_Tp, false>
{
};
template <class _Tp, bool = __derives_from_binary_function<_Tp>::value>
struct __maybe_derive_from_binary_function
    : public __derives_from_binary_function<_Tp>::type
{
};
template <class _Tp>
struct __maybe_derive_from_binary_function<_Tp, false>
{
};
template <class _Tp, bool = __has_result_type<_Tp>::value>
struct __weak_result_type_imp
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp>
{
};
template <class _Tp>
struct __weak_result_type_imp<_Tp, false>
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp>
{
};
template <class _Tp>
struct __weak_result_type
    : public __weak_result_type_imp<_Tp>
{
};
template <class _Rp>
struct __weak_result_type<_Rp ()>
{
};
template <class _Rp>
struct __weak_result_type<_Rp (&)()>
{
};
template <class _Rp>
struct __weak_result_type<_Rp (*)()>
{
};
template <class _Rp, class _A1>
struct __weak_result_type<_Rp (_A1)>
    : public __unary_function<_A1, _Rp>
{
};
template <class _Rp, class _A1>
struct __weak_result_type<_Rp (&)(_A1)>
    : public __unary_function<_A1, _Rp>
{
};
template <class _Rp, class _A1>
struct __weak_result_type<_Rp (*)(_A1)>
    : public __unary_function<_A1, _Rp>
{
};
template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)()>
    : public __unary_function<_Cp*, _Rp>
{
};
template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const>
    : public __unary_function<const _Cp*, _Rp>
{
};
template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() volatile>
    : public __unary_function<volatile _Cp*, _Rp>
{
};
template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const volatile>
    : public __unary_function<const volatile _Cp*, _Rp>
{
};
template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (_A1, _A2)>
    : public __binary_function<_A1, _A2, _Rp>
{
};
template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (*)(_A1, _A2)>
    : public __binary_function<_A1, _A2, _Rp>
{
};
template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (&)(_A1, _A2)>
    : public __binary_function<_A1, _A2, _Rp>
{
};
template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1)>
    : public __binary_function<_Cp*, _A1, _Rp>
{
};
template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const>
    : public __binary_function<const _Cp*, _A1, _Rp>
{
};
template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>
    : public __binary_function<volatile _Cp*, _A1, _Rp>
{
};
template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>
    : public __binary_function<const volatile _Cp*, _A1, _Rp>
{
};
template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
struct __weak_result_type<_Rp (_A1, _A2, _A3, _A4...)>
{
};
template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
struct __weak_result_type<_Rp (&)(_A1, _A2, _A3, _A4...)>
{
};
template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
struct __weak_result_type<_Rp (*)(_A1, _A2, _A3, _A4...)>
{
};
template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...)>
{
};
template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const>
{
};
template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) volatile>
{
};
template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const volatile>
{
};
template <class _Tp, class ..._Args>
struct __invoke_return
{
    typedef decltype(std::__invoke(std::declval<_Tp>(), std::declval<_Args>()...)) type;
};
}}
namespace std { inline namespace __1 {
template <class _Tp>
class __attribute__((__type_visibility__("default"))) reference_wrapper : public __weak_result_type<_Tp>
{
public:
    typedef _Tp type;
private:
    type* __f_;
    static void __fun(_Tp&) noexcept;
    static void __fun(_Tp&&) = delete;
public:
    template <class _Up, class = __enable_if_t<!__is_same_uncvref<_Up, reference_wrapper>::value, decltype(__fun(std::declval<_Up>())) > >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    reference_wrapper(_Up&& __u) noexcept(noexcept(__fun(std::declval<_Up>()))) {
        type& __f = static_cast<_Up&&>(__u);
        __f_ = std::addressof(__f);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    operator type&() const noexcept {return *__f_;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    type& get() const noexcept {return *__f_;}
    template <class... _ArgTypes>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    typename __invoke_of<type&, _ArgTypes...>::type
    operator() (_ArgTypes&&... __args) const {
        return std::__invoke(get(), std::forward<_ArgTypes>(__args)...);
    }
};
template <class _Tp>
reference_wrapper(_Tp&) -> reference_wrapper<_Tp>;
template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
reference_wrapper<_Tp>
ref(_Tp& __t) noexcept
{
    return reference_wrapper<_Tp>(__t);
}
template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
reference_wrapper<_Tp>
ref(reference_wrapper<_Tp> __t) noexcept
{
    return __t;
}
template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
reference_wrapper<const _Tp>
cref(const _Tp& __t) noexcept
{
    return reference_wrapper<const _Tp>(__t);
}
template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
reference_wrapper<const _Tp>
cref(reference_wrapper<_Tp> __t) noexcept
{
    return __t;
}
template <class _Tp> void ref(const _Tp&&) = delete;
template <class _Tp> void cref(const _Tp&&) = delete;
}}
namespace std { inline namespace __1 {
template <class _Alloc>
class __allocator_destructor
{
    typedef __attribute__((__nodebug__)) allocator_traits<_Alloc> __alloc_traits;
public:
    typedef __attribute__((__nodebug__)) typename __alloc_traits::pointer pointer;
    typedef __attribute__((__nodebug__)) typename __alloc_traits::size_type size_type;
private:
    _Alloc& __alloc_;
    size_type __s_;
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) __allocator_destructor(_Alloc& __a, size_type __s)
             noexcept
        : __alloc_(__a), __s_(__s) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    void operator()(pointer __p) noexcept
        {__alloc_traits::deallocate(__alloc_, __p, __s_);}
};
}}
namespace std { inline namespace __1 {
template <class _ValueType>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_ValueType __libcpp_relaxed_load(_ValueType const* __value) {
    return __atomic_load_n(__value, 0);
}
template <class _ValueType>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_ValueType __libcpp_acquire_load(_ValueType const* __value) {
    return __atomic_load_n(__value, 2);
}
template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) _Tp
__libcpp_atomic_refcount_increment(_Tp& __t) noexcept
{
    return __atomic_add_fetch(&__t, 1, 0);
}
template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) _Tp
__libcpp_atomic_refcount_decrement(_Tp& __t) noexcept
{
    return __atomic_add_fetch(&__t, -1, 4);
}
class __attribute__((__visibility__("default"))) bad_weak_ptr
    : public std::exception
{
public:
    bad_weak_ptr() noexcept = default;
    bad_weak_ptr(const bad_weak_ptr&) noexcept = default;
    ~bad_weak_ptr() noexcept override;
    const char* what() const noexcept override;
};
[[noreturn]] inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void __throw_bad_weak_ptr()
{
    throw bad_weak_ptr();
}
template<class _Tp> class __attribute__((__type_visibility__("default"))) weak_ptr;
class __attribute__((__visibility__("default"))) __shared_count
{
    __shared_count(const __shared_count&);
    __shared_count& operator=(const __shared_count&);
protected:
    long __shared_owners_;
    virtual ~__shared_count();
private:
    virtual void __on_zero_shared() noexcept = 0;
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    explicit __shared_count(long __refs = 0) noexcept
        : __shared_owners_(__refs) {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    void __add_shared() noexcept {
      __libcpp_atomic_refcount_increment(__shared_owners_);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool __release_shared() noexcept {
      if (__libcpp_atomic_refcount_decrement(__shared_owners_) == -1) {
        __on_zero_shared();
        return true;
      }
      return false;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    long use_count() const noexcept {
        return __libcpp_relaxed_load(&__shared_owners_) + 1;
    }
};
class __attribute__((__visibility__("default"))) __shared_weak_count
    : private __shared_count
{
    long __shared_weak_owners_;
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    explicit __shared_weak_count(long __refs = 0) noexcept
        : __shared_count(__refs),
          __shared_weak_owners_(__refs) {}
protected:
    ~__shared_weak_count() override;
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    void __add_shared() noexcept {
      __shared_count::__add_shared();
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    void __add_weak() noexcept {
      __libcpp_atomic_refcount_increment(__shared_weak_owners_);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    void __release_shared() noexcept {
      if (__shared_count::__release_shared())
        __release_weak();
    }
    void __release_weak() noexcept;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    long use_count() const noexcept {return __shared_count::use_count();}
    __shared_weak_count* lock() noexcept;
    virtual const void* __get_deleter(const type_info&) const noexcept;
private:
    virtual void __on_zero_shared_weak() noexcept = 0;
};
template <class _Tp, class _Dp, class _Alloc>
class __shared_ptr_pointer
    : public __shared_weak_count
{
    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)
        : __data_(__compressed_pair<_Tp, _Dp>(__p, std::move(__d)), std::move(__a)) {}
    const void* __get_deleter(const type_info&) const noexcept override;
private:
    void __on_zero_shared() noexcept override;
    void __on_zero_shared_weak() noexcept override;
};
template <class _Tp, class _Dp, class _Alloc>
const void*
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const noexcept
{
    return __t == typeid(_Dp) ? std::addressof(__data_.first().second()) : nullptr;
}
template <class _Tp, class _Dp, class _Alloc>
void
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() noexcept
{
    __data_.first().second()(__data_.first().first());
    __data_.first().second().~_Dp();
}
template <class _Tp, class _Dp, class _Alloc>
void
__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() noexcept
{
    typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_pointer>::type _Al;
    typedef allocator_traits<_Al> _ATraits;
    typedef pointer_traits<typename _ATraits::pointer> _PTraits;
    _Al __a(__data_.second());
    __data_.second().~_Alloc();
    __a.deallocate(_PTraits::pointer_to(*this), 1);
}
struct __for_overwrite_tag {};
template <class _Tp, class _Alloc>
struct __shared_ptr_emplace
    : __shared_weak_count
{
    template<class ..._Args>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    explicit __shared_ptr_emplace(_Alloc __a, _Args&& ...__args)
        : __storage_(std::move(__a))
    {
        if constexpr (is_same_v<typename _Alloc::value_type, __for_overwrite_tag>) {
            static_assert(sizeof...(_Args) == 0, "No argument should be provided to the control block when using _for_overwrite");
            ::new ((void*)__get_elem()) _Tp;
        } else {
            using _TpAlloc = typename __allocator_traits_rebind<_Alloc, _Tp>::type;
            _TpAlloc __tmp(*__get_alloc());
            allocator_traits<_TpAlloc>::construct(__tmp, __get_elem(), std::forward<_Args>(__args)...);
        }
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Alloc* __get_alloc() noexcept { return __storage_.__get_alloc(); }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Tp* __get_elem() noexcept { return __storage_.__get_elem(); }
private:
    void __on_zero_shared() noexcept override {
        if constexpr (is_same_v<typename _Alloc::value_type, __for_overwrite_tag>) {
            __get_elem()->~_Tp();
        } else {
            using _TpAlloc = typename __allocator_traits_rebind<_Alloc, _Tp>::type;
            _TpAlloc __tmp(*__get_alloc());
            allocator_traits<_TpAlloc>::destroy(__tmp, __get_elem());
        }
    }
    void __on_zero_shared_weak() noexcept override {
        using _ControlBlockAlloc = typename __allocator_traits_rebind<_Alloc, __shared_ptr_emplace>::type;
        using _ControlBlockPointer = typename allocator_traits<_ControlBlockAlloc>::pointer;
        _ControlBlockAlloc __tmp(*__get_alloc());
        __storage_.~_Storage();
        allocator_traits<_ControlBlockAlloc>::deallocate(__tmp,
            pointer_traits<_ControlBlockPointer>::pointer_to(*this), 1);
    }
    using _CompressedPair = __compressed_pair<_Alloc, _Tp>;
    struct alignas(_CompressedPair) _Storage {
        char __blob_[sizeof(_CompressedPair)];
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) explicit _Storage(_Alloc&& __a) {
            ::new ((void*)__get_alloc()) _Alloc(std::move(__a));
        }
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) ~_Storage() {
            __get_alloc()->~_Alloc();
        }
        _Alloc* __get_alloc() noexcept {
            _CompressedPair *__as_pair = reinterpret_cast<_CompressedPair*>(__blob_);
            typename _CompressedPair::_Base1* __first = _CompressedPair::__get_first_base(__as_pair);
            _Alloc *__alloc = reinterpret_cast<_Alloc*>(__first);
            return __alloc;
        }
        __attribute__((__no_sanitize__("cfi"))) _Tp* __get_elem() noexcept {
            _CompressedPair *__as_pair = reinterpret_cast<_CompressedPair*>(__blob_);
            typename _CompressedPair::_Base2* __second = _CompressedPair::__get_second_base(__as_pair);
            _Tp *__elem = reinterpret_cast<_Tp*>(__second);
            return __elem;
        }
    };
    static_assert(alignof(_Storage) == alignof(_CompressedPair), "");
    static_assert(sizeof(_Storage) == sizeof(_CompressedPair), "");
    _Storage __storage_;
};
struct __shared_ptr_dummy_rebind_allocator_type;
template <>
class __attribute__((__type_visibility__("default"))) allocator<__shared_ptr_dummy_rebind_allocator_type>
{
public:
    template <class _Other>
    struct rebind
    {
        typedef allocator<_Other> other;
    };
};
template<class _Tp> class __attribute__((__type_visibility__("default"))) enable_shared_from_this;
template <class _Yp, class _Tp>
struct __bounded_convertible_to_unbounded : false_type {};
template <class _Up, std::size_t _Np, class _Tp>
struct __bounded_convertible_to_unbounded<_Up[_Np], _Tp>
        : is_same<__remove_cv_t<_Tp>, _Up[]> {};
template <class _Yp, class _Tp>
struct __compatible_with
    : _Or<
        is_convertible<_Yp*, _Tp*>,
        __bounded_convertible_to_unbounded<_Yp, _Tp>
    > {};
template <class _Yp, class _Tp, class = void>
struct __raw_pointer_compatible_with : _And<
        _Not<is_array<_Tp>>,
        is_convertible<_Yp*, _Tp*>
        > {};
template <class _Yp, class _Up, std::size_t _Np>
struct __raw_pointer_compatible_with<_Yp, _Up[_Np], __enable_if_t<
            is_convertible<_Yp(*)[_Np], _Up(*)[_Np]>::value> >
        : true_type {};
template <class _Yp, class _Up>
struct __raw_pointer_compatible_with<_Yp, _Up[], __enable_if_t<
            is_convertible<_Yp(*)[], _Up(*)[]>::value> >
        : true_type {};
template <class _Ptr, class = void>
struct __is_deletable : false_type { };
template <class _Ptr>
struct __is_deletable<_Ptr, decltype(delete std::declval<_Ptr>())> : true_type { };
template <class _Ptr, class = void>
struct __is_array_deletable : false_type { };
template <class _Ptr>
struct __is_array_deletable<_Ptr, decltype(delete[] std::declval<_Ptr>())> : true_type { };
template <class _Dp, class _Pt,
    class = decltype(std::declval<_Dp>()(std::declval<_Pt>()))>
static true_type __well_formed_deleter_test(int);
template <class, class>
static false_type __well_formed_deleter_test(...);
template <class _Dp, class _Pt>
struct __well_formed_deleter : decltype(std::__well_formed_deleter_test<_Dp, _Pt>(0)) {};
template<class _Dp, class _Yp, class _Tp>
struct __shared_ptr_deleter_ctor_reqs
{
    static const bool value = __raw_pointer_compatible_with<_Yp, _Tp>::value &&
                              is_move_constructible<_Dp>::value &&
                              __well_formed_deleter<_Dp, _Yp*>::value;
};
template<class _Tp>
class __attribute__((__type_visibility__("default"))) shared_ptr
{
public:
    typedef weak_ptr<_Tp> weak_type;
    typedef remove_extent_t<_Tp> element_type;
private:
    element_type* __ptr_;
    __shared_weak_count* __cntrl_;
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr shared_ptr() noexcept
        : __ptr_(nullptr),
          __cntrl_(nullptr)
    { }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr shared_ptr(nullptr_t) noexcept
        : __ptr_(nullptr),
          __cntrl_(nullptr)
    { }
    template<class _Yp, class = __enable_if_t<
        _And<
            __raw_pointer_compatible_with<_Yp, _Tp>
            , _If<is_array<_Tp>::value, __is_array_deletable<_Yp*>, __is_deletable<_Yp*> >
        >::value
    > >
    explicit shared_ptr(_Yp* __p) : __ptr_(__p) {
        unique_ptr<_Yp> __hold(__p);
        typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
        typedef __shared_ptr_pointer<_Yp*, __shared_ptr_default_delete<_Tp, _Yp>, _AllocT> _CntrlBlk;
        __cntrl_ = new _CntrlBlk(__p, __shared_ptr_default_delete<_Tp, _Yp>(), _AllocT());
        __hold.release();
        __enable_weak_this(__p, __p);
    }
    template<class _Yp, class _Dp, class = __enable_if_t<__shared_ptr_deleter_ctor_reqs<_Dp, _Yp, _Tp>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    shared_ptr(_Yp* __p, _Dp __d)
        : __ptr_(__p)
    {
        try
        {
            typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
            typedef __shared_ptr_pointer<_Yp*, _Dp, _AllocT> _CntrlBlk;
            __cntrl_ = new _CntrlBlk(__p, std::move(__d), _AllocT());
            __enable_weak_this(__p, __p);
        }
        catch (...)
        {
            __d(__p);
            throw;
        }
    }
    template<class _Yp, class _Dp, class _Alloc, class = __enable_if_t<__shared_ptr_deleter_ctor_reqs<_Dp, _Yp, _Tp>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    shared_ptr(_Yp* __p, _Dp __d, _Alloc __a)
        : __ptr_(__p)
    {
        try
        {
            typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;
            typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
            typedef __allocator_destructor<_A2> _D2;
            _A2 __a2(__a);
            unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
            ::new ((void*)std::addressof(*__hold2.get()))
                _CntrlBlk(__p, std::move(__d), __a);
            __cntrl_ = std::addressof(*__hold2.release());
            __enable_weak_this(__p, __p);
        }
        catch (...)
        {
            __d(__p);
            throw;
        }
    }
    template<class _Dp>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    shared_ptr(nullptr_t __p, _Dp __d)
        : __ptr_(nullptr)
    {
        try
        {
            typedef typename __shared_ptr_default_allocator<_Tp>::type _AllocT;
            typedef __shared_ptr_pointer<nullptr_t, _Dp, _AllocT> _CntrlBlk;
            __cntrl_ = new _CntrlBlk(__p, std::move(__d), _AllocT());
        }
        catch (...)
        {
            __d(__p);
            throw;
        }
    }
    template<class _Dp, class _Alloc>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)
        : __ptr_(nullptr)
    {
        try
        {
            typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;
            typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
            typedef __allocator_destructor<_A2> _D2;
            _A2 __a2(__a);
            unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
            ::new ((void*)std::addressof(*__hold2.get()))
                _CntrlBlk(__p, std::move(__d), __a);
            __cntrl_ = std::addressof(*__hold2.release());
        }
        catch (...)
        {
            __d(__p);
            throw;
        }
    }
    template<class _Yp>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) noexcept
        : __ptr_(__p),
          __cntrl_(__r.__cntrl_)
    {
        if (__cntrl_)
            __cntrl_->__add_shared();
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    shared_ptr(const shared_ptr& __r) noexcept
        : __ptr_(__r.__ptr_),
          __cntrl_(__r.__cntrl_)
    {
        if (__cntrl_)
            __cntrl_->__add_shared();
    }
    template<class _Yp, class = __enable_if_t<__compatible_with<_Yp, _Tp>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    shared_ptr(const shared_ptr<_Yp>& __r) noexcept
        : __ptr_(__r.__ptr_),
          __cntrl_(__r.__cntrl_)
    {
        if (__cntrl_)
            __cntrl_->__add_shared();
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    shared_ptr(shared_ptr&& __r) noexcept
        : __ptr_(__r.__ptr_),
          __cntrl_(__r.__cntrl_)
    {
        __r.__ptr_ = nullptr;
        __r.__cntrl_ = nullptr;
    }
    template<class _Yp, class = __enable_if_t<__compatible_with<_Yp, _Tp>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    shared_ptr(shared_ptr<_Yp>&& __r) noexcept
        : __ptr_(__r.__ptr_),
          __cntrl_(__r.__cntrl_)
    {
        __r.__ptr_ = nullptr;
        __r.__cntrl_ = nullptr;
    }
    template<class _Yp, class = __enable_if_t<__compatible_with<_Yp, _Tp>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    explicit shared_ptr(const weak_ptr<_Yp>& __r)
        : __ptr_(__r.__ptr_),
          __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)
    {
        if (__cntrl_ == nullptr)
            __throw_bad_weak_ptr();
    }
    template <class _Yp, class _Dp, class = __enable_if_t<
        !is_lvalue_reference<_Dp>::value &&
         __compatible_with<_Yp, _Tp>::value &&
         is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value
    > >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    shared_ptr(unique_ptr<_Yp, _Dp>&& __r)
        : __ptr_(__r.get())
    {
        if (__ptr_ == nullptr)
            __cntrl_ = nullptr;
        else
        {
            typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
            typedef __shared_ptr_pointer<typename unique_ptr<_Yp, _Dp>::pointer, _Dp, _AllocT> _CntrlBlk;
            __cntrl_ = new _CntrlBlk(__r.get(), std::move(__r.get_deleter()), _AllocT());
            __enable_weak_this(__r.get(), __r.get());
        }
        __r.release();
    }
    template <class _Yp, class _Dp, class = void, class = __enable_if_t<
        is_lvalue_reference<_Dp>::value &&
         __compatible_with<_Yp, _Tp>::value &&
        is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value
    > >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    shared_ptr(unique_ptr<_Yp, _Dp>&& __r)
        : __ptr_(__r.get())
    {
        if (__ptr_ == nullptr)
            __cntrl_ = nullptr;
        else
        {
            typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
            typedef __shared_ptr_pointer<typename unique_ptr<_Yp, _Dp>::pointer,
                                        reference_wrapper<__libcpp_remove_reference_t<_Dp> >,
                                        _AllocT> _CntrlBlk;
            __cntrl_ = new _CntrlBlk(__r.get(), std::ref(__r.get_deleter()), _AllocT());
            __enable_weak_this(__r.get(), __r.get());
        }
        __r.release();
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    ~shared_ptr()
    {
        if (__cntrl_)
            __cntrl_->__release_shared();
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    shared_ptr<_Tp>& operator=(const shared_ptr& __r) noexcept
    {
        shared_ptr(__r).swap(*this);
        return *this;
    }
    template<class _Yp, class = __enable_if_t<__compatible_with<_Yp, _Tp>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    shared_ptr<_Tp>& operator=(const shared_ptr<_Yp>& __r) noexcept
    {
        shared_ptr(__r).swap(*this);
        return *this;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    shared_ptr<_Tp>& operator=(shared_ptr&& __r) noexcept
    {
        shared_ptr(std::move(__r)).swap(*this);
        return *this;
    }
    template<class _Yp, class = __enable_if_t<__compatible_with<_Yp, _Tp>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    shared_ptr<_Tp>& operator=(shared_ptr<_Yp>&& __r)
    {
        shared_ptr(std::move(__r)).swap(*this);
        return *this;
    }
    template <class _Yp, class _Dp, class = __enable_if_t<_And<
        __compatible_with<_Yp, _Tp>,
        is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>
    >::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    shared_ptr<_Tp>& operator=(unique_ptr<_Yp, _Dp>&& __r)
    {
        shared_ptr(std::move(__r)).swap(*this);
        return *this;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    void swap(shared_ptr& __r) noexcept
    {
        std::swap(__ptr_, __r.__ptr_);
        std::swap(__cntrl_, __r.__cntrl_);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    void reset() noexcept
    {
        shared_ptr().swap(*this);
    }
    template<class _Yp, class = __enable_if_t<
        __raw_pointer_compatible_with<_Yp, _Tp>::value
    > >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    void reset(_Yp* __p)
    {
        shared_ptr(__p).swap(*this);
    }
    template<class _Yp, class _Dp, class = __enable_if_t<
        __shared_ptr_deleter_ctor_reqs<_Dp, _Yp, _Tp>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    void reset(_Yp* __p, _Dp __d)
    {
        shared_ptr(__p, __d).swap(*this);
    }
    template<class _Yp, class _Dp, class _Alloc, class = __enable_if_t<
        __shared_ptr_deleter_ctor_reqs<_Dp, _Yp, _Tp>::value> >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    void reset(_Yp* __p, _Dp __d, _Alloc __a)
    {
        shared_ptr(__p, __d, __a).swap(*this);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    element_type* get() const noexcept
    {
        return __ptr_;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    __add_lvalue_reference_t<element_type> operator*() const noexcept
    {
        return *__ptr_;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    element_type* operator->() const noexcept
    {
        static_assert(!is_array<_Tp>::value,
                      "std::shared_ptr<T>::operator-> is only valid when T is not an array type.");
        return __ptr_;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    long use_count() const noexcept
    {
        return __cntrl_ ? __cntrl_->use_count() : 0;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool unique() const noexcept
    {
        return use_count() == 1;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    explicit operator bool() const noexcept
    {
        return get() != nullptr;
    }
    template <class _Up>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool owner_before(shared_ptr<_Up> const& __p) const noexcept
    {
        return __cntrl_ < __p.__cntrl_;
    }
    template <class _Up>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool owner_before(weak_ptr<_Up> const& __p) const noexcept
    {
        return __cntrl_ < __p.__cntrl_;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool __owner_equivalent(const shared_ptr& __p) const
    {
        return __cntrl_ == __p.__cntrl_;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    __add_lvalue_reference_t<element_type> operator[](ptrdiff_t __i) const
    {
            static_assert(is_array<_Tp>::value,
                          "std::shared_ptr<T>::operator[] is only valid when T is an array type.");
            return __ptr_[__i];
    }
    template <class _Dp>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    _Dp* __get_deleter() const noexcept
    {
        return static_cast<_Dp*>(__cntrl_
                    ? const_cast<void *>(__cntrl_->__get_deleter(typeid(_Dp)))
                      : nullptr);
    }
    template<class _Yp, class _CntrlBlk>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    static shared_ptr<_Tp> __create_with_control_block(_Yp* __p, _CntrlBlk* __cntrl) noexcept
    {
        shared_ptr<_Tp> __r;
        __r.__ptr_ = __p;
        __r.__cntrl_ = __cntrl;
        __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
        return __r;
    }
private:
    template <class _Yp, bool = is_function<_Yp>::value>
    struct __shared_ptr_default_allocator
    {
        typedef allocator<_Yp> type;
    };
    template <class _Yp>
    struct __shared_ptr_default_allocator<_Yp, true>
    {
        typedef allocator<__shared_ptr_dummy_rebind_allocator_type> type;
    };
    template <class _Yp, class _OrigPtr, class = __enable_if_t<
        is_convertible<_OrigPtr*, const enable_shared_from_this<_Yp>*>::value
    > >
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    void __enable_weak_this(const enable_shared_from_this<_Yp>* __e, _OrigPtr* __ptr) noexcept
    {
        typedef __remove_cv_t<_Yp> _RawYp;
        if (__e && __e->__weak_this_.expired())
        {
            __e->__weak_this_ = shared_ptr<_RawYp>(*this,
                const_cast<_RawYp*>(static_cast<const _Yp*>(__ptr)));
        }
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void __enable_weak_this(...) noexcept { }
    template <class, class _Yp>
    struct __shared_ptr_default_delete
        : default_delete<_Yp>
    { };
    template <class _Yp, class _Un, size_t _Sz>
    struct __shared_ptr_default_delete<_Yp[_Sz], _Un>
        : default_delete<_Yp[]>
    { };
    template <class _Yp, class _Un>
    struct __shared_ptr_default_delete<_Yp[], _Un>
        : default_delete<_Yp[]>
    { };
    template <class _Up> friend class __attribute__((__type_visibility__("default"))) shared_ptr;
    template <class _Up> friend class __attribute__((__type_visibility__("default"))) weak_ptr;
};
template<class _Tp>
shared_ptr(weak_ptr<_Tp>) -> shared_ptr<_Tp>;
template<class _Tp, class _Dp>
shared_ptr(unique_ptr<_Tp, _Dp>) -> shared_ptr<_Tp>;
template<class _Tp, class _Alloc, class ..._Args, class = __enable_if_t<!is_array<_Tp>::value> >
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
shared_ptr<_Tp> allocate_shared(const _Alloc& __a, _Args&& ...__args)
{
    using _ControlBlock = __shared_ptr_emplace<_Tp, _Alloc>;
    using _ControlBlockAllocator = typename __allocator_traits_rebind<_Alloc, _ControlBlock>::type;
    __allocation_guard<_ControlBlockAllocator> __guard(__a, 1);
    ::new ((void*)std::addressof(*__guard.__get())) _ControlBlock(__a, std::forward<_Args>(__args)...);
    auto __control_block = __guard.__release_ptr();
    return shared_ptr<_Tp>::__create_with_control_block((*__control_block).__get_elem(), std::addressof(*__control_block));
}
template<class _Tp, class ..._Args, class = __enable_if_t<!is_array<_Tp>::value> >
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
shared_ptr<_Tp> make_shared(_Args&& ...__args)
{
    return std::allocate_shared<_Tp>(allocator<_Tp>(), std::forward<_Args>(__args)...);
}
template<class _Tp, class _Alloc, __enable_if_t<!is_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
shared_ptr<_Tp> allocate_shared_for_overwrite(const _Alloc& __a)
{
    using _ForOverwriteAllocator = __allocator_traits_rebind_t<_Alloc, __for_overwrite_tag>;
    _ForOverwriteAllocator __alloc(__a);
    return std::allocate_shared<_Tp>(__alloc);
}
template<class _Tp, __enable_if_t<!is_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
shared_ptr<_Tp> make_shared_for_overwrite()
{
    return std::allocate_shared_for_overwrite<_Tp>(allocator<_Tp>());
}
template <size_t _Alignment>
struct __sp_aligned_storage {
    alignas(_Alignment) char __storage[_Alignment];
};
template <class _Tp, class _Alloc>
struct __unbounded_array_control_block;
template <class _Tp, class _Alloc>
struct __unbounded_array_control_block<_Tp[], _Alloc> : __shared_weak_count
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    _Tp* __get_data() noexcept { return __data_; }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    explicit __unbounded_array_control_block(_Alloc const& __alloc, size_t __count, _Tp const& __arg)
        : __alloc_(__alloc), __count_(__count)
    {
        std::__uninitialized_allocator_fill_n_multidimensional(__alloc_, std::begin(__data_), __count_, __arg);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    explicit __unbounded_array_control_block(_Alloc const& __alloc, size_t __count)
        : __alloc_(__alloc), __count_(__count)
    {
        if constexpr (is_same_v<typename _Alloc::value_type, __for_overwrite_tag>) {
            std::uninitialized_default_construct_n(std::begin(__data_), __count_);
        } else {
            std::__uninitialized_allocator_value_construct_n_multidimensional(__alloc_, std::begin(__data_), __count_);
        }
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    static constexpr size_t __bytes_for(size_t __elements) {
        size_t __bytes = __elements == 0 ? sizeof(__unbounded_array_control_block)
                                         : (__elements - 1) * sizeof(_Tp) + sizeof(__unbounded_array_control_block);
        constexpr size_t __align = alignof(_Tp);
        return (__bytes + __align - 1) & ~(__align - 1);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__))
    ~__unbounded_array_control_block() override { }
private:
    void __on_zero_shared() noexcept override {
        if constexpr (is_same_v<typename _Alloc::value_type, __for_overwrite_tag>) {
            std::__reverse_destroy(__data_, __data_ + __count_);
        } else {
            __allocator_traits_rebind_t<_Alloc, _Tp> __value_alloc(__alloc_);
            std::__allocator_destroy_multidimensional(__value_alloc, __data_, __data_ + __count_);
        }
    }
    void __on_zero_shared_weak() noexcept override {
        using _AlignedStorage = __sp_aligned_storage<alignof(__unbounded_array_control_block)>;
        using _StorageAlloc = __allocator_traits_rebind_t<_Alloc, _AlignedStorage>;
        using _PointerTraits = pointer_traits<typename allocator_traits<_StorageAlloc>::pointer>;
        _StorageAlloc __tmp(__alloc_);
        __alloc_.~_Alloc();
        size_t __size = __unbounded_array_control_block::__bytes_for(__count_);
        _AlignedStorage* __storage = reinterpret_cast<_AlignedStorage*>(this);
        allocator_traits<_StorageAlloc>::deallocate(__tmp, _PointerTraits::pointer_to(*__storage), __size);
    }
    [[no_unique_address]] _Alloc __alloc_;
    size_t __count_;
    union {
        _Tp __data_[1];
    };
};
template<class _Array, class _Alloc, class... _Arg>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
shared_ptr<_Array> __allocate_shared_unbounded_array(const _Alloc& __a, size_t __n, _Arg&& ...__arg)
{
    static_assert(__libcpp_is_unbounded_array<_Array>::value);
    using _ControlBlock = __unbounded_array_control_block<_Array, _Alloc>;
    using _AlignedStorage = __sp_aligned_storage<alignof(_ControlBlock)>;
    using _StorageAlloc = __allocator_traits_rebind_t<_Alloc, _AlignedStorage>;
    __allocation_guard<_StorageAlloc> __guard(__a, _ControlBlock::__bytes_for(__n) / sizeof(_AlignedStorage));
    _ControlBlock* __control_block = reinterpret_cast<_ControlBlock*>(std::addressof(*__guard.__get()));
    std::__construct_at(__control_block, __a, __n, std::forward<_Arg>(__arg)...);
    __guard.__release_ptr();
    return shared_ptr<_Array>::__create_with_control_block(__control_block->__get_data(), __control_block);
}
template <class _Tp, class _Alloc>
struct __bounded_array_control_block;
template <class _Tp, size_t _Count, class _Alloc>
struct __bounded_array_control_block<_Tp[_Count], _Alloc>
    : __shared_weak_count
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    _Tp* __get_data() noexcept { return __data_; }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    explicit __bounded_array_control_block(_Alloc const& __alloc, _Tp const& __arg) : __alloc_(__alloc) {
        std::__uninitialized_allocator_fill_n_multidimensional(__alloc_, std::addressof(__data_[0]), _Count, __arg);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    explicit __bounded_array_control_block(_Alloc const& __alloc) : __alloc_(__alloc) {
        if constexpr (is_same_v<typename _Alloc::value_type, __for_overwrite_tag>) {
            std::uninitialized_default_construct_n(std::addressof(__data_[0]), _Count);
        } else {
            std::__uninitialized_allocator_value_construct_n_multidimensional(__alloc_, std::addressof(__data_[0]), _Count);
        }
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__))
    ~__bounded_array_control_block() override { }
private:
    void __on_zero_shared() noexcept override {
        if constexpr (is_same_v<typename _Alloc::value_type, __for_overwrite_tag>) {
            std::__reverse_destroy(__data_, __data_ + _Count);
        } else {
            __allocator_traits_rebind_t<_Alloc, _Tp> __value_alloc(__alloc_);
            std::__allocator_destroy_multidimensional(__value_alloc, __data_, __data_ + _Count);
        }
    }
    void __on_zero_shared_weak() noexcept override {
        using _ControlBlockAlloc = __allocator_traits_rebind_t<_Alloc, __bounded_array_control_block>;
        using _PointerTraits = pointer_traits<typename allocator_traits<_ControlBlockAlloc>::pointer>;
        _ControlBlockAlloc __tmp(__alloc_);
        __alloc_.~_Alloc();
        allocator_traits<_ControlBlockAlloc>::deallocate(__tmp, _PointerTraits::pointer_to(*this), sizeof(*this));
    }
    [[no_unique_address]] _Alloc __alloc_;
    union {
        _Tp __data_[_Count];
    };
};
template<class _Array, class _Alloc, class... _Arg>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
shared_ptr<_Array> __allocate_shared_bounded_array(const _Alloc& __a, _Arg&& ...__arg)
{
    static_assert(__libcpp_is_bounded_array<_Array>::value);
    using _ControlBlock = __bounded_array_control_block<_Array, _Alloc>;
    using _ControlBlockAlloc = __allocator_traits_rebind_t<_Alloc, _ControlBlock>;
    __allocation_guard<_ControlBlockAlloc> __guard(__a, 1);
    _ControlBlock* __control_block = reinterpret_cast<_ControlBlock*>(std::addressof(*__guard.__get()));
    std::__construct_at(__control_block, __a, std::forward<_Arg>(__arg)...);
    __guard.__release_ptr();
    return shared_ptr<_Array>::__create_with_control_block(__control_block->__get_data(), __control_block);
}
template<class _Tp, class _Alloc, class = __enable_if_t<is_bounded_array<_Tp>::value>>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
shared_ptr<_Tp> allocate_shared(const _Alloc& __a)
{
    return std::__allocate_shared_bounded_array<_Tp>(__a);
}
template<class _Tp, class _Alloc, class = __enable_if_t<is_bounded_array<_Tp>::value>>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
shared_ptr<_Tp> allocate_shared(const _Alloc& __a, const remove_extent_t<_Tp>& __u)
{
    return std::__allocate_shared_bounded_array<_Tp>(__a, __u);
}
template<class _Tp, class _Alloc, __enable_if_t<is_bounded_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
shared_ptr<_Tp> allocate_shared_for_overwrite(const _Alloc& __a)
{
    using _ForOverwriteAllocator = __allocator_traits_rebind_t<_Alloc, __for_overwrite_tag>;
    _ForOverwriteAllocator __alloc(__a);
    return std::__allocate_shared_bounded_array<_Tp>(__alloc);
}
template<class _Tp, class = __enable_if_t<is_bounded_array<_Tp>::value>>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
shared_ptr<_Tp> make_shared()
{
    return std::__allocate_shared_bounded_array<_Tp>(allocator<_Tp>());
}
template<class _Tp, class = __enable_if_t<is_bounded_array<_Tp>::value>>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
shared_ptr<_Tp> make_shared(const remove_extent_t<_Tp>& __u)
{
    return std::__allocate_shared_bounded_array<_Tp>(allocator<_Tp>(), __u);
}
template<class _Tp, __enable_if_t<is_bounded_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
shared_ptr<_Tp> make_shared_for_overwrite()
{
    return std::__allocate_shared_bounded_array<_Tp>(allocator<__for_overwrite_tag>());
}
template<class _Tp, class _Alloc, class = __enable_if_t<is_unbounded_array<_Tp>::value>>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
shared_ptr<_Tp> allocate_shared(const _Alloc& __a, size_t __n)
{
    return std::__allocate_shared_unbounded_array<_Tp>(__a, __n);
}
template<class _Tp, class _Alloc, class = __enable_if_t<is_unbounded_array<_Tp>::value>>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
shared_ptr<_Tp> allocate_shared(const _Alloc& __a, size_t __n, const remove_extent_t<_Tp>& __u)
{
    return std::__allocate_shared_unbounded_array<_Tp>(__a, __n, __u);
}
template<class _Tp, class _Alloc, __enable_if_t<is_unbounded_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
shared_ptr<_Tp> allocate_shared_for_overwrite(const _Alloc& __a, size_t __n)
{
    using _ForOverwriteAllocator = __allocator_traits_rebind_t<_Alloc, __for_overwrite_tag>;
    _ForOverwriteAllocator __alloc(__a);
    return std::__allocate_shared_unbounded_array<_Tp>(__alloc, __n);
}
template<class _Tp, class = __enable_if_t<is_unbounded_array<_Tp>::value>>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
shared_ptr<_Tp> make_shared(size_t __n)
{
    return std::__allocate_shared_unbounded_array<_Tp>(allocator<_Tp>(), __n);
}
template<class _Tp, class = __enable_if_t<is_unbounded_array<_Tp>::value>>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
shared_ptr<_Tp> make_shared(size_t __n, const remove_extent_t<_Tp>& __u)
{
    return std::__allocate_shared_unbounded_array<_Tp>(allocator<_Tp>(), __n, __u);
}
template<class _Tp, __enable_if_t<is_unbounded_array<_Tp>::value, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
shared_ptr<_Tp> make_shared_for_overwrite(size_t __n)
{
    return std::__allocate_shared_unbounded_array<_Tp>(allocator<__for_overwrite_tag>(), __n);
}
template<class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool
operator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) noexcept
{
    return __x.get() == __y.get();
}
template<class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) strong_ordering
operator<=>(shared_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) noexcept
{
    return compare_three_way()(__x.get(), __y.get());
}
template<class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool
operator==(const shared_ptr<_Tp>& __x, nullptr_t) noexcept
{
    return !__x;
}
template<class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) strong_ordering
operator<=>(shared_ptr<_Tp> const& __x, nullptr_t) noexcept
{
    return compare_three_way()(__x.get(), static_cast<typename shared_ptr<_Tp>::element_type*>(nullptr));
}
template<class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void
swap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) noexcept
{
    __x.swap(__y);
}
template<class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
shared_ptr<_Tp>
static_pointer_cast(const shared_ptr<_Up>& __r) noexcept
{
    return shared_ptr<_Tp>(__r,
                           static_cast<
                               typename shared_ptr<_Tp>::element_type*>(__r.get()));
}
template<class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
shared_ptr<_Tp>
dynamic_pointer_cast(const shared_ptr<_Up>& __r) noexcept
{
    typedef typename shared_ptr<_Tp>::element_type _ET;
    _ET* __p = dynamic_cast<_ET*>(__r.get());
    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();
}
template<class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) shared_ptr<_Tp>
const_pointer_cast(const shared_ptr<_Up>& __r) noexcept
{
    typedef typename shared_ptr<_Tp>::element_type _RTp;
    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));
}
template<class _Tp, class _Up>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) shared_ptr<_Tp>
reinterpret_pointer_cast(const shared_ptr<_Up>& __r) noexcept
{
    return shared_ptr<_Tp>(__r,
                           reinterpret_cast<
                               typename shared_ptr<_Tp>::element_type*>(__r.get()));
}
template<class _Dp, class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
_Dp*
get_deleter(const shared_ptr<_Tp>& __p) noexcept
{
    return __p.template __get_deleter<_Dp>();
}
template<class _Tp>
class __attribute__((__type_visibility__("default"))) weak_ptr
{
public:
    typedef remove_extent_t<_Tp> element_type;
private:
    element_type* __ptr_;
    __shared_weak_count* __cntrl_;
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    constexpr weak_ptr() noexcept;
    template<class _Yp> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) weak_ptr(shared_ptr<_Yp> const& __r,
                   typename enable_if<__compatible_with<_Yp, _Tp>::value, __nat*>::type = 0)
                        noexcept;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    weak_ptr(weak_ptr const& __r) noexcept;
    template<class _Yp> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) weak_ptr(weak_ptr<_Yp> const& __r,
                   typename enable_if<__compatible_with<_Yp, _Tp>::value, __nat*>::type = 0)
                         noexcept;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    weak_ptr(weak_ptr&& __r) noexcept;
    template<class _Yp> __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) weak_ptr(weak_ptr<_Yp>&& __r,
                   typename enable_if<__compatible_with<_Yp, _Tp>::value, __nat*>::type = 0)
                         noexcept;
    ~weak_ptr();
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    weak_ptr& operator=(weak_ptr const& __r) noexcept;
    template<class _Yp>
        typename enable_if
        <
            __compatible_with<_Yp, _Tp>::value,
            weak_ptr&
        >::type
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
        operator=(weak_ptr<_Yp> const& __r) noexcept;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    weak_ptr& operator=(weak_ptr&& __r) noexcept;
    template<class _Yp>
        typename enable_if
        <
            __compatible_with<_Yp, _Tp>::value,
            weak_ptr&
        >::type
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
        operator=(weak_ptr<_Yp>&& __r) noexcept;
    template<class _Yp>
        typename enable_if
        <
            __compatible_with<_Yp, _Tp>::value,
            weak_ptr&
        >::type
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
        operator=(shared_ptr<_Yp> const& __r) noexcept;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    void swap(weak_ptr& __r) noexcept;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    void reset() noexcept;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    long use_count() const noexcept
        {return __cntrl_ ? __cntrl_->use_count() : 0;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool expired() const noexcept
        {return __cntrl_ == nullptr || __cntrl_->use_count() == 0;}
    shared_ptr<_Tp> lock() const noexcept;
    template<class _Up>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
        bool owner_before(const shared_ptr<_Up>& __r) const noexcept
        {return __cntrl_ < __r.__cntrl_;}
    template<class _Up>
        __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
        bool owner_before(const weak_ptr<_Up>& __r) const noexcept
        {return __cntrl_ < __r.__cntrl_;}
    template <class _Up> friend class __attribute__((__type_visibility__("default"))) weak_ptr;
    template <class _Up> friend class __attribute__((__type_visibility__("default"))) shared_ptr;
};
template<class _Tp>
weak_ptr(shared_ptr<_Tp>) -> weak_ptr<_Tp>;
template<class _Tp>
inline
constexpr
weak_ptr<_Tp>::weak_ptr() noexcept
    : __ptr_(nullptr),
      __cntrl_(nullptr)
{
}
template<class _Tp>
inline
weak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}
template<class _Tp>
template<class _Yp>
inline
weak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,
                        typename enable_if<__compatible_with<_Yp, _Tp>::value, __nat*>::type)
                         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}
template<class _Tp>
template<class _Yp>
inline
weak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,
                        typename enable_if<__compatible_with<_Yp, _Tp>::value, __nat*>::type)
         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    if (__cntrl_)
        __cntrl_->__add_weak();
}
template<class _Tp>
inline
weak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = nullptr;
    __r.__cntrl_ = nullptr;
}
template<class _Tp>
template<class _Yp>
inline
weak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r,
                        typename enable_if<__compatible_with<_Yp, _Tp>::value, __nat*>::type)
         noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_)
{
    __r.__ptr_ = nullptr;
    __r.__cntrl_ = nullptr;
}
template<class _Tp>
weak_ptr<_Tp>::~weak_ptr()
{
    if (__cntrl_)
        __cntrl_->__release_weak();
}
template<class _Tp>
inline
weak_ptr<_Tp>&
weak_ptr<_Tp>::operator=(weak_ptr const& __r) noexcept
{
    weak_ptr(__r).swap(*this);
    return *this;
}
template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    __compatible_with<_Yp, _Tp>::value,
    weak_ptr<_Tp>&
>::type
weak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) noexcept
{
    weak_ptr(__r).swap(*this);
    return *this;
}
template<class _Tp>
inline
weak_ptr<_Tp>&
weak_ptr<_Tp>::operator=(weak_ptr&& __r) noexcept
{
    weak_ptr(std::move(__r)).swap(*this);
    return *this;
}
template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    __compatible_with<_Yp, _Tp>::value,
    weak_ptr<_Tp>&
>::type
weak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) noexcept
{
    weak_ptr(std::move(__r)).swap(*this);
    return *this;
}
template<class _Tp>
template<class _Yp>
inline
typename enable_if
<
    __compatible_with<_Yp, _Tp>::value,
    weak_ptr<_Tp>&
>::type
weak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) noexcept
{
    weak_ptr(__r).swap(*this);
    return *this;
}
template<class _Tp>
inline
void
weak_ptr<_Tp>::swap(weak_ptr& __r) noexcept
{
    std::swap(__ptr_, __r.__ptr_);
    std::swap(__cntrl_, __r.__cntrl_);
}
template<class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
void
swap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) noexcept
{
    __x.swap(__y);
}
template<class _Tp>
inline
void
weak_ptr<_Tp>::reset() noexcept
{
    weak_ptr().swap(*this);
}
template<class _Tp>
shared_ptr<_Tp>
weak_ptr<_Tp>::lock() const noexcept
{
    shared_ptr<_Tp> __r;
    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;
    if (__r.__cntrl_)
        __r.__ptr_ = __ptr_;
    return __r;
}
template <class _Tp = void> struct owner_less;
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) owner_less<shared_ptr<_Tp> >
    : __binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool operator()(shared_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool operator()( weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
};
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) owner_less<weak_ptr<_Tp> >
    : __binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool operator()( weak_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool operator()(shared_ptr<_Tp> const& __x, weak_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool operator()( weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const noexcept
        {return __x.owner_before(__y);}
};
template <>
struct __attribute__((__type_visibility__("default"))) owner_less<void>
{
    template <class _Tp, class _Up>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool operator()( shared_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const noexcept
        {return __x.owner_before(__y);}
    template <class _Tp, class _Up>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool operator()( shared_ptr<_Tp> const& __x, weak_ptr<_Up> const& __y) const noexcept
        {return __x.owner_before(__y);}
    template <class _Tp, class _Up>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool operator()( weak_ptr<_Tp> const& __x, shared_ptr<_Up> const& __y) const noexcept
        {return __x.owner_before(__y);}
    template <class _Tp, class _Up>
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    bool operator()( weak_ptr<_Tp> const& __x, weak_ptr<_Up> const& __y) const noexcept
        {return __x.owner_before(__y);}
    typedef void is_transparent;
};
template<class _Tp>
class __attribute__((__type_visibility__("default"))) enable_shared_from_this
{
    mutable weak_ptr<_Tp> __weak_this_;
protected:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr
    enable_shared_from_this() noexcept {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    enable_shared_from_this(enable_shared_from_this const&) noexcept {}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept
        {return *this;}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    ~enable_shared_from_this() {}
public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    shared_ptr<_Tp> shared_from_this()
        {return shared_ptr<_Tp>(__weak_this_);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    shared_ptr<_Tp const> shared_from_this() const
        {return shared_ptr<const _Tp>(__weak_this_);}
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    weak_ptr<_Tp> weak_from_this() noexcept
       { return __weak_this_; }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    weak_ptr<const _Tp> weak_from_this() const noexcept
        { return __weak_this_; }
    template <class _Up> friend class shared_ptr;
};
template <class _Tp> struct __attribute__((__type_visibility__("default"))) hash;
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) hash<shared_ptr<_Tp> >
{
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
    size_t operator()(const shared_ptr<_Tp>& __ptr) const noexcept
    {
        return hash<typename shared_ptr<_Tp>::element_type*>()(__ptr.get());
    }
};
template<class _CharT, class _Traits, class _Yp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);
class __attribute__((__visibility__("default"))) __sp_mut
{
    void* __lx_;
public:
    void lock() noexcept;
    void unlock() noexcept;
private:
    constexpr __sp_mut(void*) noexcept;
    __sp_mut(const __sp_mut&);
    __sp_mut& operator=(const __sp_mut&);
    friend __attribute__((__visibility__("default"))) __sp_mut& __get_sp_mut(const void*);
};
__attribute__((__visibility__("default"))) __attribute__((availability(macos,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
__sp_mut& __get_sp_mut(const void*);
template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
bool
atomic_is_lock_free(const shared_ptr<_Tp>*)
{
    return false;
}
template <class _Tp>
__attribute__((availability(macos,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) shared_ptr<_Tp>
atomic_load(const shared_ptr<_Tp>* __p)
{
    __sp_mut& __m = std::__get_sp_mut(__p);
    __m.lock();
    shared_ptr<_Tp> __q = *__p;
    __m.unlock();
    return __q;
}
template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
__attribute__((availability(macos,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
shared_ptr<_Tp>
atomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)
{
    return std::atomic_load(__p);
}
template <class _Tp>
__attribute__((availability(macos,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) void
atomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)
{
    __sp_mut& __m = std::__get_sp_mut(__p);
    __m.lock();
    __p->swap(__r);
    __m.unlock();
}
template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
__attribute__((availability(macos,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
void
atomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)
{
    std::atomic_store(__p, __r);
}
template <class _Tp>
__attribute__((availability(macos,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) shared_ptr<_Tp>
atomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)
{
    __sp_mut& __m = std::__get_sp_mut(__p);
    __m.lock();
    __p->swap(__r);
    __m.unlock();
    return __r;
}
template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
__attribute__((availability(macos,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
shared_ptr<_Tp>
atomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)
{
    return std::atomic_exchange(__p, __r);
}
template <class _Tp>
__attribute__((availability(macos,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) bool
atomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)
{
    shared_ptr<_Tp> __temp;
    __sp_mut& __m = std::__get_sp_mut(__p);
    __m.lock();
    if (__p->__owner_equivalent(*__v))
    {
        std::swap(__temp, *__p);
        *__p = __w;
        __m.unlock();
        return true;
    }
    std::swap(__temp, *__v);
    *__v = *__p;
    __m.unlock();
    return false;
}
template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
__attribute__((availability(macos,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
bool
atomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)
{
    return std::atomic_compare_exchange_strong(__p, __v, __w);
}
template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
__attribute__((availability(macos,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
bool
atomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,
                                        shared_ptr<_Tp> __w, memory_order, memory_order)
{
    return std::atomic_compare_exchange_strong(__p, __v, __w);
}
template <class _Tp>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006")))
__attribute__((availability(macos,strict,introduced=10.9))) __attribute__((availability(ios,strict,introduced=7.0)))
bool
atomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,
                                      shared_ptr<_Tp> __w, memory_order, memory_order)
{
    return std::atomic_compare_exchange_weak(__p, __v, __w);
}
}}
namespace std { inline namespace __1 {
template <class _Type>
inline constexpr bool __is_std_pair = false;
template <class _Type1, class _Type2>
inline constexpr bool __is_std_pair<pair<_Type1, _Type2>> = true;
template <class _Type, class _Alloc, class... _Args, __enable_if_t<!__is_std_pair<_Type>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr auto
__uses_allocator_construction_args(const _Alloc& __alloc, _Args&&... __args) noexcept {
  if constexpr (!uses_allocator_v<_Type, _Alloc> && is_constructible_v<_Type, _Args...>) {
    return std::forward_as_tuple(std::forward<_Args>(__args)...);
  } else if constexpr (uses_allocator_v<_Type, _Alloc> &&
                       is_constructible_v<_Type, allocator_arg_t, const _Alloc&, _Args...>) {
    return tuple<allocator_arg_t, const _Alloc&, _Args&&...>(allocator_arg, __alloc, std::forward<_Args>(__args)...);
  } else if constexpr (uses_allocator_v<_Type, _Alloc> && is_constructible_v<_Type, _Args..., const _Alloc&>) {
    return std::forward_as_tuple(std::forward<_Args>(__args)..., __alloc);
  } else {
    static_assert(
        sizeof(_Type) + 1 == 0, "If uses_allocator_v<Type> is true, the type has to be allocator-constructible");
  }
}
template <class _Pair, class _Alloc, class _Tuple1, class _Tuple2, __enable_if_t<__is_std_pair<_Pair>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr auto __uses_allocator_construction_args(
    const _Alloc& __alloc, piecewise_construct_t, _Tuple1&& __x, _Tuple2&& __y) noexcept {
  return std::make_tuple(
      piecewise_construct,
      std::apply(
          [&__alloc](auto&&... __args1) {
            return std::__uses_allocator_construction_args<typename _Pair::first_type>(
                __alloc, std::forward<decltype(__args1)>(__args1)...);
          },
          std::forward<_Tuple1>(__x)),
      std::apply(
          [&__alloc](auto&&... __args2) {
            return std::__uses_allocator_construction_args<typename _Pair::second_type>(
                __alloc, std::forward<decltype(__args2)>(__args2)...);
          },
          std::forward<_Tuple2>(__y)));
}
template <class _Pair, class _Alloc, __enable_if_t<__is_std_pair<_Pair>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr auto __uses_allocator_construction_args(const _Alloc& __alloc) noexcept {
  return std::__uses_allocator_construction_args<_Pair>(__alloc, piecewise_construct, tuple<>{}, tuple<>{});
}
template <class _Pair, class _Alloc, class _Up, class _Vp, __enable_if_t<__is_std_pair<_Pair>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr auto
__uses_allocator_construction_args(const _Alloc& __alloc, _Up&& __u, _Vp&& __v) noexcept {
  return std::__uses_allocator_construction_args<_Pair>(
      __alloc,
      piecewise_construct,
      std::forward_as_tuple(std::forward<_Up>(__u)),
      std::forward_as_tuple(std::forward<_Vp>(__v)));
}
template <class _Pair, class _Alloc, class _Up, class _Vp, __enable_if_t<__is_std_pair<_Pair>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr auto
__uses_allocator_construction_args(const _Alloc& __alloc, const pair<_Up, _Vp>& __pair) noexcept {
  return std::__uses_allocator_construction_args<_Pair>(
      __alloc, piecewise_construct, std::forward_as_tuple(__pair.first), std::forward_as_tuple(__pair.second));
}
template <class _Pair, class _Alloc, class _Up, class _Vp, __enable_if_t<__is_std_pair<_Pair>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr auto
__uses_allocator_construction_args(const _Alloc& __alloc, pair<_Up, _Vp>&& __pair) noexcept {
  return std::__uses_allocator_construction_args<_Pair>(
      __alloc,
      piecewise_construct,
      std::forward_as_tuple(std::get<0>(std::move(__pair))),
      std::forward_as_tuple(std::get<1>(std::move(__pair))));
}
namespace __uses_allocator_detail {
template <class _Ap, class _Bp>
void __fun(const pair<_Ap, _Bp>&);
template <class _Tp>
decltype(__uses_allocator_detail::__fun(std::declval<_Tp>()), true_type()) __convertible_to_const_pair_ref_impl(int);
template <class>
false_type __convertible_to_const_pair_ref_impl(...);
template <class _Tp>
inline constexpr bool __convertible_to_const_pair_ref =
    decltype(__uses_allocator_detail::__convertible_to_const_pair_ref_impl<_Tp>(0))::value;
}
template <
    class _Pair,
    class _Alloc,
    class _Type,
    __enable_if_t<__is_std_pair<_Pair> && !__uses_allocator_detail::__convertible_to_const_pair_ref<_Type>, int> = 0>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr auto
__uses_allocator_construction_args(const _Alloc& __alloc, _Type&& __value) noexcept;
template <class _Type, class _Alloc, class... _Args>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Type __make_obj_using_allocator(const _Alloc& __alloc, _Args&&... __args);
template <class _Pair,
          class _Alloc,
          class _Type,
          __enable_if_t<__is_std_pair<_Pair> && !__uses_allocator_detail::__convertible_to_const_pair_ref<_Type>, int>>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr auto
__uses_allocator_construction_args(const _Alloc& __alloc, _Type&& __value) noexcept {
  struct __pair_constructor {
    using _PairMutable = remove_cv_t<_Pair>;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr auto __do_construct(const _PairMutable& __pair) const {
      return std::__make_obj_using_allocator<_PairMutable>(__alloc_, __pair);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr auto __do_construct(_PairMutable&& __pair) const {
      return std::__make_obj_using_allocator<_PairMutable>(__alloc_, std::move(__pair));
    }
    const _Alloc& __alloc_;
    _Type& __value_;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr operator _PairMutable() const {
      return __do_construct(std::forward<_Type>(this->__value_));
    }
  };
  return std::make_tuple(__pair_constructor{__alloc, __value});
}
template <class _Type, class _Alloc, class... _Args>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Type __make_obj_using_allocator(const _Alloc& __alloc, _Args&&... __args) {
  return std::make_from_tuple<_Type>(
      std::__uses_allocator_construction_args<_Type>(__alloc, std::forward<_Args>(__args)...));
}
template <class _Type, class _Alloc, class... _Args>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr _Type*
__uninitialized_construct_using_allocator(_Type* __ptr, const _Alloc& __alloc, _Args&&... __args) {
  return std::apply(
      [&__ptr](auto&&... __xs) { return std::__construct_at(__ptr, std::forward<decltype(__xs)>(__xs)...); },
      std::__uses_allocator_construction_args<_Type>(__alloc, std::forward<_Args>(__args)...));
}
template <class _Type, class _Alloc, class... _Args>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr auto uses_allocator_construction_args(const _Alloc& __alloc, _Args&&... __args) noexcept
    -> decltype(std::__uses_allocator_construction_args<_Type>(__alloc, std::forward<_Args>(__args)...)) {
  return std::__uses_allocator_construction_args<_Type>(__alloc, std::forward<_Args>(__args)...);
}
template <class _Type, class _Alloc, class... _Args>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr auto make_obj_using_allocator(const _Alloc& __alloc, _Args&&... __args)
    -> decltype(std::__make_obj_using_allocator<_Type>(__alloc, std::forward<_Args>(__args)...)) {
  return std::__make_obj_using_allocator<_Type>(__alloc, std::forward<_Args>(__args)...);
}
template <class _Type, class _Alloc, class... _Args>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("v160006"))) constexpr auto
uninitialized_construct_using_allocator(_Type* __ptr, const _Alloc& __alloc, _Args&&... __args)
    -> decltype(std::__uninitialized_construct_using_allocator(__ptr, __alloc, std::forward<_Args>(__args)...)) {
  return std::__uninitialized_construct_using_allocator(__ptr, __alloc, std::forward<_Args>(__args)...);
}
}}

int main() {
}

[-[Resource consumption]-]
Time (seconds): 0.340

